//! The `types` module contains shared types used by multiple applications

use alloy::{
    hex,
    network::EthereumWallet,
    primitives::{Address, Bloom, Log, B256},
    providers::{
        fillers::{
            BlobGasFiller, ChainIdFiller, FillProvider, GasFiller, JoinFill, NonceFiller,
            WalletFiller,
        },
        Identity, RootProvider,
    },
    rpc::types::Block,
};
use async_trait::async_trait;
use serde::{de, Deserialize, Deserializer, Serialize, Serializer};
use std::fmt::{Display, Formatter};

#[allow(missing_docs)]
pub trait GetBlockRef {
    fn block_ref(&self) -> &BlockRef;
}

/// A trait for building blocks from the sequencing and settlement chains.
#[async_trait]
pub trait BlockBuilder<T>: Send {
    /// Process a single slot
    fn build_block(&self, block: &PartialBlock) -> eyre::Result<T>;
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq, Default)]
#[serde(rename_all = "camelCase")]
/// **`Receipt`**: Contains the result of a transaction, including fields like status, logs, and
/// potentially a contract address if one was created.
pub struct Receipt {
    /// The hash of the block containing the transaction.
    #[serde(deserialize_with = "deserialize_b256", serialize_with = "serialize_b256")]
    pub block_hash: B256,
    /// The number of the block containing the transaction.
    #[serde(deserialize_with = "deserialize_hex_to_u64", serialize_with = "serialize_hex_u64")]
    pub block_number: u64,
    /// The sender's address.
    #[serde(deserialize_with = "deserialize_address", serialize_with = "serialize_address")]
    pub from: Address,
    /// The recipient's address.
    #[serde(
        deserialize_with = "deserialize_optional_address",
        serialize_with = "serialize_optional_address"
    )]
    pub to: Option<Address>,
    /// The address of the contract created by the transaction, if applicable.
    #[serde(
        deserialize_with = "deserialize_optional_address",
        serialize_with = "serialize_optional_address"
    )]
    pub contract_address: Option<Address>,
    /// The logs generated by the transaction.
    pub logs: Vec<Log>,
    /// The logs bloom filter for the transaction.
    pub logs_bloom: Bloom,
    /// The transaction's execution status.
    #[serde(deserialize_with = "deserialize_hex_to_u64", serialize_with = "serialize_hex_u64")]
    pub status: u64,
    /// The transaction type, if available.
    #[serde(deserialize_with = "deserialize_hex_to_u8", serialize_with = "serialize_hex_u8")]
    pub r#type: u8,
    /// Transaction index in block
    #[serde(deserialize_with = "deserialize_hex_to_u64", serialize_with = "serialize_hex_u64")]
    pub transaction_index: u64,
    /// Transaction hash
    #[serde(deserialize_with = "deserialize_b256", serialize_with = "serialize_b256")]
    pub transaction_hash: B256,
    /// Gas used
    #[serde(deserialize_with = "deserialize_hex_to_u64", serialize_with = "serialize_hex_u64")]
    pub gas_used: u64,
    /// Cumulative gas used
    #[serde(deserialize_with = "deserialize_hex_to_u64", serialize_with = "serialize_hex_u64")]
    pub cumulative_gas_used: u64,
}

/// `PartialBlock` contains block transactions, event logs, and metadata
#[allow(missing_docs)]
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq, Default)]
pub struct PartialBlock {
    pub block_ref: BlockRef,
    pub parent_hash: B256,
    pub logs: Vec<Log>,
}

/// Convert a block and its receipts to a `PartialBlock`
pub fn convert_block_to_partial_block(block: &Block, receipts: &[Receipt]) -> PartialBlock {
    let filtered_logs: Vec<Log> =
        receipts.iter().flat_map(|receipt| receipt.logs.clone()).collect();
    PartialBlock {
        block_ref: BlockRef {
            number: block.header.number,
            hash: block.header.hash,
            timestamp: block.header.timestamp,
        },
        parent_hash: block.header.parent_hash,
        logs: filtered_logs,
    }
}

impl GetBlockRef for PartialBlock {
    fn block_ref(&self) -> &BlockRef {
        &self.block_ref
    }
}

/// A reference to a block containing just its number and timestamp.
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq, Default)]
pub struct BlockRef {
    /// The block number.
    pub number: u64,
    /// The block timestamp.
    pub timestamp: u64,
    /// The block hash.
    pub hash: B256,
}

impl Display for BlockRef {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "number: {}, ts: {}, hash: {}", self.number, self.timestamp, self.hash)
    }
}

fn deserialize_address<'de, D>(deserializer: D) -> Result<Address, D::Error>
where
    D: Deserializer<'de>,
{
    let address_str: String = Deserialize::deserialize(deserializer)?;
    let address: Address = address_str
        .parse()
        .map_err(|err| de::Error::custom(format!("Failed to parse address: {err}")))?;
    Ok(address)
}

fn deserialize_optional_address<'de, D>(deserializer: D) -> Result<Option<Address>, D::Error>
where
    D: Deserializer<'de>,
{
    let opt: Option<String> = Option::deserialize(deserializer)?;
    if let Some(address_str) = opt {
        let address: Address = address_str
            .parse()
            .map_err(|err| de::Error::custom(format!("Failed to parse address: {err}")))?;
        Ok(Some(address))
    } else {
        Ok(None)
    }
}

fn deserialize_hex_to_u64<'de, D>(deserializer: D) -> Result<u64, D::Error>
where
    D: Deserializer<'de>,
{
    let hex_str: String = Deserialize::deserialize(deserializer)?;
    u64::from_str_radix(hex_str.trim_start_matches("0x"), 16)
        .map_err(|err| de::Error::custom(format!("Failed to parse hex to u64: {}", err)))
}

fn deserialize_hex_to_u8<'de, D>(deserializer: D) -> Result<u8, D::Error>
where
    D: Deserializer<'de>,
{
    let hex_str: String = Deserialize::deserialize(deserializer)?;
    u8::from_str_radix(hex_str.trim_start_matches("0x"), 16)
        .map_err(|err| de::Error::custom(format!("Failed to parse hex to u8: {}", err)))
}

fn deserialize_b256<'de, D>(deserializer: D) -> Result<B256, D::Error>
where
    D: Deserializer<'de>,
{
    let hex_str: String = Deserialize::deserialize(deserializer)?;
    let decoded = hex::decode(hex_str.trim_start_matches("0x"))
        .map_err(|err| de::Error::custom(format!("Failed to decode hex string: {err}")))?;
    let array: [u8; 32] = decoded
        .try_into()
        .map_err(|_| de::Error::custom("Failed to convert to a 32-byte array"))?;
    Ok(B256::from(array))
}

fn serialize_b256<S>(b256: &B256, serializer: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    serializer.serialize_str(&format!("0x{}", hex::encode(b256.as_slice())))
}

fn serialize_address<S>(addr: &Address, serializer: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    serializer.serialize_str(&format!("0x{}", hex::encode(addr.as_slice())))
}

fn serialize_optional_address<S>(opt: &Option<Address>, serializer: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    match opt {
        Some(addr) => serializer.serialize_str(&format!("0x{}", hex::encode(addr.as_slice()))),
        None => serializer.serialize_none(),
    }
}

fn serialize_hex_u64<S>(num: &u64, serializer: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    serializer.serialize_str(&format!("0x{:x}", num))
}

fn serialize_hex_u8<S>(num: &u8, serializer: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    serializer.serialize_str(&format!("0x{:x}", num))
}
/// A filled provider
pub type FilledProvider = FillProvider<
    JoinFill<
        JoinFill<
            Identity,
            JoinFill<GasFiller, JoinFill<BlobGasFiller, JoinFill<NonceFiller, ChainIdFiller>>>,
        >,
        WalletFiller<EthereumWallet>,
    >,
    RootProvider,
>;
