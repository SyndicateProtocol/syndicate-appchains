/**

Generated by the following Solidity interface...
```solidity
interface MockRollup {
    type MachineStatus is uint8;
    struct Assertion {
        ExecutionState beforeState;
        ExecutionState afterState;
        uint64 numBlocks;
    }
    struct AssertionInputs {
        BeforeStateData beforeStateData;
        AssertionState beforeState;
        AssertionState afterState;
    }
    struct AssertionState {
        GlobalState globalState;
        MachineStatus machineStatus;
        bytes32 endHistoryRoot;
    }
    struct BeforeStateData {
        bytes32 prevPrevAssertionHash;
        bytes32 sequencerBatchAcc;
        ConfigData configData;
    }
    struct ConfigData {
        bytes32 wasmModuleRoot;
        uint256 requiredStake;
        address challengeManager;
        uint64 confirmPeriodBlocks;
        uint64 nextInboxPosition;
    }
    struct ExecutionState {
        GlobalState globalState;
        MachineStatus machineStatus;
    }
    struct GlobalState {
        bytes32[2] bytes32Vals;
        uint64[2] u64Vals;
    }

    event AnyTrustFastConfirmerSet(address confimer);
    event FastConfirmNewAssertionCalled(bytes32 expectedAssertionHash);
    event ForceConfirmNodeCalled(uint64 nodeNum, bytes32 blockHash, bytes32 sendRoot);
    event ForceCreateNodeCalled(uint64 prevNode, uint256 prevNodeInboxMaxCount, bytes32 expectedNodeHash);
    event RolePaused();
    event ValidatorAfkBlocksSet(uint64 blocks);
    event ValidatorsSet(address[] validators, bool[] values);

    constructor();

    function baseStake() external view returns (uint256);
    function bridge() external view returns (address);
    function challengeManager() external view returns (address);
    function computeAssertionHash(bytes32, AssertionState memory, bytes32) external view returns (bytes32);
    function confirmPeriodBlocks() external view returns (uint64);
    function fastConfirmNewAssertion(AssertionInputs memory, bytes32 expectedAssertionHash) external;
    function forceConfirmNode(uint64 nodeNum, bytes32 blockHash, bytes32 sendRoot) external;
    function forceCreateNode(uint64 prevNode, uint256 prevNodeInboxMaxCount, Assertion memory, bytes32 expectedNodeHash) external;
    function genesisAssertionHash() external view returns (bytes32);
    function getValidators() external view returns (address[] memory);
    function owner() external view returns (address);
    function pause() external;
    function paused() external pure returns (bool);
    function sequencerInbox() external view returns (address);
    function setAnyTrustFastConfirmer(address confimer) external;
    function setBaseStake(uint256 stake) external;
    function setComputedAssertionHash(bytes32 hash) external;
    function setConfirmPeriodBlocks(uint64 blocks) external;
    function setGenesisAssertionHash(bytes32 hash) external;
    function setLegacyMode(bool mode) external;
    function setOwner(address newOwner) external;
    function setSequencerInboxAcc(uint256 index, bytes32 acc) external;
    function setSequencerMessageCount(uint256 count) external;
    function setValidator(address[] memory validators, bool[] memory values) external;
    function setValidatorAfkBlocks(uint64 blocks) external;
    function setValidators(address[] memory validators) external;
    function setWasmModuleRoot(bytes32 root) external;
    function wasmModuleRoot() external view returns (bytes32);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "baseStake",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridge",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract MockBridge"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "challengeManager",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "computeAssertionHash",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct AssertionState",
        "components": [
          {
            "name": "globalState",
            "type": "tuple",
            "internalType": "struct GlobalState",
            "components": [
              {
                "name": "bytes32Vals",
                "type": "bytes32[2]",
                "internalType": "bytes32[2]"
              },
              {
                "name": "u64Vals",
                "type": "uint64[2]",
                "internalType": "uint64[2]"
              }
            ]
          },
          {
            "name": "machineStatus",
            "type": "uint8",
            "internalType": "enum MachineStatus"
          },
          {
            "name": "endHistoryRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      },
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "confirmPeriodBlocks",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "fastConfirmNewAssertion",
    "inputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct AssertionInputs",
        "components": [
          {
            "name": "beforeStateData",
            "type": "tuple",
            "internalType": "struct BeforeStateData",
            "components": [
              {
                "name": "prevPrevAssertionHash",
                "type": "bytes32",
                "internalType": "bytes32"
              },
              {
                "name": "sequencerBatchAcc",
                "type": "bytes32",
                "internalType": "bytes32"
              },
              {
                "name": "configData",
                "type": "tuple",
                "internalType": "struct ConfigData",
                "components": [
                  {
                    "name": "wasmModuleRoot",
                    "type": "bytes32",
                    "internalType": "bytes32"
                  },
                  {
                    "name": "requiredStake",
                    "type": "uint256",
                    "internalType": "uint256"
                  },
                  {
                    "name": "challengeManager",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "confirmPeriodBlocks",
                    "type": "uint64",
                    "internalType": "uint64"
                  },
                  {
                    "name": "nextInboxPosition",
                    "type": "uint64",
                    "internalType": "uint64"
                  }
                ]
              }
            ]
          },
          {
            "name": "beforeState",
            "type": "tuple",
            "internalType": "struct AssertionState",
            "components": [
              {
                "name": "globalState",
                "type": "tuple",
                "internalType": "struct GlobalState",
                "components": [
                  {
                    "name": "bytes32Vals",
                    "type": "bytes32[2]",
                    "internalType": "bytes32[2]"
                  },
                  {
                    "name": "u64Vals",
                    "type": "uint64[2]",
                    "internalType": "uint64[2]"
                  }
                ]
              },
              {
                "name": "machineStatus",
                "type": "uint8",
                "internalType": "enum MachineStatus"
              },
              {
                "name": "endHistoryRoot",
                "type": "bytes32",
                "internalType": "bytes32"
              }
            ]
          },
          {
            "name": "afterState",
            "type": "tuple",
            "internalType": "struct AssertionState",
            "components": [
              {
                "name": "globalState",
                "type": "tuple",
                "internalType": "struct GlobalState",
                "components": [
                  {
                    "name": "bytes32Vals",
                    "type": "bytes32[2]",
                    "internalType": "bytes32[2]"
                  },
                  {
                    "name": "u64Vals",
                    "type": "uint64[2]",
                    "internalType": "uint64[2]"
                  }
                ]
              },
              {
                "name": "machineStatus",
                "type": "uint8",
                "internalType": "enum MachineStatus"
              },
              {
                "name": "endHistoryRoot",
                "type": "bytes32",
                "internalType": "bytes32"
              }
            ]
          }
        ]
      },
      {
        "name": "expectedAssertionHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "forceConfirmNode",
    "inputs": [
      {
        "name": "nodeNum",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "blockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "sendRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "forceCreateNode",
    "inputs": [
      {
        "name": "prevNode",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "prevNodeInboxMaxCount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Assertion",
        "components": [
          {
            "name": "beforeState",
            "type": "tuple",
            "internalType": "struct ExecutionState",
            "components": [
              {
                "name": "globalState",
                "type": "tuple",
                "internalType": "struct GlobalState",
                "components": [
                  {
                    "name": "bytes32Vals",
                    "type": "bytes32[2]",
                    "internalType": "bytes32[2]"
                  },
                  {
                    "name": "u64Vals",
                    "type": "uint64[2]",
                    "internalType": "uint64[2]"
                  }
                ]
              },
              {
                "name": "machineStatus",
                "type": "uint8",
                "internalType": "enum MachineStatus"
              }
            ]
          },
          {
            "name": "afterState",
            "type": "tuple",
            "internalType": "struct ExecutionState",
            "components": [
              {
                "name": "globalState",
                "type": "tuple",
                "internalType": "struct GlobalState",
                "components": [
                  {
                    "name": "bytes32Vals",
                    "type": "bytes32[2]",
                    "internalType": "bytes32[2]"
                  },
                  {
                    "name": "u64Vals",
                    "type": "uint64[2]",
                    "internalType": "uint64[2]"
                  }
                ]
              },
              {
                "name": "machineStatus",
                "type": "uint8",
                "internalType": "enum MachineStatus"
              }
            ]
          },
          {
            "name": "numBlocks",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      },
      {
        "name": "expectedNodeHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "genesisAssertionHash",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getValidators",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "paused",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "sequencerInbox",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract MockSequencerInbox"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setAnyTrustFastConfirmer",
    "inputs": [
      {
        "name": "confimer",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBaseStake",
    "inputs": [
      {
        "name": "stake",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setComputedAssertionHash",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setConfirmPeriodBlocks",
    "inputs": [
      {
        "name": "blocks",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setGenesisAssertionHash",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setLegacyMode",
    "inputs": [
      {
        "name": "mode",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setOwner",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setSequencerInboxAcc",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "acc",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setSequencerMessageCount",
    "inputs": [
      {
        "name": "count",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setValidator",
    "inputs": [
      {
        "name": "validators",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "values",
        "type": "bool[]",
        "internalType": "bool[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setValidatorAfkBlocks",
    "inputs": [
      {
        "name": "blocks",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setValidators",
    "inputs": [
      {
        "name": "validators",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setWasmModuleRoot",
    "inputs": [
      {
        "name": "root",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "wasmModuleRoot",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "AnyTrustFastConfirmerSet",
    "inputs": [
      {
        "name": "confimer",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FastConfirmNewAssertionCalled",
    "inputs": [
      {
        "name": "expectedAssertionHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ForceConfirmNodeCalled",
    "inputs": [
      {
        "name": "nodeNum",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      },
      {
        "name": "blockHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "sendRoot",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ForceCreateNodeCalled",
    "inputs": [
      {
        "name": "prevNode",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      },
      {
        "name": "prevNodeInboxMaxCount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "expectedNodeHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RolePaused",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ValidatorAfkBlocksSet",
    "inputs": [
      {
        "name": "blocks",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ValidatorsSet",
    "inputs": [
      {
        "name": "validators",
        "type": "address[]",
        "indexed": false,
        "internalType": "address[]"
      },
      {
        "name": "values",
        "type": "bool[]",
        "indexed": false,
        "internalType": "bool[]"
      }
    ],
    "anonymous": false
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod MockRollup {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60806040525f5f5f6101000a81548160ff02191690831515021790555061099960075f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555061099860085f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550612710600860146101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055503480156100d6575f5ffd5b506040516100e3906101d2565b604051809103905ff0801580156100fc573d5f5f3e3d5ffd5b5060095f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060095f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660405161016a906101df565b6101749190610266565b604051809103905ff08015801561018d573d5f5f3e3d5ffd5b50600a5f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555061027f565b61025780611b9a83390190565b6106cc80611df183390190565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f819050919050565b5f61022e610229610224846101ec565b61020b565b6101ec565b9050919050565b5f61023f82610214565b9050919050565b5f61025082610235565b9050919050565b61026081610246565b82525050565b5f6020820190506102795f830184610257565b92915050565b61190e8061028c5f395ff3fe608060405234801561000f575f5ffd5b50600436106101c2575f3560e01c806376e7e23b116100f7578063b7ab4db511610095578063e78cea921161006f578063e78cea9214610478578063ee35f32714610496578063f112cea3146104b4578063f3ef4b36146104d0576101c2565b8063b7ab4db514610422578063ce66d05c14610440578063d202deaa1461045c576101c2565b80638da5cb5b116100d15780638da5cb5b146103ae5780638ee1a126146103cc5780639300c926146103ea578063a3ffb77214610406576101c2565b806376e7e23b1461036a5780638456cb59146103885780638938496014610392576101c2565b80632f7968e811610164578063468eff501161013e578063468eff50146102f8578063470dce4e146103145780635c975abb146103305780636420fb9f1461034e576101c2565b80632f7968e81461028e57806333635fc2146102aa578063353325e0146102da576101c2565b806313af4035116101a057806313af40351461021c5780631d39e389146102385780632c24eccd146102545780632e7acfa614610270576101c2565b8063023a96fe146101c657806306ae5851146101e45780630d561b3714610200575b5f5ffd5b6101ce6104ec565b6040516101db9190610bb9565b60405180910390f35b6101fe60048036038101906101f99190610c16565b610514565b005b61021a60048036038101906102159190610c6b565b61051e565b005b61023660048036038101906102319190610c6b565b610558565b005b610252600480360381019061024d9190610ccb565b61059b565b005b61026e60048036038101906102699190610d29565b6105b6565b005b6102786105c0565b6040516102859190610d76565b60405180910390f35b6102a860048036038101906102a39190610db9565b6105dc565b005b6102c460048036038101906102bf9190610e2b565b61061c565b6040516102d19190610e8b565b60405180910390f35b6102e2610629565b6040516102ef9190610e8b565b60405180910390f35b610312600480360381019061030d9190610ea4565b610680565b005b61032e600480360381019061032991906111f2565b61070d565b005b61033861074e565b6040516103459190611267565b60405180910390f35b6103686004803603810190610363919061129f565b610755565b005b610372610790565b60405161037f91906112ee565b60405180910390f35b610390610799565b005b6103ac60048036038101906103a79190610d29565b6107c7565b005b6103b66107d1565b6040516103c39190610bb9565b60405180910390f35b6103d46107f9565b6040516103e19190610e8b565b60405180910390f35b61040460048036038101906103ff91906113c7565b610802565b005b610420600480360381019061041b91906114ce565b61089e565b005b61042a6108db565b60405161043791906115fb565b60405180910390f35b61045a6004803603810190610455919061161b565b610966565b005b61047660048036038101906104719190610c16565b610991565b005b610480610a1b565b60405161048d91906116a1565b60405180910390f35b61049e610a43565b6040516104ab91906116da565b60405180910390f35b6104ce60048036038101906104c9919061161b565b610a6b565b005b6104ea60048036038101906104e59190610d29565b610ace565b005b5f60085f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b8060038190555050565b7fd3ab4cbe1b6f519eb43f09ded17a12e81b811e297063ada2d65dddef5b612c7c8160405161054d9190610bb9565b60405180910390a150565b8060075f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b805f5f6101000a81548160ff02191690831515021790555050565b8060058190555050565b5f60045f9054906101000a900467ffffffffffffffff16905090565b7f8c8b7859bbc969bec99ac564f37f8128e2de9f85d340086139ad98a88598951b83838360405161060f939291906116f3565b60405180910390a1505050565b5f60055490509392505050565b5f5f5f9054906101000a900460ff1615610678576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161066f906117a8565b60405180910390fd5b600154905090565b60095f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663468eff5083836040518363ffffffff1660e01b81526004016106dc9291906117c6565b5f604051808303815f87803b1580156106f3575f5ffd5b505af1158015610705573d5f5f3e3d5ffd5b505050505050565b7f486a73d38b9adfb3ec83a2013b18f5771a948f666b038e1b5b03f8588a62cdd7848483604051610740939291906117ed565b60405180910390a150505050565b5f5f905090565b7f36d6096d658662ba82ae29e76de7daab22d6c3b2361a8294460766a28cf505d5816040516107849190610e8b565b60405180910390a15050565b5f600354905090565b7fa69b977e9474b454c0be019138b26cd46d25e4e2fbccf823202a0b6d7bbd3a2460405160405180910390a1565b8060028190555050565b5f60075f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b5f600254905090565b8060069080519060200190610818929190610ad8565b507f0d9690f97165f35991ae60d2a97e04aff472c08729722a9236ff1bc8b9ba90c081825167ffffffffffffffff81111561085657610855610ef6565b5b6040519080825280602002602001820160405280156108845781602001602082028036833780820191505090505b506040516108939291906118d9565b60405180910390a150565b7f0d9690f97165f35991ae60d2a97e04aff472c08729722a9236ff1bc8b9ba90c082826040516108cf9291906118d9565b60405180910390a15050565b6060600680548060200260200160405190810160405280929190818152602001828054801561095c57602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311610913575b5050505050905090565b8060045f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff16021790555050565b60095f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d202deaa826040518263ffffffff1660e01b81526004016109eb91906112ee565b5f604051808303815f87803b158015610a02575f5ffd5b505af1158015610a14573d5f5f3e3d5ffd5b5050505050565b5f60095f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b5f600a5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b80600860146101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055507f77bb7cc2722114e0171bcbd5e787510981490d0764c5fc10b97c49b0b82f24d681604051610ac39190610d76565b60405180910390a150565b8060018190555050565b828054828255905f5260205f20908101928215610b4e579160200282015b82811115610b4d578251825f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555091602001919060010190610af6565b5b509050610b5b9190610b5f565b5090565b5b80821115610b76575f815f905550600101610b60565b5090565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f610ba382610b7a565b9050919050565b610bb381610b99565b82525050565b5f602082019050610bcc5f830184610baa565b92915050565b5f604051905090565b5f5ffd5b5f5ffd5b5f819050919050565b610bf581610be3565b8114610bff575f5ffd5b50565b5f81359050610c1081610bec565b92915050565b5f60208284031215610c2b57610c2a610bdb565b5b5f610c3884828501610c02565b91505092915050565b610c4a81610b99565b8114610c54575f5ffd5b50565b5f81359050610c6581610c41565b92915050565b5f60208284031215610c8057610c7f610bdb565b5b5f610c8d84828501610c57565b91505092915050565b5f8115159050919050565b610caa81610c96565b8114610cb4575f5ffd5b50565b5f81359050610cc581610ca1565b92915050565b5f60208284031215610ce057610cdf610bdb565b5b5f610ced84828501610cb7565b91505092915050565b5f819050919050565b610d0881610cf6565b8114610d12575f5ffd5b50565b5f81359050610d2381610cff565b92915050565b5f60208284031215610d3e57610d3d610bdb565b5b5f610d4b84828501610d15565b91505092915050565b5f67ffffffffffffffff82169050919050565b610d7081610d54565b82525050565b5f602082019050610d895f830184610d67565b92915050565b610d9881610d54565b8114610da2575f5ffd5b50565b5f81359050610db381610d8f565b92915050565b5f5f5f60608486031215610dd057610dcf610bdb565b5b5f610ddd86828701610da5565b9350506020610dee86828701610d15565b9250506040610dff86828701610d15565b9150509250925092565b5f5ffd5b5f60c08284031215610e2257610e21610e09565b5b81905092915050565b5f5f5f6101008486031215610e4357610e42610bdb565b5b5f610e5086828701610d15565b9350506020610e6186828701610e0d565b92505060e0610e7286828701610d15565b9150509250925092565b610e8581610cf6565b82525050565b5f602082019050610e9e5f830184610e7c565b92915050565b5f5f60408385031215610eba57610eb9610bdb565b5b5f610ec785828601610c02565b9250506020610ed885828601610d15565b9150509250929050565b5f5ffd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b610f2c82610ee6565b810181811067ffffffffffffffff82111715610f4b57610f4a610ef6565b5b80604052505050565b5f610f5d610bd2565b9050610f698282610f23565b919050565b5f5ffd5b5f67ffffffffffffffff821115610f8c57610f8b610ef6565b5b602082029050919050565b5f5ffd5b5f610fad610fa884610f72565b610f54565b90508060208402830185811115610fc757610fc6610f97565b5b835b81811015610ff05780610fdc8882610d15565b845260208401935050602081019050610fc9565b5050509392505050565b5f82601f83011261100e5761100d610f6e565b5b600261101b848285610f9b565b91505092915050565b5f67ffffffffffffffff82111561103e5761103d610ef6565b5b602082029050919050565b5f61105b61105684611024565b610f54565b9050806020840283018581111561107557611074610f97565b5b835b8181101561109e578061108a8882610da5565b845260208401935050602081019050611077565b5050509392505050565b5f82601f8301126110bc576110bb610f6e565b5b60026110c9848285611049565b91505092915050565b5f608082840312156110e7576110e6610ee2565b5b6110f16040610f54565b90505f61110084828501610ffa565b5f830152506040611113848285016110a8565b60208301525092915050565b6003811061112b575f5ffd5b50565b5f8135905061113c8161111f565b92915050565b5f60a0828403121561115757611156610ee2565b5b6111616040610f54565b90505f611170848285016110d2565b5f8301525060806111838482850161112e565b60208301525092915050565b5f61016082840312156111a5576111a4610ee2565b5b6111af6060610f54565b90505f6111be84828501611142565b5f8301525060a06111d184828501611142565b6020830152506101406111e684828501610da5565b60408301525092915050565b5f5f5f5f6101c0858703121561120b5761120a610bdb565b5b5f61121887828801610da5565b945050602061122987828801610c02565b935050604061123a8782880161118f565b9250506101a061124c87828801610d15565b91505092959194509250565b61126181610c96565b82525050565b5f60208201905061127a5f830184611258565b92915050565b5f610260828403121561129657611295610e09565b5b81905092915050565b5f5f61028083850312156112b6576112b5610bdb565b5b5f6112c385828601611280565b9250506102606112d585828601610d15565b9150509250929050565b6112e881610be3565b82525050565b5f6020820190506113015f8301846112df565b92915050565b5f67ffffffffffffffff82111561132157611320610ef6565b5b602082029050602081019050919050565b5f61134461133f84611307565b610f54565b9050808382526020820190506020840283018581111561136757611366610f97565b5b835b81811015611390578061137c8882610c57565b845260208401935050602081019050611369565b5050509392505050565b5f82601f8301126113ae576113ad610f6e565b5b81356113be848260208601611332565b91505092915050565b5f602082840312156113dc576113db610bdb565b5b5f82013567ffffffffffffffff8111156113f9576113f8610bdf565b5b6114058482850161139a565b91505092915050565b5f67ffffffffffffffff82111561142857611427610ef6565b5b602082029050602081019050919050565b5f61144b6114468461140e565b610f54565b9050808382526020820190506020840283018581111561146e5761146d610f97565b5b835b8181101561149757806114838882610cb7565b845260208401935050602081019050611470565b5050509392505050565b5f82601f8301126114b5576114b4610f6e565b5b81356114c5848260208601611439565b91505092915050565b5f5f604083850312156114e4576114e3610bdb565b5b5f83013567ffffffffffffffff81111561150157611500610bdf565b5b61150d8582860161139a565b925050602083013567ffffffffffffffff81111561152e5761152d610bdf565b5b61153a858286016114a1565b9150509250929050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b61157681610b99565b82525050565b5f611587838361156d565b60208301905092915050565b5f602082019050919050565b5f6115a982611544565b6115b3818561154e565b93506115be8361155e565b805f5b838110156115ee5781516115d5888261157c565b97506115e083611593565b9250506001810190506115c1565b5085935050505092915050565b5f6020820190508181035f830152611613818461159f565b905092915050565b5f602082840312156116305761162f610bdb565b5b5f61163d84828501610da5565b91505092915050565b5f819050919050565b5f61166961166461165f84610b7a565b611646565b610b7a565b9050919050565b5f61167a8261164f565b9050919050565b5f61168b82611670565b9050919050565b61169b81611681565b82525050565b5f6020820190506116b45f830184611692565b92915050565b5f6116c482611670565b9050919050565b6116d4816116ba565b82525050565b5f6020820190506116ed5f8301846116cb565b92915050565b5f6060820190506117065f830186610d67565b6117136020830185610e7c565b6117206040830184610e7c565b949350505050565b5f82825260208201905092915050565b7f4c6567616379206d6f64653a206e6f2067656e6573697320617373657274696f5f8201527f6e20686173680000000000000000000000000000000000000000000000000000602082015250565b5f611792602683611728565b915061179d82611738565b604082019050919050565b5f6020820190508181035f8301526117bf81611786565b9050919050565b5f6040820190506117d95f8301856112df565b6117e66020830184610e7c565b9392505050565b5f6060820190506118005f830186610d67565b61180d60208301856112df565b61181a6040830184610e7c565b949350505050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b61185481610c96565b82525050565b5f611865838361184b565b60208301905092915050565b5f602082019050919050565b5f61188782611822565b611891818561182c565b935061189c8361183c565b805f5b838110156118cc5781516118b3888261185a565b97506118be83611871565b92505060018101905061189f565b5085935050505092915050565b5f6040820190508181035f8301526118f1818561159f565b90508181036020830152611905818461187d565b90509392505050566080604052348015600e575f5ffd5b5061023b8061001c5f395ff3fe608060405234801561000f575f5ffd5b5060043610610049575f3560e01c806284120c1461004d57806316bf55791461006b578063468eff501461009b578063d202deaa146100b7575b5f5ffd5b6100556100d3565b6040516100629190610130565b60405180910390f35b61008560048036038101906100809190610177565b6100db565b60405161009291906101ba565b60405180910390f35b6100b560048036038101906100b091906101fd565b6100f5565b005b6100d160048036038101906100cc9190610177565b61010f565b005b5f5f54905090565b5f60015f8381526020019081526020015f20549050919050565b8060015f8481526020019081526020015f20819055505050565b805f8190555050565b5f819050919050565b61012a81610118565b82525050565b5f6020820190506101435f830184610121565b92915050565b5f5ffd5b61015681610118565b8114610160575f5ffd5b50565b5f813590506101718161014d565b92915050565b5f6020828403121561018c5761018b610149565b5b5f61019984828501610163565b91505092915050565b5f819050919050565b6101b4816101a2565b82525050565b5f6020820190506101cd5f8301846101ab565b92915050565b6101dc816101a2565b81146101e6575f5ffd5b50565b5f813590506101f7816101d3565b92915050565b5f5f6040838503121561021357610212610149565b5b5f61022085828601610163565b9250506020610231858286016101e9565b915050925092905056608060405234801561000f575f5ffd5b506040516106cc3803806106cc833981810160405281019061003191906100e6565b8060015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050610111565b5f5ffd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100a48261007b565b9050919050565b5f6100b58261009a565b9050919050565b6100c5816100ab565b81146100cf575f5ffd5b50565b5f815190506100e0816100bc565b92915050565b5f602082840312156100fb576100fa610077565b5b5f610108848285016100d2565b91505092915050565b6105ae8061011e5f395ff3fe608060405234801561000f575f5ffd5b506004361061003f575f3560e01c80636e7df3e71461004357806371c3e6fe1461005f578063e0bc97291461008f575b5f5ffd5b61005d600480360381019061005891906102eb565b6100ab565b005b61007960048036038101906100749190610329565b61013b565b6040516100869190610363565b60405180910390f35b6100a960048036038101906100a4919061044b565b61018c565b005b805f5f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff0219169083151502179055507f28bcc5626d357efe966b4b0876aa1ee8ab99e26da4f131f6a2623f1800701c21828260405161012f929190610504565b60405180910390a15050565b5f5f5f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff169050919050565b60015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d202deaa60026040518263ffffffff1660e01b81526004016101e7919061056d565b5f604051808303815f87803b1580156101fe575f5ffd5b505af1158015610210573d5f5f3e3d5ffd5b505050507f1eb13a7f15212b56ad60574a2b0ad542f125db9cf126374b72e84c8b9d953ec3876040516102439190610595565b60405180910390a150505050505050565b5f5ffd5b5f5ffd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6102858261025c565b9050919050565b6102958161027b565b811461029f575f5ffd5b50565b5f813590506102b08161028c565b92915050565b5f8115159050919050565b6102ca816102b6565b81146102d4575f5ffd5b50565b5f813590506102e5816102c1565b92915050565b5f5f6040838503121561030157610300610254565b5b5f61030e858286016102a2565b925050602061031f858286016102d7565b9150509250929050565b5f6020828403121561033e5761033d610254565b5b5f61034b848285016102a2565b91505092915050565b61035d816102b6565b82525050565b5f6020820190506103765f830184610354565b92915050565b5f819050919050565b61038e8161037c565b8114610398575f5ffd5b50565b5f813590506103a981610385565b92915050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83601f8401126103d0576103cf6103af565b5b8235905067ffffffffffffffff8111156103ed576103ec6103b3565b5b602083019150836001820283011115610409576104086103b7565b5b9250929050565b5f61041a8261027b565b9050919050565b61042a81610410565b8114610434575f5ffd5b50565b5f8135905061044581610421565b92915050565b5f5f5f5f5f5f5f60c0888a03121561046657610465610254565b5b5f6104738a828b0161039b565b975050602088013567ffffffffffffffff81111561049457610493610258565b5b6104a08a828b016103bb565b965096505060406104b38a828b0161039b565b94505060606104c48a828b01610437565b93505060806104d58a828b0161039b565b92505060a06104e68a828b0161039b565b91505092959891949750929550565b6104fe8161027b565b82525050565b5f6040820190506105175f8301856104f5565b6105246020830184610354565b9392505050565b5f819050919050565b5f819050919050565b5f61055761055261054d8461052b565b610534565b61037c565b9050919050565b6105678161053d565b82525050565b5f6020820190506105805f83018461055e565b92915050565b61058f8161037c565b82525050565b5f6020820190506105a85f830184610586565b9291505056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R___a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPa\t\x99`\x07_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPa\t\x98`\x08_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPa'\x10`\x08`\x14a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP4\x80\x15a\0\xD6W__\xFD[P`@Qa\0\xE3\x90a\x01\xD2V[`@Q\x80\x91\x03\x90_\xF0\x80\x15\x80\x15a\0\xFCW=__>=_\xFD[P`\t_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\t_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`@Qa\x01j\x90a\x01\xDFV[a\x01t\x91\x90a\x02fV[`@Q\x80\x91\x03\x90_\xF0\x80\x15\x80\x15a\x01\x8DW=__>=_\xFD[P`\n_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPa\x02\x7FV[a\x02W\x80a\x1B\x9A\x839\x01\x90V[a\x06\xCC\x80a\x1D\xF1\x839\x01\x90V[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[_a\x02.a\x02)a\x02$\x84a\x01\xECV[a\x02\x0BV[a\x01\xECV[\x90P\x91\x90PV[_a\x02?\x82a\x02\x14V[\x90P\x91\x90PV[_a\x02P\x82a\x025V[\x90P\x91\x90PV[a\x02`\x81a\x02FV[\x82RPPV[_` \x82\x01\x90Pa\x02y_\x83\x01\x84a\x02WV[\x92\x91PPV[a\x19\x0E\x80a\x02\x8C_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01\xC2W_5`\xE0\x1C\x80cv\xE7\xE2;\x11a\0\xF7W\x80c\xB7\xABM\xB5\x11a\0\x95W\x80c\xE7\x8C\xEA\x92\x11a\0oW\x80c\xE7\x8C\xEA\x92\x14a\x04xW\x80c\xEE5\xF3'\x14a\x04\x96W\x80c\xF1\x12\xCE\xA3\x14a\x04\xB4W\x80c\xF3\xEFK6\x14a\x04\xD0Wa\x01\xC2V[\x80c\xB7\xABM\xB5\x14a\x04\"W\x80c\xCEf\xD0\\\x14a\x04@W\x80c\xD2\x02\xDE\xAA\x14a\x04\\Wa\x01\xC2V[\x80c\x8D\xA5\xCB[\x11a\0\xD1W\x80c\x8D\xA5\xCB[\x14a\x03\xAEW\x80c\x8E\xE1\xA1&\x14a\x03\xCCW\x80c\x93\0\xC9&\x14a\x03\xEAW\x80c\xA3\xFF\xB7r\x14a\x04\x06Wa\x01\xC2V[\x80cv\xE7\xE2;\x14a\x03jW\x80c\x84V\xCBY\x14a\x03\x88W\x80c\x898I`\x14a\x03\x92Wa\x01\xC2V[\x80c/yh\xE8\x11a\x01dW\x80cF\x8E\xFFP\x11a\x01>W\x80cF\x8E\xFFP\x14a\x02\xF8W\x80cG\r\xCEN\x14a\x03\x14W\x80c\\\x97Z\xBB\x14a\x030W\x80cd \xFB\x9F\x14a\x03NWa\x01\xC2V[\x80c/yh\xE8\x14a\x02\x8EW\x80c3c_\xC2\x14a\x02\xAAW\x80c53%\xE0\x14a\x02\xDAWa\x01\xC2V[\x80c\x13\xAF@5\x11a\x01\xA0W\x80c\x13\xAF@5\x14a\x02\x1CW\x80c\x1D9\xE3\x89\x14a\x028W\x80c,$\xEC\xCD\x14a\x02TW\x80c.z\xCF\xA6\x14a\x02pWa\x01\xC2V[\x80c\x02:\x96\xFE\x14a\x01\xC6W\x80c\x06\xAEXQ\x14a\x01\xE4W\x80c\rV\x1B7\x14a\x02\0W[__\xFD[a\x01\xCEa\x04\xECV[`@Qa\x01\xDB\x91\x90a\x0B\xB9V[`@Q\x80\x91\x03\x90\xF3[a\x01\xFE`\x04\x806\x03\x81\x01\x90a\x01\xF9\x91\x90a\x0C\x16V[a\x05\x14V[\0[a\x02\x1A`\x04\x806\x03\x81\x01\x90a\x02\x15\x91\x90a\x0CkV[a\x05\x1EV[\0[a\x026`\x04\x806\x03\x81\x01\x90a\x021\x91\x90a\x0CkV[a\x05XV[\0[a\x02R`\x04\x806\x03\x81\x01\x90a\x02M\x91\x90a\x0C\xCBV[a\x05\x9BV[\0[a\x02n`\x04\x806\x03\x81\x01\x90a\x02i\x91\x90a\r)V[a\x05\xB6V[\0[a\x02xa\x05\xC0V[`@Qa\x02\x85\x91\x90a\rvV[`@Q\x80\x91\x03\x90\xF3[a\x02\xA8`\x04\x806\x03\x81\x01\x90a\x02\xA3\x91\x90a\r\xB9V[a\x05\xDCV[\0[a\x02\xC4`\x04\x806\x03\x81\x01\x90a\x02\xBF\x91\x90a\x0E+V[a\x06\x1CV[`@Qa\x02\xD1\x91\x90a\x0E\x8BV[`@Q\x80\x91\x03\x90\xF3[a\x02\xE2a\x06)V[`@Qa\x02\xEF\x91\x90a\x0E\x8BV[`@Q\x80\x91\x03\x90\xF3[a\x03\x12`\x04\x806\x03\x81\x01\x90a\x03\r\x91\x90a\x0E\xA4V[a\x06\x80V[\0[a\x03.`\x04\x806\x03\x81\x01\x90a\x03)\x91\x90a\x11\xF2V[a\x07\rV[\0[a\x038a\x07NV[`@Qa\x03E\x91\x90a\x12gV[`@Q\x80\x91\x03\x90\xF3[a\x03h`\x04\x806\x03\x81\x01\x90a\x03c\x91\x90a\x12\x9FV[a\x07UV[\0[a\x03ra\x07\x90V[`@Qa\x03\x7F\x91\x90a\x12\xEEV[`@Q\x80\x91\x03\x90\xF3[a\x03\x90a\x07\x99V[\0[a\x03\xAC`\x04\x806\x03\x81\x01\x90a\x03\xA7\x91\x90a\r)V[a\x07\xC7V[\0[a\x03\xB6a\x07\xD1V[`@Qa\x03\xC3\x91\x90a\x0B\xB9V[`@Q\x80\x91\x03\x90\xF3[a\x03\xD4a\x07\xF9V[`@Qa\x03\xE1\x91\x90a\x0E\x8BV[`@Q\x80\x91\x03\x90\xF3[a\x04\x04`\x04\x806\x03\x81\x01\x90a\x03\xFF\x91\x90a\x13\xC7V[a\x08\x02V[\0[a\x04 `\x04\x806\x03\x81\x01\x90a\x04\x1B\x91\x90a\x14\xCEV[a\x08\x9EV[\0[a\x04*a\x08\xDBV[`@Qa\x047\x91\x90a\x15\xFBV[`@Q\x80\x91\x03\x90\xF3[a\x04Z`\x04\x806\x03\x81\x01\x90a\x04U\x91\x90a\x16\x1BV[a\tfV[\0[a\x04v`\x04\x806\x03\x81\x01\x90a\x04q\x91\x90a\x0C\x16V[a\t\x91V[\0[a\x04\x80a\n\x1BV[`@Qa\x04\x8D\x91\x90a\x16\xA1V[`@Q\x80\x91\x03\x90\xF3[a\x04\x9Ea\nCV[`@Qa\x04\xAB\x91\x90a\x16\xDAV[`@Q\x80\x91\x03\x90\xF3[a\x04\xCE`\x04\x806\x03\x81\x01\x90a\x04\xC9\x91\x90a\x16\x1BV[a\nkV[\0[a\x04\xEA`\x04\x806\x03\x81\x01\x90a\x04\xE5\x91\x90a\r)V[a\n\xCEV[\0[_`\x08_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[\x80`\x03\x81\x90UPPV[\x7F\xD3\xABL\xBE\x1BoQ\x9E\xB4?\t\xDE\xD1z\x12\xE8\x1B\x81\x1E)pc\xAD\xA2\xD6]\xDD\xEF[a,|\x81`@Qa\x05M\x91\x90a\x0B\xB9V[`@Q\x80\x91\x03\x90\xA1PV[\x80`\x07_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[\x80__a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPPV[\x80`\x05\x81\x90UPPV[_`\x04_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[\x7F\x8C\x8BxY\xBB\xC9i\xBE\xC9\x9A\xC5d\xF3\x7F\x81(\xE2\xDE\x9F\x85\xD3@\x08a9\xAD\x98\xA8\x85\x98\x95\x1B\x83\x83\x83`@Qa\x06\x0F\x93\x92\x91\x90a\x16\xF3V[`@Q\x80\x91\x03\x90\xA1PPPV[_`\x05T\x90P\x93\x92PPPV[___\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a\x06xW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06o\x90a\x17\xA8V[`@Q\x80\x91\x03\x90\xFD[`\x01T\x90P\x90V[`\t_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cF\x8E\xFFP\x83\x83`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x06\xDC\x92\x91\x90a\x17\xC6V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x06\xF3W__\xFD[PZ\xF1\x15\x80\x15a\x07\x05W=__>=_\xFD[PPPPPPV[\x7FHjs\xD3\x8B\x9A\xDF\xB3\xEC\x83\xA2\x01;\x18\xF5w\x1A\x94\x8Ffk\x03\x8E\x1B[\x03\xF8X\x8Ab\xCD\xD7\x84\x84\x83`@Qa\x07@\x93\x92\x91\x90a\x17\xEDV[`@Q\x80\x91\x03\x90\xA1PPPPV[__\x90P\x90V[\x7F6\xD6\tme\x86b\xBA\x82\xAE)\xE7m\xE7\xDA\xAB\"\xD6\xC3\xB26\x1A\x82\x94F\x07f\xA2\x8C\xF5\x05\xD5\x81`@Qa\x07\x84\x91\x90a\x0E\x8BV[`@Q\x80\x91\x03\x90\xA1PPV[_`\x03T\x90P\x90V[\x7F\xA6\x9B\x97~\x94t\xB4T\xC0\xBE\x01\x918\xB2l\xD4m%\xE4\xE2\xFB\xCC\xF8# *\x0Bm{\xBD:$`@Q`@Q\x80\x91\x03\x90\xA1V[\x80`\x02\x81\x90UPPV[_`\x07_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[_`\x02T\x90P\x90V[\x80`\x06\x90\x80Q\x90` \x01\x90a\x08\x18\x92\x91\x90a\n\xD8V[P\x7F\r\x96\x90\xF9qe\xF3Y\x91\xAE`\xD2\xA9~\x04\xAF\xF4r\xC0\x87)r*\x926\xFF\x1B\xC8\xB9\xBA\x90\xC0\x81\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x08VWa\x08Ua\x0E\xF6V[[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x08\x84W\x81` \x01` \x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P`@Qa\x08\x93\x92\x91\x90a\x18\xD9V[`@Q\x80\x91\x03\x90\xA1PV[\x7F\r\x96\x90\xF9qe\xF3Y\x91\xAE`\xD2\xA9~\x04\xAF\xF4r\xC0\x87)r*\x926\xFF\x1B\xC8\xB9\xBA\x90\xC0\x82\x82`@Qa\x08\xCF\x92\x91\x90a\x18\xD9V[`@Q\x80\x91\x03\x90\xA1PPV[```\x06\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\t\\W` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\t\x13W[PPPPP\x90P\x90V[\x80`\x04_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[`\t_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD2\x02\xDE\xAA\x82`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\t\xEB\x91\x90a\x12\xEEV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\n\x02W__\xFD[PZ\xF1\x15\x80\x15a\n\x14W=__>=_\xFD[PPPPPV[_`\t_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[_`\n_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[\x80`\x08`\x14a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7Fw\xBB|\xC2r!\x14\xE0\x17\x1B\xCB\xD5\xE7\x87Q\t\x81I\r\x07d\xC5\xFC\x10\xB9|I\xB0\xB8/$\xD6\x81`@Qa\n\xC3\x91\x90a\rvV[`@Q\x80\x91\x03\x90\xA1PV[\x80`\x01\x81\x90UPPV[\x82\x80T\x82\x82U\x90_R` _ \x90\x81\x01\x92\x82\x15a\x0BNW\x91` \x02\x82\x01[\x82\x81\x11\x15a\x0BMW\x82Q\x82_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x91` \x01\x91\x90`\x01\x01\x90a\n\xF6V[[P\x90Pa\x0B[\x91\x90a\x0B_V[P\x90V[[\x80\x82\x11\x15a\x0BvW_\x81_\x90UP`\x01\x01a\x0B`V[P\x90V[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a\x0B\xA3\x82a\x0BzV[\x90P\x91\x90PV[a\x0B\xB3\x81a\x0B\x99V[\x82RPPV[_` \x82\x01\x90Pa\x0B\xCC_\x83\x01\x84a\x0B\xAAV[\x92\x91PPV[_`@Q\x90P\x90V[__\xFD[__\xFD[_\x81\x90P\x91\x90PV[a\x0B\xF5\x81a\x0B\xE3V[\x81\x14a\x0B\xFFW__\xFD[PV[_\x815\x90Pa\x0C\x10\x81a\x0B\xECV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x0C+Wa\x0C*a\x0B\xDBV[[_a\x0C8\x84\x82\x85\x01a\x0C\x02V[\x91PP\x92\x91PPV[a\x0CJ\x81a\x0B\x99V[\x81\x14a\x0CTW__\xFD[PV[_\x815\x90Pa\x0Ce\x81a\x0CAV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x0C\x80Wa\x0C\x7Fa\x0B\xDBV[[_a\x0C\x8D\x84\x82\x85\x01a\x0CWV[\x91PP\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[a\x0C\xAA\x81a\x0C\x96V[\x81\x14a\x0C\xB4W__\xFD[PV[_\x815\x90Pa\x0C\xC5\x81a\x0C\xA1V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x0C\xE0Wa\x0C\xDFa\x0B\xDBV[[_a\x0C\xED\x84\x82\x85\x01a\x0C\xB7V[\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[a\r\x08\x81a\x0C\xF6V[\x81\x14a\r\x12W__\xFD[PV[_\x815\x90Pa\r#\x81a\x0C\xFFV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\r>Wa\r=a\x0B\xDBV[[_a\rK\x84\x82\x85\x01a\r\x15V[\x91PP\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a\rp\x81a\rTV[\x82RPPV[_` \x82\x01\x90Pa\r\x89_\x83\x01\x84a\rgV[\x92\x91PPV[a\r\x98\x81a\rTV[\x81\x14a\r\xA2W__\xFD[PV[_\x815\x90Pa\r\xB3\x81a\r\x8FV[\x92\x91PPV[___``\x84\x86\x03\x12\x15a\r\xD0Wa\r\xCFa\x0B\xDBV[[_a\r\xDD\x86\x82\x87\x01a\r\xA5V[\x93PP` a\r\xEE\x86\x82\x87\x01a\r\x15V[\x92PP`@a\r\xFF\x86\x82\x87\x01a\r\x15V[\x91PP\x92P\x92P\x92V[__\xFD[_`\xC0\x82\x84\x03\x12\x15a\x0E\"Wa\x0E!a\x0E\tV[[\x81\x90P\x92\x91PPV[___a\x01\0\x84\x86\x03\x12\x15a\x0ECWa\x0EBa\x0B\xDBV[[_a\x0EP\x86\x82\x87\x01a\r\x15V[\x93PP` a\x0Ea\x86\x82\x87\x01a\x0E\rV[\x92PP`\xE0a\x0Er\x86\x82\x87\x01a\r\x15V[\x91PP\x92P\x92P\x92V[a\x0E\x85\x81a\x0C\xF6V[\x82RPPV[_` \x82\x01\x90Pa\x0E\x9E_\x83\x01\x84a\x0E|V[\x92\x91PPV[__`@\x83\x85\x03\x12\x15a\x0E\xBAWa\x0E\xB9a\x0B\xDBV[[_a\x0E\xC7\x85\x82\x86\x01a\x0C\x02V[\x92PP` a\x0E\xD8\x85\x82\x86\x01a\r\x15V[\x91PP\x92P\x92\x90PV[__\xFD[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a\x0F,\x82a\x0E\xE6V[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a\x0FKWa\x0FJa\x0E\xF6V[[\x80`@RPPPV[_a\x0F]a\x0B\xD2V[\x90Pa\x0Fi\x82\x82a\x0F#V[\x91\x90PV[__\xFD[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x0F\x8CWa\x0F\x8Ba\x0E\xF6V[[` \x82\x02\x90P\x91\x90PV[__\xFD[_a\x0F\xADa\x0F\xA8\x84a\x0FrV[a\x0FTV[\x90P\x80` \x84\x02\x83\x01\x85\x81\x11\x15a\x0F\xC7Wa\x0F\xC6a\x0F\x97V[[\x83[\x81\x81\x10\x15a\x0F\xF0W\x80a\x0F\xDC\x88\x82a\r\x15V[\x84R` \x84\x01\x93PP` \x81\x01\x90Pa\x0F\xC9V[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\x10\x0EWa\x10\ra\x0FnV[[`\x02a\x10\x1B\x84\x82\x85a\x0F\x9BV[\x91PP\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x10>Wa\x10=a\x0E\xF6V[[` \x82\x02\x90P\x91\x90PV[_a\x10[a\x10V\x84a\x10$V[a\x0FTV[\x90P\x80` \x84\x02\x83\x01\x85\x81\x11\x15a\x10uWa\x10ta\x0F\x97V[[\x83[\x81\x81\x10\x15a\x10\x9EW\x80a\x10\x8A\x88\x82a\r\xA5V[\x84R` \x84\x01\x93PP` \x81\x01\x90Pa\x10wV[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\x10\xBCWa\x10\xBBa\x0FnV[[`\x02a\x10\xC9\x84\x82\x85a\x10IV[\x91PP\x92\x91PPV[_`\x80\x82\x84\x03\x12\x15a\x10\xE7Wa\x10\xE6a\x0E\xE2V[[a\x10\xF1`@a\x0FTV[\x90P_a\x11\0\x84\x82\x85\x01a\x0F\xFAV[_\x83\x01RP`@a\x11\x13\x84\x82\x85\x01a\x10\xA8V[` \x83\x01RP\x92\x91PPV[`\x03\x81\x10a\x11+W__\xFD[PV[_\x815\x90Pa\x11<\x81a\x11\x1FV[\x92\x91PPV[_`\xA0\x82\x84\x03\x12\x15a\x11WWa\x11Va\x0E\xE2V[[a\x11a`@a\x0FTV[\x90P_a\x11p\x84\x82\x85\x01a\x10\xD2V[_\x83\x01RP`\x80a\x11\x83\x84\x82\x85\x01a\x11.V[` \x83\x01RP\x92\x91PPV[_a\x01`\x82\x84\x03\x12\x15a\x11\xA5Wa\x11\xA4a\x0E\xE2V[[a\x11\xAF``a\x0FTV[\x90P_a\x11\xBE\x84\x82\x85\x01a\x11BV[_\x83\x01RP`\xA0a\x11\xD1\x84\x82\x85\x01a\x11BV[` \x83\x01RPa\x01@a\x11\xE6\x84\x82\x85\x01a\r\xA5V[`@\x83\x01RP\x92\x91PPV[____a\x01\xC0\x85\x87\x03\x12\x15a\x12\x0BWa\x12\na\x0B\xDBV[[_a\x12\x18\x87\x82\x88\x01a\r\xA5V[\x94PP` a\x12)\x87\x82\x88\x01a\x0C\x02V[\x93PP`@a\x12:\x87\x82\x88\x01a\x11\x8FV[\x92PPa\x01\xA0a\x12L\x87\x82\x88\x01a\r\x15V[\x91PP\x92\x95\x91\x94P\x92PV[a\x12a\x81a\x0C\x96V[\x82RPPV[_` \x82\x01\x90Pa\x12z_\x83\x01\x84a\x12XV[\x92\x91PPV[_a\x02`\x82\x84\x03\x12\x15a\x12\x96Wa\x12\x95a\x0E\tV[[\x81\x90P\x92\x91PPV[__a\x02\x80\x83\x85\x03\x12\x15a\x12\xB6Wa\x12\xB5a\x0B\xDBV[[_a\x12\xC3\x85\x82\x86\x01a\x12\x80V[\x92PPa\x02`a\x12\xD5\x85\x82\x86\x01a\r\x15V[\x91PP\x92P\x92\x90PV[a\x12\xE8\x81a\x0B\xE3V[\x82RPPV[_` \x82\x01\x90Pa\x13\x01_\x83\x01\x84a\x12\xDFV[\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x13!Wa\x13 a\x0E\xF6V[[` \x82\x02\x90P` \x81\x01\x90P\x91\x90PV[_a\x13Da\x13?\x84a\x13\x07V[a\x0FTV[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a\x13gWa\x13fa\x0F\x97V[[\x83[\x81\x81\x10\x15a\x13\x90W\x80a\x13|\x88\x82a\x0CWV[\x84R` \x84\x01\x93PP` \x81\x01\x90Pa\x13iV[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\x13\xAEWa\x13\xADa\x0FnV[[\x815a\x13\xBE\x84\x82` \x86\x01a\x132V[\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x13\xDCWa\x13\xDBa\x0B\xDBV[[_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x13\xF9Wa\x13\xF8a\x0B\xDFV[[a\x14\x05\x84\x82\x85\x01a\x13\x9AV[\x91PP\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x14(Wa\x14'a\x0E\xF6V[[` \x82\x02\x90P` \x81\x01\x90P\x91\x90PV[_a\x14Ka\x14F\x84a\x14\x0EV[a\x0FTV[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a\x14nWa\x14ma\x0F\x97V[[\x83[\x81\x81\x10\x15a\x14\x97W\x80a\x14\x83\x88\x82a\x0C\xB7V[\x84R` \x84\x01\x93PP` \x81\x01\x90Pa\x14pV[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\x14\xB5Wa\x14\xB4a\x0FnV[[\x815a\x14\xC5\x84\x82` \x86\x01a\x149V[\x91PP\x92\x91PPV[__`@\x83\x85\x03\x12\x15a\x14\xE4Wa\x14\xE3a\x0B\xDBV[[_\x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x15\x01Wa\x15\0a\x0B\xDFV[[a\x15\r\x85\x82\x86\x01a\x13\x9AV[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x15.Wa\x15-a\x0B\xDFV[[a\x15:\x85\x82\x86\x01a\x14\xA1V[\x91PP\x92P\x92\x90PV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[a\x15v\x81a\x0B\x99V[\x82RPPV[_a\x15\x87\x83\x83a\x15mV[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a\x15\xA9\x82a\x15DV[a\x15\xB3\x81\x85a\x15NV[\x93Pa\x15\xBE\x83a\x15^V[\x80_[\x83\x81\x10\x15a\x15\xEEW\x81Qa\x15\xD5\x88\x82a\x15|V[\x97Pa\x15\xE0\x83a\x15\x93V[\x92PP`\x01\x81\x01\x90Pa\x15\xC1V[P\x85\x93PPPP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x16\x13\x81\x84a\x15\x9FV[\x90P\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x160Wa\x16/a\x0B\xDBV[[_a\x16=\x84\x82\x85\x01a\r\xA5V[\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[_a\x16ia\x16da\x16_\x84a\x0BzV[a\x16FV[a\x0BzV[\x90P\x91\x90PV[_a\x16z\x82a\x16OV[\x90P\x91\x90PV[_a\x16\x8B\x82a\x16pV[\x90P\x91\x90PV[a\x16\x9B\x81a\x16\x81V[\x82RPPV[_` \x82\x01\x90Pa\x16\xB4_\x83\x01\x84a\x16\x92V[\x92\x91PPV[_a\x16\xC4\x82a\x16pV[\x90P\x91\x90PV[a\x16\xD4\x81a\x16\xBAV[\x82RPPV[_` \x82\x01\x90Pa\x16\xED_\x83\x01\x84a\x16\xCBV[\x92\x91PPV[_``\x82\x01\x90Pa\x17\x06_\x83\x01\x86a\rgV[a\x17\x13` \x83\x01\x85a\x0E|V[a\x17 `@\x83\x01\x84a\x0E|V[\x94\x93PPPPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7FLegacy mode: no genesis assertio_\x82\x01R\x7Fn hash\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\x17\x92`&\x83a\x17(V[\x91Pa\x17\x9D\x82a\x178V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x17\xBF\x81a\x17\x86V[\x90P\x91\x90PV[_`@\x82\x01\x90Pa\x17\xD9_\x83\x01\x85a\x12\xDFV[a\x17\xE6` \x83\x01\x84a\x0E|V[\x93\x92PPPV[_``\x82\x01\x90Pa\x18\0_\x83\x01\x86a\rgV[a\x18\r` \x83\x01\x85a\x12\xDFV[a\x18\x1A`@\x83\x01\x84a\x0E|V[\x94\x93PPPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[a\x18T\x81a\x0C\x96V[\x82RPPV[_a\x18e\x83\x83a\x18KV[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a\x18\x87\x82a\x18\"V[a\x18\x91\x81\x85a\x18,V[\x93Pa\x18\x9C\x83a\x18<V[\x80_[\x83\x81\x10\x15a\x18\xCCW\x81Qa\x18\xB3\x88\x82a\x18ZV[\x97Pa\x18\xBE\x83a\x18qV[\x92PP`\x01\x81\x01\x90Pa\x18\x9FV[P\x85\x93PPPP\x92\x91PPV[_`@\x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x18\xF1\x81\x85a\x15\x9FV[\x90P\x81\x81\x03` \x83\x01Ra\x19\x05\x81\x84a\x18}V[\x90P\x93\x92PPPV`\x80`@R4\x80\x15`\x0EW__\xFD[Pa\x02;\x80a\0\x1C_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\0IW_5`\xE0\x1C\x80b\x84\x12\x0C\x14a\0MW\x80c\x16\xBFUy\x14a\0kW\x80cF\x8E\xFFP\x14a\0\x9BW\x80c\xD2\x02\xDE\xAA\x14a\0\xB7W[__\xFD[a\0Ua\0\xD3V[`@Qa\0b\x91\x90a\x010V[`@Q\x80\x91\x03\x90\xF3[a\0\x85`\x04\x806\x03\x81\x01\x90a\0\x80\x91\x90a\x01wV[a\0\xDBV[`@Qa\0\x92\x91\x90a\x01\xBAV[`@Q\x80\x91\x03\x90\xF3[a\0\xB5`\x04\x806\x03\x81\x01\x90a\0\xB0\x91\x90a\x01\xFDV[a\0\xF5V[\0[a\0\xD1`\x04\x806\x03\x81\x01\x90a\0\xCC\x91\x90a\x01wV[a\x01\x0FV[\0[__T\x90P\x90V[_`\x01_\x83\x81R` \x01\x90\x81R` \x01_ T\x90P\x91\x90PV[\x80`\x01_\x84\x81R` \x01\x90\x81R` \x01_ \x81\x90UPPPV[\x80_\x81\x90UPPV[_\x81\x90P\x91\x90PV[a\x01*\x81a\x01\x18V[\x82RPPV[_` \x82\x01\x90Pa\x01C_\x83\x01\x84a\x01!V[\x92\x91PPV[__\xFD[a\x01V\x81a\x01\x18V[\x81\x14a\x01`W__\xFD[PV[_\x815\x90Pa\x01q\x81a\x01MV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x01\x8CWa\x01\x8Ba\x01IV[[_a\x01\x99\x84\x82\x85\x01a\x01cV[\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[a\x01\xB4\x81a\x01\xA2V[\x82RPPV[_` \x82\x01\x90Pa\x01\xCD_\x83\x01\x84a\x01\xABV[\x92\x91PPV[a\x01\xDC\x81a\x01\xA2V[\x81\x14a\x01\xE6W__\xFD[PV[_\x815\x90Pa\x01\xF7\x81a\x01\xD3V[\x92\x91PPV[__`@\x83\x85\x03\x12\x15a\x02\x13Wa\x02\x12a\x01IV[[_a\x02 \x85\x82\x86\x01a\x01cV[\x92PP` a\x021\x85\x82\x86\x01a\x01\xE9V[\x91PP\x92P\x92\x90PV`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`@Qa\x06\xCC8\x03\x80a\x06\xCC\x839\x81\x81\x01`@R\x81\x01\x90a\x001\x91\x90a\0\xE6V[\x80`\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPa\x01\x11V[__\xFD[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a\0\xA4\x82a\0{V[\x90P\x91\x90PV[_a\0\xB5\x82a\0\x9AV[\x90P\x91\x90PV[a\0\xC5\x81a\0\xABV[\x81\x14a\0\xCFW__\xFD[PV[_\x81Q\x90Pa\0\xE0\x81a\0\xBCV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\0\xFBWa\0\xFAa\0wV[[_a\x01\x08\x84\x82\x85\x01a\0\xD2V[\x91PP\x92\x91PPV[a\x05\xAE\x80a\x01\x1E_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\0?W_5`\xE0\x1C\x80cn}\xF3\xE7\x14a\0CW\x80cq\xC3\xE6\xFE\x14a\0_W\x80c\xE0\xBC\x97)\x14a\0\x8FW[__\xFD[a\0]`\x04\x806\x03\x81\x01\x90a\0X\x91\x90a\x02\xEBV[a\0\xABV[\0[a\0y`\x04\x806\x03\x81\x01\x90a\0t\x91\x90a\x03)V[a\x01;V[`@Qa\0\x86\x91\x90a\x03cV[`@Q\x80\x91\x03\x90\xF3[a\0\xA9`\x04\x806\x03\x81\x01\x90a\0\xA4\x91\x90a\x04KV[a\x01\x8CV[\0[\x80__\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F(\xBC\xC5bm5~\xFE\x96kK\x08v\xAA\x1E\xE8\xAB\x99\xE2m\xA4\xF11\xF6\xA2b?\x18\0p\x1C!\x82\x82`@Qa\x01/\x92\x91\x90a\x05\x04V[`@Q\x80\x91\x03\x90\xA1PPV[___\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x91\x90PV[`\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD2\x02\xDE\xAA`\x02`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x01\xE7\x91\x90a\x05mV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x01\xFEW__\xFD[PZ\xF1\x15\x80\x15a\x02\x10W=__>=_\xFD[PPPP\x7F\x1E\xB1:\x7F\x15!+V\xAD`WJ+\n\xD5B\xF1%\xDB\x9C\xF1&7Kr\xE8L\x8B\x9D\x95>\xC3\x87`@Qa\x02C\x91\x90a\x05\x95V[`@Q\x80\x91\x03\x90\xA1PPPPPPPV[__\xFD[__\xFD[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a\x02\x85\x82a\x02\\V[\x90P\x91\x90PV[a\x02\x95\x81a\x02{V[\x81\x14a\x02\x9FW__\xFD[PV[_\x815\x90Pa\x02\xB0\x81a\x02\x8CV[\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[a\x02\xCA\x81a\x02\xB6V[\x81\x14a\x02\xD4W__\xFD[PV[_\x815\x90Pa\x02\xE5\x81a\x02\xC1V[\x92\x91PPV[__`@\x83\x85\x03\x12\x15a\x03\x01Wa\x03\0a\x02TV[[_a\x03\x0E\x85\x82\x86\x01a\x02\xA2V[\x92PP` a\x03\x1F\x85\x82\x86\x01a\x02\xD7V[\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15a\x03>Wa\x03=a\x02TV[[_a\x03K\x84\x82\x85\x01a\x02\xA2V[\x91PP\x92\x91PPV[a\x03]\x81a\x02\xB6V[\x82RPPV[_` \x82\x01\x90Pa\x03v_\x83\x01\x84a\x03TV[\x92\x91PPV[_\x81\x90P\x91\x90PV[a\x03\x8E\x81a\x03|V[\x81\x14a\x03\x98W__\xFD[PV[_\x815\x90Pa\x03\xA9\x81a\x03\x85V[\x92\x91PPV[__\xFD[__\xFD[__\xFD[__\x83`\x1F\x84\x01\x12a\x03\xD0Wa\x03\xCFa\x03\xAFV[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x03\xEDWa\x03\xECa\x03\xB3V[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15a\x04\tWa\x04\x08a\x03\xB7V[[\x92P\x92\x90PV[_a\x04\x1A\x82a\x02{V[\x90P\x91\x90PV[a\x04*\x81a\x04\x10V[\x81\x14a\x044W__\xFD[PV[_\x815\x90Pa\x04E\x81a\x04!V[\x92\x91PPV[_______`\xC0\x88\x8A\x03\x12\x15a\x04fWa\x04ea\x02TV[[_a\x04s\x8A\x82\x8B\x01a\x03\x9BV[\x97PP` \x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x04\x94Wa\x04\x93a\x02XV[[a\x04\xA0\x8A\x82\x8B\x01a\x03\xBBV[\x96P\x96PP`@a\x04\xB3\x8A\x82\x8B\x01a\x03\x9BV[\x94PP``a\x04\xC4\x8A\x82\x8B\x01a\x047V[\x93PP`\x80a\x04\xD5\x8A\x82\x8B\x01a\x03\x9BV[\x92PP`\xA0a\x04\xE6\x8A\x82\x8B\x01a\x03\x9BV[\x91PP\x92\x95\x98\x91\x94\x97P\x92\x95PV[a\x04\xFE\x81a\x02{V[\x82RPPV[_`@\x82\x01\x90Pa\x05\x17_\x83\x01\x85a\x04\xF5V[a\x05$` \x83\x01\x84a\x03TV[\x93\x92PPPV[_\x81\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[_a\x05Wa\x05Ra\x05M\x84a\x05+V[a\x054V[a\x03|V[\x90P\x91\x90PV[a\x05g\x81a\x05=V[\x82RPPV[_` \x82\x01\x90Pa\x05\x80_\x83\x01\x84a\x05^V[\x92\x91PPV[a\x05\x8F\x81a\x03|V[\x82RPPV[_` \x82\x01\x90Pa\x05\xA8_\x83\x01\x84a\x05\x86V[\x92\x91PPV",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b50600436106101c2575f3560e01c806376e7e23b116100f7578063b7ab4db511610095578063e78cea921161006f578063e78cea9214610478578063ee35f32714610496578063f112cea3146104b4578063f3ef4b36146104d0576101c2565b8063b7ab4db514610422578063ce66d05c14610440578063d202deaa1461045c576101c2565b80638da5cb5b116100d15780638da5cb5b146103ae5780638ee1a126146103cc5780639300c926146103ea578063a3ffb77214610406576101c2565b806376e7e23b1461036a5780638456cb59146103885780638938496014610392576101c2565b80632f7968e811610164578063468eff501161013e578063468eff50146102f8578063470dce4e146103145780635c975abb146103305780636420fb9f1461034e576101c2565b80632f7968e81461028e57806333635fc2146102aa578063353325e0146102da576101c2565b806313af4035116101a057806313af40351461021c5780631d39e389146102385780632c24eccd146102545780632e7acfa614610270576101c2565b8063023a96fe146101c657806306ae5851146101e45780630d561b3714610200575b5f5ffd5b6101ce6104ec565b6040516101db9190610bb9565b60405180910390f35b6101fe60048036038101906101f99190610c16565b610514565b005b61021a60048036038101906102159190610c6b565b61051e565b005b61023660048036038101906102319190610c6b565b610558565b005b610252600480360381019061024d9190610ccb565b61059b565b005b61026e60048036038101906102699190610d29565b6105b6565b005b6102786105c0565b6040516102859190610d76565b60405180910390f35b6102a860048036038101906102a39190610db9565b6105dc565b005b6102c460048036038101906102bf9190610e2b565b61061c565b6040516102d19190610e8b565b60405180910390f35b6102e2610629565b6040516102ef9190610e8b565b60405180910390f35b610312600480360381019061030d9190610ea4565b610680565b005b61032e600480360381019061032991906111f2565b61070d565b005b61033861074e565b6040516103459190611267565b60405180910390f35b6103686004803603810190610363919061129f565b610755565b005b610372610790565b60405161037f91906112ee565b60405180910390f35b610390610799565b005b6103ac60048036038101906103a79190610d29565b6107c7565b005b6103b66107d1565b6040516103c39190610bb9565b60405180910390f35b6103d46107f9565b6040516103e19190610e8b565b60405180910390f35b61040460048036038101906103ff91906113c7565b610802565b005b610420600480360381019061041b91906114ce565b61089e565b005b61042a6108db565b60405161043791906115fb565b60405180910390f35b61045a6004803603810190610455919061161b565b610966565b005b61047660048036038101906104719190610c16565b610991565b005b610480610a1b565b60405161048d91906116a1565b60405180910390f35b61049e610a43565b6040516104ab91906116da565b60405180910390f35b6104ce60048036038101906104c9919061161b565b610a6b565b005b6104ea60048036038101906104e59190610d29565b610ace565b005b5f60085f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b8060038190555050565b7fd3ab4cbe1b6f519eb43f09ded17a12e81b811e297063ada2d65dddef5b612c7c8160405161054d9190610bb9565b60405180910390a150565b8060075f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b805f5f6101000a81548160ff02191690831515021790555050565b8060058190555050565b5f60045f9054906101000a900467ffffffffffffffff16905090565b7f8c8b7859bbc969bec99ac564f37f8128e2de9f85d340086139ad98a88598951b83838360405161060f939291906116f3565b60405180910390a1505050565b5f60055490509392505050565b5f5f5f9054906101000a900460ff1615610678576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161066f906117a8565b60405180910390fd5b600154905090565b60095f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663468eff5083836040518363ffffffff1660e01b81526004016106dc9291906117c6565b5f604051808303815f87803b1580156106f3575f5ffd5b505af1158015610705573d5f5f3e3d5ffd5b505050505050565b7f486a73d38b9adfb3ec83a2013b18f5771a948f666b038e1b5b03f8588a62cdd7848483604051610740939291906117ed565b60405180910390a150505050565b5f5f905090565b7f36d6096d658662ba82ae29e76de7daab22d6c3b2361a8294460766a28cf505d5816040516107849190610e8b565b60405180910390a15050565b5f600354905090565b7fa69b977e9474b454c0be019138b26cd46d25e4e2fbccf823202a0b6d7bbd3a2460405160405180910390a1565b8060028190555050565b5f60075f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b5f600254905090565b8060069080519060200190610818929190610ad8565b507f0d9690f97165f35991ae60d2a97e04aff472c08729722a9236ff1bc8b9ba90c081825167ffffffffffffffff81111561085657610855610ef6565b5b6040519080825280602002602001820160405280156108845781602001602082028036833780820191505090505b506040516108939291906118d9565b60405180910390a150565b7f0d9690f97165f35991ae60d2a97e04aff472c08729722a9236ff1bc8b9ba90c082826040516108cf9291906118d9565b60405180910390a15050565b6060600680548060200260200160405190810160405280929190818152602001828054801561095c57602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311610913575b5050505050905090565b8060045f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff16021790555050565b60095f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d202deaa826040518263ffffffff1660e01b81526004016109eb91906112ee565b5f604051808303815f87803b158015610a02575f5ffd5b505af1158015610a14573d5f5f3e3d5ffd5b5050505050565b5f60095f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b5f600a5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b80600860146101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055507f77bb7cc2722114e0171bcbd5e787510981490d0764c5fc10b97c49b0b82f24d681604051610ac39190610d76565b60405180910390a150565b8060018190555050565b828054828255905f5260205f20908101928215610b4e579160200282015b82811115610b4d578251825f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555091602001919060010190610af6565b5b509050610b5b9190610b5f565b5090565b5b80821115610b76575f815f905550600101610b60565b5090565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f610ba382610b7a565b9050919050565b610bb381610b99565b82525050565b5f602082019050610bcc5f830184610baa565b92915050565b5f604051905090565b5f5ffd5b5f5ffd5b5f819050919050565b610bf581610be3565b8114610bff575f5ffd5b50565b5f81359050610c1081610bec565b92915050565b5f60208284031215610c2b57610c2a610bdb565b5b5f610c3884828501610c02565b91505092915050565b610c4a81610b99565b8114610c54575f5ffd5b50565b5f81359050610c6581610c41565b92915050565b5f60208284031215610c8057610c7f610bdb565b5b5f610c8d84828501610c57565b91505092915050565b5f8115159050919050565b610caa81610c96565b8114610cb4575f5ffd5b50565b5f81359050610cc581610ca1565b92915050565b5f60208284031215610ce057610cdf610bdb565b5b5f610ced84828501610cb7565b91505092915050565b5f819050919050565b610d0881610cf6565b8114610d12575f5ffd5b50565b5f81359050610d2381610cff565b92915050565b5f60208284031215610d3e57610d3d610bdb565b5b5f610d4b84828501610d15565b91505092915050565b5f67ffffffffffffffff82169050919050565b610d7081610d54565b82525050565b5f602082019050610d895f830184610d67565b92915050565b610d9881610d54565b8114610da2575f5ffd5b50565b5f81359050610db381610d8f565b92915050565b5f5f5f60608486031215610dd057610dcf610bdb565b5b5f610ddd86828701610da5565b9350506020610dee86828701610d15565b9250506040610dff86828701610d15565b9150509250925092565b5f5ffd5b5f60c08284031215610e2257610e21610e09565b5b81905092915050565b5f5f5f6101008486031215610e4357610e42610bdb565b5b5f610e5086828701610d15565b9350506020610e6186828701610e0d565b92505060e0610e7286828701610d15565b9150509250925092565b610e8581610cf6565b82525050565b5f602082019050610e9e5f830184610e7c565b92915050565b5f5f60408385031215610eba57610eb9610bdb565b5b5f610ec785828601610c02565b9250506020610ed885828601610d15565b9150509250929050565b5f5ffd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b610f2c82610ee6565b810181811067ffffffffffffffff82111715610f4b57610f4a610ef6565b5b80604052505050565b5f610f5d610bd2565b9050610f698282610f23565b919050565b5f5ffd5b5f67ffffffffffffffff821115610f8c57610f8b610ef6565b5b602082029050919050565b5f5ffd5b5f610fad610fa884610f72565b610f54565b90508060208402830185811115610fc757610fc6610f97565b5b835b81811015610ff05780610fdc8882610d15565b845260208401935050602081019050610fc9565b5050509392505050565b5f82601f83011261100e5761100d610f6e565b5b600261101b848285610f9b565b91505092915050565b5f67ffffffffffffffff82111561103e5761103d610ef6565b5b602082029050919050565b5f61105b61105684611024565b610f54565b9050806020840283018581111561107557611074610f97565b5b835b8181101561109e578061108a8882610da5565b845260208401935050602081019050611077565b5050509392505050565b5f82601f8301126110bc576110bb610f6e565b5b60026110c9848285611049565b91505092915050565b5f608082840312156110e7576110e6610ee2565b5b6110f16040610f54565b90505f61110084828501610ffa565b5f830152506040611113848285016110a8565b60208301525092915050565b6003811061112b575f5ffd5b50565b5f8135905061113c8161111f565b92915050565b5f60a0828403121561115757611156610ee2565b5b6111616040610f54565b90505f611170848285016110d2565b5f8301525060806111838482850161112e565b60208301525092915050565b5f61016082840312156111a5576111a4610ee2565b5b6111af6060610f54565b90505f6111be84828501611142565b5f8301525060a06111d184828501611142565b6020830152506101406111e684828501610da5565b60408301525092915050565b5f5f5f5f6101c0858703121561120b5761120a610bdb565b5b5f61121887828801610da5565b945050602061122987828801610c02565b935050604061123a8782880161118f565b9250506101a061124c87828801610d15565b91505092959194509250565b61126181610c96565b82525050565b5f60208201905061127a5f830184611258565b92915050565b5f610260828403121561129657611295610e09565b5b81905092915050565b5f5f61028083850312156112b6576112b5610bdb565b5b5f6112c385828601611280565b9250506102606112d585828601610d15565b9150509250929050565b6112e881610be3565b82525050565b5f6020820190506113015f8301846112df565b92915050565b5f67ffffffffffffffff82111561132157611320610ef6565b5b602082029050602081019050919050565b5f61134461133f84611307565b610f54565b9050808382526020820190506020840283018581111561136757611366610f97565b5b835b81811015611390578061137c8882610c57565b845260208401935050602081019050611369565b5050509392505050565b5f82601f8301126113ae576113ad610f6e565b5b81356113be848260208601611332565b91505092915050565b5f602082840312156113dc576113db610bdb565b5b5f82013567ffffffffffffffff8111156113f9576113f8610bdf565b5b6114058482850161139a565b91505092915050565b5f67ffffffffffffffff82111561142857611427610ef6565b5b602082029050602081019050919050565b5f61144b6114468461140e565b610f54565b9050808382526020820190506020840283018581111561146e5761146d610f97565b5b835b8181101561149757806114838882610cb7565b845260208401935050602081019050611470565b5050509392505050565b5f82601f8301126114b5576114b4610f6e565b5b81356114c5848260208601611439565b91505092915050565b5f5f604083850312156114e4576114e3610bdb565b5b5f83013567ffffffffffffffff81111561150157611500610bdf565b5b61150d8582860161139a565b925050602083013567ffffffffffffffff81111561152e5761152d610bdf565b5b61153a858286016114a1565b9150509250929050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b61157681610b99565b82525050565b5f611587838361156d565b60208301905092915050565b5f602082019050919050565b5f6115a982611544565b6115b3818561154e565b93506115be8361155e565b805f5b838110156115ee5781516115d5888261157c565b97506115e083611593565b9250506001810190506115c1565b5085935050505092915050565b5f6020820190508181035f830152611613818461159f565b905092915050565b5f602082840312156116305761162f610bdb565b5b5f61163d84828501610da5565b91505092915050565b5f819050919050565b5f61166961166461165f84610b7a565b611646565b610b7a565b9050919050565b5f61167a8261164f565b9050919050565b5f61168b82611670565b9050919050565b61169b81611681565b82525050565b5f6020820190506116b45f830184611692565b92915050565b5f6116c482611670565b9050919050565b6116d4816116ba565b82525050565b5f6020820190506116ed5f8301846116cb565b92915050565b5f6060820190506117065f830186610d67565b6117136020830185610e7c565b6117206040830184610e7c565b949350505050565b5f82825260208201905092915050565b7f4c6567616379206d6f64653a206e6f2067656e6573697320617373657274696f5f8201527f6e20686173680000000000000000000000000000000000000000000000000000602082015250565b5f611792602683611728565b915061179d82611738565b604082019050919050565b5f6020820190508181035f8301526117bf81611786565b9050919050565b5f6040820190506117d95f8301856112df565b6117e66020830184610e7c565b9392505050565b5f6060820190506118005f830186610d67565b61180d60208301856112df565b61181a6040830184610e7c565b949350505050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b61185481610c96565b82525050565b5f611865838361184b565b60208301905092915050565b5f602082019050919050565b5f61188782611822565b611891818561182c565b935061189c8361183c565b805f5b838110156118cc5781516118b3888261185a565b97506118be83611871565b92505060018101905061189f565b5085935050505092915050565b5f6040820190508181035f8301526118f1818561159f565b90508181036020830152611905818461187d565b9050939250505056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01\xC2W_5`\xE0\x1C\x80cv\xE7\xE2;\x11a\0\xF7W\x80c\xB7\xABM\xB5\x11a\0\x95W\x80c\xE7\x8C\xEA\x92\x11a\0oW\x80c\xE7\x8C\xEA\x92\x14a\x04xW\x80c\xEE5\xF3'\x14a\x04\x96W\x80c\xF1\x12\xCE\xA3\x14a\x04\xB4W\x80c\xF3\xEFK6\x14a\x04\xD0Wa\x01\xC2V[\x80c\xB7\xABM\xB5\x14a\x04\"W\x80c\xCEf\xD0\\\x14a\x04@W\x80c\xD2\x02\xDE\xAA\x14a\x04\\Wa\x01\xC2V[\x80c\x8D\xA5\xCB[\x11a\0\xD1W\x80c\x8D\xA5\xCB[\x14a\x03\xAEW\x80c\x8E\xE1\xA1&\x14a\x03\xCCW\x80c\x93\0\xC9&\x14a\x03\xEAW\x80c\xA3\xFF\xB7r\x14a\x04\x06Wa\x01\xC2V[\x80cv\xE7\xE2;\x14a\x03jW\x80c\x84V\xCBY\x14a\x03\x88W\x80c\x898I`\x14a\x03\x92Wa\x01\xC2V[\x80c/yh\xE8\x11a\x01dW\x80cF\x8E\xFFP\x11a\x01>W\x80cF\x8E\xFFP\x14a\x02\xF8W\x80cG\r\xCEN\x14a\x03\x14W\x80c\\\x97Z\xBB\x14a\x030W\x80cd \xFB\x9F\x14a\x03NWa\x01\xC2V[\x80c/yh\xE8\x14a\x02\x8EW\x80c3c_\xC2\x14a\x02\xAAW\x80c53%\xE0\x14a\x02\xDAWa\x01\xC2V[\x80c\x13\xAF@5\x11a\x01\xA0W\x80c\x13\xAF@5\x14a\x02\x1CW\x80c\x1D9\xE3\x89\x14a\x028W\x80c,$\xEC\xCD\x14a\x02TW\x80c.z\xCF\xA6\x14a\x02pWa\x01\xC2V[\x80c\x02:\x96\xFE\x14a\x01\xC6W\x80c\x06\xAEXQ\x14a\x01\xE4W\x80c\rV\x1B7\x14a\x02\0W[__\xFD[a\x01\xCEa\x04\xECV[`@Qa\x01\xDB\x91\x90a\x0B\xB9V[`@Q\x80\x91\x03\x90\xF3[a\x01\xFE`\x04\x806\x03\x81\x01\x90a\x01\xF9\x91\x90a\x0C\x16V[a\x05\x14V[\0[a\x02\x1A`\x04\x806\x03\x81\x01\x90a\x02\x15\x91\x90a\x0CkV[a\x05\x1EV[\0[a\x026`\x04\x806\x03\x81\x01\x90a\x021\x91\x90a\x0CkV[a\x05XV[\0[a\x02R`\x04\x806\x03\x81\x01\x90a\x02M\x91\x90a\x0C\xCBV[a\x05\x9BV[\0[a\x02n`\x04\x806\x03\x81\x01\x90a\x02i\x91\x90a\r)V[a\x05\xB6V[\0[a\x02xa\x05\xC0V[`@Qa\x02\x85\x91\x90a\rvV[`@Q\x80\x91\x03\x90\xF3[a\x02\xA8`\x04\x806\x03\x81\x01\x90a\x02\xA3\x91\x90a\r\xB9V[a\x05\xDCV[\0[a\x02\xC4`\x04\x806\x03\x81\x01\x90a\x02\xBF\x91\x90a\x0E+V[a\x06\x1CV[`@Qa\x02\xD1\x91\x90a\x0E\x8BV[`@Q\x80\x91\x03\x90\xF3[a\x02\xE2a\x06)V[`@Qa\x02\xEF\x91\x90a\x0E\x8BV[`@Q\x80\x91\x03\x90\xF3[a\x03\x12`\x04\x806\x03\x81\x01\x90a\x03\r\x91\x90a\x0E\xA4V[a\x06\x80V[\0[a\x03.`\x04\x806\x03\x81\x01\x90a\x03)\x91\x90a\x11\xF2V[a\x07\rV[\0[a\x038a\x07NV[`@Qa\x03E\x91\x90a\x12gV[`@Q\x80\x91\x03\x90\xF3[a\x03h`\x04\x806\x03\x81\x01\x90a\x03c\x91\x90a\x12\x9FV[a\x07UV[\0[a\x03ra\x07\x90V[`@Qa\x03\x7F\x91\x90a\x12\xEEV[`@Q\x80\x91\x03\x90\xF3[a\x03\x90a\x07\x99V[\0[a\x03\xAC`\x04\x806\x03\x81\x01\x90a\x03\xA7\x91\x90a\r)V[a\x07\xC7V[\0[a\x03\xB6a\x07\xD1V[`@Qa\x03\xC3\x91\x90a\x0B\xB9V[`@Q\x80\x91\x03\x90\xF3[a\x03\xD4a\x07\xF9V[`@Qa\x03\xE1\x91\x90a\x0E\x8BV[`@Q\x80\x91\x03\x90\xF3[a\x04\x04`\x04\x806\x03\x81\x01\x90a\x03\xFF\x91\x90a\x13\xC7V[a\x08\x02V[\0[a\x04 `\x04\x806\x03\x81\x01\x90a\x04\x1B\x91\x90a\x14\xCEV[a\x08\x9EV[\0[a\x04*a\x08\xDBV[`@Qa\x047\x91\x90a\x15\xFBV[`@Q\x80\x91\x03\x90\xF3[a\x04Z`\x04\x806\x03\x81\x01\x90a\x04U\x91\x90a\x16\x1BV[a\tfV[\0[a\x04v`\x04\x806\x03\x81\x01\x90a\x04q\x91\x90a\x0C\x16V[a\t\x91V[\0[a\x04\x80a\n\x1BV[`@Qa\x04\x8D\x91\x90a\x16\xA1V[`@Q\x80\x91\x03\x90\xF3[a\x04\x9Ea\nCV[`@Qa\x04\xAB\x91\x90a\x16\xDAV[`@Q\x80\x91\x03\x90\xF3[a\x04\xCE`\x04\x806\x03\x81\x01\x90a\x04\xC9\x91\x90a\x16\x1BV[a\nkV[\0[a\x04\xEA`\x04\x806\x03\x81\x01\x90a\x04\xE5\x91\x90a\r)V[a\n\xCEV[\0[_`\x08_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[\x80`\x03\x81\x90UPPV[\x7F\xD3\xABL\xBE\x1BoQ\x9E\xB4?\t\xDE\xD1z\x12\xE8\x1B\x81\x1E)pc\xAD\xA2\xD6]\xDD\xEF[a,|\x81`@Qa\x05M\x91\x90a\x0B\xB9V[`@Q\x80\x91\x03\x90\xA1PV[\x80`\x07_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[\x80__a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPPV[\x80`\x05\x81\x90UPPV[_`\x04_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[\x7F\x8C\x8BxY\xBB\xC9i\xBE\xC9\x9A\xC5d\xF3\x7F\x81(\xE2\xDE\x9F\x85\xD3@\x08a9\xAD\x98\xA8\x85\x98\x95\x1B\x83\x83\x83`@Qa\x06\x0F\x93\x92\x91\x90a\x16\xF3V[`@Q\x80\x91\x03\x90\xA1PPPV[_`\x05T\x90P\x93\x92PPPV[___\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a\x06xW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06o\x90a\x17\xA8V[`@Q\x80\x91\x03\x90\xFD[`\x01T\x90P\x90V[`\t_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cF\x8E\xFFP\x83\x83`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x06\xDC\x92\x91\x90a\x17\xC6V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x06\xF3W__\xFD[PZ\xF1\x15\x80\x15a\x07\x05W=__>=_\xFD[PPPPPPV[\x7FHjs\xD3\x8B\x9A\xDF\xB3\xEC\x83\xA2\x01;\x18\xF5w\x1A\x94\x8Ffk\x03\x8E\x1B[\x03\xF8X\x8Ab\xCD\xD7\x84\x84\x83`@Qa\x07@\x93\x92\x91\x90a\x17\xEDV[`@Q\x80\x91\x03\x90\xA1PPPPV[__\x90P\x90V[\x7F6\xD6\tme\x86b\xBA\x82\xAE)\xE7m\xE7\xDA\xAB\"\xD6\xC3\xB26\x1A\x82\x94F\x07f\xA2\x8C\xF5\x05\xD5\x81`@Qa\x07\x84\x91\x90a\x0E\x8BV[`@Q\x80\x91\x03\x90\xA1PPV[_`\x03T\x90P\x90V[\x7F\xA6\x9B\x97~\x94t\xB4T\xC0\xBE\x01\x918\xB2l\xD4m%\xE4\xE2\xFB\xCC\xF8# *\x0Bm{\xBD:$`@Q`@Q\x80\x91\x03\x90\xA1V[\x80`\x02\x81\x90UPPV[_`\x07_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[_`\x02T\x90P\x90V[\x80`\x06\x90\x80Q\x90` \x01\x90a\x08\x18\x92\x91\x90a\n\xD8V[P\x7F\r\x96\x90\xF9qe\xF3Y\x91\xAE`\xD2\xA9~\x04\xAF\xF4r\xC0\x87)r*\x926\xFF\x1B\xC8\xB9\xBA\x90\xC0\x81\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x08VWa\x08Ua\x0E\xF6V[[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x08\x84W\x81` \x01` \x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P`@Qa\x08\x93\x92\x91\x90a\x18\xD9V[`@Q\x80\x91\x03\x90\xA1PV[\x7F\r\x96\x90\xF9qe\xF3Y\x91\xAE`\xD2\xA9~\x04\xAF\xF4r\xC0\x87)r*\x926\xFF\x1B\xC8\xB9\xBA\x90\xC0\x82\x82`@Qa\x08\xCF\x92\x91\x90a\x18\xD9V[`@Q\x80\x91\x03\x90\xA1PPV[```\x06\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\t\\W` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\t\x13W[PPPPP\x90P\x90V[\x80`\x04_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[`\t_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD2\x02\xDE\xAA\x82`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\t\xEB\x91\x90a\x12\xEEV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\n\x02W__\xFD[PZ\xF1\x15\x80\x15a\n\x14W=__>=_\xFD[PPPPPV[_`\t_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[_`\n_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[\x80`\x08`\x14a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7Fw\xBB|\xC2r!\x14\xE0\x17\x1B\xCB\xD5\xE7\x87Q\t\x81I\r\x07d\xC5\xFC\x10\xB9|I\xB0\xB8/$\xD6\x81`@Qa\n\xC3\x91\x90a\rvV[`@Q\x80\x91\x03\x90\xA1PV[\x80`\x01\x81\x90UPPV[\x82\x80T\x82\x82U\x90_R` _ \x90\x81\x01\x92\x82\x15a\x0BNW\x91` \x02\x82\x01[\x82\x81\x11\x15a\x0BMW\x82Q\x82_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x91` \x01\x91\x90`\x01\x01\x90a\n\xF6V[[P\x90Pa\x0B[\x91\x90a\x0B_V[P\x90V[[\x80\x82\x11\x15a\x0BvW_\x81_\x90UP`\x01\x01a\x0B`V[P\x90V[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a\x0B\xA3\x82a\x0BzV[\x90P\x91\x90PV[a\x0B\xB3\x81a\x0B\x99V[\x82RPPV[_` \x82\x01\x90Pa\x0B\xCC_\x83\x01\x84a\x0B\xAAV[\x92\x91PPV[_`@Q\x90P\x90V[__\xFD[__\xFD[_\x81\x90P\x91\x90PV[a\x0B\xF5\x81a\x0B\xE3V[\x81\x14a\x0B\xFFW__\xFD[PV[_\x815\x90Pa\x0C\x10\x81a\x0B\xECV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x0C+Wa\x0C*a\x0B\xDBV[[_a\x0C8\x84\x82\x85\x01a\x0C\x02V[\x91PP\x92\x91PPV[a\x0CJ\x81a\x0B\x99V[\x81\x14a\x0CTW__\xFD[PV[_\x815\x90Pa\x0Ce\x81a\x0CAV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x0C\x80Wa\x0C\x7Fa\x0B\xDBV[[_a\x0C\x8D\x84\x82\x85\x01a\x0CWV[\x91PP\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[a\x0C\xAA\x81a\x0C\x96V[\x81\x14a\x0C\xB4W__\xFD[PV[_\x815\x90Pa\x0C\xC5\x81a\x0C\xA1V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x0C\xE0Wa\x0C\xDFa\x0B\xDBV[[_a\x0C\xED\x84\x82\x85\x01a\x0C\xB7V[\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[a\r\x08\x81a\x0C\xF6V[\x81\x14a\r\x12W__\xFD[PV[_\x815\x90Pa\r#\x81a\x0C\xFFV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\r>Wa\r=a\x0B\xDBV[[_a\rK\x84\x82\x85\x01a\r\x15V[\x91PP\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a\rp\x81a\rTV[\x82RPPV[_` \x82\x01\x90Pa\r\x89_\x83\x01\x84a\rgV[\x92\x91PPV[a\r\x98\x81a\rTV[\x81\x14a\r\xA2W__\xFD[PV[_\x815\x90Pa\r\xB3\x81a\r\x8FV[\x92\x91PPV[___``\x84\x86\x03\x12\x15a\r\xD0Wa\r\xCFa\x0B\xDBV[[_a\r\xDD\x86\x82\x87\x01a\r\xA5V[\x93PP` a\r\xEE\x86\x82\x87\x01a\r\x15V[\x92PP`@a\r\xFF\x86\x82\x87\x01a\r\x15V[\x91PP\x92P\x92P\x92V[__\xFD[_`\xC0\x82\x84\x03\x12\x15a\x0E\"Wa\x0E!a\x0E\tV[[\x81\x90P\x92\x91PPV[___a\x01\0\x84\x86\x03\x12\x15a\x0ECWa\x0EBa\x0B\xDBV[[_a\x0EP\x86\x82\x87\x01a\r\x15V[\x93PP` a\x0Ea\x86\x82\x87\x01a\x0E\rV[\x92PP`\xE0a\x0Er\x86\x82\x87\x01a\r\x15V[\x91PP\x92P\x92P\x92V[a\x0E\x85\x81a\x0C\xF6V[\x82RPPV[_` \x82\x01\x90Pa\x0E\x9E_\x83\x01\x84a\x0E|V[\x92\x91PPV[__`@\x83\x85\x03\x12\x15a\x0E\xBAWa\x0E\xB9a\x0B\xDBV[[_a\x0E\xC7\x85\x82\x86\x01a\x0C\x02V[\x92PP` a\x0E\xD8\x85\x82\x86\x01a\r\x15V[\x91PP\x92P\x92\x90PV[__\xFD[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a\x0F,\x82a\x0E\xE6V[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a\x0FKWa\x0FJa\x0E\xF6V[[\x80`@RPPPV[_a\x0F]a\x0B\xD2V[\x90Pa\x0Fi\x82\x82a\x0F#V[\x91\x90PV[__\xFD[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x0F\x8CWa\x0F\x8Ba\x0E\xF6V[[` \x82\x02\x90P\x91\x90PV[__\xFD[_a\x0F\xADa\x0F\xA8\x84a\x0FrV[a\x0FTV[\x90P\x80` \x84\x02\x83\x01\x85\x81\x11\x15a\x0F\xC7Wa\x0F\xC6a\x0F\x97V[[\x83[\x81\x81\x10\x15a\x0F\xF0W\x80a\x0F\xDC\x88\x82a\r\x15V[\x84R` \x84\x01\x93PP` \x81\x01\x90Pa\x0F\xC9V[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\x10\x0EWa\x10\ra\x0FnV[[`\x02a\x10\x1B\x84\x82\x85a\x0F\x9BV[\x91PP\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x10>Wa\x10=a\x0E\xF6V[[` \x82\x02\x90P\x91\x90PV[_a\x10[a\x10V\x84a\x10$V[a\x0FTV[\x90P\x80` \x84\x02\x83\x01\x85\x81\x11\x15a\x10uWa\x10ta\x0F\x97V[[\x83[\x81\x81\x10\x15a\x10\x9EW\x80a\x10\x8A\x88\x82a\r\xA5V[\x84R` \x84\x01\x93PP` \x81\x01\x90Pa\x10wV[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\x10\xBCWa\x10\xBBa\x0FnV[[`\x02a\x10\xC9\x84\x82\x85a\x10IV[\x91PP\x92\x91PPV[_`\x80\x82\x84\x03\x12\x15a\x10\xE7Wa\x10\xE6a\x0E\xE2V[[a\x10\xF1`@a\x0FTV[\x90P_a\x11\0\x84\x82\x85\x01a\x0F\xFAV[_\x83\x01RP`@a\x11\x13\x84\x82\x85\x01a\x10\xA8V[` \x83\x01RP\x92\x91PPV[`\x03\x81\x10a\x11+W__\xFD[PV[_\x815\x90Pa\x11<\x81a\x11\x1FV[\x92\x91PPV[_`\xA0\x82\x84\x03\x12\x15a\x11WWa\x11Va\x0E\xE2V[[a\x11a`@a\x0FTV[\x90P_a\x11p\x84\x82\x85\x01a\x10\xD2V[_\x83\x01RP`\x80a\x11\x83\x84\x82\x85\x01a\x11.V[` \x83\x01RP\x92\x91PPV[_a\x01`\x82\x84\x03\x12\x15a\x11\xA5Wa\x11\xA4a\x0E\xE2V[[a\x11\xAF``a\x0FTV[\x90P_a\x11\xBE\x84\x82\x85\x01a\x11BV[_\x83\x01RP`\xA0a\x11\xD1\x84\x82\x85\x01a\x11BV[` \x83\x01RPa\x01@a\x11\xE6\x84\x82\x85\x01a\r\xA5V[`@\x83\x01RP\x92\x91PPV[____a\x01\xC0\x85\x87\x03\x12\x15a\x12\x0BWa\x12\na\x0B\xDBV[[_a\x12\x18\x87\x82\x88\x01a\r\xA5V[\x94PP` a\x12)\x87\x82\x88\x01a\x0C\x02V[\x93PP`@a\x12:\x87\x82\x88\x01a\x11\x8FV[\x92PPa\x01\xA0a\x12L\x87\x82\x88\x01a\r\x15V[\x91PP\x92\x95\x91\x94P\x92PV[a\x12a\x81a\x0C\x96V[\x82RPPV[_` \x82\x01\x90Pa\x12z_\x83\x01\x84a\x12XV[\x92\x91PPV[_a\x02`\x82\x84\x03\x12\x15a\x12\x96Wa\x12\x95a\x0E\tV[[\x81\x90P\x92\x91PPV[__a\x02\x80\x83\x85\x03\x12\x15a\x12\xB6Wa\x12\xB5a\x0B\xDBV[[_a\x12\xC3\x85\x82\x86\x01a\x12\x80V[\x92PPa\x02`a\x12\xD5\x85\x82\x86\x01a\r\x15V[\x91PP\x92P\x92\x90PV[a\x12\xE8\x81a\x0B\xE3V[\x82RPPV[_` \x82\x01\x90Pa\x13\x01_\x83\x01\x84a\x12\xDFV[\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x13!Wa\x13 a\x0E\xF6V[[` \x82\x02\x90P` \x81\x01\x90P\x91\x90PV[_a\x13Da\x13?\x84a\x13\x07V[a\x0FTV[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a\x13gWa\x13fa\x0F\x97V[[\x83[\x81\x81\x10\x15a\x13\x90W\x80a\x13|\x88\x82a\x0CWV[\x84R` \x84\x01\x93PP` \x81\x01\x90Pa\x13iV[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\x13\xAEWa\x13\xADa\x0FnV[[\x815a\x13\xBE\x84\x82` \x86\x01a\x132V[\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x13\xDCWa\x13\xDBa\x0B\xDBV[[_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x13\xF9Wa\x13\xF8a\x0B\xDFV[[a\x14\x05\x84\x82\x85\x01a\x13\x9AV[\x91PP\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x14(Wa\x14'a\x0E\xF6V[[` \x82\x02\x90P` \x81\x01\x90P\x91\x90PV[_a\x14Ka\x14F\x84a\x14\x0EV[a\x0FTV[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a\x14nWa\x14ma\x0F\x97V[[\x83[\x81\x81\x10\x15a\x14\x97W\x80a\x14\x83\x88\x82a\x0C\xB7V[\x84R` \x84\x01\x93PP` \x81\x01\x90Pa\x14pV[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\x14\xB5Wa\x14\xB4a\x0FnV[[\x815a\x14\xC5\x84\x82` \x86\x01a\x149V[\x91PP\x92\x91PPV[__`@\x83\x85\x03\x12\x15a\x14\xE4Wa\x14\xE3a\x0B\xDBV[[_\x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x15\x01Wa\x15\0a\x0B\xDFV[[a\x15\r\x85\x82\x86\x01a\x13\x9AV[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x15.Wa\x15-a\x0B\xDFV[[a\x15:\x85\x82\x86\x01a\x14\xA1V[\x91PP\x92P\x92\x90PV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[a\x15v\x81a\x0B\x99V[\x82RPPV[_a\x15\x87\x83\x83a\x15mV[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a\x15\xA9\x82a\x15DV[a\x15\xB3\x81\x85a\x15NV[\x93Pa\x15\xBE\x83a\x15^V[\x80_[\x83\x81\x10\x15a\x15\xEEW\x81Qa\x15\xD5\x88\x82a\x15|V[\x97Pa\x15\xE0\x83a\x15\x93V[\x92PP`\x01\x81\x01\x90Pa\x15\xC1V[P\x85\x93PPPP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x16\x13\x81\x84a\x15\x9FV[\x90P\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x160Wa\x16/a\x0B\xDBV[[_a\x16=\x84\x82\x85\x01a\r\xA5V[\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[_a\x16ia\x16da\x16_\x84a\x0BzV[a\x16FV[a\x0BzV[\x90P\x91\x90PV[_a\x16z\x82a\x16OV[\x90P\x91\x90PV[_a\x16\x8B\x82a\x16pV[\x90P\x91\x90PV[a\x16\x9B\x81a\x16\x81V[\x82RPPV[_` \x82\x01\x90Pa\x16\xB4_\x83\x01\x84a\x16\x92V[\x92\x91PPV[_a\x16\xC4\x82a\x16pV[\x90P\x91\x90PV[a\x16\xD4\x81a\x16\xBAV[\x82RPPV[_` \x82\x01\x90Pa\x16\xED_\x83\x01\x84a\x16\xCBV[\x92\x91PPV[_``\x82\x01\x90Pa\x17\x06_\x83\x01\x86a\rgV[a\x17\x13` \x83\x01\x85a\x0E|V[a\x17 `@\x83\x01\x84a\x0E|V[\x94\x93PPPPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7FLegacy mode: no genesis assertio_\x82\x01R\x7Fn hash\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\x17\x92`&\x83a\x17(V[\x91Pa\x17\x9D\x82a\x178V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x17\xBF\x81a\x17\x86V[\x90P\x91\x90PV[_`@\x82\x01\x90Pa\x17\xD9_\x83\x01\x85a\x12\xDFV[a\x17\xE6` \x83\x01\x84a\x0E|V[\x93\x92PPPV[_``\x82\x01\x90Pa\x18\0_\x83\x01\x86a\rgV[a\x18\r` \x83\x01\x85a\x12\xDFV[a\x18\x1A`@\x83\x01\x84a\x0E|V[\x94\x93PPPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[a\x18T\x81a\x0C\x96V[\x82RPPV[_a\x18e\x83\x83a\x18KV[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a\x18\x87\x82a\x18\"V[a\x18\x91\x81\x85a\x18,V[\x93Pa\x18\x9C\x83a\x18<V[\x80_[\x83\x81\x10\x15a\x18\xCCW\x81Qa\x18\xB3\x88\x82a\x18ZV[\x97Pa\x18\xBE\x83a\x18qV[\x92PP`\x01\x81\x01\x90Pa\x18\x9FV[P\x85\x93PPPP\x92\x91PPV[_`@\x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x18\xF1\x81\x85a\x15\x9FV[\x90P\x81\x81\x03` \x83\x01Ra\x19\x05\x81\x84a\x18}V[\x90P\x93\x92PPPV",
    );
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MachineStatus(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<MachineStatus> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl MachineStatus {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for MachineStatus {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for MachineStatus {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    /**```solidity
struct Assertion { ExecutionState beforeState; ExecutionState afterState; uint64 numBlocks; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Assertion {
        #[allow(missing_docs)]
        pub beforeState: <ExecutionState as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub afterState: <ExecutionState as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub numBlocks: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ExecutionState,
            ExecutionState,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <ExecutionState as alloy::sol_types::SolType>::RustType,
            <ExecutionState as alloy::sol_types::SolType>::RustType,
            u64,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Assertion> for UnderlyingRustTuple<'_> {
            fn from(value: Assertion) -> Self {
                (value.beforeState, value.afterState, value.numBlocks)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Assertion {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    beforeState: tuple.0,
                    afterState: tuple.1,
                    numBlocks: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Assertion {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Assertion {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <ExecutionState as alloy_sol_types::SolType>::tokenize(
                        &self.beforeState,
                    ),
                    <ExecutionState as alloy_sol_types::SolType>::tokenize(
                        &self.afterState,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBlocks),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Assertion {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Assertion {
            const NAME: &'static str = "Assertion";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Assertion(ExecutionState beforeState,ExecutionState afterState,uint64 numBlocks)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(2);
                components
                    .push(
                        <ExecutionState as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <ExecutionState as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
                    .push(
                        <ExecutionState as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <ExecutionState as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <ExecutionState as alloy_sol_types::SolType>::eip712_data_word(
                            &self.beforeState,
                        )
                        .0,
                    <ExecutionState as alloy_sol_types::SolType>::eip712_data_word(
                            &self.afterState,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.numBlocks)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Assertion {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <ExecutionState as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.beforeState,
                    )
                    + <ExecutionState as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.afterState,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.numBlocks,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <ExecutionState as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.beforeState,
                    out,
                );
                <ExecutionState as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.afterState,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.numBlocks,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct AssertionInputs { BeforeStateData beforeStateData; AssertionState beforeState; AssertionState afterState; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssertionInputs {
        #[allow(missing_docs)]
        pub beforeStateData: <BeforeStateData as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub beforeState: <AssertionState as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub afterState: <AssertionState as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (BeforeStateData, AssertionState, AssertionState);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <BeforeStateData as alloy::sol_types::SolType>::RustType,
            <AssertionState as alloy::sol_types::SolType>::RustType,
            <AssertionState as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssertionInputs> for UnderlyingRustTuple<'_> {
            fn from(value: AssertionInputs) -> Self {
                (value.beforeStateData, value.beforeState, value.afterState)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssertionInputs {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    beforeStateData: tuple.0,
                    beforeState: tuple.1,
                    afterState: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for AssertionInputs {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for AssertionInputs {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <BeforeStateData as alloy_sol_types::SolType>::tokenize(
                        &self.beforeStateData,
                    ),
                    <AssertionState as alloy_sol_types::SolType>::tokenize(
                        &self.beforeState,
                    ),
                    <AssertionState as alloy_sol_types::SolType>::tokenize(
                        &self.afterState,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for AssertionInputs {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for AssertionInputs {
            const NAME: &'static str = "AssertionInputs";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "AssertionInputs(BeforeStateData beforeStateData,AssertionState beforeState,AssertionState afterState)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(3);
                components
                    .push(
                        <BeforeStateData as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BeforeStateData as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
                    .push(
                        <AssertionState as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <AssertionState as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
                    .push(
                        <AssertionState as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <AssertionState as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <BeforeStateData as alloy_sol_types::SolType>::eip712_data_word(
                            &self.beforeStateData,
                        )
                        .0,
                    <AssertionState as alloy_sol_types::SolType>::eip712_data_word(
                            &self.beforeState,
                        )
                        .0,
                    <AssertionState as alloy_sol_types::SolType>::eip712_data_word(
                            &self.afterState,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for AssertionInputs {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <BeforeStateData as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.beforeStateData,
                    )
                    + <AssertionState as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.beforeState,
                    )
                    + <AssertionState as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.afterState,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <BeforeStateData as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.beforeStateData,
                    out,
                );
                <AssertionState as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.beforeState,
                    out,
                );
                <AssertionState as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.afterState,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct AssertionState { GlobalState globalState; MachineStatus machineStatus; bytes32 endHistoryRoot; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssertionState {
        #[allow(missing_docs)]
        pub globalState: <GlobalState as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub machineStatus: <MachineStatus as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            GlobalState,
            MachineStatus,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <GlobalState as alloy::sol_types::SolType>::RustType,
            <MachineStatus as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssertionState> for UnderlyingRustTuple<'_> {
            fn from(value: AssertionState) -> Self {
                (value.globalState, value.machineStatus, value.endHistoryRoot)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssertionState {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    globalState: tuple.0,
                    machineStatus: tuple.1,
                    endHistoryRoot: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for AssertionState {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for AssertionState {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <GlobalState as alloy_sol_types::SolType>::tokenize(
                        &self.globalState,
                    ),
                    <MachineStatus as alloy_sol_types::SolType>::tokenize(
                        &self.machineStatus,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHistoryRoot),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for AssertionState {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for AssertionState {
            const NAME: &'static str = "AssertionState";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "AssertionState(GlobalState globalState,uint8 machineStatus,bytes32 endHistoryRoot)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <GlobalState as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <GlobalState as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <GlobalState as alloy_sol_types::SolType>::eip712_data_word(
                            &self.globalState,
                        )
                        .0,
                    <MachineStatus as alloy_sol_types::SolType>::eip712_data_word(
                            &self.machineStatus,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.endHistoryRoot,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for AssertionState {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <GlobalState as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.globalState,
                    )
                    + <MachineStatus as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.machineStatus,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.endHistoryRoot,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <GlobalState as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.globalState,
                    out,
                );
                <MachineStatus as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.machineStatus,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.endHistoryRoot,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct BeforeStateData { bytes32 prevPrevAssertionHash; bytes32 sequencerBatchAcc; ConfigData configData; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BeforeStateData {
        #[allow(missing_docs)]
        pub prevPrevAssertionHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sequencerBatchAcc: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub configData: <ConfigData as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            ConfigData,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            <ConfigData as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BeforeStateData> for UnderlyingRustTuple<'_> {
            fn from(value: BeforeStateData) -> Self {
                (value.prevPrevAssertionHash, value.sequencerBatchAcc, value.configData)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BeforeStateData {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    prevPrevAssertionHash: tuple.0,
                    sequencerBatchAcc: tuple.1,
                    configData: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BeforeStateData {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BeforeStateData {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.prevPrevAssertionHash,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.sequencerBatchAcc),
                    <ConfigData as alloy_sol_types::SolType>::tokenize(&self.configData),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BeforeStateData {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BeforeStateData {
            const NAME: &'static str = "BeforeStateData";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BeforeStateData(bytes32 prevPrevAssertionHash,bytes32 sequencerBatchAcc,ConfigData configData)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <ConfigData as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <ConfigData as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.prevPrevAssertionHash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sequencerBatchAcc,
                        )
                        .0,
                    <ConfigData as alloy_sol_types::SolType>::eip712_data_word(
                            &self.configData,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BeforeStateData {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.prevPrevAssertionHash,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sequencerBatchAcc,
                    )
                    + <ConfigData as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.configData,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.prevPrevAssertionHash,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sequencerBatchAcc,
                    out,
                );
                <ConfigData as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.configData,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ConfigData { bytes32 wasmModuleRoot; uint256 requiredStake; address challengeManager; uint64 confirmPeriodBlocks; uint64 nextInboxPosition; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ConfigData {
        #[allow(missing_docs)]
        pub wasmModuleRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub requiredStake: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub challengeManager: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub confirmPeriodBlocks: u64,
        #[allow(missing_docs)]
        pub nextInboxPosition: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            u64,
            u64,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ConfigData> for UnderlyingRustTuple<'_> {
            fn from(value: ConfigData) -> Self {
                (
                    value.wasmModuleRoot,
                    value.requiredStake,
                    value.challengeManager,
                    value.confirmPeriodBlocks,
                    value.nextInboxPosition,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ConfigData {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    wasmModuleRoot: tuple.0,
                    requiredStake: tuple.1,
                    challengeManager: tuple.2,
                    confirmPeriodBlocks: tuple.3,
                    nextInboxPosition: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ConfigData {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ConfigData {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.wasmModuleRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.requiredStake),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.challengeManager,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.confirmPeriodBlocks),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.nextInboxPosition),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ConfigData {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ConfigData {
            const NAME: &'static str = "ConfigData";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ConfigData(bytes32 wasmModuleRoot,uint256 requiredStake,address challengeManager,uint64 confirmPeriodBlocks,uint64 nextInboxPosition)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.wasmModuleRoot,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.requiredStake)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.challengeManager,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.confirmPeriodBlocks,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.nextInboxPosition,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ConfigData {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.wasmModuleRoot,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.requiredStake,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.challengeManager,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.confirmPeriodBlocks,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.nextInboxPosition,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.wasmModuleRoot,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.requiredStake,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.challengeManager,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.confirmPeriodBlocks,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nextInboxPosition,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExecutionState { GlobalState globalState; MachineStatus machineStatus; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExecutionState {
        #[allow(missing_docs)]
        pub globalState: <GlobalState as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub machineStatus: <MachineStatus as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (GlobalState, MachineStatus);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <GlobalState as alloy::sol_types::SolType>::RustType,
            <MachineStatus as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExecutionState> for UnderlyingRustTuple<'_> {
            fn from(value: ExecutionState) -> Self {
                (value.globalState, value.machineStatus)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExecutionState {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    globalState: tuple.0,
                    machineStatus: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExecutionState {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ExecutionState {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <GlobalState as alloy_sol_types::SolType>::tokenize(
                        &self.globalState,
                    ),
                    <MachineStatus as alloy_sol_types::SolType>::tokenize(
                        &self.machineStatus,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExecutionState {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExecutionState {
            const NAME: &'static str = "ExecutionState";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExecutionState(GlobalState globalState,uint8 machineStatus)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <GlobalState as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <GlobalState as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <GlobalState as alloy_sol_types::SolType>::eip712_data_word(
                            &self.globalState,
                        )
                        .0,
                    <MachineStatus as alloy_sol_types::SolType>::eip712_data_word(
                            &self.machineStatus,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExecutionState {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <GlobalState as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.globalState,
                    )
                    + <MachineStatus as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.machineStatus,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <GlobalState as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.globalState,
                    out,
                );
                <MachineStatus as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.machineStatus,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct GlobalState { bytes32[2] bytes32Vals; uint64[2] u64Vals; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GlobalState {
        #[allow(missing_docs)]
        pub bytes32Vals: [alloy::sol_types::private::FixedBytes<32>; 2usize],
        #[allow(missing_docs)]
        pub u64Vals: [u64; 2usize],
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedArray<
                alloy::sol_types::sol_data::FixedBytes<32>,
                2usize,
            >,
            alloy::sol_types::sol_data::FixedArray<
                alloy::sol_types::sol_data::Uint<64>,
                2usize,
            >,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            [alloy::sol_types::private::FixedBytes<32>; 2usize],
            [u64; 2usize],
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<GlobalState> for UnderlyingRustTuple<'_> {
            fn from(value: GlobalState) -> Self {
                (value.bytes32Vals, value.u64Vals)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for GlobalState {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    bytes32Vals: tuple.0,
                    u64Vals: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for GlobalState {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for GlobalState {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.bytes32Vals),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<64>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.u64Vals),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for GlobalState {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for GlobalState {
            const NAME: &'static str = "GlobalState";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "GlobalState(bytes32[2] bytes32Vals,uint64[2] u64Vals)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                        2usize,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.bytes32Vals)
                        .0,
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<64>,
                        2usize,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.u64Vals)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for GlobalState {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                        2usize,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.bytes32Vals,
                    )
                    + <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<64>,
                        2usize,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.u64Vals,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                    2usize,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.bytes32Vals,
                    out,
                );
                <alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<64>,
                    2usize,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.u64Vals,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Event with signature `AnyTrustFastConfirmerSet(address)` and selector `0xd3ab4cbe1b6f519eb43f09ded17a12e81b811e297063ada2d65dddef5b612c7c`.
```solidity
event AnyTrustFastConfirmerSet(address confimer);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct AnyTrustFastConfirmerSet {
        #[allow(missing_docs)]
        pub confimer: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for AnyTrustFastConfirmerSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "AnyTrustFastConfirmerSet(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                211u8,
                171u8,
                76u8,
                190u8,
                27u8,
                111u8,
                81u8,
                158u8,
                180u8,
                63u8,
                9u8,
                222u8,
                209u8,
                122u8,
                18u8,
                232u8,
                27u8,
                129u8,
                30u8,
                41u8,
                112u8,
                99u8,
                173u8,
                162u8,
                214u8,
                93u8,
                221u8,
                239u8,
                91u8,
                97u8,
                44u8,
                124u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { confimer: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.confimer,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for AnyTrustFastConfirmerSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&AnyTrustFastConfirmerSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &AnyTrustFastConfirmerSet,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `FastConfirmNewAssertionCalled(bytes32)` and selector `0x36d6096d658662ba82ae29e76de7daab22d6c3b2361a8294460766a28cf505d5`.
```solidity
event FastConfirmNewAssertionCalled(bytes32 expectedAssertionHash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FastConfirmNewAssertionCalled {
        #[allow(missing_docs)]
        pub expectedAssertionHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FastConfirmNewAssertionCalled {
            type DataTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "FastConfirmNewAssertionCalled(bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                54u8,
                214u8,
                9u8,
                109u8,
                101u8,
                134u8,
                98u8,
                186u8,
                130u8,
                174u8,
                41u8,
                231u8,
                109u8,
                231u8,
                218u8,
                171u8,
                34u8,
                214u8,
                195u8,
                178u8,
                54u8,
                26u8,
                130u8,
                148u8,
                70u8,
                7u8,
                102u8,
                162u8,
                140u8,
                245u8,
                5u8,
                213u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    expectedAssertionHash: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.expectedAssertionHash,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FastConfirmNewAssertionCalled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FastConfirmNewAssertionCalled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &FastConfirmNewAssertionCalled,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ForceConfirmNodeCalled(uint64,bytes32,bytes32)` and selector `0x8c8b7859bbc969bec99ac564f37f8128e2de9f85d340086139ad98a88598951b`.
```solidity
event ForceConfirmNodeCalled(uint64 nodeNum, bytes32 blockHash, bytes32 sendRoot);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ForceConfirmNodeCalled {
        #[allow(missing_docs)]
        pub nodeNum: u64,
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sendRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ForceConfirmNodeCalled {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ForceConfirmNodeCalled(uint64,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                140u8,
                139u8,
                120u8,
                89u8,
                187u8,
                201u8,
                105u8,
                190u8,
                201u8,
                154u8,
                197u8,
                100u8,
                243u8,
                127u8,
                129u8,
                40u8,
                226u8,
                222u8,
                159u8,
                133u8,
                211u8,
                64u8,
                8u8,
                97u8,
                57u8,
                173u8,
                152u8,
                168u8,
                133u8,
                152u8,
                149u8,
                27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    nodeNum: data.0,
                    blockHash: data.1,
                    sendRoot: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.nodeNum),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.sendRoot),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ForceConfirmNodeCalled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ForceConfirmNodeCalled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ForceConfirmNodeCalled) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ForceCreateNodeCalled(uint64,uint256,bytes32)` and selector `0x486a73d38b9adfb3ec83a2013b18f5771a948f666b038e1b5b03f8588a62cdd7`.
```solidity
event ForceCreateNodeCalled(uint64 prevNode, uint256 prevNodeInboxMaxCount, bytes32 expectedNodeHash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ForceCreateNodeCalled {
        #[allow(missing_docs)]
        pub prevNode: u64,
        #[allow(missing_docs)]
        pub prevNodeInboxMaxCount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub expectedNodeHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ForceCreateNodeCalled {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ForceCreateNodeCalled(uint64,uint256,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                72u8,
                106u8,
                115u8,
                211u8,
                139u8,
                154u8,
                223u8,
                179u8,
                236u8,
                131u8,
                162u8,
                1u8,
                59u8,
                24u8,
                245u8,
                119u8,
                26u8,
                148u8,
                143u8,
                102u8,
                107u8,
                3u8,
                142u8,
                27u8,
                91u8,
                3u8,
                248u8,
                88u8,
                138u8,
                98u8,
                205u8,
                215u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    prevNode: data.0,
                    prevNodeInboxMaxCount: data.1,
                    expectedNodeHash: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.prevNode),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.prevNodeInboxMaxCount,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.expectedNodeHash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ForceCreateNodeCalled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ForceCreateNodeCalled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ForceCreateNodeCalled) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RolePaused()` and selector `0xa69b977e9474b454c0be019138b26cd46d25e4e2fbccf823202a0b6d7bbd3a24`.
```solidity
event RolePaused();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RolePaused {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RolePaused {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "RolePaused()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                166u8,
                155u8,
                151u8,
                126u8,
                148u8,
                116u8,
                180u8,
                84u8,
                192u8,
                190u8,
                1u8,
                145u8,
                56u8,
                178u8,
                108u8,
                212u8,
                109u8,
                37u8,
                228u8,
                226u8,
                251u8,
                204u8,
                248u8,
                35u8,
                32u8,
                42u8,
                11u8,
                109u8,
                123u8,
                189u8,
                58u8,
                36u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RolePaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RolePaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RolePaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ValidatorAfkBlocksSet(uint64)` and selector `0x77bb7cc2722114e0171bcbd5e787510981490d0764c5fc10b97c49b0b82f24d6`.
```solidity
event ValidatorAfkBlocksSet(uint64 blocks);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ValidatorAfkBlocksSet {
        #[allow(missing_docs)]
        pub blocks: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ValidatorAfkBlocksSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ValidatorAfkBlocksSet(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                119u8,
                187u8,
                124u8,
                194u8,
                114u8,
                33u8,
                20u8,
                224u8,
                23u8,
                27u8,
                203u8,
                213u8,
                231u8,
                135u8,
                81u8,
                9u8,
                129u8,
                73u8,
                13u8,
                7u8,
                100u8,
                197u8,
                252u8,
                16u8,
                185u8,
                124u8,
                73u8,
                176u8,
                184u8,
                47u8,
                36u8,
                214u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { blocks: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blocks),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ValidatorAfkBlocksSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ValidatorAfkBlocksSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ValidatorAfkBlocksSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ValidatorsSet(address[],bool[])` and selector `0x0d9690f97165f35991ae60d2a97e04aff472c08729722a9236ff1bc8b9ba90c0`.
```solidity
event ValidatorsSet(address[] validators, bool[] values);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ValidatorsSet {
        #[allow(missing_docs)]
        pub validators: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
        #[allow(missing_docs)]
        pub values: alloy::sol_types::private::Vec<bool>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ValidatorsSet {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ValidatorsSet(address[],bool[])";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                13u8,
                150u8,
                144u8,
                249u8,
                113u8,
                101u8,
                243u8,
                89u8,
                145u8,
                174u8,
                96u8,
                210u8,
                169u8,
                126u8,
                4u8,
                175u8,
                244u8,
                114u8,
                192u8,
                135u8,
                41u8,
                114u8,
                42u8,
                146u8,
                54u8,
                255u8,
                27u8,
                200u8,
                185u8,
                186u8,
                144u8,
                192u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    validators: data.0,
                    values: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.validators),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bool,
                    > as alloy_sol_types::SolType>::tokenize(&self.values),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ValidatorsSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ValidatorsSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ValidatorsSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Function with signature `baseStake()` and selector `0x76e7e23b`.
```solidity
function baseStake() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct baseStakeCall {}
    ///Container type for the return parameters of the [`baseStake()`](baseStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct baseStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<baseStakeCall> for UnderlyingRustTuple<'_> {
                fn from(value: baseStakeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for baseStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<baseStakeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: baseStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for baseStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for baseStakeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = baseStakeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "baseStake()";
            const SELECTOR: [u8; 4] = [118u8, 231u8, 226u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridge()` and selector `0xe78cea92`.
```solidity
function bridge() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeCall {}
    ///Container type for the return parameters of the [`bridge()`](bridgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridge()";
            const SELECTOR: [u8; 4] = [231u8, 140u8, 234u8, 146u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `challengeManager()` and selector `0x023a96fe`.
```solidity
function challengeManager() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeManagerCall {}
    ///Container type for the return parameters of the [`challengeManager()`](challengeManagerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeManagerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeManagerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeManagerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeManagerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeManagerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeManagerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeManagerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for challengeManagerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = challengeManagerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "challengeManager()";
            const SELECTOR: [u8; 4] = [2u8, 58u8, 150u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `computeAssertionHash(bytes32,((bytes32[2],uint64[2]),uint8,bytes32),bytes32)` and selector `0x33635fc2`.
```solidity
function computeAssertionHash(bytes32, AssertionState memory, bytes32) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct computeAssertionHashCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub _1: <AssertionState as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub _2: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`computeAssertionHash(bytes32,((bytes32[2],uint64[2]),uint8,bytes32),bytes32)`](computeAssertionHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct computeAssertionHashReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                AssertionState,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                <AssertionState as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<computeAssertionHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: computeAssertionHashCall) -> Self {
                    (value._0, value._1, value._2)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for computeAssertionHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                        _2: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<computeAssertionHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: computeAssertionHashReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for computeAssertionHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for computeAssertionHashCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                AssertionState,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = computeAssertionHashReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "computeAssertionHash(bytes32,((bytes32[2],uint64[2]),uint8,bytes32),bytes32)";
            const SELECTOR: [u8; 4] = [51u8, 99u8, 95u8, 194u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <AssertionState as alloy_sol_types::SolType>::tokenize(&self._1),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._2),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `confirmPeriodBlocks()` and selector `0x2e7acfa6`.
```solidity
function confirmPeriodBlocks() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct confirmPeriodBlocksCall {}
    ///Container type for the return parameters of the [`confirmPeriodBlocks()`](confirmPeriodBlocksCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct confirmPeriodBlocksReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<confirmPeriodBlocksCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: confirmPeriodBlocksCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for confirmPeriodBlocksCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<confirmPeriodBlocksReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: confirmPeriodBlocksReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for confirmPeriodBlocksReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for confirmPeriodBlocksCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = confirmPeriodBlocksReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "confirmPeriodBlocks()";
            const SELECTOR: [u8; 4] = [46u8, 122u8, 207u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `fastConfirmNewAssertion(((bytes32,bytes32,(bytes32,uint256,address,uint64,uint64)),((bytes32[2],uint64[2]),uint8,bytes32),((bytes32[2],uint64[2]),uint8,bytes32)),bytes32)` and selector `0x6420fb9f`.
```solidity
function fastConfirmNewAssertion(AssertionInputs memory, bytes32 expectedAssertionHash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fastConfirmNewAssertionCall {
        #[allow(missing_docs)]
        pub _0: <AssertionInputs as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub expectedAssertionHash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`fastConfirmNewAssertion(((bytes32,bytes32,(bytes32,uint256,address,uint64,uint64)),((bytes32[2],uint64[2]),uint8,bytes32),((bytes32[2],uint64[2]),uint8,bytes32)),bytes32)`](fastConfirmNewAssertionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fastConfirmNewAssertionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                AssertionInputs,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <AssertionInputs as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fastConfirmNewAssertionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: fastConfirmNewAssertionCall) -> Self {
                    (value._0, value.expectedAssertionHash)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for fastConfirmNewAssertionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        expectedAssertionHash: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fastConfirmNewAssertionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: fastConfirmNewAssertionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for fastConfirmNewAssertionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fastConfirmNewAssertionCall {
            type Parameters<'a> = (
                AssertionInputs,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = fastConfirmNewAssertionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fastConfirmNewAssertion(((bytes32,bytes32,(bytes32,uint256,address,uint64,uint64)),((bytes32[2],uint64[2]),uint8,bytes32),((bytes32[2],uint64[2]),uint8,bytes32)),bytes32)";
            const SELECTOR: [u8; 4] = [100u8, 32u8, 251u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <AssertionInputs as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.expectedAssertionHash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `forceConfirmNode(uint64,bytes32,bytes32)` and selector `0x2f7968e8`.
```solidity
function forceConfirmNode(uint64 nodeNum, bytes32 blockHash, bytes32 sendRoot) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct forceConfirmNodeCall {
        #[allow(missing_docs)]
        pub nodeNum: u64,
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sendRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`forceConfirmNode(uint64,bytes32,bytes32)`](forceConfirmNodeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct forceConfirmNodeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u64,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<forceConfirmNodeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: forceConfirmNodeCall) -> Self {
                    (value.nodeNum, value.blockHash, value.sendRoot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for forceConfirmNodeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        nodeNum: tuple.0,
                        blockHash: tuple.1,
                        sendRoot: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<forceConfirmNodeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: forceConfirmNodeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for forceConfirmNodeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for forceConfirmNodeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = forceConfirmNodeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "forceConfirmNode(uint64,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [47u8, 121u8, 104u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.nodeNum),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.sendRoot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `forceCreateNode(uint64,uint256,(((bytes32[2],uint64[2]),uint8),((bytes32[2],uint64[2]),uint8),uint64),bytes32)` and selector `0x470dce4e`.
```solidity
function forceCreateNode(uint64 prevNode, uint256 prevNodeInboxMaxCount, Assertion memory, bytes32 expectedNodeHash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct forceCreateNodeCall {
        #[allow(missing_docs)]
        pub prevNode: u64,
        #[allow(missing_docs)]
        pub prevNodeInboxMaxCount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _2: <Assertion as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub expectedNodeHash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`forceCreateNode(uint64,uint256,(((bytes32[2],uint64[2]),uint8),((bytes32[2],uint64[2]),uint8),uint64),bytes32)`](forceCreateNodeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct forceCreateNodeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                Assertion,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u64,
                alloy::sol_types::private::primitives::aliases::U256,
                <Assertion as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<forceCreateNodeCall> for UnderlyingRustTuple<'_> {
                fn from(value: forceCreateNodeCall) -> Self {
                    (
                        value.prevNode,
                        value.prevNodeInboxMaxCount,
                        value._2,
                        value.expectedNodeHash,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for forceCreateNodeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        prevNode: tuple.0,
                        prevNodeInboxMaxCount: tuple.1,
                        _2: tuple.2,
                        expectedNodeHash: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<forceCreateNodeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: forceCreateNodeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for forceCreateNodeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for forceCreateNodeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                Assertion,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = forceCreateNodeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "forceCreateNode(uint64,uint256,(((bytes32[2],uint64[2]),uint8),((bytes32[2],uint64[2]),uint8),uint64),bytes32)";
            const SELECTOR: [u8; 4] = [71u8, 13u8, 206u8, 78u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.prevNode),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.prevNodeInboxMaxCount,
                    ),
                    <Assertion as alloy_sol_types::SolType>::tokenize(&self._2),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.expectedNodeHash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `genesisAssertionHash()` and selector `0x353325e0`.
```solidity
function genesisAssertionHash() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct genesisAssertionHashCall {}
    ///Container type for the return parameters of the [`genesisAssertionHash()`](genesisAssertionHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct genesisAssertionHashReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<genesisAssertionHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: genesisAssertionHashCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for genesisAssertionHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<genesisAssertionHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: genesisAssertionHashReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for genesisAssertionHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for genesisAssertionHashCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = genesisAssertionHashReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "genesisAssertionHash()";
            const SELECTOR: [u8; 4] = [53u8, 51u8, 37u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getValidators()` and selector `0xb7ab4db5`.
```solidity
function getValidators() external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getValidatorsCall {}
    ///Container type for the return parameters of the [`getValidators()`](getValidatorsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getValidatorsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getValidatorsCall> for UnderlyingRustTuple<'_> {
                fn from(value: getValidatorsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getValidatorsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getValidatorsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getValidatorsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getValidatorsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getValidatorsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getValidatorsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getValidators()";
            const SELECTOR: [u8; 4] = [183u8, 171u8, 77u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall {}
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pause()` and selector `0x8456cb59`.
```solidity
function pause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseCall {}
    ///Container type for the return parameters of the [`pause()`](pauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause()";
            const SELECTOR: [u8; 4] = [132u8, 86u8, 203u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `paused()` and selector `0x5c975abb`.
```solidity
function paused() external pure returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedCall {}
    ///Container type for the return parameters of the [`paused()`](pausedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedCall> for UnderlyingRustTuple<'_> {
                fn from(value: pausedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pausedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pausedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pausedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sequencerInbox()` and selector `0xee35f327`.
```solidity
function sequencerInbox() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sequencerInboxCall {}
    ///Container type for the return parameters of the [`sequencerInbox()`](sequencerInboxCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sequencerInboxReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sequencerInboxCall> for UnderlyingRustTuple<'_> {
                fn from(value: sequencerInboxCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sequencerInboxCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sequencerInboxReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: sequencerInboxReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sequencerInboxReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sequencerInboxCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sequencerInboxReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sequencerInbox()";
            const SELECTOR: [u8; 4] = [238u8, 53u8, 243u8, 39u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setAnyTrustFastConfirmer(address)` and selector `0x0d561b37`.
```solidity
function setAnyTrustFastConfirmer(address confimer) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAnyTrustFastConfirmerCall {
        #[allow(missing_docs)]
        pub confimer: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setAnyTrustFastConfirmer(address)`](setAnyTrustFastConfirmerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAnyTrustFastConfirmerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAnyTrustFastConfirmerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAnyTrustFastConfirmerCall) -> Self {
                    (value.confimer,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAnyTrustFastConfirmerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { confimer: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAnyTrustFastConfirmerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAnyTrustFastConfirmerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAnyTrustFastConfirmerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setAnyTrustFastConfirmerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setAnyTrustFastConfirmerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setAnyTrustFastConfirmer(address)";
            const SELECTOR: [u8; 4] = [13u8, 86u8, 27u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.confimer,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBaseStake(uint256)` and selector `0x06ae5851`.
```solidity
function setBaseStake(uint256 stake) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBaseStakeCall {
        #[allow(missing_docs)]
        pub stake: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setBaseStake(uint256)`](setBaseStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBaseStakeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBaseStakeCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBaseStakeCall) -> Self {
                    (value.stake,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBaseStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stake: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBaseStakeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setBaseStakeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBaseStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBaseStakeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBaseStakeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBaseStake(uint256)";
            const SELECTOR: [u8; 4] = [6u8, 174u8, 88u8, 81u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.stake),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setComputedAssertionHash(bytes32)` and selector `0x2c24eccd`.
```solidity
function setComputedAssertionHash(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setComputedAssertionHashCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`setComputedAssertionHash(bytes32)`](setComputedAssertionHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setComputedAssertionHashReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setComputedAssertionHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setComputedAssertionHashCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setComputedAssertionHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setComputedAssertionHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setComputedAssertionHashReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setComputedAssertionHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setComputedAssertionHashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setComputedAssertionHashReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setComputedAssertionHash(bytes32)";
            const SELECTOR: [u8; 4] = [44u8, 36u8, 236u8, 205u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setConfirmPeriodBlocks(uint64)` and selector `0xce66d05c`.
```solidity
function setConfirmPeriodBlocks(uint64 blocks) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setConfirmPeriodBlocksCall {
        #[allow(missing_docs)]
        pub blocks: u64,
    }
    ///Container type for the return parameters of the [`setConfirmPeriodBlocks(uint64)`](setConfirmPeriodBlocksCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setConfirmPeriodBlocksReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setConfirmPeriodBlocksCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setConfirmPeriodBlocksCall) -> Self {
                    (value.blocks,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setConfirmPeriodBlocksCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blocks: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setConfirmPeriodBlocksReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setConfirmPeriodBlocksReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setConfirmPeriodBlocksReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setConfirmPeriodBlocksCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setConfirmPeriodBlocksReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setConfirmPeriodBlocks(uint64)";
            const SELECTOR: [u8; 4] = [206u8, 102u8, 208u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blocks),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setGenesisAssertionHash(bytes32)` and selector `0xf3ef4b36`.
```solidity
function setGenesisAssertionHash(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setGenesisAssertionHashCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`setGenesisAssertionHash(bytes32)`](setGenesisAssertionHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setGenesisAssertionHashReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setGenesisAssertionHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setGenesisAssertionHashCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setGenesisAssertionHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setGenesisAssertionHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setGenesisAssertionHashReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setGenesisAssertionHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setGenesisAssertionHashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setGenesisAssertionHashReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setGenesisAssertionHash(bytes32)";
            const SELECTOR: [u8; 4] = [243u8, 239u8, 75u8, 54u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setLegacyMode(bool)` and selector `0x1d39e389`.
```solidity
function setLegacyMode(bool mode) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setLegacyModeCall {
        #[allow(missing_docs)]
        pub mode: bool,
    }
    ///Container type for the return parameters of the [`setLegacyMode(bool)`](setLegacyModeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setLegacyModeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setLegacyModeCall> for UnderlyingRustTuple<'_> {
                fn from(value: setLegacyModeCall) -> Self {
                    (value.mode,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setLegacyModeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { mode: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setLegacyModeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setLegacyModeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setLegacyModeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setLegacyModeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bool,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setLegacyModeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setLegacyMode(bool)";
            const SELECTOR: [u8; 4] = [29u8, 57u8, 227u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.mode,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setOwner(address)` and selector `0x13af4035`.
```solidity
function setOwner(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setOwnerCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setOwner(address)`](setOwnerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setOwnerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setOwnerCall> for UnderlyingRustTuple<'_> {
                fn from(value: setOwnerCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setOwnerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setOwnerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setOwnerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setOwnerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setOwnerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setOwnerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setOwner(address)";
            const SELECTOR: [u8; 4] = [19u8, 175u8, 64u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setSequencerInboxAcc(uint256,bytes32)` and selector `0x468eff50`.
```solidity
function setSequencerInboxAcc(uint256 index, bytes32 acc) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSequencerInboxAccCall {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub acc: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`setSequencerInboxAcc(uint256,bytes32)`](setSequencerInboxAccCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSequencerInboxAccReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSequencerInboxAccCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setSequencerInboxAccCall) -> Self {
                    (value.index, value.acc)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setSequencerInboxAccCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        index: tuple.0,
                        acc: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSequencerInboxAccReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setSequencerInboxAccReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setSequencerInboxAccReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setSequencerInboxAccCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setSequencerInboxAccReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setSequencerInboxAcc(uint256,bytes32)";
            const SELECTOR: [u8; 4] = [70u8, 142u8, 255u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.acc),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setSequencerMessageCount(uint256)` and selector `0xd202deaa`.
```solidity
function setSequencerMessageCount(uint256 count) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSequencerMessageCountCall {
        #[allow(missing_docs)]
        pub count: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setSequencerMessageCount(uint256)`](setSequencerMessageCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSequencerMessageCountReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSequencerMessageCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setSequencerMessageCountCall) -> Self {
                    (value.count,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setSequencerMessageCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { count: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSequencerMessageCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setSequencerMessageCountReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setSequencerMessageCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setSequencerMessageCountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setSequencerMessageCountReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setSequencerMessageCount(uint256)";
            const SELECTOR: [u8; 4] = [210u8, 2u8, 222u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.count),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setValidator(address[],bool[])` and selector `0xa3ffb772`.
```solidity
function setValidator(address[] memory validators, bool[] memory values) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setValidatorCall {
        #[allow(missing_docs)]
        pub validators: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
        #[allow(missing_docs)]
        pub values: alloy::sol_types::private::Vec<bool>,
    }
    ///Container type for the return parameters of the [`setValidator(address[],bool[])`](setValidatorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setValidatorReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::Vec<bool>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setValidatorCall> for UnderlyingRustTuple<'_> {
                fn from(value: setValidatorCall) -> Self {
                    (value.validators, value.values)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setValidatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        validators: tuple.0,
                        values: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setValidatorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setValidatorReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setValidatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setValidatorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setValidatorReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setValidator(address[],bool[])";
            const SELECTOR: [u8; 4] = [163u8, 255u8, 183u8, 114u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.validators),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bool,
                    > as alloy_sol_types::SolType>::tokenize(&self.values),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setValidatorAfkBlocks(uint64)` and selector `0xf112cea3`.
```solidity
function setValidatorAfkBlocks(uint64 blocks) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setValidatorAfkBlocksCall {
        #[allow(missing_docs)]
        pub blocks: u64,
    }
    ///Container type for the return parameters of the [`setValidatorAfkBlocks(uint64)`](setValidatorAfkBlocksCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setValidatorAfkBlocksReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setValidatorAfkBlocksCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setValidatorAfkBlocksCall) -> Self {
                    (value.blocks,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setValidatorAfkBlocksCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blocks: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setValidatorAfkBlocksReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setValidatorAfkBlocksReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setValidatorAfkBlocksReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setValidatorAfkBlocksCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setValidatorAfkBlocksReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setValidatorAfkBlocks(uint64)";
            const SELECTOR: [u8; 4] = [241u8, 18u8, 206u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blocks),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setValidators(address[])` and selector `0x9300c926`.
```solidity
function setValidators(address[] memory validators) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setValidatorsCall {
        #[allow(missing_docs)]
        pub validators: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    ///Container type for the return parameters of the [`setValidators(address[])`](setValidatorsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setValidatorsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setValidatorsCall> for UnderlyingRustTuple<'_> {
                fn from(value: setValidatorsCall) -> Self {
                    (value.validators,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setValidatorsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { validators: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setValidatorsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setValidatorsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setValidatorsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setValidatorsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setValidatorsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setValidators(address[])";
            const SELECTOR: [u8; 4] = [147u8, 0u8, 201u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.validators),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setWasmModuleRoot(bytes32)` and selector `0x89384960`.
```solidity
function setWasmModuleRoot(bytes32 root) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setWasmModuleRootCall {
        #[allow(missing_docs)]
        pub root: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`setWasmModuleRoot(bytes32)`](setWasmModuleRootCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setWasmModuleRootReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setWasmModuleRootCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setWasmModuleRootCall) -> Self {
                    (value.root,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setWasmModuleRootCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { root: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setWasmModuleRootReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setWasmModuleRootReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setWasmModuleRootReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setWasmModuleRootCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setWasmModuleRootReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setWasmModuleRoot(bytes32)";
            const SELECTOR: [u8; 4] = [137u8, 56u8, 73u8, 96u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.root),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `wasmModuleRoot()` and selector `0x8ee1a126`.
```solidity
function wasmModuleRoot() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct wasmModuleRootCall {}
    ///Container type for the return parameters of the [`wasmModuleRoot()`](wasmModuleRootCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct wasmModuleRootReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<wasmModuleRootCall> for UnderlyingRustTuple<'_> {
                fn from(value: wasmModuleRootCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for wasmModuleRootCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<wasmModuleRootReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: wasmModuleRootReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for wasmModuleRootReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for wasmModuleRootCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = wasmModuleRootReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "wasmModuleRoot()";
            const SELECTOR: [u8; 4] = [142u8, 225u8, 161u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`MockRollup`](self) function calls.
    pub enum MockRollupCalls {
        #[allow(missing_docs)]
        baseStake(baseStakeCall),
        #[allow(missing_docs)]
        bridge(bridgeCall),
        #[allow(missing_docs)]
        challengeManager(challengeManagerCall),
        #[allow(missing_docs)]
        computeAssertionHash(computeAssertionHashCall),
        #[allow(missing_docs)]
        confirmPeriodBlocks(confirmPeriodBlocksCall),
        #[allow(missing_docs)]
        fastConfirmNewAssertion(fastConfirmNewAssertionCall),
        #[allow(missing_docs)]
        forceConfirmNode(forceConfirmNodeCall),
        #[allow(missing_docs)]
        forceCreateNode(forceCreateNodeCall),
        #[allow(missing_docs)]
        genesisAssertionHash(genesisAssertionHashCall),
        #[allow(missing_docs)]
        getValidators(getValidatorsCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        pause(pauseCall),
        #[allow(missing_docs)]
        paused(pausedCall),
        #[allow(missing_docs)]
        sequencerInbox(sequencerInboxCall),
        #[allow(missing_docs)]
        setAnyTrustFastConfirmer(setAnyTrustFastConfirmerCall),
        #[allow(missing_docs)]
        setBaseStake(setBaseStakeCall),
        #[allow(missing_docs)]
        setComputedAssertionHash(setComputedAssertionHashCall),
        #[allow(missing_docs)]
        setConfirmPeriodBlocks(setConfirmPeriodBlocksCall),
        #[allow(missing_docs)]
        setGenesisAssertionHash(setGenesisAssertionHashCall),
        #[allow(missing_docs)]
        setLegacyMode(setLegacyModeCall),
        #[allow(missing_docs)]
        setOwner(setOwnerCall),
        #[allow(missing_docs)]
        setSequencerInboxAcc(setSequencerInboxAccCall),
        #[allow(missing_docs)]
        setSequencerMessageCount(setSequencerMessageCountCall),
        #[allow(missing_docs)]
        setValidator(setValidatorCall),
        #[allow(missing_docs)]
        setValidatorAfkBlocks(setValidatorAfkBlocksCall),
        #[allow(missing_docs)]
        setValidators(setValidatorsCall),
        #[allow(missing_docs)]
        setWasmModuleRoot(setWasmModuleRootCall),
        #[allow(missing_docs)]
        wasmModuleRoot(wasmModuleRootCall),
    }
    #[automatically_derived]
    impl MockRollupCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [2u8, 58u8, 150u8, 254u8],
            [6u8, 174u8, 88u8, 81u8],
            [13u8, 86u8, 27u8, 55u8],
            [19u8, 175u8, 64u8, 53u8],
            [29u8, 57u8, 227u8, 137u8],
            [44u8, 36u8, 236u8, 205u8],
            [46u8, 122u8, 207u8, 166u8],
            [47u8, 121u8, 104u8, 232u8],
            [51u8, 99u8, 95u8, 194u8],
            [53u8, 51u8, 37u8, 224u8],
            [70u8, 142u8, 255u8, 80u8],
            [71u8, 13u8, 206u8, 78u8],
            [92u8, 151u8, 90u8, 187u8],
            [100u8, 32u8, 251u8, 159u8],
            [118u8, 231u8, 226u8, 59u8],
            [132u8, 86u8, 203u8, 89u8],
            [137u8, 56u8, 73u8, 96u8],
            [141u8, 165u8, 203u8, 91u8],
            [142u8, 225u8, 161u8, 38u8],
            [147u8, 0u8, 201u8, 38u8],
            [163u8, 255u8, 183u8, 114u8],
            [183u8, 171u8, 77u8, 181u8],
            [206u8, 102u8, 208u8, 92u8],
            [210u8, 2u8, 222u8, 170u8],
            [231u8, 140u8, 234u8, 146u8],
            [238u8, 53u8, 243u8, 39u8],
            [241u8, 18u8, 206u8, 163u8],
            [243u8, 239u8, 75u8, 54u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for MockRollupCalls {
        const NAME: &'static str = "MockRollupCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 28usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::baseStake(_) => {
                    <baseStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridge(_) => <bridgeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::challengeManager(_) => {
                    <challengeManagerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::computeAssertionHash(_) => {
                    <computeAssertionHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::confirmPeriodBlocks(_) => {
                    <confirmPeriodBlocksCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::fastConfirmNewAssertion(_) => {
                    <fastConfirmNewAssertionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::forceConfirmNode(_) => {
                    <forceConfirmNodeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::forceCreateNode(_) => {
                    <forceCreateNodeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::genesisAssertionHash(_) => {
                    <genesisAssertionHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getValidators(_) => {
                    <getValidatorsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::paused(_) => <pausedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::sequencerInbox(_) => {
                    <sequencerInboxCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setAnyTrustFastConfirmer(_) => {
                    <setAnyTrustFastConfirmerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBaseStake(_) => {
                    <setBaseStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setComputedAssertionHash(_) => {
                    <setComputedAssertionHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setConfirmPeriodBlocks(_) => {
                    <setConfirmPeriodBlocksCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setGenesisAssertionHash(_) => {
                    <setGenesisAssertionHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setLegacyMode(_) => {
                    <setLegacyModeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setOwner(_) => <setOwnerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::setSequencerInboxAcc(_) => {
                    <setSequencerInboxAccCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setSequencerMessageCount(_) => {
                    <setSequencerMessageCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setValidator(_) => {
                    <setValidatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setValidatorAfkBlocks(_) => {
                    <setValidatorAfkBlocksCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setValidators(_) => {
                    <setValidatorsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setWasmModuleRoot(_) => {
                    <setWasmModuleRootCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::wasmModuleRoot(_) => {
                    <wasmModuleRootCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<MockRollupCalls>] = &[
                {
                    fn challengeManager(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <challengeManagerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::challengeManager)
                    }
                    challengeManager
                },
                {
                    fn setBaseStake(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setBaseStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setBaseStake)
                    }
                    setBaseStake
                },
                {
                    fn setAnyTrustFastConfirmer(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setAnyTrustFastConfirmerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setAnyTrustFastConfirmer)
                    }
                    setAnyTrustFastConfirmer
                },
                {
                    fn setOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setOwnerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setOwner)
                    }
                    setOwner
                },
                {
                    fn setLegacyMode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setLegacyModeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setLegacyMode)
                    }
                    setLegacyMode
                },
                {
                    fn setComputedAssertionHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setComputedAssertionHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setComputedAssertionHash)
                    }
                    setComputedAssertionHash
                },
                {
                    fn confirmPeriodBlocks(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <confirmPeriodBlocksCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::confirmPeriodBlocks)
                    }
                    confirmPeriodBlocks
                },
                {
                    fn forceConfirmNode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <forceConfirmNodeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::forceConfirmNode)
                    }
                    forceConfirmNode
                },
                {
                    fn computeAssertionHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <computeAssertionHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::computeAssertionHash)
                    }
                    computeAssertionHash
                },
                {
                    fn genesisAssertionHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <genesisAssertionHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::genesisAssertionHash)
                    }
                    genesisAssertionHash
                },
                {
                    fn setSequencerInboxAcc(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setSequencerInboxAccCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setSequencerInboxAcc)
                    }
                    setSequencerInboxAcc
                },
                {
                    fn forceCreateNode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <forceCreateNodeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::forceCreateNode)
                    }
                    forceCreateNode
                },
                {
                    fn paused(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::paused)
                    }
                    paused
                },
                {
                    fn fastConfirmNewAssertion(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <fastConfirmNewAssertionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::fastConfirmNewAssertion)
                    }
                    fastConfirmNewAssertion
                },
                {
                    fn baseStake(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <baseStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::baseStake)
                    }
                    baseStake
                },
                {
                    fn pause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::pause)
                    }
                    pause
                },
                {
                    fn setWasmModuleRoot(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setWasmModuleRootCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setWasmModuleRoot)
                    }
                    setWasmModuleRoot
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::owner)
                    }
                    owner
                },
                {
                    fn wasmModuleRoot(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <wasmModuleRootCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::wasmModuleRoot)
                    }
                    wasmModuleRoot
                },
                {
                    fn setValidators(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setValidatorsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setValidators)
                    }
                    setValidators
                },
                {
                    fn setValidator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setValidatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setValidator)
                    }
                    setValidator
                },
                {
                    fn getValidators(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <getValidatorsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::getValidators)
                    }
                    getValidators
                },
                {
                    fn setConfirmPeriodBlocks(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setConfirmPeriodBlocksCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setConfirmPeriodBlocks)
                    }
                    setConfirmPeriodBlocks
                },
                {
                    fn setSequencerMessageCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setSequencerMessageCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setSequencerMessageCount)
                    }
                    setSequencerMessageCount
                },
                {
                    fn bridge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <bridgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::bridge)
                    }
                    bridge
                },
                {
                    fn sequencerInbox(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <sequencerInboxCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::sequencerInbox)
                    }
                    sequencerInbox
                },
                {
                    fn setValidatorAfkBlocks(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setValidatorAfkBlocksCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setValidatorAfkBlocks)
                    }
                    setValidatorAfkBlocks
                },
                {
                    fn setGenesisAssertionHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setGenesisAssertionHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setGenesisAssertionHash)
                    }
                    setGenesisAssertionHash
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::baseStake(inner) => {
                    <baseStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::bridge(inner) => {
                    <bridgeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::challengeManager(inner) => {
                    <challengeManagerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::computeAssertionHash(inner) => {
                    <computeAssertionHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::confirmPeriodBlocks(inner) => {
                    <confirmPeriodBlocksCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::fastConfirmNewAssertion(inner) => {
                    <fastConfirmNewAssertionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::forceConfirmNode(inner) => {
                    <forceConfirmNodeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::forceCreateNode(inner) => {
                    <forceCreateNodeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::genesisAssertionHash(inner) => {
                    <genesisAssertionHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getValidators(inner) => {
                    <getValidatorsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::sequencerInbox(inner) => {
                    <sequencerInboxCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setAnyTrustFastConfirmer(inner) => {
                    <setAnyTrustFastConfirmerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setBaseStake(inner) => {
                    <setBaseStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setComputedAssertionHash(inner) => {
                    <setComputedAssertionHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setConfirmPeriodBlocks(inner) => {
                    <setConfirmPeriodBlocksCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setGenesisAssertionHash(inner) => {
                    <setGenesisAssertionHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setLegacyMode(inner) => {
                    <setLegacyModeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setOwner(inner) => {
                    <setOwnerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setSequencerInboxAcc(inner) => {
                    <setSequencerInboxAccCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setSequencerMessageCount(inner) => {
                    <setSequencerMessageCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setValidator(inner) => {
                    <setValidatorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setValidatorAfkBlocks(inner) => {
                    <setValidatorAfkBlocksCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setValidators(inner) => {
                    <setValidatorsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setWasmModuleRoot(inner) => {
                    <setWasmModuleRootCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::wasmModuleRoot(inner) => {
                    <wasmModuleRootCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::baseStake(inner) => {
                    <baseStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridge(inner) => {
                    <bridgeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::challengeManager(inner) => {
                    <challengeManagerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::computeAssertionHash(inner) => {
                    <computeAssertionHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::confirmPeriodBlocks(inner) => {
                    <confirmPeriodBlocksCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fastConfirmNewAssertion(inner) => {
                    <fastConfirmNewAssertionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::forceConfirmNode(inner) => {
                    <forceConfirmNodeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::forceCreateNode(inner) => {
                    <forceCreateNodeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::genesisAssertionHash(inner) => {
                    <genesisAssertionHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getValidators(inner) => {
                    <getValidatorsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::sequencerInbox(inner) => {
                    <sequencerInboxCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setAnyTrustFastConfirmer(inner) => {
                    <setAnyTrustFastConfirmerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBaseStake(inner) => {
                    <setBaseStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setComputedAssertionHash(inner) => {
                    <setComputedAssertionHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setConfirmPeriodBlocks(inner) => {
                    <setConfirmPeriodBlocksCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setGenesisAssertionHash(inner) => {
                    <setGenesisAssertionHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setLegacyMode(inner) => {
                    <setLegacyModeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setOwner(inner) => {
                    <setOwnerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setSequencerInboxAcc(inner) => {
                    <setSequencerInboxAccCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setSequencerMessageCount(inner) => {
                    <setSequencerMessageCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setValidator(inner) => {
                    <setValidatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setValidatorAfkBlocks(inner) => {
                    <setValidatorAfkBlocksCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setValidators(inner) => {
                    <setValidatorsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setWasmModuleRoot(inner) => {
                    <setWasmModuleRootCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::wasmModuleRoot(inner) => {
                    <wasmModuleRootCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`MockRollup`](self) events.
    pub enum MockRollupEvents {
        #[allow(missing_docs)]
        AnyTrustFastConfirmerSet(AnyTrustFastConfirmerSet),
        #[allow(missing_docs)]
        FastConfirmNewAssertionCalled(FastConfirmNewAssertionCalled),
        #[allow(missing_docs)]
        ForceConfirmNodeCalled(ForceConfirmNodeCalled),
        #[allow(missing_docs)]
        ForceCreateNodeCalled(ForceCreateNodeCalled),
        #[allow(missing_docs)]
        RolePaused(RolePaused),
        #[allow(missing_docs)]
        ValidatorAfkBlocksSet(ValidatorAfkBlocksSet),
        #[allow(missing_docs)]
        ValidatorsSet(ValidatorsSet),
    }
    #[automatically_derived]
    impl MockRollupEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                13u8,
                150u8,
                144u8,
                249u8,
                113u8,
                101u8,
                243u8,
                89u8,
                145u8,
                174u8,
                96u8,
                210u8,
                169u8,
                126u8,
                4u8,
                175u8,
                244u8,
                114u8,
                192u8,
                135u8,
                41u8,
                114u8,
                42u8,
                146u8,
                54u8,
                255u8,
                27u8,
                200u8,
                185u8,
                186u8,
                144u8,
                192u8,
            ],
            [
                54u8,
                214u8,
                9u8,
                109u8,
                101u8,
                134u8,
                98u8,
                186u8,
                130u8,
                174u8,
                41u8,
                231u8,
                109u8,
                231u8,
                218u8,
                171u8,
                34u8,
                214u8,
                195u8,
                178u8,
                54u8,
                26u8,
                130u8,
                148u8,
                70u8,
                7u8,
                102u8,
                162u8,
                140u8,
                245u8,
                5u8,
                213u8,
            ],
            [
                72u8,
                106u8,
                115u8,
                211u8,
                139u8,
                154u8,
                223u8,
                179u8,
                236u8,
                131u8,
                162u8,
                1u8,
                59u8,
                24u8,
                245u8,
                119u8,
                26u8,
                148u8,
                143u8,
                102u8,
                107u8,
                3u8,
                142u8,
                27u8,
                91u8,
                3u8,
                248u8,
                88u8,
                138u8,
                98u8,
                205u8,
                215u8,
            ],
            [
                119u8,
                187u8,
                124u8,
                194u8,
                114u8,
                33u8,
                20u8,
                224u8,
                23u8,
                27u8,
                203u8,
                213u8,
                231u8,
                135u8,
                81u8,
                9u8,
                129u8,
                73u8,
                13u8,
                7u8,
                100u8,
                197u8,
                252u8,
                16u8,
                185u8,
                124u8,
                73u8,
                176u8,
                184u8,
                47u8,
                36u8,
                214u8,
            ],
            [
                140u8,
                139u8,
                120u8,
                89u8,
                187u8,
                201u8,
                105u8,
                190u8,
                201u8,
                154u8,
                197u8,
                100u8,
                243u8,
                127u8,
                129u8,
                40u8,
                226u8,
                222u8,
                159u8,
                133u8,
                211u8,
                64u8,
                8u8,
                97u8,
                57u8,
                173u8,
                152u8,
                168u8,
                133u8,
                152u8,
                149u8,
                27u8,
            ],
            [
                166u8,
                155u8,
                151u8,
                126u8,
                148u8,
                116u8,
                180u8,
                84u8,
                192u8,
                190u8,
                1u8,
                145u8,
                56u8,
                178u8,
                108u8,
                212u8,
                109u8,
                37u8,
                228u8,
                226u8,
                251u8,
                204u8,
                248u8,
                35u8,
                32u8,
                42u8,
                11u8,
                109u8,
                123u8,
                189u8,
                58u8,
                36u8,
            ],
            [
                211u8,
                171u8,
                76u8,
                190u8,
                27u8,
                111u8,
                81u8,
                158u8,
                180u8,
                63u8,
                9u8,
                222u8,
                209u8,
                122u8,
                18u8,
                232u8,
                27u8,
                129u8,
                30u8,
                41u8,
                112u8,
                99u8,
                173u8,
                162u8,
                214u8,
                93u8,
                221u8,
                239u8,
                91u8,
                97u8,
                44u8,
                124u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for MockRollupEvents {
        const NAME: &'static str = "MockRollupEvents";
        const COUNT: usize = 7usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <AnyTrustFastConfirmerSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <AnyTrustFastConfirmerSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::AnyTrustFastConfirmerSet)
                }
                Some(
                    <FastConfirmNewAssertionCalled as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <FastConfirmNewAssertionCalled as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::FastConfirmNewAssertionCalled)
                }
                Some(
                    <ForceConfirmNodeCalled as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ForceConfirmNodeCalled as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ForceConfirmNodeCalled)
                }
                Some(
                    <ForceCreateNodeCalled as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ForceCreateNodeCalled as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ForceCreateNodeCalled)
                }
                Some(<RolePaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RolePaused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RolePaused)
                }
                Some(
                    <ValidatorAfkBlocksSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ValidatorAfkBlocksSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ValidatorAfkBlocksSet)
                }
                Some(<ValidatorsSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ValidatorsSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ValidatorsSet)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for MockRollupEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AnyTrustFastConfirmerSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FastConfirmNewAssertionCalled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ForceConfirmNodeCalled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ForceCreateNodeCalled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RolePaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ValidatorAfkBlocksSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ValidatorsSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AnyTrustFastConfirmerSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FastConfirmNewAssertionCalled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ForceConfirmNodeCalled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ForceCreateNodeCalled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RolePaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ValidatorAfkBlocksSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ValidatorsSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`MockRollup`](self) contract instance.

See the [wrapper's documentation](`MockRollupInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> MockRollupInstance<T, P, N> {
        MockRollupInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<MockRollupInstance<T, P, N>>,
    > {
        MockRollupInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        MockRollupInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`MockRollup`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`MockRollup`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct MockRollupInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for MockRollupInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("MockRollupInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockRollupInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`MockRollup`](self) contract instance.

See the [wrapper's documentation](`MockRollupInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<MockRollupInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> MockRollupInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> MockRollupInstance<T, P, N> {
            MockRollupInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockRollupInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`baseStake`] function.
        pub fn baseStake(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, baseStakeCall, N> {
            self.call_builder(&baseStakeCall {})
        }
        ///Creates a new call builder for the [`bridge`] function.
        pub fn bridge(&self) -> alloy_contract::SolCallBuilder<T, &P, bridgeCall, N> {
            self.call_builder(&bridgeCall {})
        }
        ///Creates a new call builder for the [`challengeManager`] function.
        pub fn challengeManager(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, challengeManagerCall, N> {
            self.call_builder(&challengeManagerCall {})
        }
        ///Creates a new call builder for the [`computeAssertionHash`] function.
        pub fn computeAssertionHash(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
            _1: <AssertionState as alloy::sol_types::SolType>::RustType,
            _2: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, computeAssertionHashCall, N> {
            self.call_builder(
                &computeAssertionHashCall {
                    _0,
                    _1,
                    _2,
                },
            )
        }
        ///Creates a new call builder for the [`confirmPeriodBlocks`] function.
        pub fn confirmPeriodBlocks(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, confirmPeriodBlocksCall, N> {
            self.call_builder(&confirmPeriodBlocksCall {})
        }
        ///Creates a new call builder for the [`fastConfirmNewAssertion`] function.
        pub fn fastConfirmNewAssertion(
            &self,
            _0: <AssertionInputs as alloy::sol_types::SolType>::RustType,
            expectedAssertionHash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, fastConfirmNewAssertionCall, N> {
            self.call_builder(
                &fastConfirmNewAssertionCall {
                    _0,
                    expectedAssertionHash,
                },
            )
        }
        ///Creates a new call builder for the [`forceConfirmNode`] function.
        pub fn forceConfirmNode(
            &self,
            nodeNum: u64,
            blockHash: alloy::sol_types::private::FixedBytes<32>,
            sendRoot: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, forceConfirmNodeCall, N> {
            self.call_builder(
                &forceConfirmNodeCall {
                    nodeNum,
                    blockHash,
                    sendRoot,
                },
            )
        }
        ///Creates a new call builder for the [`forceCreateNode`] function.
        pub fn forceCreateNode(
            &self,
            prevNode: u64,
            prevNodeInboxMaxCount: alloy::sol_types::private::primitives::aliases::U256,
            _2: <Assertion as alloy::sol_types::SolType>::RustType,
            expectedNodeHash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, forceCreateNodeCall, N> {
            self.call_builder(
                &forceCreateNodeCall {
                    prevNode,
                    prevNodeInboxMaxCount,
                    _2,
                    expectedNodeHash,
                },
            )
        }
        ///Creates a new call builder for the [`genesisAssertionHash`] function.
        pub fn genesisAssertionHash(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, genesisAssertionHashCall, N> {
            self.call_builder(&genesisAssertionHashCall {})
        }
        ///Creates a new call builder for the [`getValidators`] function.
        pub fn getValidators(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getValidatorsCall, N> {
            self.call_builder(&getValidatorsCall {})
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        ///Creates a new call builder for the [`pause`] function.
        pub fn pause(&self) -> alloy_contract::SolCallBuilder<T, &P, pauseCall, N> {
            self.call_builder(&pauseCall {})
        }
        ///Creates a new call builder for the [`paused`] function.
        pub fn paused(&self) -> alloy_contract::SolCallBuilder<T, &P, pausedCall, N> {
            self.call_builder(&pausedCall {})
        }
        ///Creates a new call builder for the [`sequencerInbox`] function.
        pub fn sequencerInbox(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, sequencerInboxCall, N> {
            self.call_builder(&sequencerInboxCall {})
        }
        ///Creates a new call builder for the [`setAnyTrustFastConfirmer`] function.
        pub fn setAnyTrustFastConfirmer(
            &self,
            confimer: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setAnyTrustFastConfirmerCall, N> {
            self.call_builder(
                &setAnyTrustFastConfirmerCall {
                    confimer,
                },
            )
        }
        ///Creates a new call builder for the [`setBaseStake`] function.
        pub fn setBaseStake(
            &self,
            stake: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBaseStakeCall, N> {
            self.call_builder(&setBaseStakeCall { stake })
        }
        ///Creates a new call builder for the [`setComputedAssertionHash`] function.
        pub fn setComputedAssertionHash(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setComputedAssertionHashCall, N> {
            self.call_builder(
                &setComputedAssertionHashCall {
                    hash,
                },
            )
        }
        ///Creates a new call builder for the [`setConfirmPeriodBlocks`] function.
        pub fn setConfirmPeriodBlocks(
            &self,
            blocks: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, setConfirmPeriodBlocksCall, N> {
            self.call_builder(
                &setConfirmPeriodBlocksCall {
                    blocks,
                },
            )
        }
        ///Creates a new call builder for the [`setGenesisAssertionHash`] function.
        pub fn setGenesisAssertionHash(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setGenesisAssertionHashCall, N> {
            self.call_builder(
                &setGenesisAssertionHashCall {
                    hash,
                },
            )
        }
        ///Creates a new call builder for the [`setLegacyMode`] function.
        pub fn setLegacyMode(
            &self,
            mode: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, setLegacyModeCall, N> {
            self.call_builder(&setLegacyModeCall { mode })
        }
        ///Creates a new call builder for the [`setOwner`] function.
        pub fn setOwner(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setOwnerCall, N> {
            self.call_builder(&setOwnerCall { newOwner })
        }
        ///Creates a new call builder for the [`setSequencerInboxAcc`] function.
        pub fn setSequencerInboxAcc(
            &self,
            index: alloy::sol_types::private::primitives::aliases::U256,
            acc: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setSequencerInboxAccCall, N> {
            self.call_builder(
                &setSequencerInboxAccCall {
                    index,
                    acc,
                },
            )
        }
        ///Creates a new call builder for the [`setSequencerMessageCount`] function.
        pub fn setSequencerMessageCount(
            &self,
            count: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setSequencerMessageCountCall, N> {
            self.call_builder(
                &setSequencerMessageCountCall {
                    count,
                },
            )
        }
        ///Creates a new call builder for the [`setValidator`] function.
        pub fn setValidator(
            &self,
            validators: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
            values: alloy::sol_types::private::Vec<bool>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setValidatorCall, N> {
            self.call_builder(
                &setValidatorCall {
                    validators,
                    values,
                },
            )
        }
        ///Creates a new call builder for the [`setValidatorAfkBlocks`] function.
        pub fn setValidatorAfkBlocks(
            &self,
            blocks: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, setValidatorAfkBlocksCall, N> {
            self.call_builder(
                &setValidatorAfkBlocksCall {
                    blocks,
                },
            )
        }
        ///Creates a new call builder for the [`setValidators`] function.
        pub fn setValidators(
            &self,
            validators: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, setValidatorsCall, N> {
            self.call_builder(&setValidatorsCall { validators })
        }
        ///Creates a new call builder for the [`setWasmModuleRoot`] function.
        pub fn setWasmModuleRoot(
            &self,
            root: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setWasmModuleRootCall, N> {
            self.call_builder(&setWasmModuleRootCall { root })
        }
        ///Creates a new call builder for the [`wasmModuleRoot`] function.
        pub fn wasmModuleRoot(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, wasmModuleRootCall, N> {
            self.call_builder(&wasmModuleRootCall {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockRollupInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`AnyTrustFastConfirmerSet`] event.
        pub fn AnyTrustFastConfirmerSet_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, AnyTrustFastConfirmerSet, N> {
            self.event_filter::<AnyTrustFastConfirmerSet>()
        }
        ///Creates a new event filter for the [`FastConfirmNewAssertionCalled`] event.
        pub fn FastConfirmNewAssertionCalled_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, FastConfirmNewAssertionCalled, N> {
            self.event_filter::<FastConfirmNewAssertionCalled>()
        }
        ///Creates a new event filter for the [`ForceConfirmNodeCalled`] event.
        pub fn ForceConfirmNodeCalled_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ForceConfirmNodeCalled, N> {
            self.event_filter::<ForceConfirmNodeCalled>()
        }
        ///Creates a new event filter for the [`ForceCreateNodeCalled`] event.
        pub fn ForceCreateNodeCalled_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ForceCreateNodeCalled, N> {
            self.event_filter::<ForceCreateNodeCalled>()
        }
        ///Creates a new event filter for the [`RolePaused`] event.
        pub fn RolePaused_filter(&self) -> alloy_contract::Event<T, &P, RolePaused, N> {
            self.event_filter::<RolePaused>()
        }
        ///Creates a new event filter for the [`ValidatorAfkBlocksSet`] event.
        pub fn ValidatorAfkBlocksSet_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ValidatorAfkBlocksSet, N> {
            self.event_filter::<ValidatorAfkBlocksSet>()
        }
        ///Creates a new event filter for the [`ValidatorsSet`] event.
        pub fn ValidatorsSet_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ValidatorsSet, N> {
            self.event_filter::<ValidatorsSet>()
        }
    }
}
