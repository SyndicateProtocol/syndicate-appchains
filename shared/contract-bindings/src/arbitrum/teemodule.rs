/**

Generated by the following Solidity interface...
```solidity
interface TeeModule {
    struct PendingAssertion {
        bytes32 blockHash;
        bytes32 sendRoot;
    }

    error ECDSAInvalidSignature();
    error ECDSAInvalidSignatureLength(uint256 length);
    error ECDSAInvalidSignatureS(bytes32 s);

    event ChallengeResolved(PendingAssertion);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event TeeAppchainConfigHash(bytes32 hash);
    event TeeHacked(uint256);
    event TeeKeysRevoked();
    event TeeProgramHashAdded(bytes32 hash);
    event TeeProgramHashRemoved(bytes32 hash);

    constructor(address poster_, bytes32 appchainConfigHash_);

    function addTeeKey(address publicKey, bytes memory zkProof) external;
    function addTeeProgramHash(bytes32 hash) external;
    function challengeWindowDuration() external view returns (uint256);
    function challengeWindowEnd() external view returns (uint256);
    function closeChallengeWindow() external;
    function isTeeKey(address) external view returns (bool);
    function isTeeProgramHash(bytes32) external view returns (bool);
    function owner() external view returns (address);
    function pendingAssertions(uint256) external view returns (bytes32 blockHash, bytes32 sendRoot);
    function poster() external view returns (address);
    function removeTeeProgramHash(bytes32 hash) external;
    function renounceOwnership() external;
    function resolveChallenge(PendingAssertion memory assertion) external;
    function revokeAllTeeKeys() external;
    function setAppchainConfigHash(bytes32 hash) external;
    function setChallengeWindowDuration(uint256 duration) external;
    function submitAssertion(PendingAssertion memory assertion, bytes memory signature, address rewardAddr) external;
    function teeHackCount() external view returns (uint256);
    function teeKeys(uint256) external view returns (address);
    function teeTrustedInput() external view returns (bytes32 appchainConfigHash, bytes32 setEndBlockHash, bytes32 l1EndBlockHash, bytes32 appchainStartBlockHash);
    function transferOwnership(address newOwner) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "poster_",
        "type": "address",
        "internalType": "contract AssertionPoster"
      },
      {
        "name": "appchainConfigHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addTeeKey",
    "inputs": [
      {
        "name": "publicKey",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "zkProof",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addTeeProgramHash",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "challengeWindowDuration",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "challengeWindowEnd",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "closeChallengeWindow",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "isTeeKey",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isTeeProgramHash",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pendingAssertions",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "blockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "sendRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "poster",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract AssertionPoster"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "removeTeeProgramHash",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "resolveChallenge",
    "inputs": [
      {
        "name": "assertion",
        "type": "tuple",
        "internalType": "struct PendingAssertion",
        "components": [
          {
            "name": "blockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "sendRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeAllTeeKeys",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setAppchainConfigHash",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setChallengeWindowDuration",
    "inputs": [
      {
        "name": "duration",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "submitAssertion",
    "inputs": [
      {
        "name": "assertion",
        "type": "tuple",
        "internalType": "struct PendingAssertion",
        "components": [
          {
            "name": "blockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "sendRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      },
      {
        "name": "signature",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "rewardAddr",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "teeHackCount",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "teeKeys",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "teeTrustedInput",
    "inputs": [],
    "outputs": [
      {
        "name": "appchainConfigHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "setEndBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "l1EndBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "appchainStartBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "ChallengeResolved",
    "inputs": [
      {
        "name": "",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct PendingAssertion",
        "components": [
          {
            "name": "blockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "sendRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeAppchainConfigHash",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeHacked",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeKeysRevoked",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeProgramHashAdded",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeProgramHashRemoved",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureLength",
    "inputs": [
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureS",
    "inputs": [
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod TeeModule {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a060405234801561000f575f5ffd5b5060405161286438038061286483398181016040528101906100319190610232565b61004d6100426100c860201b60201c565b6100cf60201b60201c565b8173ffffffffffffffffffffffffffffffffffffffff1660808173ffffffffffffffffffffffffffffffffffffffff16815250508060015f01819055507fb7a180228497ed95c6896fc1b081a016999116f98ab95b52123659efea259764816040516100b9919061027f565b60405180910390a15050610298565b5f33905090565b5f5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f5f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f5ffd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6101bd82610194565b9050919050565b5f6101ce826101b3565b9050919050565b6101de816101c4565b81146101e8575f5ffd5b50565b5f815190506101f9816101d5565b92915050565b5f819050919050565b610211816101ff565b811461021b575f5ffd5b50565b5f8151905061022c81610208565b92915050565b5f5f6040838503121561024857610247610190565b5b5f610255858286016101eb565b92505060206102668582860161021e565b9150509250929050565b610279816101ff565b82525050565b5f6020820190506102925f830184610270565b92915050565b6080516125ad6102b75f395f8181610a810152610e1a01526125ad5ff3fe608060405234801561000f575f5ffd5b5060043610610135575f3560e01c80636ebed0f0116100b6578063a380ef871161007a578063a380ef87146102dc578063a56ec6cd1461030c578063b26700341461033d578063ee1c28b814610359578063f223055c14610377578063f2fde38b1461039357610135565b80636ebed0f01461025c5780636ef012011461028c578063715018a61461029657806380959721146102a05780638da5cb5b146102be57610135565b806347742640116100fd57806347742640146101ca5780634bd167c9146101fa5780635d4bedc314610218578063697b5e62146102345780636c4c20601461025257610135565b80630ad195ab146101395780630b7c0241146101555780631caf5d13146101715780633ceaae7d1461018d57806343de5f33146101ae575b5f5ffd5b610153600480360381019061014e91906118aa565b6103af565b005b61016f600480360381019061016a91906118f7565b61048d565b005b61018b60048036038101906101869190611955565b61066d565b005b6101956106f3565b6040516101a5949392919061198f565b60405180910390f35b6101c860048036038101906101c391906118aa565b610710565b005b6101e460048036038101906101df9190611a2c565b6107ef565b6040516101f19190611a71565b60405180910390f35b61020261080c565b60405161020f9190611a99565b60405180910390f35b610232600480360381019061022d9190611b13565b610812565b005b61023c61092f565b6040516102499190611a99565b60405180910390f35b61025a610935565b005b61027660048036038101906102719190611955565b610bf0565b6040516102839190611b7f565b60405180910390f35b610294610c2b565b005b61029e610d91565b005b6102a8610e18565b6040516102b59190611bf3565b60405180910390f35b6102c6610e3c565b6040516102d39190611b7f565b60405180910390f35b6102f660048036038101906102f191906118aa565b610e63565b6040516103039190611a71565b60405180910390f35b61032660048036038101906103219190611955565b610e80565b604051610334929190611c0c565b60405180910390f35b61035760048036038101906103529190611c33565b610eaf565b005b61036161120a565b60405161036e9190611a99565b60405180910390f35b610391600480360381019061038c91906118aa565b611210565b005b6103ad60048036038101906103a89190611a2c565b6112cf565b005b6103b76113c5565b73ffffffffffffffffffffffffffffffffffffffff166103d5610e3c565b73ffffffffffffffffffffffffffffffffffffffff161461042b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161042290611cfe565b60405180910390fd5b5f60095f8381526020019081526020015f205f6101000a81548160ff0219169083151502179055507f0db166bb4e47a660aafc32f78bbacdda0b90b0735e45b2134aeec3a5ea5655ab816040516104829190611d1c565b60405180910390a150565b6104956113c5565b73ffffffffffffffffffffffffffffffffffffffff166104b3610e3c565b73ffffffffffffffffffffffffffffffffffffffff1614610509576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161050090611cfe565b60405180910390fd5b600160058054905011610551576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161054890611d7f565b60405180910390fd5b5f5f90505b60058054905081101561062e5761058c826005838154811061057b5761057a611d9d565b5b905f5260205f2090600202016113cc565b156106215760055f61059e91906117f1565b600582908060018154018082558091505060019003905f5260205f2090600202015f9091909190915081816105d39190611ebf565b50505f600a819055506105e4610935565b7f114e9c798e3c6d158b5d1dd711ce1e22785f3d94898ddb1ce7f9bc75173175d3826040516106139190611f2f565b60405180910390a15061066a565b8080600101915050610556565b506040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161066190611f92565b60405180910390fd5b50565b6106756113c5565b73ffffffffffffffffffffffffffffffffffffffff16610693610e3c565b73ffffffffffffffffffffffffffffffffffffffff16146106e9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106e090611cfe565b60405180910390fd5b80600b8190555050565b6001805f0154908060010154908060020154908060030154905084565b6107186113c5565b73ffffffffffffffffffffffffffffffffffffffff16610736610e3c565b73ffffffffffffffffffffffffffffffffffffffff161461078c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161078390611cfe565b60405180910390fd5b600160095f8381526020019081526020015f205f6101000a81548160ff0219169083151502179055507f43885026c59ecbb824d102785fee5f9593e695bb9a8490864d9830952524e5d5816040516107e49190611d1c565b60405180910390a150565b6008602052805f5260405f205f915054906101000a900460ff1681565b600b5481565b6001828290501461082657610825611fb0565b5b60085f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1661092a57600160085f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550600783908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b505050565b60065481565b5f734200000000000000000000000000000000000015905060016005805490501115610996576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161098d9061204d565b60405180910390fd5b600a548173ffffffffffffffffffffffffffffffffffffffff1663b80777ea6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156109e2573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a06919061207f565b11610a46576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a3d9061211a565b60405180910390fd5b5f6005805490501115610b4d5760055f81548110610a6757610a66611d9d565b5b905f5260205f2090600202015f01546001600301819055507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663daeab41260055f81548110610acf57610ace611d9d565b5b905f5260205f2090600202015f015460055f81548110610af257610af1611d9d565b5b905f5260205f209060020201600101546040518363ffffffff1660e01b8152600401610b1f929190611c0c565b5f604051808303815f87803b158015610b36575f5ffd5b505af1158015610b48573d5f5f3e3d5ffd5b505050505b600143610b5a9190612165565b4060018001819055508073ffffffffffffffffffffffffffffffffffffffff166309bd5a606040518163ffffffff1660e01b8152600401602060405180830381865afa158015610bac573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610bd091906121ac565b600160020181905550600b5442610be791906121d7565b600a8190555050565b60078181548110610bff575f80fd5b905f5260205f20015f915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b610c336113c5565b73ffffffffffffffffffffffffffffffffffffffff16610c51610e3c565b73ffffffffffffffffffffffffffffffffffffffff1614610ca7576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c9e90611cfe565b60405180910390fd5b5f5f90505b600780549050811015610d55575f60085f60078481548110610cd157610cd0611d9d565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff0219169083151502179055508080600101915050610cac565b5060075f610d639190611812565b7feca62e0074a13a90d600f003b7cb8d5bd50100008d3f3915f2554f3f8552c5cc60405160405180910390a1565b610d996113c5565b73ffffffffffffffffffffffffffffffffffffffff16610db7610e3c565b73ffffffffffffffffffffffffffffffffffffffff1614610e0d576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610e0490611cfe565b60405180910390fd5b610e165f6113f1565b565b7f000000000000000000000000000000000000000000000000000000000000000081565b5f5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b6009602052805f5260405f205f915054906101000a900460ff1681565b60058181548110610e8f575f80fd5b905f5260205f2090600202015f91509050805f0154908060010154905082565b60418383905014610ef5576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610eec90612254565b60405180910390fd5b5f610f0060016114b2565b855f01358660200135604051602001610f1b93929190612292565b60405160208183030381529060405280519060200120905060085f610f9486868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f81840152601f19601f82011690508083019250505050505050610f86856114f6565b61152990919063ffffffff16565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff16611019576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161101090612318565b60405180910390fd5b5f5f90505b6005805490508110156110a157611054866005838154811061104357611042611d9d565b5b905f5260205f2090600202016113cc565b15611094576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161108b90612380565b60405180910390fd5b808060010191505061101e565b505f600580549050036110c357600b54426110bc91906121d7565b600a819055505b600585908060018154018082558091505060019003905f5260205f2090600202015f9091909190915081816110f89190611ebf565b505060026005805490500361120357600160065f82825461111991906121d7565b925050819055507f37e8add694c5926d564e971160f5974103cbbbc7c90747c4c6f802031d3567a76006546040516111519190611a99565b60405180910390a15f8273ffffffffffffffffffffffffffffffffffffffff164760405161117e906123cb565b5f6040518083038185875af1925050503d805f81146111b8576040519150601f19603f3d011682016040523d82523d5f602084013e6111bd565b606091505b5050905080611201576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016111f890612429565b60405180910390fd5b505b5050505050565b600a5481565b6112186113c5565b73ffffffffffffffffffffffffffffffffffffffff16611236610e3c565b73ffffffffffffffffffffffffffffffffffffffff161461128c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161128390611cfe565b60405180910390fd5b8060015f01819055507fb7a180228497ed95c6896fc1b081a016999116f98ab95b52123659efea259764816040516112c49190611d1c565b60405180910390a150565b6112d76113c5565b73ffffffffffffffffffffffffffffffffffffffff166112f5610e3c565b73ffffffffffffffffffffffffffffffffffffffff161461134b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161134290611cfe565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16036113b9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016113b0906124b7565b60405180910390fd5b6113c2816113f1565b50565b5f33905090565b5f815f0154835f01351480156113e9575081600101548360200135145b905092915050565b5f5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f5f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f815f01548260010154836002015484600301546040516020016114d994939291906124d5565b604051602081830303815290604052805190602001209050919050565b5f7f19457468657265756d205369676e6564204d6573736167653a0a3332000000005f5281601c52603c5f209050919050565b5f5f5f5f6115378686611553565b92509250925061154782826115a8565b82935050505092915050565b5f5f5f6041845103611593575f5f5f602087015192506040870151915060608701515f1a90506115858882858561170a565b9550955095505050506115a1565b5f600285515f1b9250925092505b9250925092565b5f60038111156115bb576115ba612522565b5b8260038111156115ce576115cd612522565b5b031561170657600160038111156115e8576115e7612522565b5b8260038111156115fb576115fa612522565b5b03611632576040517ff645eedf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6002600381111561164657611645612522565b5b82600381111561165957611658612522565b5b0361169d57805f1c6040517ffce698f70000000000000000000000000000000000000000000000000000000081526004016116949190611a99565b60405180910390fd5b6003808111156116b0576116af612522565b5b8260038111156116c3576116c2612522565b5b0361170557806040517fd78bce0c0000000000000000000000000000000000000000000000000000000081526004016116fc9190611d1c565b60405180910390fd5b5b5050565b5f5f5f7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0845f1c1115611746575f6003859250925092506117e7565b5f6001888888886040515f8152602001604052604051611769949392919061256a565b6020604051602081039080840390855afa158015611789573d5f5f3e3d5ffd5b5050506020604051035190505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16036117da575f60015f5f1b935093509350506117e7565b805f5f5f1b935093509350505b9450945094915050565b5080545f8255600202905f5260205f209081019061180f9190611830565b50565b5080545f8255905f5260205f209081019061182d9190611854565b50565b5b80821115611850575f5f82015f9055600182015f905550600201611831565b5090565b5b8082111561186b575f815f905550600101611855565b5090565b5f5ffd5b5f5ffd5b5f819050919050565b61188981611877565b8114611893575f5ffd5b50565b5f813590506118a481611880565b92915050565b5f602082840312156118bf576118be61186f565b5b5f6118cc84828501611896565b91505092915050565b5f5ffd5b5f604082840312156118ee576118ed6118d5565b5b81905092915050565b5f6040828403121561190c5761190b61186f565b5b5f611919848285016118d9565b91505092915050565b5f819050919050565b61193481611922565b811461193e575f5ffd5b50565b5f8135905061194f8161192b565b92915050565b5f6020828403121561196a5761196961186f565b5b5f61197784828501611941565b91505092915050565b61198981611877565b82525050565b5f6080820190506119a25f830187611980565b6119af6020830186611980565b6119bc6040830185611980565b6119c96060830184611980565b95945050505050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6119fb826119d2565b9050919050565b611a0b816119f1565b8114611a15575f5ffd5b50565b5f81359050611a2681611a02565b92915050565b5f60208284031215611a4157611a4061186f565b5b5f611a4e84828501611a18565b91505092915050565b5f8115159050919050565b611a6b81611a57565b82525050565b5f602082019050611a845f830184611a62565b92915050565b611a9381611922565b82525050565b5f602082019050611aac5f830184611a8a565b92915050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83601f840112611ad357611ad2611ab2565b5b8235905067ffffffffffffffff811115611af057611aef611ab6565b5b602083019150836001820283011115611b0c57611b0b611aba565b5b9250929050565b5f5f5f60408486031215611b2a57611b2961186f565b5b5f611b3786828701611a18565b935050602084013567ffffffffffffffff811115611b5857611b57611873565b5b611b6486828701611abe565b92509250509250925092565b611b79816119f1565b82525050565b5f602082019050611b925f830184611b70565b92915050565b5f819050919050565b5f611bbb611bb6611bb1846119d2565b611b98565b6119d2565b9050919050565b5f611bcc82611ba1565b9050919050565b5f611bdd82611bc2565b9050919050565b611bed81611bd3565b82525050565b5f602082019050611c065f830184611be4565b92915050565b5f604082019050611c1f5f830185611980565b611c2c6020830184611980565b9392505050565b5f5f5f5f60808587031215611c4b57611c4a61186f565b5b5f611c58878288016118d9565b945050604085013567ffffffffffffffff811115611c7957611c78611873565b5b611c8587828801611abe565b93509350506060611c9887828801611a18565b91505092959194509250565b5f82825260208201905092915050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65725f82015250565b5f611ce8602083611ca4565b9150611cf382611cb4565b602082019050919050565b5f6020820190508181035f830152611d1581611cdc565b9050919050565b5f602082019050611d2f5f830184611980565b92915050565b7f6368616c6c656e676520646f6573206e6f7420657869737400000000000000005f82015250565b5f611d69601883611ca4565b9150611d7482611d35565b602082019050919050565b5f6020820190508181035f830152611d9681611d5d565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f8135611dd681611880565b80915050919050565b5f815f1b9050919050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff611e1584611ddf565b9350801983169250808416831791505092915050565b5f611e3582611877565b9050919050565b5f815f1c9050919050565b5f611e5182611e3c565b9050919050565b611e6182611e2b565b611e74611e6d82611e47565b8354611dea565b8255505050565b5f81015f830180611e8b81611dca565b9050611e978184611e58565b505050600181016020830180611eac81611dca565b9050611eb88184611e58565b5050505050565b611ec98282611e7b565b5050565b5f611edb6020840184611896565b905092915050565b611eec81611877565b82525050565b60408201611f025f830183611ecd565b611f0e5f850182611ee3565b50611f1c6020830183611ecd565b611f296020850182611ee3565b50505050565b5f604082019050611f425f830184611ef2565b92915050565b7f617373657274696f6e206e6f7420666f756e64000000000000000000000000005f82015250565b5f611f7c601383611ca4565b9150611f8782611f48565b602082019050919050565b5f6020820190508181035f830152611fa981611f70565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52600160045260245ffd5b7f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201527f746f6f206d616e7920617373657274696f6e7300000000000000000000000000602082015250565b5f612037603383611ca4565b915061204282611fdd565b604082019050919050565b5f6020820190508181035f8301526120648161202b565b9050919050565b5f815190506120798161192b565b92915050565b5f602082840312156120945761209361186f565b5b5f6120a18482850161206b565b91505092915050565b7f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201527f696e73756666696369656e742074696d65206861732070617373656400000000602082015250565b5f612104603c83611ca4565b915061210f826120aa565b604082019050919050565b5f6020820190508181035f830152612131816120f8565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f61216f82611922565b915061217a83611922565b925082820390508181111561219257612191612138565b5b92915050565b5f815190506121a681611880565b92915050565b5f602082840312156121c1576121c061186f565b5b5f6121ce84828501612198565b91505092915050565b5f6121e182611922565b91506121ec83611922565b925082820190508082111561220457612203612138565b5b92915050565b7f696e76616c6964207369676e6174757265206c656e67746800000000000000005f82015250565b5f61223e601883611ca4565b91506122498261220a565b602082019050919050565b5f6020820190508181035f83015261226b81612232565b9050919050565b5f819050919050565b61228c61228782611877565b612272565b82525050565b5f61229d828661227b565b6020820191506122ad828561227b565b6020820191506122bd828461227b565b602082019150819050949350505050565b7f696e76616c696420746565207369676e617475726500000000000000000000005f82015250565b5f612302601583611ca4565b915061230d826122ce565b602082019050919050565b5f6020820190508181035f83015261232f816122f6565b9050919050565b7f617373657274696f6e20616c72656164792065786973747300000000000000005f82015250565b5f61236a601883611ca4565b915061237582612336565b602082019050919050565b5f6020820190508181035f8301526123978161235e565b9050919050565b5f81905092915050565b50565b5f6123b65f8361239e565b91506123c1826123a8565b5f82019050919050565b5f6123d5826123ab565b9150819050919050565b7f7061796d656e74206661696c65640000000000000000000000000000000000005f82015250565b5f612413600e83611ca4565b915061241e826123df565b602082019050919050565b5f6020820190508181035f83015261244081612407565b9050919050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f20615f8201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b5f6124a1602683611ca4565b91506124ac82612447565b604082019050919050565b5f6020820190508181035f8301526124ce81612495565b9050919050565b5f6124e0828761227b565b6020820191506124f0828661227b565b602082019150612500828561227b565b602082019150612510828461227b565b60208201915081905095945050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b5f60ff82169050919050565b6125648161254f565b82525050565b5f60808201905061257d5f830187611980565b61258a602083018661255b565b6125976040830185611980565b6125a46060830184611980565b9594505050505056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R4\x80\x15a\0\x0FW__\xFD[P`@Qa(d8\x03\x80a(d\x839\x81\x81\x01`@R\x81\x01\x90a\x001\x91\x90a\x022V[a\0Ma\0Ba\0\xC8` \x1B` \x1CV[a\0\xCF` \x1B` \x1CV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x80\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP\x80`\x01_\x01\x81\x90UP\x7F\xB7\xA1\x80\"\x84\x97\xED\x95\xC6\x89o\xC1\xB0\x81\xA0\x16\x99\x91\x16\xF9\x8A\xB9[R\x126Y\xEF\xEA%\x97d\x81`@Qa\0\xB9\x91\x90a\x02\x7FV[`@Q\x80\x91\x03\x90\xA1PPa\x02\x98V[_3\x90P\x90V[___\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81__a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPV[__\xFD[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a\x01\xBD\x82a\x01\x94V[\x90P\x91\x90PV[_a\x01\xCE\x82a\x01\xB3V[\x90P\x91\x90PV[a\x01\xDE\x81a\x01\xC4V[\x81\x14a\x01\xE8W__\xFD[PV[_\x81Q\x90Pa\x01\xF9\x81a\x01\xD5V[\x92\x91PPV[_\x81\x90P\x91\x90PV[a\x02\x11\x81a\x01\xFFV[\x81\x14a\x02\x1BW__\xFD[PV[_\x81Q\x90Pa\x02,\x81a\x02\x08V[\x92\x91PPV[__`@\x83\x85\x03\x12\x15a\x02HWa\x02Ga\x01\x90V[[_a\x02U\x85\x82\x86\x01a\x01\xEBV[\x92PP` a\x02f\x85\x82\x86\x01a\x02\x1EV[\x91PP\x92P\x92\x90PV[a\x02y\x81a\x01\xFFV[\x82RPPV[_` \x82\x01\x90Pa\x02\x92_\x83\x01\x84a\x02pV[\x92\x91PPV[`\x80Qa%\xADa\x02\xB7_9_\x81\x81a\n\x81\x01Ra\x0E\x1A\x01Ra%\xAD_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x015W_5`\xE0\x1C\x80cn\xBE\xD0\xF0\x11a\0\xB6W\x80c\xA3\x80\xEF\x87\x11a\0zW\x80c\xA3\x80\xEF\x87\x14a\x02\xDCW\x80c\xA5n\xC6\xCD\x14a\x03\x0CW\x80c\xB2g\x004\x14a\x03=W\x80c\xEE\x1C(\xB8\x14a\x03YW\x80c\xF2#\x05\\\x14a\x03wW\x80c\xF2\xFD\xE3\x8B\x14a\x03\x93Wa\x015V[\x80cn\xBE\xD0\xF0\x14a\x02\\W\x80cn\xF0\x12\x01\x14a\x02\x8CW\x80cqP\x18\xA6\x14a\x02\x96W\x80c\x80\x95\x97!\x14a\x02\xA0W\x80c\x8D\xA5\xCB[\x14a\x02\xBEWa\x015V[\x80cGt&@\x11a\0\xFDW\x80cGt&@\x14a\x01\xCAW\x80cK\xD1g\xC9\x14a\x01\xFAW\x80c]K\xED\xC3\x14a\x02\x18W\x80ci{^b\x14a\x024W\x80clL `\x14a\x02RWa\x015V[\x80c\n\xD1\x95\xAB\x14a\x019W\x80c\x0B|\x02A\x14a\x01UW\x80c\x1C\xAF]\x13\x14a\x01qW\x80c<\xEA\xAE}\x14a\x01\x8DW\x80cC\xDE_3\x14a\x01\xAEW[__\xFD[a\x01S`\x04\x806\x03\x81\x01\x90a\x01N\x91\x90a\x18\xAAV[a\x03\xAFV[\0[a\x01o`\x04\x806\x03\x81\x01\x90a\x01j\x91\x90a\x18\xF7V[a\x04\x8DV[\0[a\x01\x8B`\x04\x806\x03\x81\x01\x90a\x01\x86\x91\x90a\x19UV[a\x06mV[\0[a\x01\x95a\x06\xF3V[`@Qa\x01\xA5\x94\x93\x92\x91\x90a\x19\x8FV[`@Q\x80\x91\x03\x90\xF3[a\x01\xC8`\x04\x806\x03\x81\x01\x90a\x01\xC3\x91\x90a\x18\xAAV[a\x07\x10V[\0[a\x01\xE4`\x04\x806\x03\x81\x01\x90a\x01\xDF\x91\x90a\x1A,V[a\x07\xEFV[`@Qa\x01\xF1\x91\x90a\x1AqV[`@Q\x80\x91\x03\x90\xF3[a\x02\x02a\x08\x0CV[`@Qa\x02\x0F\x91\x90a\x1A\x99V[`@Q\x80\x91\x03\x90\xF3[a\x022`\x04\x806\x03\x81\x01\x90a\x02-\x91\x90a\x1B\x13V[a\x08\x12V[\0[a\x02<a\t/V[`@Qa\x02I\x91\x90a\x1A\x99V[`@Q\x80\x91\x03\x90\xF3[a\x02Za\t5V[\0[a\x02v`\x04\x806\x03\x81\x01\x90a\x02q\x91\x90a\x19UV[a\x0B\xF0V[`@Qa\x02\x83\x91\x90a\x1B\x7FV[`@Q\x80\x91\x03\x90\xF3[a\x02\x94a\x0C+V[\0[a\x02\x9Ea\r\x91V[\0[a\x02\xA8a\x0E\x18V[`@Qa\x02\xB5\x91\x90a\x1B\xF3V[`@Q\x80\x91\x03\x90\xF3[a\x02\xC6a\x0E<V[`@Qa\x02\xD3\x91\x90a\x1B\x7FV[`@Q\x80\x91\x03\x90\xF3[a\x02\xF6`\x04\x806\x03\x81\x01\x90a\x02\xF1\x91\x90a\x18\xAAV[a\x0EcV[`@Qa\x03\x03\x91\x90a\x1AqV[`@Q\x80\x91\x03\x90\xF3[a\x03&`\x04\x806\x03\x81\x01\x90a\x03!\x91\x90a\x19UV[a\x0E\x80V[`@Qa\x034\x92\x91\x90a\x1C\x0CV[`@Q\x80\x91\x03\x90\xF3[a\x03W`\x04\x806\x03\x81\x01\x90a\x03R\x91\x90a\x1C3V[a\x0E\xAFV[\0[a\x03aa\x12\nV[`@Qa\x03n\x91\x90a\x1A\x99V[`@Q\x80\x91\x03\x90\xF3[a\x03\x91`\x04\x806\x03\x81\x01\x90a\x03\x8C\x91\x90a\x18\xAAV[a\x12\x10V[\0[a\x03\xAD`\x04\x806\x03\x81\x01\x90a\x03\xA8\x91\x90a\x1A,V[a\x12\xCFV[\0[a\x03\xB7a\x13\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x03\xD5a\x0E<V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x04+W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x04\"\x90a\x1C\xFEV[`@Q\x80\x91\x03\x90\xFD[_`\t_\x83\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\r\xB1f\xBBNG\xA6`\xAA\xFC2\xF7\x8B\xBA\xCD\xDA\x0B\x90\xB0s^E\xB2\x13J\xEE\xC3\xA5\xEAVU\xAB\x81`@Qa\x04\x82\x91\x90a\x1D\x1CV[`@Q\x80\x91\x03\x90\xA1PV[a\x04\x95a\x13\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x04\xB3a\x0E<V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x05\tW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05\0\x90a\x1C\xFEV[`@Q\x80\x91\x03\x90\xFD[`\x01`\x05\x80T\x90P\x11a\x05QW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05H\x90a\x1D\x7FV[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x05\x80T\x90P\x81\x10\x15a\x06.Wa\x05\x8C\x82`\x05\x83\x81T\x81\x10a\x05{Wa\x05za\x1D\x9DV[[\x90_R` _ \x90`\x02\x02\x01a\x13\xCCV[\x15a\x06!W`\x05_a\x05\x9E\x91\x90a\x17\xF1V[`\x05\x82\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x02\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a\x05\xD3\x91\x90a\x1E\xBFV[PP_`\n\x81\x90UPa\x05\xE4a\t5V[\x7F\x11N\x9Cy\x8E<m\x15\x8B]\x1D\xD7\x11\xCE\x1E\"x_=\x94\x89\x8D\xDB\x1C\xE7\xF9\xBCu\x171u\xD3\x82`@Qa\x06\x13\x91\x90a\x1F/V[`@Q\x80\x91\x03\x90\xA1Pa\x06jV[\x80\x80`\x01\x01\x91PPa\x05VV[P`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06a\x90a\x1F\x92V[`@Q\x80\x91\x03\x90\xFD[PV[a\x06ua\x13\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x06\x93a\x0E<V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x06\xE9W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xE0\x90a\x1C\xFEV[`@Q\x80\x91\x03\x90\xFD[\x80`\x0B\x81\x90UPPV[`\x01\x80_\x01T\x90\x80`\x01\x01T\x90\x80`\x02\x01T\x90\x80`\x03\x01T\x90P\x84V[a\x07\x18a\x13\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x076a\x0E<V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x07\x8CW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x07\x83\x90a\x1C\xFEV[`@Q\x80\x91\x03\x90\xFD[`\x01`\t_\x83\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7FC\x88P&\xC5\x9E\xCB\xB8$\xD1\x02x_\xEE_\x95\x93\xE6\x95\xBB\x9A\x84\x90\x86M\x980\x95%$\xE5\xD5\x81`@Qa\x07\xE4\x91\x90a\x1D\x1CV[`@Q\x80\x91\x03\x90\xA1PV[`\x08` R\x80_R`@_ _\x91PT\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[`\x0BT\x81V[`\x01\x82\x82\x90P\x14a\x08&Wa\x08%a\x1F\xB0V[[`\x08_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\t*W`\x01`\x08_\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP`\x07\x83\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP[PPPV[`\x06T\x81V[_sB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\x90P`\x01`\x05\x80T\x90P\x11\x15a\t\x96W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\t\x8D\x90a MV[`@Q\x80\x91\x03\x90\xFD[`\nT\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xB8\x07w\xEA`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\t\xE2W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\x06\x91\x90a \x7FV[\x11a\nFW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\n=\x90a!\x1AV[`@Q\x80\x91\x03\x90\xFD[_`\x05\x80T\x90P\x11\x15a\x0BMW`\x05_\x81T\x81\x10a\ngWa\nfa\x1D\x9DV[[\x90_R` _ \x90`\x02\x02\x01_\x01T`\x01`\x03\x01\x81\x90UP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xDA\xEA\xB4\x12`\x05_\x81T\x81\x10a\n\xCFWa\n\xCEa\x1D\x9DV[[\x90_R` _ \x90`\x02\x02\x01_\x01T`\x05_\x81T\x81\x10a\n\xF2Wa\n\xF1a\x1D\x9DV[[\x90_R` _ \x90`\x02\x02\x01`\x01\x01T`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0B\x1F\x92\x91\x90a\x1C\x0CV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0B6W__\xFD[PZ\xF1\x15\x80\x15a\x0BHW=__>=_\xFD[PPPP[`\x01Ca\x0BZ\x91\x90a!eV[@`\x01\x80\x01\x81\x90UP\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\t\xBDZ``@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0B\xACW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0B\xD0\x91\x90a!\xACV[`\x01`\x02\x01\x81\x90UP`\x0BTBa\x0B\xE7\x91\x90a!\xD7V[`\n\x81\x90UPPV[`\x07\x81\x81T\x81\x10a\x0B\xFFW_\x80\xFD[\x90_R` _ \x01_\x91PT\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[a\x0C3a\x13\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x0CQa\x0E<V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x0C\xA7W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0C\x9E\x90a\x1C\xFEV[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x07\x80T\x90P\x81\x10\x15a\rUW_`\x08_`\x07\x84\x81T\x81\x10a\x0C\xD1Wa\x0C\xD0a\x1D\x9DV[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa\x0C\xACV[P`\x07_a\rc\x91\x90a\x18\x12V[\x7F\xEC\xA6.\0t\xA1:\x90\xD6\0\xF0\x03\xB7\xCB\x8D[\xD5\x01\0\0\x8D?9\x15\xF2UO?\x85R\xC5\xCC`@Q`@Q\x80\x91\x03\x90\xA1V[a\r\x99a\x13\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\r\xB7a\x0E<V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x0E\rW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0E\x04\x90a\x1C\xFEV[`@Q\x80\x91\x03\x90\xFD[a\x0E\x16_a\x13\xF1V[V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[___\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[`\t` R\x80_R`@_ _\x91PT\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[`\x05\x81\x81T\x81\x10a\x0E\x8FW_\x80\xFD[\x90_R` _ \x90`\x02\x02\x01_\x91P\x90P\x80_\x01T\x90\x80`\x01\x01T\x90P\x82V[`A\x83\x83\x90P\x14a\x0E\xF5W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0E\xEC\x90a\"TV[`@Q\x80\x91\x03\x90\xFD[_a\x0F\0`\x01a\x14\xB2V[\x85_\x015\x86` \x015`@Q` \x01a\x0F\x1B\x93\x92\x91\x90a\"\x92V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P`\x08_a\x0F\x94\x86\x86\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x81\x84\x01R`\x1F\x19`\x1F\x82\x01\x16\x90P\x80\x83\x01\x92PPPPPPPa\x0F\x86\x85a\x14\xF6V[a\x15)\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x10\x19W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x10\x10\x90a#\x18V[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x05\x80T\x90P\x81\x10\x15a\x10\xA1Wa\x10T\x86`\x05\x83\x81T\x81\x10a\x10CWa\x10Ba\x1D\x9DV[[\x90_R` _ \x90`\x02\x02\x01a\x13\xCCV[\x15a\x10\x94W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x10\x8B\x90a#\x80V[`@Q\x80\x91\x03\x90\xFD[\x80\x80`\x01\x01\x91PPa\x10\x1EV[P_`\x05\x80T\x90P\x03a\x10\xC3W`\x0BTBa\x10\xBC\x91\x90a!\xD7V[`\n\x81\x90UP[`\x05\x85\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x02\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a\x10\xF8\x91\x90a\x1E\xBFV[PP`\x02`\x05\x80T\x90P\x03a\x12\x03W`\x01`\x06_\x82\x82Ta\x11\x19\x91\x90a!\xD7V[\x92PP\x81\x90UP\x7F7\xE8\xAD\xD6\x94\xC5\x92mVN\x97\x11`\xF5\x97A\x03\xCB\xBB\xC7\xC9\x07G\xC4\xC6\xF8\x02\x03\x1D5g\xA7`\x06T`@Qa\x11Q\x91\x90a\x1A\x99V[`@Q\x80\x91\x03\x90\xA1_\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16G`@Qa\x11~\x90a#\xCBV[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a\x11\xB8W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x11\xBDV[``\x91P[PP\x90P\x80a\x12\x01W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x11\xF8\x90a$)V[`@Q\x80\x91\x03\x90\xFD[P[PPPPPV[`\nT\x81V[a\x12\x18a\x13\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x126a\x0E<V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x12\x8CW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x12\x83\x90a\x1C\xFEV[`@Q\x80\x91\x03\x90\xFD[\x80`\x01_\x01\x81\x90UP\x7F\xB7\xA1\x80\"\x84\x97\xED\x95\xC6\x89o\xC1\xB0\x81\xA0\x16\x99\x91\x16\xF9\x8A\xB9[R\x126Y\xEF\xEA%\x97d\x81`@Qa\x12\xC4\x91\x90a\x1D\x1CV[`@Q\x80\x91\x03\x90\xA1PV[a\x12\xD7a\x13\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x12\xF5a\x0E<V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x13KW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13B\x90a\x1C\xFEV[`@Q\x80\x91\x03\x90\xFD[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x13\xB9W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\xB0\x90a$\xB7V[`@Q\x80\x91\x03\x90\xFD[a\x13\xC2\x81a\x13\xF1V[PV[_3\x90P\x90V[_\x81_\x01T\x83_\x015\x14\x80\x15a\x13\xE9WP\x81`\x01\x01T\x83` \x015\x14[\x90P\x92\x91PPV[___\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81__a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPV[_\x81_\x01T\x82`\x01\x01T\x83`\x02\x01T\x84`\x03\x01T`@Q` \x01a\x14\xD9\x94\x93\x92\x91\x90a$\xD5V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x91\x90PV[_\x7F\x19Ethereum Signed Message:\n32\0\0\0\0_R\x81`\x1CR`<_ \x90P\x91\x90PV[____a\x157\x86\x86a\x15SV[\x92P\x92P\x92Pa\x15G\x82\x82a\x15\xA8V[\x82\x93PPPP\x92\x91PPV[___`A\x84Q\x03a\x15\x93W___` \x87\x01Q\x92P`@\x87\x01Q\x91P``\x87\x01Q_\x1A\x90Pa\x15\x85\x88\x82\x85\x85a\x17\nV[\x95P\x95P\x95PPPPa\x15\xA1V[_`\x02\x85Q_\x1B\x92P\x92P\x92P[\x92P\x92P\x92V[_`\x03\x81\x11\x15a\x15\xBBWa\x15\xBAa%\"V[[\x82`\x03\x81\x11\x15a\x15\xCEWa\x15\xCDa%\"V[[\x03\x15a\x17\x06W`\x01`\x03\x81\x11\x15a\x15\xE8Wa\x15\xE7a%\"V[[\x82`\x03\x81\x11\x15a\x15\xFBWa\x15\xFAa%\"V[[\x03a\x162W`@Q\x7F\xF6E\xEE\xDF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`\x03\x81\x11\x15a\x16FWa\x16Ea%\"V[[\x82`\x03\x81\x11\x15a\x16YWa\x16Xa%\"V[[\x03a\x16\x9DW\x80_\x1C`@Q\x7F\xFC\xE6\x98\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x16\x94\x91\x90a\x1A\x99V[`@Q\x80\x91\x03\x90\xFD[`\x03\x80\x81\x11\x15a\x16\xB0Wa\x16\xAFa%\"V[[\x82`\x03\x81\x11\x15a\x16\xC3Wa\x16\xC2a%\"V[[\x03a\x17\x05W\x80`@Q\x7F\xD7\x8B\xCE\x0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x16\xFC\x91\x90a\x1D\x1CV[`@Q\x80\x91\x03\x90\xFD[[PPV[___\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0\x84_\x1C\x11\x15a\x17FW_`\x03\x85\x92P\x92P\x92Pa\x17\xE7V[_`\x01\x88\x88\x88\x88`@Q_\x81R` \x01`@R`@Qa\x17i\x94\x93\x92\x91\x90a%jV[` `@Q` \x81\x03\x90\x80\x84\x03\x90\x85Z\xFA\x15\x80\x15a\x17\x89W=__>=_\xFD[PPP` `@Q\x03Q\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x17\xDAW_`\x01__\x1B\x93P\x93P\x93PPa\x17\xE7V[\x80___\x1B\x93P\x93P\x93PP[\x94P\x94P\x94\x91PPV[P\x80T_\x82U`\x02\x02\x90_R` _ \x90\x81\x01\x90a\x18\x0F\x91\x90a\x180V[PV[P\x80T_\x82U\x90_R` _ \x90\x81\x01\x90a\x18-\x91\x90a\x18TV[PV[[\x80\x82\x11\x15a\x18PW__\x82\x01_\x90U`\x01\x82\x01_\x90UP`\x02\x01a\x181V[P\x90V[[\x80\x82\x11\x15a\x18kW_\x81_\x90UP`\x01\x01a\x18UV[P\x90V[__\xFD[__\xFD[_\x81\x90P\x91\x90PV[a\x18\x89\x81a\x18wV[\x81\x14a\x18\x93W__\xFD[PV[_\x815\x90Pa\x18\xA4\x81a\x18\x80V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x18\xBFWa\x18\xBEa\x18oV[[_a\x18\xCC\x84\x82\x85\x01a\x18\x96V[\x91PP\x92\x91PPV[__\xFD[_`@\x82\x84\x03\x12\x15a\x18\xEEWa\x18\xEDa\x18\xD5V[[\x81\x90P\x92\x91PPV[_`@\x82\x84\x03\x12\x15a\x19\x0CWa\x19\x0Ba\x18oV[[_a\x19\x19\x84\x82\x85\x01a\x18\xD9V[\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[a\x194\x81a\x19\"V[\x81\x14a\x19>W__\xFD[PV[_\x815\x90Pa\x19O\x81a\x19+V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x19jWa\x19ia\x18oV[[_a\x19w\x84\x82\x85\x01a\x19AV[\x91PP\x92\x91PPV[a\x19\x89\x81a\x18wV[\x82RPPV[_`\x80\x82\x01\x90Pa\x19\xA2_\x83\x01\x87a\x19\x80V[a\x19\xAF` \x83\x01\x86a\x19\x80V[a\x19\xBC`@\x83\x01\x85a\x19\x80V[a\x19\xC9``\x83\x01\x84a\x19\x80V[\x95\x94PPPPPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a\x19\xFB\x82a\x19\xD2V[\x90P\x91\x90PV[a\x1A\x0B\x81a\x19\xF1V[\x81\x14a\x1A\x15W__\xFD[PV[_\x815\x90Pa\x1A&\x81a\x1A\x02V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x1AAWa\x1A@a\x18oV[[_a\x1AN\x84\x82\x85\x01a\x1A\x18V[\x91PP\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[a\x1Ak\x81a\x1AWV[\x82RPPV[_` \x82\x01\x90Pa\x1A\x84_\x83\x01\x84a\x1AbV[\x92\x91PPV[a\x1A\x93\x81a\x19\"V[\x82RPPV[_` \x82\x01\x90Pa\x1A\xAC_\x83\x01\x84a\x1A\x8AV[\x92\x91PPV[__\xFD[__\xFD[__\xFD[__\x83`\x1F\x84\x01\x12a\x1A\xD3Wa\x1A\xD2a\x1A\xB2V[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1A\xF0Wa\x1A\xEFa\x1A\xB6V[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15a\x1B\x0CWa\x1B\x0Ba\x1A\xBAV[[\x92P\x92\x90PV[___`@\x84\x86\x03\x12\x15a\x1B*Wa\x1B)a\x18oV[[_a\x1B7\x86\x82\x87\x01a\x1A\x18V[\x93PP` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1BXWa\x1BWa\x18sV[[a\x1Bd\x86\x82\x87\x01a\x1A\xBEV[\x92P\x92PP\x92P\x92P\x92V[a\x1By\x81a\x19\xF1V[\x82RPPV[_` \x82\x01\x90Pa\x1B\x92_\x83\x01\x84a\x1BpV[\x92\x91PPV[_\x81\x90P\x91\x90PV[_a\x1B\xBBa\x1B\xB6a\x1B\xB1\x84a\x19\xD2V[a\x1B\x98V[a\x19\xD2V[\x90P\x91\x90PV[_a\x1B\xCC\x82a\x1B\xA1V[\x90P\x91\x90PV[_a\x1B\xDD\x82a\x1B\xC2V[\x90P\x91\x90PV[a\x1B\xED\x81a\x1B\xD3V[\x82RPPV[_` \x82\x01\x90Pa\x1C\x06_\x83\x01\x84a\x1B\xE4V[\x92\x91PPV[_`@\x82\x01\x90Pa\x1C\x1F_\x83\x01\x85a\x19\x80V[a\x1C,` \x83\x01\x84a\x19\x80V[\x93\x92PPPV[____`\x80\x85\x87\x03\x12\x15a\x1CKWa\x1CJa\x18oV[[_a\x1CX\x87\x82\x88\x01a\x18\xD9V[\x94PP`@\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1CyWa\x1Cxa\x18sV[[a\x1C\x85\x87\x82\x88\x01a\x1A\xBEV[\x93P\x93PP``a\x1C\x98\x87\x82\x88\x01a\x1A\x18V[\x91PP\x92\x95\x91\x94P\x92PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7FOwnable: caller is not the owner_\x82\x01RPV[_a\x1C\xE8` \x83a\x1C\xA4V[\x91Pa\x1C\xF3\x82a\x1C\xB4V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x1D\x15\x81a\x1C\xDCV[\x90P\x91\x90PV[_` \x82\x01\x90Pa\x1D/_\x83\x01\x84a\x19\x80V[\x92\x91PPV[\x7Fchallenge does not exist\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x1Di`\x18\x83a\x1C\xA4V[\x91Pa\x1Dt\x82a\x1D5V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x1D\x96\x81a\x1D]V[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[_\x815a\x1D\xD6\x81a\x18\x80V[\x80\x91PP\x91\x90PV[_\x81_\x1B\x90P\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x1E\x15\x84a\x1D\xDFV[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_a\x1E5\x82a\x18wV[\x90P\x91\x90PV[_\x81_\x1C\x90P\x91\x90PV[_a\x1EQ\x82a\x1E<V[\x90P\x91\x90PV[a\x1Ea\x82a\x1E+V[a\x1Eta\x1Em\x82a\x1EGV[\x83Ta\x1D\xEAV[\x82UPPPV[_\x81\x01_\x83\x01\x80a\x1E\x8B\x81a\x1D\xCAV[\x90Pa\x1E\x97\x81\x84a\x1EXV[PPP`\x01\x81\x01` \x83\x01\x80a\x1E\xAC\x81a\x1D\xCAV[\x90Pa\x1E\xB8\x81\x84a\x1EXV[PPPPPV[a\x1E\xC9\x82\x82a\x1E{V[PPV[_a\x1E\xDB` \x84\x01\x84a\x18\x96V[\x90P\x92\x91PPV[a\x1E\xEC\x81a\x18wV[\x82RPPV[`@\x82\x01a\x1F\x02_\x83\x01\x83a\x1E\xCDV[a\x1F\x0E_\x85\x01\x82a\x1E\xE3V[Pa\x1F\x1C` \x83\x01\x83a\x1E\xCDV[a\x1F)` \x85\x01\x82a\x1E\xE3V[PPPPV[_`@\x82\x01\x90Pa\x1FB_\x83\x01\x84a\x1E\xF2V[\x92\x91PPV[\x7Fassertion not found\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x1F|`\x13\x83a\x1C\xA4V[\x91Pa\x1F\x87\x82a\x1FHV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x1F\xA9\x81a\x1FpV[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x01`\x04R`$_\xFD[\x7Fcannot close challenge window - _\x82\x01R\x7Ftoo many assertions\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a 7`3\x83a\x1C\xA4V[\x91Pa B\x82a\x1F\xDDV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra d\x81a +V[\x90P\x91\x90PV[_\x81Q\x90Pa y\x81a\x19+V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a \x94Wa \x93a\x18oV[[_a \xA1\x84\x82\x85\x01a kV[\x91PP\x92\x91PPV[\x7Fcannot close challenge window - _\x82\x01R\x7Finsufficient time has passed\0\0\0\0` \x82\x01RPV[_a!\x04`<\x83a\x1C\xA4V[\x91Pa!\x0F\x82a \xAAV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra!1\x81a \xF8V[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a!o\x82a\x19\"V[\x91Pa!z\x83a\x19\"V[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15a!\x92Wa!\x91a!8V[[\x92\x91PPV[_\x81Q\x90Pa!\xA6\x81a\x18\x80V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a!\xC1Wa!\xC0a\x18oV[[_a!\xCE\x84\x82\x85\x01a!\x98V[\x91PP\x92\x91PPV[_a!\xE1\x82a\x19\"V[\x91Pa!\xEC\x83a\x19\"V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a\"\x04Wa\"\x03a!8V[[\x92\x91PPV[\x7Finvalid signature length\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\">`\x18\x83a\x1C\xA4V[\x91Pa\"I\x82a\"\nV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\"k\x81a\"2V[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a\"\x8Ca\"\x87\x82a\x18wV[a\"rV[\x82RPPV[_a\"\x9D\x82\x86a\"{V[` \x82\x01\x91Pa\"\xAD\x82\x85a\"{V[` \x82\x01\x91Pa\"\xBD\x82\x84a\"{V[` \x82\x01\x91P\x81\x90P\x94\x93PPPPV[\x7Finvalid tee signature\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a#\x02`\x15\x83a\x1C\xA4V[\x91Pa#\r\x82a\"\xCEV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra#/\x81a\"\xF6V[\x90P\x91\x90PV[\x7Fassertion already exists\0\0\0\0\0\0\0\0_\x82\x01RPV[_a#j`\x18\x83a\x1C\xA4V[\x91Pa#u\x82a#6V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra#\x97\x81a#^V[\x90P\x91\x90PV[_\x81\x90P\x92\x91PPV[PV[_a#\xB6_\x83a#\x9EV[\x91Pa#\xC1\x82a#\xA8V[_\x82\x01\x90P\x91\x90PV[_a#\xD5\x82a#\xABV[\x91P\x81\x90P\x91\x90PV[\x7Fpayment failed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a$\x13`\x0E\x83a\x1C\xA4V[\x91Pa$\x1E\x82a#\xDFV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra$@\x81a$\x07V[\x90P\x91\x90PV[\x7FOwnable: new owner is the zero a_\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a$\xA1`&\x83a\x1C\xA4V[\x91Pa$\xAC\x82a$GV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra$\xCE\x81a$\x95V[\x90P\x91\x90PV[_a$\xE0\x82\x87a\"{V[` \x82\x01\x91Pa$\xF0\x82\x86a\"{V[` \x82\x01\x91Pa%\0\x82\x85a\"{V[` \x82\x01\x91Pa%\x10\x82\x84a\"{V[` \x82\x01\x91P\x81\x90P\x95\x94PPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[_`\xFF\x82\x16\x90P\x91\x90PV[a%d\x81a%OV[\x82RPPV[_`\x80\x82\x01\x90Pa%}_\x83\x01\x87a\x19\x80V[a%\x8A` \x83\x01\x86a%[V[a%\x97`@\x83\x01\x85a\x19\x80V[a%\xA4``\x83\x01\x84a\x19\x80V[\x95\x94PPPPPV",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b5060043610610135575f3560e01c80636ebed0f0116100b6578063a380ef871161007a578063a380ef87146102dc578063a56ec6cd1461030c578063b26700341461033d578063ee1c28b814610359578063f223055c14610377578063f2fde38b1461039357610135565b80636ebed0f01461025c5780636ef012011461028c578063715018a61461029657806380959721146102a05780638da5cb5b146102be57610135565b806347742640116100fd57806347742640146101ca5780634bd167c9146101fa5780635d4bedc314610218578063697b5e62146102345780636c4c20601461025257610135565b80630ad195ab146101395780630b7c0241146101555780631caf5d13146101715780633ceaae7d1461018d57806343de5f33146101ae575b5f5ffd5b610153600480360381019061014e91906118aa565b6103af565b005b61016f600480360381019061016a91906118f7565b61048d565b005b61018b60048036038101906101869190611955565b61066d565b005b6101956106f3565b6040516101a5949392919061198f565b60405180910390f35b6101c860048036038101906101c391906118aa565b610710565b005b6101e460048036038101906101df9190611a2c565b6107ef565b6040516101f19190611a71565b60405180910390f35b61020261080c565b60405161020f9190611a99565b60405180910390f35b610232600480360381019061022d9190611b13565b610812565b005b61023c61092f565b6040516102499190611a99565b60405180910390f35b61025a610935565b005b61027660048036038101906102719190611955565b610bf0565b6040516102839190611b7f565b60405180910390f35b610294610c2b565b005b61029e610d91565b005b6102a8610e18565b6040516102b59190611bf3565b60405180910390f35b6102c6610e3c565b6040516102d39190611b7f565b60405180910390f35b6102f660048036038101906102f191906118aa565b610e63565b6040516103039190611a71565b60405180910390f35b61032660048036038101906103219190611955565b610e80565b604051610334929190611c0c565b60405180910390f35b61035760048036038101906103529190611c33565b610eaf565b005b61036161120a565b60405161036e9190611a99565b60405180910390f35b610391600480360381019061038c91906118aa565b611210565b005b6103ad60048036038101906103a89190611a2c565b6112cf565b005b6103b76113c5565b73ffffffffffffffffffffffffffffffffffffffff166103d5610e3c565b73ffffffffffffffffffffffffffffffffffffffff161461042b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161042290611cfe565b60405180910390fd5b5f60095f8381526020019081526020015f205f6101000a81548160ff0219169083151502179055507f0db166bb4e47a660aafc32f78bbacdda0b90b0735e45b2134aeec3a5ea5655ab816040516104829190611d1c565b60405180910390a150565b6104956113c5565b73ffffffffffffffffffffffffffffffffffffffff166104b3610e3c565b73ffffffffffffffffffffffffffffffffffffffff1614610509576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161050090611cfe565b60405180910390fd5b600160058054905011610551576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161054890611d7f565b60405180910390fd5b5f5f90505b60058054905081101561062e5761058c826005838154811061057b5761057a611d9d565b5b905f5260205f2090600202016113cc565b156106215760055f61059e91906117f1565b600582908060018154018082558091505060019003905f5260205f2090600202015f9091909190915081816105d39190611ebf565b50505f600a819055506105e4610935565b7f114e9c798e3c6d158b5d1dd711ce1e22785f3d94898ddb1ce7f9bc75173175d3826040516106139190611f2f565b60405180910390a15061066a565b8080600101915050610556565b506040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161066190611f92565b60405180910390fd5b50565b6106756113c5565b73ffffffffffffffffffffffffffffffffffffffff16610693610e3c565b73ffffffffffffffffffffffffffffffffffffffff16146106e9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106e090611cfe565b60405180910390fd5b80600b8190555050565b6001805f0154908060010154908060020154908060030154905084565b6107186113c5565b73ffffffffffffffffffffffffffffffffffffffff16610736610e3c565b73ffffffffffffffffffffffffffffffffffffffff161461078c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161078390611cfe565b60405180910390fd5b600160095f8381526020019081526020015f205f6101000a81548160ff0219169083151502179055507f43885026c59ecbb824d102785fee5f9593e695bb9a8490864d9830952524e5d5816040516107e49190611d1c565b60405180910390a150565b6008602052805f5260405f205f915054906101000a900460ff1681565b600b5481565b6001828290501461082657610825611fb0565b5b60085f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1661092a57600160085f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550600783908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b505050565b60065481565b5f734200000000000000000000000000000000000015905060016005805490501115610996576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161098d9061204d565b60405180910390fd5b600a548173ffffffffffffffffffffffffffffffffffffffff1663b80777ea6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156109e2573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a06919061207f565b11610a46576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a3d9061211a565b60405180910390fd5b5f6005805490501115610b4d5760055f81548110610a6757610a66611d9d565b5b905f5260205f2090600202015f01546001600301819055507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663daeab41260055f81548110610acf57610ace611d9d565b5b905f5260205f2090600202015f015460055f81548110610af257610af1611d9d565b5b905f5260205f209060020201600101546040518363ffffffff1660e01b8152600401610b1f929190611c0c565b5f604051808303815f87803b158015610b36575f5ffd5b505af1158015610b48573d5f5f3e3d5ffd5b505050505b600143610b5a9190612165565b4060018001819055508073ffffffffffffffffffffffffffffffffffffffff166309bd5a606040518163ffffffff1660e01b8152600401602060405180830381865afa158015610bac573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610bd091906121ac565b600160020181905550600b5442610be791906121d7565b600a8190555050565b60078181548110610bff575f80fd5b905f5260205f20015f915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b610c336113c5565b73ffffffffffffffffffffffffffffffffffffffff16610c51610e3c565b73ffffffffffffffffffffffffffffffffffffffff1614610ca7576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c9e90611cfe565b60405180910390fd5b5f5f90505b600780549050811015610d55575f60085f60078481548110610cd157610cd0611d9d565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff0219169083151502179055508080600101915050610cac565b5060075f610d639190611812565b7feca62e0074a13a90d600f003b7cb8d5bd50100008d3f3915f2554f3f8552c5cc60405160405180910390a1565b610d996113c5565b73ffffffffffffffffffffffffffffffffffffffff16610db7610e3c565b73ffffffffffffffffffffffffffffffffffffffff1614610e0d576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610e0490611cfe565b60405180910390fd5b610e165f6113f1565b565b7f000000000000000000000000000000000000000000000000000000000000000081565b5f5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b6009602052805f5260405f205f915054906101000a900460ff1681565b60058181548110610e8f575f80fd5b905f5260205f2090600202015f91509050805f0154908060010154905082565b60418383905014610ef5576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610eec90612254565b60405180910390fd5b5f610f0060016114b2565b855f01358660200135604051602001610f1b93929190612292565b60405160208183030381529060405280519060200120905060085f610f9486868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f81840152601f19601f82011690508083019250505050505050610f86856114f6565b61152990919063ffffffff16565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff16611019576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161101090612318565b60405180910390fd5b5f5f90505b6005805490508110156110a157611054866005838154811061104357611042611d9d565b5b905f5260205f2090600202016113cc565b15611094576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161108b90612380565b60405180910390fd5b808060010191505061101e565b505f600580549050036110c357600b54426110bc91906121d7565b600a819055505b600585908060018154018082558091505060019003905f5260205f2090600202015f9091909190915081816110f89190611ebf565b505060026005805490500361120357600160065f82825461111991906121d7565b925050819055507f37e8add694c5926d564e971160f5974103cbbbc7c90747c4c6f802031d3567a76006546040516111519190611a99565b60405180910390a15f8273ffffffffffffffffffffffffffffffffffffffff164760405161117e906123cb565b5f6040518083038185875af1925050503d805f81146111b8576040519150601f19603f3d011682016040523d82523d5f602084013e6111bd565b606091505b5050905080611201576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016111f890612429565b60405180910390fd5b505b5050505050565b600a5481565b6112186113c5565b73ffffffffffffffffffffffffffffffffffffffff16611236610e3c565b73ffffffffffffffffffffffffffffffffffffffff161461128c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161128390611cfe565b60405180910390fd5b8060015f01819055507fb7a180228497ed95c6896fc1b081a016999116f98ab95b52123659efea259764816040516112c49190611d1c565b60405180910390a150565b6112d76113c5565b73ffffffffffffffffffffffffffffffffffffffff166112f5610e3c565b73ffffffffffffffffffffffffffffffffffffffff161461134b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161134290611cfe565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16036113b9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016113b0906124b7565b60405180910390fd5b6113c2816113f1565b50565b5f33905090565b5f815f0154835f01351480156113e9575081600101548360200135145b905092915050565b5f5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f5f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f815f01548260010154836002015484600301546040516020016114d994939291906124d5565b604051602081830303815290604052805190602001209050919050565b5f7f19457468657265756d205369676e6564204d6573736167653a0a3332000000005f5281601c52603c5f209050919050565b5f5f5f5f6115378686611553565b92509250925061154782826115a8565b82935050505092915050565b5f5f5f6041845103611593575f5f5f602087015192506040870151915060608701515f1a90506115858882858561170a565b9550955095505050506115a1565b5f600285515f1b9250925092505b9250925092565b5f60038111156115bb576115ba612522565b5b8260038111156115ce576115cd612522565b5b031561170657600160038111156115e8576115e7612522565b5b8260038111156115fb576115fa612522565b5b03611632576040517ff645eedf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6002600381111561164657611645612522565b5b82600381111561165957611658612522565b5b0361169d57805f1c6040517ffce698f70000000000000000000000000000000000000000000000000000000081526004016116949190611a99565b60405180910390fd5b6003808111156116b0576116af612522565b5b8260038111156116c3576116c2612522565b5b0361170557806040517fd78bce0c0000000000000000000000000000000000000000000000000000000081526004016116fc9190611d1c565b60405180910390fd5b5b5050565b5f5f5f7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0845f1c1115611746575f6003859250925092506117e7565b5f6001888888886040515f8152602001604052604051611769949392919061256a565b6020604051602081039080840390855afa158015611789573d5f5f3e3d5ffd5b5050506020604051035190505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16036117da575f60015f5f1b935093509350506117e7565b805f5f5f1b935093509350505b9450945094915050565b5080545f8255600202905f5260205f209081019061180f9190611830565b50565b5080545f8255905f5260205f209081019061182d9190611854565b50565b5b80821115611850575f5f82015f9055600182015f905550600201611831565b5090565b5b8082111561186b575f815f905550600101611855565b5090565b5f5ffd5b5f5ffd5b5f819050919050565b61188981611877565b8114611893575f5ffd5b50565b5f813590506118a481611880565b92915050565b5f602082840312156118bf576118be61186f565b5b5f6118cc84828501611896565b91505092915050565b5f5ffd5b5f604082840312156118ee576118ed6118d5565b5b81905092915050565b5f6040828403121561190c5761190b61186f565b5b5f611919848285016118d9565b91505092915050565b5f819050919050565b61193481611922565b811461193e575f5ffd5b50565b5f8135905061194f8161192b565b92915050565b5f6020828403121561196a5761196961186f565b5b5f61197784828501611941565b91505092915050565b61198981611877565b82525050565b5f6080820190506119a25f830187611980565b6119af6020830186611980565b6119bc6040830185611980565b6119c96060830184611980565b95945050505050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6119fb826119d2565b9050919050565b611a0b816119f1565b8114611a15575f5ffd5b50565b5f81359050611a2681611a02565b92915050565b5f60208284031215611a4157611a4061186f565b5b5f611a4e84828501611a18565b91505092915050565b5f8115159050919050565b611a6b81611a57565b82525050565b5f602082019050611a845f830184611a62565b92915050565b611a9381611922565b82525050565b5f602082019050611aac5f830184611a8a565b92915050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83601f840112611ad357611ad2611ab2565b5b8235905067ffffffffffffffff811115611af057611aef611ab6565b5b602083019150836001820283011115611b0c57611b0b611aba565b5b9250929050565b5f5f5f60408486031215611b2a57611b2961186f565b5b5f611b3786828701611a18565b935050602084013567ffffffffffffffff811115611b5857611b57611873565b5b611b6486828701611abe565b92509250509250925092565b611b79816119f1565b82525050565b5f602082019050611b925f830184611b70565b92915050565b5f819050919050565b5f611bbb611bb6611bb1846119d2565b611b98565b6119d2565b9050919050565b5f611bcc82611ba1565b9050919050565b5f611bdd82611bc2565b9050919050565b611bed81611bd3565b82525050565b5f602082019050611c065f830184611be4565b92915050565b5f604082019050611c1f5f830185611980565b611c2c6020830184611980565b9392505050565b5f5f5f5f60808587031215611c4b57611c4a61186f565b5b5f611c58878288016118d9565b945050604085013567ffffffffffffffff811115611c7957611c78611873565b5b611c8587828801611abe565b93509350506060611c9887828801611a18565b91505092959194509250565b5f82825260208201905092915050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65725f82015250565b5f611ce8602083611ca4565b9150611cf382611cb4565b602082019050919050565b5f6020820190508181035f830152611d1581611cdc565b9050919050565b5f602082019050611d2f5f830184611980565b92915050565b7f6368616c6c656e676520646f6573206e6f7420657869737400000000000000005f82015250565b5f611d69601883611ca4565b9150611d7482611d35565b602082019050919050565b5f6020820190508181035f830152611d9681611d5d565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f8135611dd681611880565b80915050919050565b5f815f1b9050919050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff611e1584611ddf565b9350801983169250808416831791505092915050565b5f611e3582611877565b9050919050565b5f815f1c9050919050565b5f611e5182611e3c565b9050919050565b611e6182611e2b565b611e74611e6d82611e47565b8354611dea565b8255505050565b5f81015f830180611e8b81611dca565b9050611e978184611e58565b505050600181016020830180611eac81611dca565b9050611eb88184611e58565b5050505050565b611ec98282611e7b565b5050565b5f611edb6020840184611896565b905092915050565b611eec81611877565b82525050565b60408201611f025f830183611ecd565b611f0e5f850182611ee3565b50611f1c6020830183611ecd565b611f296020850182611ee3565b50505050565b5f604082019050611f425f830184611ef2565b92915050565b7f617373657274696f6e206e6f7420666f756e64000000000000000000000000005f82015250565b5f611f7c601383611ca4565b9150611f8782611f48565b602082019050919050565b5f6020820190508181035f830152611fa981611f70565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52600160045260245ffd5b7f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201527f746f6f206d616e7920617373657274696f6e7300000000000000000000000000602082015250565b5f612037603383611ca4565b915061204282611fdd565b604082019050919050565b5f6020820190508181035f8301526120648161202b565b9050919050565b5f815190506120798161192b565b92915050565b5f602082840312156120945761209361186f565b5b5f6120a18482850161206b565b91505092915050565b7f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201527f696e73756666696369656e742074696d65206861732070617373656400000000602082015250565b5f612104603c83611ca4565b915061210f826120aa565b604082019050919050565b5f6020820190508181035f830152612131816120f8565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f61216f82611922565b915061217a83611922565b925082820390508181111561219257612191612138565b5b92915050565b5f815190506121a681611880565b92915050565b5f602082840312156121c1576121c061186f565b5b5f6121ce84828501612198565b91505092915050565b5f6121e182611922565b91506121ec83611922565b925082820190508082111561220457612203612138565b5b92915050565b7f696e76616c6964207369676e6174757265206c656e67746800000000000000005f82015250565b5f61223e601883611ca4565b91506122498261220a565b602082019050919050565b5f6020820190508181035f83015261226b81612232565b9050919050565b5f819050919050565b61228c61228782611877565b612272565b82525050565b5f61229d828661227b565b6020820191506122ad828561227b565b6020820191506122bd828461227b565b602082019150819050949350505050565b7f696e76616c696420746565207369676e617475726500000000000000000000005f82015250565b5f612302601583611ca4565b915061230d826122ce565b602082019050919050565b5f6020820190508181035f83015261232f816122f6565b9050919050565b7f617373657274696f6e20616c72656164792065786973747300000000000000005f82015250565b5f61236a601883611ca4565b915061237582612336565b602082019050919050565b5f6020820190508181035f8301526123978161235e565b9050919050565b5f81905092915050565b50565b5f6123b65f8361239e565b91506123c1826123a8565b5f82019050919050565b5f6123d5826123ab565b9150819050919050565b7f7061796d656e74206661696c65640000000000000000000000000000000000005f82015250565b5f612413600e83611ca4565b915061241e826123df565b602082019050919050565b5f6020820190508181035f83015261244081612407565b9050919050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f20615f8201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b5f6124a1602683611ca4565b91506124ac82612447565b604082019050919050565b5f6020820190508181035f8301526124ce81612495565b9050919050565b5f6124e0828761227b565b6020820191506124f0828661227b565b602082019150612500828561227b565b602082019150612510828461227b565b60208201915081905095945050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b5f60ff82169050919050565b6125648161254f565b82525050565b5f60808201905061257d5f830187611980565b61258a602083018661255b565b6125976040830185611980565b6125a46060830184611980565b9594505050505056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x015W_5`\xE0\x1C\x80cn\xBE\xD0\xF0\x11a\0\xB6W\x80c\xA3\x80\xEF\x87\x11a\0zW\x80c\xA3\x80\xEF\x87\x14a\x02\xDCW\x80c\xA5n\xC6\xCD\x14a\x03\x0CW\x80c\xB2g\x004\x14a\x03=W\x80c\xEE\x1C(\xB8\x14a\x03YW\x80c\xF2#\x05\\\x14a\x03wW\x80c\xF2\xFD\xE3\x8B\x14a\x03\x93Wa\x015V[\x80cn\xBE\xD0\xF0\x14a\x02\\W\x80cn\xF0\x12\x01\x14a\x02\x8CW\x80cqP\x18\xA6\x14a\x02\x96W\x80c\x80\x95\x97!\x14a\x02\xA0W\x80c\x8D\xA5\xCB[\x14a\x02\xBEWa\x015V[\x80cGt&@\x11a\0\xFDW\x80cGt&@\x14a\x01\xCAW\x80cK\xD1g\xC9\x14a\x01\xFAW\x80c]K\xED\xC3\x14a\x02\x18W\x80ci{^b\x14a\x024W\x80clL `\x14a\x02RWa\x015V[\x80c\n\xD1\x95\xAB\x14a\x019W\x80c\x0B|\x02A\x14a\x01UW\x80c\x1C\xAF]\x13\x14a\x01qW\x80c<\xEA\xAE}\x14a\x01\x8DW\x80cC\xDE_3\x14a\x01\xAEW[__\xFD[a\x01S`\x04\x806\x03\x81\x01\x90a\x01N\x91\x90a\x18\xAAV[a\x03\xAFV[\0[a\x01o`\x04\x806\x03\x81\x01\x90a\x01j\x91\x90a\x18\xF7V[a\x04\x8DV[\0[a\x01\x8B`\x04\x806\x03\x81\x01\x90a\x01\x86\x91\x90a\x19UV[a\x06mV[\0[a\x01\x95a\x06\xF3V[`@Qa\x01\xA5\x94\x93\x92\x91\x90a\x19\x8FV[`@Q\x80\x91\x03\x90\xF3[a\x01\xC8`\x04\x806\x03\x81\x01\x90a\x01\xC3\x91\x90a\x18\xAAV[a\x07\x10V[\0[a\x01\xE4`\x04\x806\x03\x81\x01\x90a\x01\xDF\x91\x90a\x1A,V[a\x07\xEFV[`@Qa\x01\xF1\x91\x90a\x1AqV[`@Q\x80\x91\x03\x90\xF3[a\x02\x02a\x08\x0CV[`@Qa\x02\x0F\x91\x90a\x1A\x99V[`@Q\x80\x91\x03\x90\xF3[a\x022`\x04\x806\x03\x81\x01\x90a\x02-\x91\x90a\x1B\x13V[a\x08\x12V[\0[a\x02<a\t/V[`@Qa\x02I\x91\x90a\x1A\x99V[`@Q\x80\x91\x03\x90\xF3[a\x02Za\t5V[\0[a\x02v`\x04\x806\x03\x81\x01\x90a\x02q\x91\x90a\x19UV[a\x0B\xF0V[`@Qa\x02\x83\x91\x90a\x1B\x7FV[`@Q\x80\x91\x03\x90\xF3[a\x02\x94a\x0C+V[\0[a\x02\x9Ea\r\x91V[\0[a\x02\xA8a\x0E\x18V[`@Qa\x02\xB5\x91\x90a\x1B\xF3V[`@Q\x80\x91\x03\x90\xF3[a\x02\xC6a\x0E<V[`@Qa\x02\xD3\x91\x90a\x1B\x7FV[`@Q\x80\x91\x03\x90\xF3[a\x02\xF6`\x04\x806\x03\x81\x01\x90a\x02\xF1\x91\x90a\x18\xAAV[a\x0EcV[`@Qa\x03\x03\x91\x90a\x1AqV[`@Q\x80\x91\x03\x90\xF3[a\x03&`\x04\x806\x03\x81\x01\x90a\x03!\x91\x90a\x19UV[a\x0E\x80V[`@Qa\x034\x92\x91\x90a\x1C\x0CV[`@Q\x80\x91\x03\x90\xF3[a\x03W`\x04\x806\x03\x81\x01\x90a\x03R\x91\x90a\x1C3V[a\x0E\xAFV[\0[a\x03aa\x12\nV[`@Qa\x03n\x91\x90a\x1A\x99V[`@Q\x80\x91\x03\x90\xF3[a\x03\x91`\x04\x806\x03\x81\x01\x90a\x03\x8C\x91\x90a\x18\xAAV[a\x12\x10V[\0[a\x03\xAD`\x04\x806\x03\x81\x01\x90a\x03\xA8\x91\x90a\x1A,V[a\x12\xCFV[\0[a\x03\xB7a\x13\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x03\xD5a\x0E<V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x04+W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x04\"\x90a\x1C\xFEV[`@Q\x80\x91\x03\x90\xFD[_`\t_\x83\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\r\xB1f\xBBNG\xA6`\xAA\xFC2\xF7\x8B\xBA\xCD\xDA\x0B\x90\xB0s^E\xB2\x13J\xEE\xC3\xA5\xEAVU\xAB\x81`@Qa\x04\x82\x91\x90a\x1D\x1CV[`@Q\x80\x91\x03\x90\xA1PV[a\x04\x95a\x13\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x04\xB3a\x0E<V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x05\tW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05\0\x90a\x1C\xFEV[`@Q\x80\x91\x03\x90\xFD[`\x01`\x05\x80T\x90P\x11a\x05QW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05H\x90a\x1D\x7FV[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x05\x80T\x90P\x81\x10\x15a\x06.Wa\x05\x8C\x82`\x05\x83\x81T\x81\x10a\x05{Wa\x05za\x1D\x9DV[[\x90_R` _ \x90`\x02\x02\x01a\x13\xCCV[\x15a\x06!W`\x05_a\x05\x9E\x91\x90a\x17\xF1V[`\x05\x82\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x02\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a\x05\xD3\x91\x90a\x1E\xBFV[PP_`\n\x81\x90UPa\x05\xE4a\t5V[\x7F\x11N\x9Cy\x8E<m\x15\x8B]\x1D\xD7\x11\xCE\x1E\"x_=\x94\x89\x8D\xDB\x1C\xE7\xF9\xBCu\x171u\xD3\x82`@Qa\x06\x13\x91\x90a\x1F/V[`@Q\x80\x91\x03\x90\xA1Pa\x06jV[\x80\x80`\x01\x01\x91PPa\x05VV[P`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06a\x90a\x1F\x92V[`@Q\x80\x91\x03\x90\xFD[PV[a\x06ua\x13\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x06\x93a\x0E<V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x06\xE9W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xE0\x90a\x1C\xFEV[`@Q\x80\x91\x03\x90\xFD[\x80`\x0B\x81\x90UPPV[`\x01\x80_\x01T\x90\x80`\x01\x01T\x90\x80`\x02\x01T\x90\x80`\x03\x01T\x90P\x84V[a\x07\x18a\x13\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x076a\x0E<V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x07\x8CW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x07\x83\x90a\x1C\xFEV[`@Q\x80\x91\x03\x90\xFD[`\x01`\t_\x83\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7FC\x88P&\xC5\x9E\xCB\xB8$\xD1\x02x_\xEE_\x95\x93\xE6\x95\xBB\x9A\x84\x90\x86M\x980\x95%$\xE5\xD5\x81`@Qa\x07\xE4\x91\x90a\x1D\x1CV[`@Q\x80\x91\x03\x90\xA1PV[`\x08` R\x80_R`@_ _\x91PT\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[`\x0BT\x81V[`\x01\x82\x82\x90P\x14a\x08&Wa\x08%a\x1F\xB0V[[`\x08_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\t*W`\x01`\x08_\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP`\x07\x83\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP[PPPV[`\x06T\x81V[_sB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\x90P`\x01`\x05\x80T\x90P\x11\x15a\t\x96W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\t\x8D\x90a MV[`@Q\x80\x91\x03\x90\xFD[`\nT\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xB8\x07w\xEA`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\t\xE2W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\x06\x91\x90a \x7FV[\x11a\nFW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\n=\x90a!\x1AV[`@Q\x80\x91\x03\x90\xFD[_`\x05\x80T\x90P\x11\x15a\x0BMW`\x05_\x81T\x81\x10a\ngWa\nfa\x1D\x9DV[[\x90_R` _ \x90`\x02\x02\x01_\x01T`\x01`\x03\x01\x81\x90UP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xDA\xEA\xB4\x12`\x05_\x81T\x81\x10a\n\xCFWa\n\xCEa\x1D\x9DV[[\x90_R` _ \x90`\x02\x02\x01_\x01T`\x05_\x81T\x81\x10a\n\xF2Wa\n\xF1a\x1D\x9DV[[\x90_R` _ \x90`\x02\x02\x01`\x01\x01T`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0B\x1F\x92\x91\x90a\x1C\x0CV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0B6W__\xFD[PZ\xF1\x15\x80\x15a\x0BHW=__>=_\xFD[PPPP[`\x01Ca\x0BZ\x91\x90a!eV[@`\x01\x80\x01\x81\x90UP\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\t\xBDZ``@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0B\xACW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0B\xD0\x91\x90a!\xACV[`\x01`\x02\x01\x81\x90UP`\x0BTBa\x0B\xE7\x91\x90a!\xD7V[`\n\x81\x90UPPV[`\x07\x81\x81T\x81\x10a\x0B\xFFW_\x80\xFD[\x90_R` _ \x01_\x91PT\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[a\x0C3a\x13\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x0CQa\x0E<V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x0C\xA7W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0C\x9E\x90a\x1C\xFEV[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x07\x80T\x90P\x81\x10\x15a\rUW_`\x08_`\x07\x84\x81T\x81\x10a\x0C\xD1Wa\x0C\xD0a\x1D\x9DV[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa\x0C\xACV[P`\x07_a\rc\x91\x90a\x18\x12V[\x7F\xEC\xA6.\0t\xA1:\x90\xD6\0\xF0\x03\xB7\xCB\x8D[\xD5\x01\0\0\x8D?9\x15\xF2UO?\x85R\xC5\xCC`@Q`@Q\x80\x91\x03\x90\xA1V[a\r\x99a\x13\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\r\xB7a\x0E<V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x0E\rW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0E\x04\x90a\x1C\xFEV[`@Q\x80\x91\x03\x90\xFD[a\x0E\x16_a\x13\xF1V[V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[___\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[`\t` R\x80_R`@_ _\x91PT\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[`\x05\x81\x81T\x81\x10a\x0E\x8FW_\x80\xFD[\x90_R` _ \x90`\x02\x02\x01_\x91P\x90P\x80_\x01T\x90\x80`\x01\x01T\x90P\x82V[`A\x83\x83\x90P\x14a\x0E\xF5W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0E\xEC\x90a\"TV[`@Q\x80\x91\x03\x90\xFD[_a\x0F\0`\x01a\x14\xB2V[\x85_\x015\x86` \x015`@Q` \x01a\x0F\x1B\x93\x92\x91\x90a\"\x92V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P`\x08_a\x0F\x94\x86\x86\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x81\x84\x01R`\x1F\x19`\x1F\x82\x01\x16\x90P\x80\x83\x01\x92PPPPPPPa\x0F\x86\x85a\x14\xF6V[a\x15)\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x10\x19W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x10\x10\x90a#\x18V[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x05\x80T\x90P\x81\x10\x15a\x10\xA1Wa\x10T\x86`\x05\x83\x81T\x81\x10a\x10CWa\x10Ba\x1D\x9DV[[\x90_R` _ \x90`\x02\x02\x01a\x13\xCCV[\x15a\x10\x94W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x10\x8B\x90a#\x80V[`@Q\x80\x91\x03\x90\xFD[\x80\x80`\x01\x01\x91PPa\x10\x1EV[P_`\x05\x80T\x90P\x03a\x10\xC3W`\x0BTBa\x10\xBC\x91\x90a!\xD7V[`\n\x81\x90UP[`\x05\x85\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x02\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a\x10\xF8\x91\x90a\x1E\xBFV[PP`\x02`\x05\x80T\x90P\x03a\x12\x03W`\x01`\x06_\x82\x82Ta\x11\x19\x91\x90a!\xD7V[\x92PP\x81\x90UP\x7F7\xE8\xAD\xD6\x94\xC5\x92mVN\x97\x11`\xF5\x97A\x03\xCB\xBB\xC7\xC9\x07G\xC4\xC6\xF8\x02\x03\x1D5g\xA7`\x06T`@Qa\x11Q\x91\x90a\x1A\x99V[`@Q\x80\x91\x03\x90\xA1_\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16G`@Qa\x11~\x90a#\xCBV[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a\x11\xB8W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x11\xBDV[``\x91P[PP\x90P\x80a\x12\x01W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x11\xF8\x90a$)V[`@Q\x80\x91\x03\x90\xFD[P[PPPPPV[`\nT\x81V[a\x12\x18a\x13\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x126a\x0E<V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x12\x8CW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x12\x83\x90a\x1C\xFEV[`@Q\x80\x91\x03\x90\xFD[\x80`\x01_\x01\x81\x90UP\x7F\xB7\xA1\x80\"\x84\x97\xED\x95\xC6\x89o\xC1\xB0\x81\xA0\x16\x99\x91\x16\xF9\x8A\xB9[R\x126Y\xEF\xEA%\x97d\x81`@Qa\x12\xC4\x91\x90a\x1D\x1CV[`@Q\x80\x91\x03\x90\xA1PV[a\x12\xD7a\x13\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x12\xF5a\x0E<V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x13KW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13B\x90a\x1C\xFEV[`@Q\x80\x91\x03\x90\xFD[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x13\xB9W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\xB0\x90a$\xB7V[`@Q\x80\x91\x03\x90\xFD[a\x13\xC2\x81a\x13\xF1V[PV[_3\x90P\x90V[_\x81_\x01T\x83_\x015\x14\x80\x15a\x13\xE9WP\x81`\x01\x01T\x83` \x015\x14[\x90P\x92\x91PPV[___\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81__a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPV[_\x81_\x01T\x82`\x01\x01T\x83`\x02\x01T\x84`\x03\x01T`@Q` \x01a\x14\xD9\x94\x93\x92\x91\x90a$\xD5V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x91\x90PV[_\x7F\x19Ethereum Signed Message:\n32\0\0\0\0_R\x81`\x1CR`<_ \x90P\x91\x90PV[____a\x157\x86\x86a\x15SV[\x92P\x92P\x92Pa\x15G\x82\x82a\x15\xA8V[\x82\x93PPPP\x92\x91PPV[___`A\x84Q\x03a\x15\x93W___` \x87\x01Q\x92P`@\x87\x01Q\x91P``\x87\x01Q_\x1A\x90Pa\x15\x85\x88\x82\x85\x85a\x17\nV[\x95P\x95P\x95PPPPa\x15\xA1V[_`\x02\x85Q_\x1B\x92P\x92P\x92P[\x92P\x92P\x92V[_`\x03\x81\x11\x15a\x15\xBBWa\x15\xBAa%\"V[[\x82`\x03\x81\x11\x15a\x15\xCEWa\x15\xCDa%\"V[[\x03\x15a\x17\x06W`\x01`\x03\x81\x11\x15a\x15\xE8Wa\x15\xE7a%\"V[[\x82`\x03\x81\x11\x15a\x15\xFBWa\x15\xFAa%\"V[[\x03a\x162W`@Q\x7F\xF6E\xEE\xDF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`\x03\x81\x11\x15a\x16FWa\x16Ea%\"V[[\x82`\x03\x81\x11\x15a\x16YWa\x16Xa%\"V[[\x03a\x16\x9DW\x80_\x1C`@Q\x7F\xFC\xE6\x98\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x16\x94\x91\x90a\x1A\x99V[`@Q\x80\x91\x03\x90\xFD[`\x03\x80\x81\x11\x15a\x16\xB0Wa\x16\xAFa%\"V[[\x82`\x03\x81\x11\x15a\x16\xC3Wa\x16\xC2a%\"V[[\x03a\x17\x05W\x80`@Q\x7F\xD7\x8B\xCE\x0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x16\xFC\x91\x90a\x1D\x1CV[`@Q\x80\x91\x03\x90\xFD[[PPV[___\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0\x84_\x1C\x11\x15a\x17FW_`\x03\x85\x92P\x92P\x92Pa\x17\xE7V[_`\x01\x88\x88\x88\x88`@Q_\x81R` \x01`@R`@Qa\x17i\x94\x93\x92\x91\x90a%jV[` `@Q` \x81\x03\x90\x80\x84\x03\x90\x85Z\xFA\x15\x80\x15a\x17\x89W=__>=_\xFD[PPP` `@Q\x03Q\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x17\xDAW_`\x01__\x1B\x93P\x93P\x93PPa\x17\xE7V[\x80___\x1B\x93P\x93P\x93PP[\x94P\x94P\x94\x91PPV[P\x80T_\x82U`\x02\x02\x90_R` _ \x90\x81\x01\x90a\x18\x0F\x91\x90a\x180V[PV[P\x80T_\x82U\x90_R` _ \x90\x81\x01\x90a\x18-\x91\x90a\x18TV[PV[[\x80\x82\x11\x15a\x18PW__\x82\x01_\x90U`\x01\x82\x01_\x90UP`\x02\x01a\x181V[P\x90V[[\x80\x82\x11\x15a\x18kW_\x81_\x90UP`\x01\x01a\x18UV[P\x90V[__\xFD[__\xFD[_\x81\x90P\x91\x90PV[a\x18\x89\x81a\x18wV[\x81\x14a\x18\x93W__\xFD[PV[_\x815\x90Pa\x18\xA4\x81a\x18\x80V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x18\xBFWa\x18\xBEa\x18oV[[_a\x18\xCC\x84\x82\x85\x01a\x18\x96V[\x91PP\x92\x91PPV[__\xFD[_`@\x82\x84\x03\x12\x15a\x18\xEEWa\x18\xEDa\x18\xD5V[[\x81\x90P\x92\x91PPV[_`@\x82\x84\x03\x12\x15a\x19\x0CWa\x19\x0Ba\x18oV[[_a\x19\x19\x84\x82\x85\x01a\x18\xD9V[\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[a\x194\x81a\x19\"V[\x81\x14a\x19>W__\xFD[PV[_\x815\x90Pa\x19O\x81a\x19+V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x19jWa\x19ia\x18oV[[_a\x19w\x84\x82\x85\x01a\x19AV[\x91PP\x92\x91PPV[a\x19\x89\x81a\x18wV[\x82RPPV[_`\x80\x82\x01\x90Pa\x19\xA2_\x83\x01\x87a\x19\x80V[a\x19\xAF` \x83\x01\x86a\x19\x80V[a\x19\xBC`@\x83\x01\x85a\x19\x80V[a\x19\xC9``\x83\x01\x84a\x19\x80V[\x95\x94PPPPPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a\x19\xFB\x82a\x19\xD2V[\x90P\x91\x90PV[a\x1A\x0B\x81a\x19\xF1V[\x81\x14a\x1A\x15W__\xFD[PV[_\x815\x90Pa\x1A&\x81a\x1A\x02V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x1AAWa\x1A@a\x18oV[[_a\x1AN\x84\x82\x85\x01a\x1A\x18V[\x91PP\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[a\x1Ak\x81a\x1AWV[\x82RPPV[_` \x82\x01\x90Pa\x1A\x84_\x83\x01\x84a\x1AbV[\x92\x91PPV[a\x1A\x93\x81a\x19\"V[\x82RPPV[_` \x82\x01\x90Pa\x1A\xAC_\x83\x01\x84a\x1A\x8AV[\x92\x91PPV[__\xFD[__\xFD[__\xFD[__\x83`\x1F\x84\x01\x12a\x1A\xD3Wa\x1A\xD2a\x1A\xB2V[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1A\xF0Wa\x1A\xEFa\x1A\xB6V[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15a\x1B\x0CWa\x1B\x0Ba\x1A\xBAV[[\x92P\x92\x90PV[___`@\x84\x86\x03\x12\x15a\x1B*Wa\x1B)a\x18oV[[_a\x1B7\x86\x82\x87\x01a\x1A\x18V[\x93PP` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1BXWa\x1BWa\x18sV[[a\x1Bd\x86\x82\x87\x01a\x1A\xBEV[\x92P\x92PP\x92P\x92P\x92V[a\x1By\x81a\x19\xF1V[\x82RPPV[_` \x82\x01\x90Pa\x1B\x92_\x83\x01\x84a\x1BpV[\x92\x91PPV[_\x81\x90P\x91\x90PV[_a\x1B\xBBa\x1B\xB6a\x1B\xB1\x84a\x19\xD2V[a\x1B\x98V[a\x19\xD2V[\x90P\x91\x90PV[_a\x1B\xCC\x82a\x1B\xA1V[\x90P\x91\x90PV[_a\x1B\xDD\x82a\x1B\xC2V[\x90P\x91\x90PV[a\x1B\xED\x81a\x1B\xD3V[\x82RPPV[_` \x82\x01\x90Pa\x1C\x06_\x83\x01\x84a\x1B\xE4V[\x92\x91PPV[_`@\x82\x01\x90Pa\x1C\x1F_\x83\x01\x85a\x19\x80V[a\x1C,` \x83\x01\x84a\x19\x80V[\x93\x92PPPV[____`\x80\x85\x87\x03\x12\x15a\x1CKWa\x1CJa\x18oV[[_a\x1CX\x87\x82\x88\x01a\x18\xD9V[\x94PP`@\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1CyWa\x1Cxa\x18sV[[a\x1C\x85\x87\x82\x88\x01a\x1A\xBEV[\x93P\x93PP``a\x1C\x98\x87\x82\x88\x01a\x1A\x18V[\x91PP\x92\x95\x91\x94P\x92PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7FOwnable: caller is not the owner_\x82\x01RPV[_a\x1C\xE8` \x83a\x1C\xA4V[\x91Pa\x1C\xF3\x82a\x1C\xB4V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x1D\x15\x81a\x1C\xDCV[\x90P\x91\x90PV[_` \x82\x01\x90Pa\x1D/_\x83\x01\x84a\x19\x80V[\x92\x91PPV[\x7Fchallenge does not exist\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x1Di`\x18\x83a\x1C\xA4V[\x91Pa\x1Dt\x82a\x1D5V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x1D\x96\x81a\x1D]V[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[_\x815a\x1D\xD6\x81a\x18\x80V[\x80\x91PP\x91\x90PV[_\x81_\x1B\x90P\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x1E\x15\x84a\x1D\xDFV[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_a\x1E5\x82a\x18wV[\x90P\x91\x90PV[_\x81_\x1C\x90P\x91\x90PV[_a\x1EQ\x82a\x1E<V[\x90P\x91\x90PV[a\x1Ea\x82a\x1E+V[a\x1Eta\x1Em\x82a\x1EGV[\x83Ta\x1D\xEAV[\x82UPPPV[_\x81\x01_\x83\x01\x80a\x1E\x8B\x81a\x1D\xCAV[\x90Pa\x1E\x97\x81\x84a\x1EXV[PPP`\x01\x81\x01` \x83\x01\x80a\x1E\xAC\x81a\x1D\xCAV[\x90Pa\x1E\xB8\x81\x84a\x1EXV[PPPPPV[a\x1E\xC9\x82\x82a\x1E{V[PPV[_a\x1E\xDB` \x84\x01\x84a\x18\x96V[\x90P\x92\x91PPV[a\x1E\xEC\x81a\x18wV[\x82RPPV[`@\x82\x01a\x1F\x02_\x83\x01\x83a\x1E\xCDV[a\x1F\x0E_\x85\x01\x82a\x1E\xE3V[Pa\x1F\x1C` \x83\x01\x83a\x1E\xCDV[a\x1F)` \x85\x01\x82a\x1E\xE3V[PPPPV[_`@\x82\x01\x90Pa\x1FB_\x83\x01\x84a\x1E\xF2V[\x92\x91PPV[\x7Fassertion not found\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x1F|`\x13\x83a\x1C\xA4V[\x91Pa\x1F\x87\x82a\x1FHV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x1F\xA9\x81a\x1FpV[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x01`\x04R`$_\xFD[\x7Fcannot close challenge window - _\x82\x01R\x7Ftoo many assertions\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a 7`3\x83a\x1C\xA4V[\x91Pa B\x82a\x1F\xDDV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra d\x81a +V[\x90P\x91\x90PV[_\x81Q\x90Pa y\x81a\x19+V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a \x94Wa \x93a\x18oV[[_a \xA1\x84\x82\x85\x01a kV[\x91PP\x92\x91PPV[\x7Fcannot close challenge window - _\x82\x01R\x7Finsufficient time has passed\0\0\0\0` \x82\x01RPV[_a!\x04`<\x83a\x1C\xA4V[\x91Pa!\x0F\x82a \xAAV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra!1\x81a \xF8V[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a!o\x82a\x19\"V[\x91Pa!z\x83a\x19\"V[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15a!\x92Wa!\x91a!8V[[\x92\x91PPV[_\x81Q\x90Pa!\xA6\x81a\x18\x80V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a!\xC1Wa!\xC0a\x18oV[[_a!\xCE\x84\x82\x85\x01a!\x98V[\x91PP\x92\x91PPV[_a!\xE1\x82a\x19\"V[\x91Pa!\xEC\x83a\x19\"V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a\"\x04Wa\"\x03a!8V[[\x92\x91PPV[\x7Finvalid signature length\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\">`\x18\x83a\x1C\xA4V[\x91Pa\"I\x82a\"\nV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\"k\x81a\"2V[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a\"\x8Ca\"\x87\x82a\x18wV[a\"rV[\x82RPPV[_a\"\x9D\x82\x86a\"{V[` \x82\x01\x91Pa\"\xAD\x82\x85a\"{V[` \x82\x01\x91Pa\"\xBD\x82\x84a\"{V[` \x82\x01\x91P\x81\x90P\x94\x93PPPPV[\x7Finvalid tee signature\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a#\x02`\x15\x83a\x1C\xA4V[\x91Pa#\r\x82a\"\xCEV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra#/\x81a\"\xF6V[\x90P\x91\x90PV[\x7Fassertion already exists\0\0\0\0\0\0\0\0_\x82\x01RPV[_a#j`\x18\x83a\x1C\xA4V[\x91Pa#u\x82a#6V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra#\x97\x81a#^V[\x90P\x91\x90PV[_\x81\x90P\x92\x91PPV[PV[_a#\xB6_\x83a#\x9EV[\x91Pa#\xC1\x82a#\xA8V[_\x82\x01\x90P\x91\x90PV[_a#\xD5\x82a#\xABV[\x91P\x81\x90P\x91\x90PV[\x7Fpayment failed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a$\x13`\x0E\x83a\x1C\xA4V[\x91Pa$\x1E\x82a#\xDFV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra$@\x81a$\x07V[\x90P\x91\x90PV[\x7FOwnable: new owner is the zero a_\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a$\xA1`&\x83a\x1C\xA4V[\x91Pa$\xAC\x82a$GV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra$\xCE\x81a$\x95V[\x90P\x91\x90PV[_a$\xE0\x82\x87a\"{V[` \x82\x01\x91Pa$\xF0\x82\x86a\"{V[` \x82\x01\x91Pa%\0\x82\x85a\"{V[` \x82\x01\x91Pa%\x10\x82\x84a\"{V[` \x82\x01\x91P\x81\x90P\x95\x94PPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[_`\xFF\x82\x16\x90P\x91\x90PV[a%d\x81a%OV[\x82RPPV[_`\x80\x82\x01\x90Pa%}_\x83\x01\x87a\x19\x80V[a%\x8A` \x83\x01\x86a%[V[a%\x97`@\x83\x01\x85a\x19\x80V[a%\xA4``\x83\x01\x84a\x19\x80V[\x95\x94PPPPPV",
    );
    /**```solidity
struct PendingAssertion { bytes32 blockHash; bytes32 sendRoot; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PendingAssertion {
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sendRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PendingAssertion> for UnderlyingRustTuple<'_> {
            fn from(value: PendingAssertion) -> Self {
                (value.blockHash, value.sendRoot)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PendingAssertion {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    blockHash: tuple.0,
                    sendRoot: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for PendingAssertion {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for PendingAssertion {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.sendRoot),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for PendingAssertion {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for PendingAssertion {
            const NAME: &'static str = "PendingAssertion";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "PendingAssertion(bytes32 blockHash,bytes32 sendRoot)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.blockHash)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.sendRoot)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for PendingAssertion {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.blockHash,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sendRoot,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.blockHash,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sendRoot,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignature()` and selector `0xf645eedf`.
```solidity
error ECDSAInvalidSignature();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignature {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignature()";
            const SELECTOR: [u8; 4] = [246u8, 69u8, 238u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureLength(uint256)` and selector `0xfce698f7`.
```solidity
error ECDSAInvalidSignatureLength(uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureLength {
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureLength) -> Self {
                (value.length,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ECDSAInvalidSignatureLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { length: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureLength(uint256)";
            const SELECTOR: [u8; 4] = [252u8, 230u8, 152u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureS(bytes32)` and selector `0xd78bce0c`.
```solidity
error ECDSAInvalidSignatureS(bytes32 s);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureS {
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureS> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureS) -> Self {
                (value.s,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignatureS {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { s: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureS {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureS(bytes32)";
            const SELECTOR: [u8; 4] = [215u8, 139u8, 206u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
        }
    };
    /**Event with signature `ChallengeResolved((bytes32,bytes32))` and selector `0x114e9c798e3c6d158b5d1dd711ce1e22785f3d94898ddb1ce7f9bc75173175d3`.
```solidity
event ChallengeResolved(PendingAssertion);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ChallengeResolved {
        #[allow(missing_docs)]
        pub _0: <PendingAssertion as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ChallengeResolved {
            type DataTuple<'a> = (PendingAssertion,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ChallengeResolved((bytes32,bytes32))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                17u8,
                78u8,
                156u8,
                121u8,
                142u8,
                60u8,
                109u8,
                21u8,
                139u8,
                93u8,
                29u8,
                215u8,
                17u8,
                206u8,
                30u8,
                34u8,
                120u8,
                95u8,
                61u8,
                148u8,
                137u8,
                141u8,
                219u8,
                28u8,
                231u8,
                249u8,
                188u8,
                117u8,
                23u8,
                49u8,
                117u8,
                211u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { _0: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (<PendingAssertion as alloy_sol_types::SolType>::tokenize(&self._0),)
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ChallengeResolved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ChallengeResolved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ChallengeResolved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeAppchainConfigHash(bytes32)` and selector `0xb7a180228497ed95c6896fc1b081a016999116f98ab95b52123659efea259764`.
```solidity
event TeeAppchainConfigHash(bytes32 hash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeAppchainConfigHash {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeAppchainConfigHash {
            type DataTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeAppchainConfigHash(bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                183u8,
                161u8,
                128u8,
                34u8,
                132u8,
                151u8,
                237u8,
                149u8,
                198u8,
                137u8,
                111u8,
                193u8,
                176u8,
                129u8,
                160u8,
                22u8,
                153u8,
                145u8,
                22u8,
                249u8,
                138u8,
                185u8,
                91u8,
                82u8,
                18u8,
                54u8,
                89u8,
                239u8,
                234u8,
                37u8,
                151u8,
                100u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { hash: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeAppchainConfigHash {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeAppchainConfigHash> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeAppchainConfigHash) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeHacked(uint256)` and selector `0x37e8add694c5926d564e971160f5974103cbbbc7c90747c4c6f802031d3567a7`.
```solidity
event TeeHacked(uint256);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeHacked {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeHacked {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeHacked(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                55u8,
                232u8,
                173u8,
                214u8,
                148u8,
                197u8,
                146u8,
                109u8,
                86u8,
                78u8,
                151u8,
                17u8,
                96u8,
                245u8,
                151u8,
                65u8,
                3u8,
                203u8,
                187u8,
                199u8,
                201u8,
                7u8,
                71u8,
                196u8,
                198u8,
                248u8,
                2u8,
                3u8,
                29u8,
                53u8,
                103u8,
                167u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { _0: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeHacked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeHacked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeHacked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeKeysRevoked()` and selector `0xeca62e0074a13a90d600f003b7cb8d5bd50100008d3f3915f2554f3f8552c5cc`.
```solidity
event TeeKeysRevoked();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeKeysRevoked {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeKeysRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeKeysRevoked()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                236u8,
                166u8,
                46u8,
                0u8,
                116u8,
                161u8,
                58u8,
                144u8,
                214u8,
                0u8,
                240u8,
                3u8,
                183u8,
                203u8,
                141u8,
                91u8,
                213u8,
                1u8,
                0u8,
                0u8,
                141u8,
                63u8,
                57u8,
                21u8,
                242u8,
                85u8,
                79u8,
                63u8,
                133u8,
                82u8,
                197u8,
                204u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeKeysRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeKeysRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeKeysRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeProgramHashAdded(bytes32)` and selector `0x43885026c59ecbb824d102785fee5f9593e695bb9a8490864d9830952524e5d5`.
```solidity
event TeeProgramHashAdded(bytes32 hash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeProgramHashAdded {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeProgramHashAdded {
            type DataTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeProgramHashAdded(bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                67u8,
                136u8,
                80u8,
                38u8,
                197u8,
                158u8,
                203u8,
                184u8,
                36u8,
                209u8,
                2u8,
                120u8,
                95u8,
                238u8,
                95u8,
                149u8,
                147u8,
                230u8,
                149u8,
                187u8,
                154u8,
                132u8,
                144u8,
                134u8,
                77u8,
                152u8,
                48u8,
                149u8,
                37u8,
                36u8,
                229u8,
                213u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { hash: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeProgramHashAdded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeProgramHashAdded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeProgramHashAdded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeProgramHashRemoved(bytes32)` and selector `0x0db166bb4e47a660aafc32f78bbacdda0b90b0735e45b2134aeec3a5ea5655ab`.
```solidity
event TeeProgramHashRemoved(bytes32 hash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeProgramHashRemoved {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeProgramHashRemoved {
            type DataTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeProgramHashRemoved(bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                13u8,
                177u8,
                102u8,
                187u8,
                78u8,
                71u8,
                166u8,
                96u8,
                170u8,
                252u8,
                50u8,
                247u8,
                139u8,
                186u8,
                205u8,
                218u8,
                11u8,
                144u8,
                176u8,
                115u8,
                94u8,
                69u8,
                178u8,
                19u8,
                74u8,
                238u8,
                195u8,
                165u8,
                234u8,
                86u8,
                85u8,
                171u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { hash: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeProgramHashRemoved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeProgramHashRemoved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeProgramHashRemoved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address poster_, bytes32 appchainConfigHash_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub poster_: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value.poster_, value.appchainConfigHash_)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        poster_: tuple.0,
                        appchainConfigHash_: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.poster_,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainConfigHash_),
                )
            }
        }
    };
    /**Function with signature `addTeeKey(address,bytes)` and selector `0x5d4bedc3`.
```solidity
function addTeeKey(address publicKey, bytes memory zkProof) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addTeeKeyCall {
        #[allow(missing_docs)]
        pub publicKey: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub zkProof: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`addTeeKey(address,bytes)`](addTeeKeyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addTeeKeyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addTeeKeyCall> for UnderlyingRustTuple<'_> {
                fn from(value: addTeeKeyCall) -> Self {
                    (value.publicKey, value.zkProof)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addTeeKeyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        publicKey: tuple.0,
                        zkProof: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addTeeKeyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addTeeKeyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addTeeKeyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addTeeKeyCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addTeeKeyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addTeeKey(address,bytes)";
            const SELECTOR: [u8; 4] = [93u8, 75u8, 237u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.publicKey,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.zkProof,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `addTeeProgramHash(bytes32)` and selector `0x43de5f33`.
```solidity
function addTeeProgramHash(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addTeeProgramHashCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`addTeeProgramHash(bytes32)`](addTeeProgramHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addTeeProgramHashReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addTeeProgramHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: addTeeProgramHashCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for addTeeProgramHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addTeeProgramHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: addTeeProgramHashReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for addTeeProgramHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addTeeProgramHashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addTeeProgramHashReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addTeeProgramHash(bytes32)";
            const SELECTOR: [u8; 4] = [67u8, 222u8, 95u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `challengeWindowDuration()` and selector `0x4bd167c9`.
```solidity
function challengeWindowDuration() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowDurationCall {}
    ///Container type for the return parameters of the [`challengeWindowDuration()`](challengeWindowDurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowDurationReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowDurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowDurationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowDurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowDurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowDurationReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowDurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for challengeWindowDurationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = challengeWindowDurationReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "challengeWindowDuration()";
            const SELECTOR: [u8; 4] = [75u8, 209u8, 103u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `challengeWindowEnd()` and selector `0xee1c28b8`.
```solidity
function challengeWindowEnd() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowEndCall {}
    ///Container type for the return parameters of the [`challengeWindowEnd()`](challengeWindowEndCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowEndReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowEndCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowEndCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowEndCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowEndReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowEndReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowEndReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for challengeWindowEndCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = challengeWindowEndReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "challengeWindowEnd()";
            const SELECTOR: [u8; 4] = [238u8, 28u8, 40u8, 184u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `closeChallengeWindow()` and selector `0x6c4c2060`.
```solidity
function closeChallengeWindow() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct closeChallengeWindowCall {}
    ///Container type for the return parameters of the [`closeChallengeWindow()`](closeChallengeWindowCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct closeChallengeWindowReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<closeChallengeWindowCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: closeChallengeWindowCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for closeChallengeWindowCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<closeChallengeWindowReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: closeChallengeWindowReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for closeChallengeWindowReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for closeChallengeWindowCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = closeChallengeWindowReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "closeChallengeWindow()";
            const SELECTOR: [u8; 4] = [108u8, 76u8, 32u8, 96u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isTeeKey(address)` and selector `0x47742640`.
```solidity
function isTeeKey(address) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isTeeKeyCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isTeeKey(address)`](isTeeKeyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isTeeKeyReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isTeeKeyCall> for UnderlyingRustTuple<'_> {
                fn from(value: isTeeKeyCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isTeeKeyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isTeeKeyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isTeeKeyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isTeeKeyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isTeeKeyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isTeeKeyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isTeeKey(address)";
            const SELECTOR: [u8; 4] = [71u8, 116u8, 38u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isTeeProgramHash(bytes32)` and selector `0xa380ef87`.
```solidity
function isTeeProgramHash(bytes32) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isTeeProgramHashCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`isTeeProgramHash(bytes32)`](isTeeProgramHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isTeeProgramHashReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isTeeProgramHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isTeeProgramHashCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isTeeProgramHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isTeeProgramHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isTeeProgramHashReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isTeeProgramHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isTeeProgramHashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isTeeProgramHashReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isTeeProgramHash(bytes32)";
            const SELECTOR: [u8; 4] = [163u8, 128u8, 239u8, 135u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall {}
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pendingAssertions(uint256)` and selector `0xa56ec6cd`.
```solidity
function pendingAssertions(uint256) external view returns (bytes32 blockHash, bytes32 sendRoot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingAssertionsCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`pendingAssertions(uint256)`](pendingAssertionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingAssertionsReturn {
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sendRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingAssertionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: pendingAssertionsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pendingAssertionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingAssertionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: pendingAssertionsReturn) -> Self {
                    (value.blockHash, value.sendRoot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pendingAssertionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blockHash: tuple.0,
                        sendRoot: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pendingAssertionsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pendingAssertionsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pendingAssertions(uint256)";
            const SELECTOR: [u8; 4] = [165u8, 110u8, 198u8, 205u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `poster()` and selector `0x80959721`.
```solidity
function poster() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct posterCall {}
    ///Container type for the return parameters of the [`poster()`](posterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct posterReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<posterCall> for UnderlyingRustTuple<'_> {
                fn from(value: posterCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for posterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<posterReturn> for UnderlyingRustTuple<'_> {
                fn from(value: posterReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for posterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for posterCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = posterReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "poster()";
            const SELECTOR: [u8; 4] = [128u8, 149u8, 151u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeTeeProgramHash(bytes32)` and selector `0x0ad195ab`.
```solidity
function removeTeeProgramHash(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeTeeProgramHashCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`removeTeeProgramHash(bytes32)`](removeTeeProgramHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeTeeProgramHashReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeTeeProgramHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeTeeProgramHashCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeTeeProgramHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeTeeProgramHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeTeeProgramHashReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeTeeProgramHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeTeeProgramHashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeTeeProgramHashReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeTeeProgramHash(bytes32)";
            const SELECTOR: [u8; 4] = [10u8, 209u8, 149u8, 171u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall {}
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `resolveChallenge((bytes32,bytes32))` and selector `0x0b7c0241`.
```solidity
function resolveChallenge(PendingAssertion memory assertion) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolveChallengeCall {
        #[allow(missing_docs)]
        pub assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`resolveChallenge((bytes32,bytes32))`](resolveChallengeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolveChallengeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (PendingAssertion,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PendingAssertion as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolveChallengeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: resolveChallengeCall) -> Self {
                    (value.assertion,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resolveChallengeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { assertion: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolveChallengeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: resolveChallengeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resolveChallengeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for resolveChallengeCall {
            type Parameters<'a> = (PendingAssertion,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = resolveChallengeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "resolveChallenge((bytes32,bytes32))";
            const SELECTOR: [u8; 4] = [11u8, 124u8, 2u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PendingAssertion as alloy_sol_types::SolType>::tokenize(
                        &self.assertion,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeAllTeeKeys()` and selector `0x6ef01201`.
```solidity
function revokeAllTeeKeys() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeAllTeeKeysCall {}
    ///Container type for the return parameters of the [`revokeAllTeeKeys()`](revokeAllTeeKeysCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeAllTeeKeysReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeAllTeeKeysCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: revokeAllTeeKeysCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for revokeAllTeeKeysCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeAllTeeKeysReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: revokeAllTeeKeysReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for revokeAllTeeKeysReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeAllTeeKeysCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeAllTeeKeysReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeAllTeeKeys()";
            const SELECTOR: [u8; 4] = [110u8, 240u8, 18u8, 1u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setAppchainConfigHash(bytes32)` and selector `0xf223055c`.
```solidity
function setAppchainConfigHash(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAppchainConfigHashCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`setAppchainConfigHash(bytes32)`](setAppchainConfigHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAppchainConfigHashReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAppchainConfigHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAppchainConfigHashCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAppchainConfigHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAppchainConfigHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAppchainConfigHashReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAppchainConfigHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setAppchainConfigHashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setAppchainConfigHashReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setAppchainConfigHash(bytes32)";
            const SELECTOR: [u8; 4] = [242u8, 35u8, 5u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setChallengeWindowDuration(uint256)` and selector `0x1caf5d13`.
```solidity
function setChallengeWindowDuration(uint256 duration) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setChallengeWindowDurationCall {
        #[allow(missing_docs)]
        pub duration: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setChallengeWindowDuration(uint256)`](setChallengeWindowDurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setChallengeWindowDurationReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setChallengeWindowDurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setChallengeWindowDurationCall) -> Self {
                    (value.duration,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setChallengeWindowDurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { duration: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setChallengeWindowDurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setChallengeWindowDurationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setChallengeWindowDurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setChallengeWindowDurationCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setChallengeWindowDurationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setChallengeWindowDuration(uint256)";
            const SELECTOR: [u8; 4] = [28u8, 175u8, 93u8, 19u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.duration),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `submitAssertion((bytes32,bytes32),bytes,address)` and selector `0xb2670034`.
```solidity
function submitAssertion(PendingAssertion memory assertion, bytes memory signature, address rewardAddr) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitAssertionCall {
        #[allow(missing_docs)]
        pub assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub signature: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub rewardAddr: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`submitAssertion((bytes32,bytes32),bytes,address)`](submitAssertionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitAssertionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                PendingAssertion,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PendingAssertion as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitAssertionCall> for UnderlyingRustTuple<'_> {
                fn from(value: submitAssertionCall) -> Self {
                    (value.assertion, value.signature, value.rewardAddr)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for submitAssertionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        assertion: tuple.0,
                        signature: tuple.1,
                        rewardAddr: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitAssertionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: submitAssertionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for submitAssertionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for submitAssertionCall {
            type Parameters<'a> = (
                PendingAssertion,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = submitAssertionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "submitAssertion((bytes32,bytes32),bytes,address)";
            const SELECTOR: [u8; 4] = [178u8, 103u8, 0u8, 52u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PendingAssertion as alloy_sol_types::SolType>::tokenize(
                        &self.assertion,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.signature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rewardAddr,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teeHackCount()` and selector `0x697b5e62`.
```solidity
function teeHackCount() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeHackCountCall {}
    ///Container type for the return parameters of the [`teeHackCount()`](teeHackCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeHackCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeHackCountCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeHackCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeHackCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeHackCountReturn> for UnderlyingRustTuple<'_> {
                fn from(value: teeHackCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeHackCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeHackCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeHackCountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teeHackCount()";
            const SELECTOR: [u8; 4] = [105u8, 123u8, 94u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teeKeys(uint256)` and selector `0x6ebed0f0`.
```solidity
function teeKeys(uint256) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeKeysCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`teeKeys(uint256)`](teeKeysCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeKeysReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeKeysCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeKeysCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeKeysCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeKeysReturn> for UnderlyingRustTuple<'_> {
                fn from(value: teeKeysReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeKeysReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeKeysCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeKeysReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teeKeys(uint256)";
            const SELECTOR: [u8; 4] = [110u8, 190u8, 208u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teeTrustedInput()` and selector `0x3ceaae7d`.
```solidity
function teeTrustedInput() external view returns (bytes32 appchainConfigHash, bytes32 setEndBlockHash, bytes32 l1EndBlockHash, bytes32 appchainStartBlockHash);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeTrustedInputCall {}
    ///Container type for the return parameters of the [`teeTrustedInput()`](teeTrustedInputCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeTrustedInputReturn {
        #[allow(missing_docs)]
        pub appchainConfigHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub setEndBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1EndBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub appchainStartBlockHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeTrustedInputCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeTrustedInputCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeTrustedInputCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeTrustedInputReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: teeTrustedInputReturn) -> Self {
                    (
                        value.appchainConfigHash,
                        value.setEndBlockHash,
                        value.l1EndBlockHash,
                        value.appchainStartBlockHash,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for teeTrustedInputReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        appchainConfigHash: tuple.0,
                        setEndBlockHash: tuple.1,
                        l1EndBlockHash: tuple.2,
                        appchainStartBlockHash: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeTrustedInputCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeTrustedInputReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teeTrustedInput()";
            const SELECTOR: [u8; 4] = [60u8, 234u8, 174u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`TeeModule`](self) function calls.
    pub enum TeeModuleCalls {
        #[allow(missing_docs)]
        addTeeKey(addTeeKeyCall),
        #[allow(missing_docs)]
        addTeeProgramHash(addTeeProgramHashCall),
        #[allow(missing_docs)]
        challengeWindowDuration(challengeWindowDurationCall),
        #[allow(missing_docs)]
        challengeWindowEnd(challengeWindowEndCall),
        #[allow(missing_docs)]
        closeChallengeWindow(closeChallengeWindowCall),
        #[allow(missing_docs)]
        isTeeKey(isTeeKeyCall),
        #[allow(missing_docs)]
        isTeeProgramHash(isTeeProgramHashCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        pendingAssertions(pendingAssertionsCall),
        #[allow(missing_docs)]
        poster(posterCall),
        #[allow(missing_docs)]
        removeTeeProgramHash(removeTeeProgramHashCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        resolveChallenge(resolveChallengeCall),
        #[allow(missing_docs)]
        revokeAllTeeKeys(revokeAllTeeKeysCall),
        #[allow(missing_docs)]
        setAppchainConfigHash(setAppchainConfigHashCall),
        #[allow(missing_docs)]
        setChallengeWindowDuration(setChallengeWindowDurationCall),
        #[allow(missing_docs)]
        submitAssertion(submitAssertionCall),
        #[allow(missing_docs)]
        teeHackCount(teeHackCountCall),
        #[allow(missing_docs)]
        teeKeys(teeKeysCall),
        #[allow(missing_docs)]
        teeTrustedInput(teeTrustedInputCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
    }
    #[automatically_derived]
    impl TeeModuleCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [10u8, 209u8, 149u8, 171u8],
            [11u8, 124u8, 2u8, 65u8],
            [28u8, 175u8, 93u8, 19u8],
            [60u8, 234u8, 174u8, 125u8],
            [67u8, 222u8, 95u8, 51u8],
            [71u8, 116u8, 38u8, 64u8],
            [75u8, 209u8, 103u8, 201u8],
            [93u8, 75u8, 237u8, 195u8],
            [105u8, 123u8, 94u8, 98u8],
            [108u8, 76u8, 32u8, 96u8],
            [110u8, 190u8, 208u8, 240u8],
            [110u8, 240u8, 18u8, 1u8],
            [113u8, 80u8, 24u8, 166u8],
            [128u8, 149u8, 151u8, 33u8],
            [141u8, 165u8, 203u8, 91u8],
            [163u8, 128u8, 239u8, 135u8],
            [165u8, 110u8, 198u8, 205u8],
            [178u8, 103u8, 0u8, 52u8],
            [238u8, 28u8, 40u8, 184u8],
            [242u8, 35u8, 5u8, 92u8],
            [242u8, 253u8, 227u8, 139u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for TeeModuleCalls {
        const NAME: &'static str = "TeeModuleCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 21usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::addTeeKey(_) => {
                    <addTeeKeyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addTeeProgramHash(_) => {
                    <addTeeProgramHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::challengeWindowDuration(_) => {
                    <challengeWindowDurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::challengeWindowEnd(_) => {
                    <challengeWindowEndCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::closeChallengeWindow(_) => {
                    <closeChallengeWindowCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isTeeKey(_) => <isTeeKeyCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isTeeProgramHash(_) => {
                    <isTeeProgramHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pendingAssertions(_) => {
                    <pendingAssertionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::poster(_) => <posterCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::removeTeeProgramHash(_) => {
                    <removeTeeProgramHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::resolveChallenge(_) => {
                    <resolveChallengeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeAllTeeKeys(_) => {
                    <revokeAllTeeKeysCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setAppchainConfigHash(_) => {
                    <setAppchainConfigHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setChallengeWindowDuration(_) => {
                    <setChallengeWindowDurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::submitAssertion(_) => {
                    <submitAssertionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::teeHackCount(_) => {
                    <teeHackCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::teeKeys(_) => <teeKeysCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::teeTrustedInput(_) => {
                    <teeTrustedInputCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<TeeModuleCalls>] = &[
                {
                    fn removeTeeProgramHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <removeTeeProgramHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::removeTeeProgramHash)
                    }
                    removeTeeProgramHash
                },
                {
                    fn resolveChallenge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <resolveChallengeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::resolveChallenge)
                    }
                    resolveChallenge
                },
                {
                    fn setChallengeWindowDuration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <setChallengeWindowDurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::setChallengeWindowDuration)
                    }
                    setChallengeWindowDuration
                },
                {
                    fn teeTrustedInput(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeTrustedInputCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teeTrustedInput)
                    }
                    teeTrustedInput
                },
                {
                    fn addTeeProgramHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <addTeeProgramHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::addTeeProgramHash)
                    }
                    addTeeProgramHash
                },
                {
                    fn isTeeKey(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <isTeeKeyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::isTeeKey)
                    }
                    isTeeKey
                },
                {
                    fn challengeWindowDuration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <challengeWindowDurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::challengeWindowDuration)
                    }
                    challengeWindowDuration
                },
                {
                    fn addTeeKey(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <addTeeKeyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::addTeeKey)
                    }
                    addTeeKey
                },
                {
                    fn teeHackCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeHackCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teeHackCount)
                    }
                    teeHackCount
                },
                {
                    fn closeChallengeWindow(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <closeChallengeWindowCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::closeChallengeWindow)
                    }
                    closeChallengeWindow
                },
                {
                    fn teeKeys(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeKeysCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teeKeys)
                    }
                    teeKeys
                },
                {
                    fn revokeAllTeeKeys(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <revokeAllTeeKeysCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::revokeAllTeeKeys)
                    }
                    revokeAllTeeKeys
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn poster(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <posterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::poster)
                    }
                    poster
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::owner)
                    }
                    owner
                },
                {
                    fn isTeeProgramHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <isTeeProgramHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::isTeeProgramHash)
                    }
                    isTeeProgramHash
                },
                {
                    fn pendingAssertions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <pendingAssertionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::pendingAssertions)
                    }
                    pendingAssertions
                },
                {
                    fn submitAssertion(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <submitAssertionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::submitAssertion)
                    }
                    submitAssertion
                },
                {
                    fn challengeWindowEnd(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <challengeWindowEndCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::challengeWindowEnd)
                    }
                    challengeWindowEnd
                },
                {
                    fn setAppchainConfigHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <setAppchainConfigHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::setAppchainConfigHash)
                    }
                    setAppchainConfigHash
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::transferOwnership)
                    }
                    transferOwnership
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::addTeeKey(inner) => {
                    <addTeeKeyCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::addTeeProgramHash(inner) => {
                    <addTeeProgramHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::challengeWindowDuration(inner) => {
                    <challengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::challengeWindowEnd(inner) => {
                    <challengeWindowEndCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::closeChallengeWindow(inner) => {
                    <closeChallengeWindowCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isTeeKey(inner) => {
                    <isTeeKeyCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isTeeProgramHash(inner) => {
                    <isTeeProgramHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pendingAssertions(inner) => {
                    <pendingAssertionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::poster(inner) => {
                    <posterCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::removeTeeProgramHash(inner) => {
                    <removeTeeProgramHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::resolveChallenge(inner) => {
                    <resolveChallengeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeAllTeeKeys(inner) => {
                    <revokeAllTeeKeysCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setAppchainConfigHash(inner) => {
                    <setAppchainConfigHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setChallengeWindowDuration(inner) => {
                    <setChallengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::submitAssertion(inner) => {
                    <submitAssertionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::teeHackCount(inner) => {
                    <teeHackCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::teeKeys(inner) => {
                    <teeKeysCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::teeTrustedInput(inner) => {
                    <teeTrustedInputCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::addTeeKey(inner) => {
                    <addTeeKeyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addTeeProgramHash(inner) => {
                    <addTeeProgramHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::challengeWindowDuration(inner) => {
                    <challengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::challengeWindowEnd(inner) => {
                    <challengeWindowEndCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::closeChallengeWindow(inner) => {
                    <closeChallengeWindowCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isTeeKey(inner) => {
                    <isTeeKeyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isTeeProgramHash(inner) => {
                    <isTeeProgramHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pendingAssertions(inner) => {
                    <pendingAssertionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::poster(inner) => {
                    <posterCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::removeTeeProgramHash(inner) => {
                    <removeTeeProgramHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::resolveChallenge(inner) => {
                    <resolveChallengeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeAllTeeKeys(inner) => {
                    <revokeAllTeeKeysCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setAppchainConfigHash(inner) => {
                    <setAppchainConfigHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setChallengeWindowDuration(inner) => {
                    <setChallengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::submitAssertion(inner) => {
                    <submitAssertionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::teeHackCount(inner) => {
                    <teeHackCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::teeKeys(inner) => {
                    <teeKeysCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::teeTrustedInput(inner) => {
                    <teeTrustedInputCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`TeeModule`](self) custom errors.
    pub enum TeeModuleErrors {
        #[allow(missing_docs)]
        ECDSAInvalidSignature(ECDSAInvalidSignature),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureLength(ECDSAInvalidSignatureLength),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureS(ECDSAInvalidSignatureS),
    }
    #[automatically_derived]
    impl TeeModuleErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [215u8, 139u8, 206u8, 12u8],
            [246u8, 69u8, 238u8, 223u8],
            [252u8, 230u8, 152u8, 247u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for TeeModuleErrors {
        const NAME: &'static str = "TeeModuleErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 3usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ECDSAInvalidSignature(_) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureLength(_) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureS(_) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<TeeModuleErrors>] = &[
                {
                    fn ECDSAInvalidSignatureS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::ECDSAInvalidSignatureS)
                    }
                    ECDSAInvalidSignatureS
                },
                {
                    fn ECDSAInvalidSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::ECDSAInvalidSignature)
                    }
                    ECDSAInvalidSignature
                },
                {
                    fn ECDSAInvalidSignatureLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::ECDSAInvalidSignatureLength)
                    }
                    ECDSAInvalidSignatureLength
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`TeeModule`](self) events.
    pub enum TeeModuleEvents {
        #[allow(missing_docs)]
        ChallengeResolved(ChallengeResolved),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
        #[allow(missing_docs)]
        TeeAppchainConfigHash(TeeAppchainConfigHash),
        #[allow(missing_docs)]
        TeeHacked(TeeHacked),
        #[allow(missing_docs)]
        TeeKeysRevoked(TeeKeysRevoked),
        #[allow(missing_docs)]
        TeeProgramHashAdded(TeeProgramHashAdded),
        #[allow(missing_docs)]
        TeeProgramHashRemoved(TeeProgramHashRemoved),
    }
    #[automatically_derived]
    impl TeeModuleEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                13u8,
                177u8,
                102u8,
                187u8,
                78u8,
                71u8,
                166u8,
                96u8,
                170u8,
                252u8,
                50u8,
                247u8,
                139u8,
                186u8,
                205u8,
                218u8,
                11u8,
                144u8,
                176u8,
                115u8,
                94u8,
                69u8,
                178u8,
                19u8,
                74u8,
                238u8,
                195u8,
                165u8,
                234u8,
                86u8,
                85u8,
                171u8,
            ],
            [
                17u8,
                78u8,
                156u8,
                121u8,
                142u8,
                60u8,
                109u8,
                21u8,
                139u8,
                93u8,
                29u8,
                215u8,
                17u8,
                206u8,
                30u8,
                34u8,
                120u8,
                95u8,
                61u8,
                148u8,
                137u8,
                141u8,
                219u8,
                28u8,
                231u8,
                249u8,
                188u8,
                117u8,
                23u8,
                49u8,
                117u8,
                211u8,
            ],
            [
                55u8,
                232u8,
                173u8,
                214u8,
                148u8,
                197u8,
                146u8,
                109u8,
                86u8,
                78u8,
                151u8,
                17u8,
                96u8,
                245u8,
                151u8,
                65u8,
                3u8,
                203u8,
                187u8,
                199u8,
                201u8,
                7u8,
                71u8,
                196u8,
                198u8,
                248u8,
                2u8,
                3u8,
                29u8,
                53u8,
                103u8,
                167u8,
            ],
            [
                67u8,
                136u8,
                80u8,
                38u8,
                197u8,
                158u8,
                203u8,
                184u8,
                36u8,
                209u8,
                2u8,
                120u8,
                95u8,
                238u8,
                95u8,
                149u8,
                147u8,
                230u8,
                149u8,
                187u8,
                154u8,
                132u8,
                144u8,
                134u8,
                77u8,
                152u8,
                48u8,
                149u8,
                37u8,
                36u8,
                229u8,
                213u8,
            ],
            [
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ],
            [
                183u8,
                161u8,
                128u8,
                34u8,
                132u8,
                151u8,
                237u8,
                149u8,
                198u8,
                137u8,
                111u8,
                193u8,
                176u8,
                129u8,
                160u8,
                22u8,
                153u8,
                145u8,
                22u8,
                249u8,
                138u8,
                185u8,
                91u8,
                82u8,
                18u8,
                54u8,
                89u8,
                239u8,
                234u8,
                37u8,
                151u8,
                100u8,
            ],
            [
                236u8,
                166u8,
                46u8,
                0u8,
                116u8,
                161u8,
                58u8,
                144u8,
                214u8,
                0u8,
                240u8,
                3u8,
                183u8,
                203u8,
                141u8,
                91u8,
                213u8,
                1u8,
                0u8,
                0u8,
                141u8,
                63u8,
                57u8,
                21u8,
                242u8,
                85u8,
                79u8,
                63u8,
                133u8,
                82u8,
                197u8,
                204u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for TeeModuleEvents {
        const NAME: &'static str = "TeeModuleEvents";
        const COUNT: usize = 7usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <ChallengeResolved as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ChallengeResolved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ChallengeResolved)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(
                    <TeeAppchainConfigHash as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <TeeAppchainConfigHash as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeAppchainConfigHash)
                }
                Some(<TeeHacked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TeeHacked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeHacked)
                }
                Some(<TeeKeysRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TeeKeysRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeKeysRevoked)
                }
                Some(
                    <TeeProgramHashAdded as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <TeeProgramHashAdded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeProgramHashAdded)
                }
                Some(
                    <TeeProgramHashRemoved as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <TeeProgramHashRemoved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeProgramHashRemoved)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for TeeModuleEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChallengeResolved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeAppchainConfigHash(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeHacked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeKeysRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeProgramHashAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeProgramHashRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChallengeResolved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeAppchainConfigHash(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeHacked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeKeysRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeProgramHashAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeProgramHashRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`TeeModule`](self) contract instance.

See the [wrapper's documentation](`TeeModuleInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> TeeModuleInstance<T, P, N> {
        TeeModuleInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        poster_: alloy::sol_types::private::Address,
        appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<TeeModuleInstance<T, P, N>>,
    > {
        TeeModuleInstance::<T, P, N>::deploy(provider, poster_, appchainConfigHash_)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        poster_: alloy::sol_types::private::Address,
        appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        TeeModuleInstance::<
            T,
            P,
            N,
        >::deploy_builder(provider, poster_, appchainConfigHash_)
    }
    /**A [`TeeModule`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`TeeModule`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct TeeModuleInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for TeeModuleInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("TeeModuleInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TeeModuleInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`TeeModule`](self) contract instance.

See the [wrapper's documentation](`TeeModuleInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            poster_: alloy::sol_types::private::Address,
            appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::Result<TeeModuleInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                poster_,
                appchainConfigHash_,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            poster_: alloy::sol_types::private::Address,
            appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            poster_,
                            appchainConfigHash_,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> TeeModuleInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> TeeModuleInstance<T, P, N> {
            TeeModuleInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TeeModuleInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`addTeeKey`] function.
        pub fn addTeeKey(
            &self,
            publicKey: alloy::sol_types::private::Address,
            zkProof: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, addTeeKeyCall, N> {
            self.call_builder(
                &addTeeKeyCall {
                    publicKey,
                    zkProof,
                },
            )
        }
        ///Creates a new call builder for the [`addTeeProgramHash`] function.
        pub fn addTeeProgramHash(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, addTeeProgramHashCall, N> {
            self.call_builder(&addTeeProgramHashCall { hash })
        }
        ///Creates a new call builder for the [`challengeWindowDuration`] function.
        pub fn challengeWindowDuration(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, challengeWindowDurationCall, N> {
            self.call_builder(&challengeWindowDurationCall {})
        }
        ///Creates a new call builder for the [`challengeWindowEnd`] function.
        pub fn challengeWindowEnd(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, challengeWindowEndCall, N> {
            self.call_builder(&challengeWindowEndCall {})
        }
        ///Creates a new call builder for the [`closeChallengeWindow`] function.
        pub fn closeChallengeWindow(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, closeChallengeWindowCall, N> {
            self.call_builder(&closeChallengeWindowCall {})
        }
        ///Creates a new call builder for the [`isTeeKey`] function.
        pub fn isTeeKey(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isTeeKeyCall, N> {
            self.call_builder(&isTeeKeyCall { _0 })
        }
        ///Creates a new call builder for the [`isTeeProgramHash`] function.
        pub fn isTeeProgramHash(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, isTeeProgramHashCall, N> {
            self.call_builder(&isTeeProgramHashCall { _0 })
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        ///Creates a new call builder for the [`pendingAssertions`] function.
        pub fn pendingAssertions(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, pendingAssertionsCall, N> {
            self.call_builder(&pendingAssertionsCall { _0 })
        }
        ///Creates a new call builder for the [`poster`] function.
        pub fn poster(&self) -> alloy_contract::SolCallBuilder<T, &P, posterCall, N> {
            self.call_builder(&posterCall {})
        }
        ///Creates a new call builder for the [`removeTeeProgramHash`] function.
        pub fn removeTeeProgramHash(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeTeeProgramHashCall, N> {
            self.call_builder(&removeTeeProgramHashCall { hash })
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall {})
        }
        ///Creates a new call builder for the [`resolveChallenge`] function.
        pub fn resolveChallenge(
            &self,
            assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, resolveChallengeCall, N> {
            self.call_builder(&resolveChallengeCall { assertion })
        }
        ///Creates a new call builder for the [`revokeAllTeeKeys`] function.
        pub fn revokeAllTeeKeys(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, revokeAllTeeKeysCall, N> {
            self.call_builder(&revokeAllTeeKeysCall {})
        }
        ///Creates a new call builder for the [`setAppchainConfigHash`] function.
        pub fn setAppchainConfigHash(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setAppchainConfigHashCall, N> {
            self.call_builder(&setAppchainConfigHashCall { hash })
        }
        ///Creates a new call builder for the [`setChallengeWindowDuration`] function.
        pub fn setChallengeWindowDuration(
            &self,
            duration: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setChallengeWindowDurationCall, N> {
            self.call_builder(
                &setChallengeWindowDurationCall {
                    duration,
                },
            )
        }
        ///Creates a new call builder for the [`submitAssertion`] function.
        pub fn submitAssertion(
            &self,
            assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
            signature: alloy::sol_types::private::Bytes,
            rewardAddr: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, submitAssertionCall, N> {
            self.call_builder(
                &submitAssertionCall {
                    assertion,
                    signature,
                    rewardAddr,
                },
            )
        }
        ///Creates a new call builder for the [`teeHackCount`] function.
        pub fn teeHackCount(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeHackCountCall, N> {
            self.call_builder(&teeHackCountCall {})
        }
        ///Creates a new call builder for the [`teeKeys`] function.
        pub fn teeKeys(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeKeysCall, N> {
            self.call_builder(&teeKeysCall { _0 })
        }
        ///Creates a new call builder for the [`teeTrustedInput`] function.
        pub fn teeTrustedInput(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeTrustedInputCall, N> {
            self.call_builder(&teeTrustedInputCall {})
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TeeModuleInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`ChallengeResolved`] event.
        pub fn ChallengeResolved_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ChallengeResolved, N> {
            self.event_filter::<ChallengeResolved>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`TeeAppchainConfigHash`] event.
        pub fn TeeAppchainConfigHash_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeAppchainConfigHash, N> {
            self.event_filter::<TeeAppchainConfigHash>()
        }
        ///Creates a new event filter for the [`TeeHacked`] event.
        pub fn TeeHacked_filter(&self) -> alloy_contract::Event<T, &P, TeeHacked, N> {
            self.event_filter::<TeeHacked>()
        }
        ///Creates a new event filter for the [`TeeKeysRevoked`] event.
        pub fn TeeKeysRevoked_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeKeysRevoked, N> {
            self.event_filter::<TeeKeysRevoked>()
        }
        ///Creates a new event filter for the [`TeeProgramHashAdded`] event.
        pub fn TeeProgramHashAdded_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeProgramHashAdded, N> {
            self.event_filter::<TeeProgramHashAdded>()
        }
        ///Creates a new event filter for the [`TeeProgramHashRemoved`] event.
        pub fn TeeProgramHashRemoved_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeProgramHashRemoved, N> {
            self.event_filter::<TeeProgramHashRemoved>()
        }
    }
}
