/**

Generated by the following Solidity interface...
```solidity
interface TeeModule {
    struct PendingAssertion {
        bytes32 blockHash;
        bytes32 sendRoot;
        bytes32 seqBlockHash;
    }

    error ECDSAInvalidSignature();
    error ECDSAInvalidSignatureLength(uint256 length);
    error ECDSAInvalidSignatureS(bytes32 s);

    event ChallengeResolved(PendingAssertion);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event TeeAppchainConfigHash(bytes32 configHash, bytes32 blockHash);
    event TeeHacked(uint256);
    event TeeKeysRevoked();
    event TeeProgramAdded(bytes32 hash);
    event TeeProgramRemoved(bytes32 hash);
    event TeeSeqConfigHash(bytes32 configHash, bytes32 blockHash);

    constructor(address poster_, address bridge_, bytes32 appchainConfigHash_, bytes32 appchainStartBlockHash_, bytes32 seqConfigHash_, bytes32 seqStartBlockHash_, bytes32 l1StartBlockHash_, bytes32 teeProgram);

    receive() external payable;

    function addTeeKey(address publicKey, bytes32 programHash, bytes memory zkProof) external;
    function addTeeProgram(bytes32 hash) external;
    function bridge() external view returns (address);
    function challengeWindowDuration() external view returns (uint256);
    function challengeWindowEnd() external view returns (uint256);
    function closeChallengeWindow() external;
    function isTeeKey(address) external view returns (bool);
    function owner() external view returns (address);
    function pendingAssertions(uint256) external view returns (bytes32 blockHash, bytes32 sendRoot, bytes32 seqBlockHash);
    function poster() external view returns (address);
    function removeTeeProgram(bytes32 hash) external;
    function renounceOwnership() external;
    function resolveChallenge(PendingAssertion memory assertion) external;
    function revokeAllTeeKeys() external;
    function setAppchainConfigHash(bytes32 hash) external;
    function setChallengeWindowDuration(uint256 duration) external;
    function setSeqConfigHash(bytes32 hash) external;
    function submitAssertion(PendingAssertion memory assertion, bytes memory signature, address rewardAddr) external;
    function teeHackCount() external view returns (uint256);
    function teeProgramKeys(bytes32, uint256) external view returns (address);
    function teePrograms(uint256) external view returns (bytes32);
    function teeTrustedInput() external view returns (bytes32 appchainConfigHash, bytes32 appchainStartBlockHash, bytes32 seqConfigHash, bytes32 seqStartBlockHash, bytes32 setDelayedMessageAcc, bytes32 l1StartBlockHash, bytes32 l1EndBlockHash);
    function transferOwnership(address newOwner) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "poster_",
        "type": "address",
        "internalType": "contract AssertionPoster"
      },
      {
        "name": "bridge_",
        "type": "address",
        "internalType": "contract IBridge"
      },
      {
        "name": "appchainConfigHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "appchainStartBlockHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "seqConfigHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "seqStartBlockHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "l1StartBlockHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "teeProgram",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "receive",
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "addTeeKey",
    "inputs": [
      {
        "name": "publicKey",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "programHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "zkProof",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addTeeProgram",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "bridge",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IBridge"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "challengeWindowDuration",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "challengeWindowEnd",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "closeChallengeWindow",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "isTeeKey",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pendingAssertions",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "blockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "sendRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "seqBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "poster",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract AssertionPoster"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "removeTeeProgram",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "resolveChallenge",
    "inputs": [
      {
        "name": "assertion",
        "type": "tuple",
        "internalType": "struct PendingAssertion",
        "components": [
          {
            "name": "blockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "sendRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "seqBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeAllTeeKeys",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setAppchainConfigHash",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setChallengeWindowDuration",
    "inputs": [
      {
        "name": "duration",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setSeqConfigHash",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "submitAssertion",
    "inputs": [
      {
        "name": "assertion",
        "type": "tuple",
        "internalType": "struct PendingAssertion",
        "components": [
          {
            "name": "blockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "sendRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "seqBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      },
      {
        "name": "signature",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "rewardAddr",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "teeHackCount",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "teeProgramKeys",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "teePrograms",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "teeTrustedInput",
    "inputs": [],
    "outputs": [
      {
        "name": "appchainConfigHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "appchainStartBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "seqConfigHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "seqStartBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "setDelayedMessageAcc",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "l1StartBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "l1EndBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "ChallengeResolved",
    "inputs": [
      {
        "name": "",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct PendingAssertion",
        "components": [
          {
            "name": "blockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "sendRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "seqBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeAppchainConfigHash",
    "inputs": [
      {
        "name": "configHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "blockHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeHacked",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeKeysRevoked",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeProgramAdded",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeProgramRemoved",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeSeqConfigHash",
    "inputs": [
      {
        "name": "configHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "blockHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureLength",
    "inputs": [
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureS",
    "inputs": [
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod TeeModule {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60c060405234801561000f575f5ffd5b506040516142b03803806142b0833981810160405281019061003191906109f0565b61004d61004261047360201b60201c565b61047a60201b60201c565b5f73420000000000000000000000000000000000001573ffffffffffffffffffffffffffffffffffffffff1663b80777ea6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156100ab573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906100cf9190610ade565b67ffffffffffffffff1611801561016757505f5f1b73420000000000000000000000000000000000001573ffffffffffffffffffffffffffffffffffffffff166309bd5a606040518163ffffffff1660e01b8152600401602060405180830381865afa158015610141573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906101659190610b09565b115b6101a6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161019d90610bb4565b60405180910390fd5b5f8873ffffffffffffffffffffffffffffffffffffffff163b116101ff576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016101f690610c42565b60405180910390fd5b8773ffffffffffffffffffffffffffffffffffffffff1660808173ffffffffffffffffffffffffffffffffffffffff16815250505f8773ffffffffffffffffffffffffffffffffffffffff1663eca067ad6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561027d573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906102a19190610c93565b116102e1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102d890610d2e565b60405180910390fd5b8673ffffffffffffffffffffffffffffffffffffffff1660a08173ffffffffffffffffffffffffffffffffffffffff16815250508560015f01819055508460018001819055507fc985bccbd0c90e197f4a7373020a33ba6ff864d0399fd7d65c5c7c32ffb015ec8686604051610358929190610d5b565b60405180910390a183600160020181905550826001600301819055507fb9eb20b32fac965884cb58326102257cae604504f0a36cd1008a32845ad5c29b84846040516103a5929190610d5b565b60405180910390a1816001600501819055505f5f1b81036103fb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103f290610df2565b60405180910390fd5b600a81908060018154018082558091505060019003905f5260205f20015f90919091909150557f9a7a6469c25cf017890607695e4a149cc771f294fd871e2080d24cd109033ab6816040516104509190610e10565b60405180910390a161046661053b60201b60201c565b505050505050505061102d565b5f33905090565b5f5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f5f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b60016008805490501115610584576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161057b90610e99565b60405180910390fd5b600d5473420000000000000000000000000000000000001573ffffffffffffffffffffffffffffffffffffffff1663b80777ea6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105e4573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906106089190610ade565b67ffffffffffffffff1611610652576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161064990610f27565b60405180910390fd5b5f60088054905011156107765760085f8154811061067357610672610f45565b5b905f5260205f2090600302015f0154600180018190555060085f8154811061069e5761069d610f45565b5b905f5260205f2090600302016002015460016003018190555060016006015460016005018190555060805173ffffffffffffffffffffffffffffffffffffffff1663daeab41260085f815481106106f8576106f7610f45565b5b905f5260205f2090600302015f015460085f8154811061071b5761071a610f45565b5b905f5260205f209060030201600101546040518363ffffffff1660e01b8152600401610748929190610d5b565b5f604051808303815f87803b15801561075f575f5ffd5b505af1158015610771573d5f5f3e3d5ffd5b505050505b60a05173ffffffffffffffffffffffffffffffffffffffff1663d5719dc2600160a05173ffffffffffffffffffffffffffffffffffffffff1663eca067ad6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156107e1573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906108059190610c93565b61080f9190610f9f565b6040518263ffffffff1660e01b815260040161082b9190610fe1565b602060405180830381865afa158015610846573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061086a9190610b09565b60016004018190555073420000000000000000000000000000000000001573ffffffffffffffffffffffffffffffffffffffff166309bd5a606040518163ffffffff1660e01b8152600401602060405180830381865afa1580156108d0573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906108f49190610b09565b600160060181905550600e544261090b9190610ffa565b600d81905550565b5f5ffd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f61094082610917565b9050919050565b5f61095182610936565b9050919050565b61096181610947565b811461096b575f5ffd5b50565b5f8151905061097c81610958565b92915050565b5f61098c82610936565b9050919050565b61099c81610982565b81146109a6575f5ffd5b50565b5f815190506109b781610993565b92915050565b5f819050919050565b6109cf816109bd565b81146109d9575f5ffd5b50565b5f815190506109ea816109c6565b92915050565b5f5f5f5f5f5f5f5f610100898b031215610a0d57610a0c610913565b5b5f610a1a8b828c0161096e565b9850506020610a2b8b828c016109a9565b9750506040610a3c8b828c016109dc565b9650506060610a4d8b828c016109dc565b9550506080610a5e8b828c016109dc565b94505060a0610a6f8b828c016109dc565b93505060c0610a808b828c016109dc565b92505060e0610a918b828c016109dc565b9150509295985092959890939650565b5f67ffffffffffffffff82169050919050565b610abd81610aa1565b8114610ac7575f5ffd5b50565b5f81519050610ad881610ab4565b92915050565b5f60208284031215610af357610af2610913565b5b5f610b0084828501610aca565b91505092915050565b5f60208284031215610b1e57610b1d610913565b5b5f610b2b848285016109dc565b91505092915050565b5f82825260208201905092915050565b7f636861696e206973206e6f7420616e206c3220626564726f636b20726f6c6c755f8201527f7000000000000000000000000000000000000000000000000000000000000000602082015250565b5f610b9e602183610b34565b9150610ba982610b44565b604082019050919050565b5f6020820190508181035f830152610bcb81610b92565b9050919050565b7f706f73746572206164647265737320646f6573206e6f74206861766520616e795f8201527f20636f6465000000000000000000000000000000000000000000000000000000602082015250565b5f610c2c602583610b34565b9150610c3782610bd2565b604082019050919050565b5f6020820190508181035f830152610c5981610c20565b9050919050565b5f819050919050565b610c7281610c60565b8114610c7c575f5ffd5b50565b5f81519050610c8d81610c69565b92915050565b5f60208284031215610ca857610ca7610913565b5b5f610cb584828501610c7f565b91505092915050565b7f696e73756666696369656e742064656c61796564206d6573736167657320696e5f8201527f2062726964676500000000000000000000000000000000000000000000000000602082015250565b5f610d18602783610b34565b9150610d2382610cbe565b604082019050919050565b5f6020820190508181035f830152610d4581610d0c565b9050919050565b610d55816109bd565b82525050565b5f604082019050610d6e5f830185610d4c565b610d7b6020830184610d4c565b9392505050565b7f7465652070726f6772616d2068617368206d757374206265206e6f6e2d7a65725f8201527f6f00000000000000000000000000000000000000000000000000000000000000602082015250565b5f610ddc602183610b34565b9150610de782610d82565b604082019050919050565b5f6020820190508181035f830152610e0981610dd0565b9050919050565b5f602082019050610e235f830184610d4c565b92915050565b7f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201527f746f6f206d616e7920617373657274696f6e7300000000000000000000000000602082015250565b5f610e83603383610b34565b9150610e8e82610e29565b604082019050919050565b5f6020820190508181035f830152610eb081610e77565b9050919050565b7f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201527f696e73756666696369656e742074696d65206861732070617373656400000000602082015250565b5f610f11603c83610b34565b9150610f1c82610eb7565b604082019050919050565b5f6020820190508181035f830152610f3e81610f05565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610fa982610c60565b9150610fb483610c60565b9250828203905081811115610fcc57610fcb610f72565b5b92915050565b610fdb81610c60565b82525050565b5f602082019050610ff45f830184610fd2565b92915050565b5f61100482610c60565b915061100f83610c60565b925082820190508082111561102757611026610f72565b5b92915050565b60805160a05161324d6110635f395f8181610c3e01528181610c7c01526118d101525f8181610b7001526111bf015261324d5ff3fe608060405260043610610143575f3560e01c806370646ea2116100b5578063c3f2dbd31161006e578063c3f2dbd314610422578063e50c61561461044a578063e78cea9214610472578063ee1c28b81461049c578063f223055c146104c6578063f2fde38b146104ee5761014a565b806370646ea21461032a578063715018a61461035257806380959721146103685780638da5cb5b146103925780638fed55a3146103bc578063a56ec6cd146103e45761014a565b80634afffcc9116101075780634afffcc9146102465780634bd167c9146102825780635f70c441146102ac578063697b5e62146102d45780636c4c2060146102fe5780636ef01201146103145761014a565b80631c12427f1461014e5780631caf5d1314610176578063333390061461019e5780633ceaae7d146101da578063477426401461020a5761014a565b3661014a57005b5f5ffd5b348015610159575f5ffd5b50610174600480360381019061016f9190612045565b610516565b005b348015610181575f5ffd5b5061019c600480360381019061019791906120a3565b610670565b005b3480156101a9575f5ffd5b506101c460048036038101906101bf91906120ce565b61073d565b6040516101d1919061214b565b60405180910390f35b3480156101e5575f5ffd5b506101ee610785565b6040516102019796959493929190612173565b60405180910390f35b348015610215575f5ffd5b50610230600480360381019061022b919061220a565b6107b4565b60405161023d919061224f565b60405180910390f35b348015610251575f5ffd5b5061026c600480360381019061026791906120a3565b6107d1565b6040516102799190612268565b60405180910390f35b34801561028d575f5ffd5b506102966107f1565b6040516102a39190612290565b60405180910390f35b3480156102b7575f5ffd5b506102d260048036038101906102cd9190612045565b6107f7565b005b3480156102df575f5ffd5b506102e86109dd565b6040516102f59190612290565b60405180910390f35b348015610309575f5ffd5b506103126109e3565b005b34801561031f575f5ffd5b50610328610e15565b005b348015610335575f5ffd5b50610350600480360381019061034b919061230a565b610f11565b005b34801561035d575f5ffd5b50610366611136565b005b348015610373575f5ffd5b5061037c6111bd565b60405161038991906123d6565b60405180910390f35b34801561039d575f5ffd5b506103a66111e1565b6040516103b3919061214b565b60405180910390f35b3480156103c7575f5ffd5b506103e260048036038101906103dd9190612411565b611208565b005b3480156103ef575f5ffd5b5061040a600480360381019061040591906120a3565b6113e8565b6040516104199392919061243c565b60405180910390f35b34801561042d575f5ffd5b5061044860048036038101906104439190612045565b61141d565b005b348015610455575f5ffd5b50610470600480360381019061046b9190612471565b61152b565b005b34801561047d575f5ffd5b506104866118cf565b6040516104939190612502565b60405180910390f35b3480156104a7575f5ffd5b506104b06118f3565b6040516104bd9190612290565b60405180910390f35b3480156104d1575f5ffd5b506104ec60048036038101906104e79190612045565b6118f9565b005b3480156104f9575f5ffd5b50610514600480360381019061050f919061220a565b611a05565b005b61051e611afb565b73ffffffffffffffffffffffffffffffffffffffff1661053c6111e1565b73ffffffffffffffffffffffffffffffffffffffff1614610592576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161058990612575565b60405180910390fd5b5f5f90505b600a8054905081101561060f5781600a82815481106105b9576105b8612593565b5b905f5260205f20015403610602576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105f99061260a565b60405180910390fd5b8080600101915050610597565b50600a81908060018154018082558091505060019003905f5260205f20015f90919091909150557f9a7a6469c25cf017890607695e4a149cc771f294fd871e2080d24cd109033ab6816040516106659190612268565b60405180910390a150565b610678611afb565b73ffffffffffffffffffffffffffffffffffffffff166106966111e1565b73ffffffffffffffffffffffffffffffffffffffff16146106ec576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106e390612575565b60405180910390fd5b5f60088054905014610733576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161072a90612698565b60405180910390fd5b80600e8190555050565b600b602052815f5260405f208181548110610756575f80fd5b905f5260205f20015f915091509054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6001805f0154908060010154908060020154908060030154908060040154908060050154908060060154905087565b600c602052805f5260405f205f915054906101000a900460ff1681565b600a81815481106107e0575f80fd5b905f5260205f20015f915090505481565b600e5481565b6107ff611afb565b73ffffffffffffffffffffffffffffffffffffffff1661081d6111e1565b73ffffffffffffffffffffffffffffffffffffffff1614610873576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161086a90612575565b60405180910390fd5b5f600880549050146108ba576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108b190612726565b60405180910390fd5b5f5f90505b600b5f8381526020019081526020015f2080549050811015610986575f600c5f600b5f8681526020019081526020015f20848154811061090257610901612593565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff02191690831515021790555080806001019150506108bf565b50600b5f8281526020019081526020015f205f6109a39190611f4c565b7f2621c61d3315f2a3d26b22d746ba21a96d249f51ada323f7226cce5fe5fc3d64816040516109d29190612268565b60405180910390a150565b60095481565b60016008805490501115610a2c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a23906127b4565b60405180910390fd5b600d5473420000000000000000000000000000000000001573ffffffffffffffffffffffffffffffffffffffff1663b80777ea6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a8c573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610ab0919061280f565b67ffffffffffffffff1611610afa576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610af1906128aa565b60405180910390fd5b5f6008805490501115610c3c5760085f81548110610b1b57610b1a612593565b5b905f5260205f2090600302015f0154600180018190555060085f81548110610b4657610b45612593565b5b905f5260205f209060030201600201546001600301819055506001600601546001600501819055507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663daeab41260085f81548110610bbe57610bbd612593565b5b905f5260205f2090600302015f015460085f81548110610be157610be0612593565b5b905f5260205f209060030201600101546040518363ffffffff1660e01b8152600401610c0e9291906128c8565b5f604051808303815f87803b158015610c25575f5ffd5b505af1158015610c37573d5f5f3e3d5ffd5b505050505b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663d5719dc260017f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663eca067ad6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ce3573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d079190612903565b610d11919061295b565b6040518263ffffffff1660e01b8152600401610d2d9190612290565b602060405180830381865afa158015610d48573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d6c91906129a2565b60016004018190555073420000000000000000000000000000000000001573ffffffffffffffffffffffffffffffffffffffff166309bd5a606040518163ffffffff1660e01b8152600401602060405180830381865afa158015610dd2573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610df691906129a2565b600160060181905550600e5442610e0d91906129cd565b600d81905550565b610e1d611afb565b73ffffffffffffffffffffffffffffffffffffffff16610e3b6111e1565b73ffffffffffffffffffffffffffffffffffffffff1614610e91576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610e8890612575565b60405180910390fd5b5f5f90505b600a80549050811015610ed557610ec8600a8281548110610eba57610eb9612593565b5b905f5260205f2001546107f7565b8080600101915050610e96565b50600a5f610ee39190611f6a565b7feca62e0074a13a90d600f003b7cb8d5bd50100008d3f3915f2554f3f8552c5cc60405160405180910390a1565b60018282905014610f57576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610f4e90612a4a565b60405180910390fd5b600c5f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1615610fe1576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610fd890612ab2565b60405180910390fd5b5f600b5f8581526020019081526020015f20805490500361106b575f5f90505f600a8054905090505b5f81111561105d5784600a600183611022919061295b565b8154811061103357611032612593565b5b905f5260205f2001540361104a576001915061105d565b808061105590612ad0565b91505061100a565b50806110695750611130565b505b6001600c5f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550600b5f8481526020019081526020015f2084908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b50505050565b61113e611afb565b73ffffffffffffffffffffffffffffffffffffffff1661115c6111e1565b73ffffffffffffffffffffffffffffffffffffffff16146111b2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016111a990612575565b60405180910390fd5b6111bb5f611b02565b565b7f000000000000000000000000000000000000000000000000000000000000000081565b5f5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b611210611afb565b73ffffffffffffffffffffffffffffffffffffffff1661122e6111e1565b73ffffffffffffffffffffffffffffffffffffffff1614611284576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161127b90612575565b60405180910390fd5b6001600880549050116112cc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016112c390612b41565b60405180910390fd5b5f5f90505b6008805490508110156113a95761130782600883815481106112f6576112f5612593565b5b905f5260205f209060030201611bc3565b1561139c5760085f6113199190611f88565b600882908060018154018082558091505060019003905f5260205f2090600302015f90919091909150818161134e9190612c75565b50505f600d8190555061135f6109e3565b7fe42eaf0737e2478a5f5aed3a0610ae7b09a27cbac9ad6a5cc4d68f78afd1425b8260405161138e9190612d00565b60405180910390a1506113e5565b80806001019150506112d1565b506040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016113dc90612d63565b60405180910390fd5b50565b600881815481106113f7575f80fd5b905f5260205f2090600302015f91509050805f0154908060010154908060020154905083565b611425611afb565b73ffffffffffffffffffffffffffffffffffffffff166114436111e1565b73ffffffffffffffffffffffffffffffffffffffff1614611499576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161149090612575565b60405180910390fd5b5f600880549050146114e0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016114d790612df1565b60405180910390fd5b806001600201819055507fb9eb20b32fac965884cb58326102257cae604504f0a36cd1008a32845ad5c29b816001600301546040516115209291906128c8565b60405180910390a150565b60418383905014611571576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161156890612e59565b60405180910390fd5b5f61157c6001611bfb565b855f0135866020013560405160200161159793929190612e97565b604051602081830303815290604052805190602001209050600c5f61161086868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f81840152601f19601f8201169050808301925050505050505061160285611c51565b611c8490919063ffffffff16565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff16611695576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161168c90612f1d565b60405180910390fd5b6001800154855f0135036116de576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016116d590612f85565b60405180910390fd5b5f5f90505b60088054905081101561176657611719866008838154811061170857611707612593565b5b905f5260205f209060030201611bc3565b15611759576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161175090612fed565b60405180910390fd5b80806001019150506116e3565b505f6008805490500361178857600e544261178191906129cd565b600d819055505b600885908060018154018082558091505060019003905f5260205f2090600302015f9091909190915081816117bd9190612c75565b50506002600880549050036118c857600160095f8282546117de91906129cd565b925050819055507f37e8add694c5926d564e971160f5974103cbbbc7c90747c4c6f802031d3567a76009546040516118169190612290565b60405180910390a15f8273ffffffffffffffffffffffffffffffffffffffff164760405161184390613038565b5f6040518083038185875af1925050503d805f811461187d576040519150601f19603f3d011682016040523d82523d5f602084013e611882565b606091505b50509050806118c6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016118bd90613096565b60405180910390fd5b505b5050505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b600d5481565b611901611afb565b73ffffffffffffffffffffffffffffffffffffffff1661191f6111e1565b73ffffffffffffffffffffffffffffffffffffffff1614611975576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161196c90612575565b60405180910390fd5b5f600880549050146119bc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016119b390612df1565b60405180910390fd5b8060015f01819055507fc985bccbd0c90e197f4a7373020a33ba6ff864d0399fd7d65c5c7c32ffb015ec8160018001546040516119fa9291906128c8565b60405180910390a150565b611a0d611afb565b73ffffffffffffffffffffffffffffffffffffffff16611a2b6111e1565b73ffffffffffffffffffffffffffffffffffffffff1614611a81576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611a7890612575565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603611aef576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611ae690613124565b60405180910390fd5b611af881611b02565b50565b5f33905090565b5f5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f5f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f815f0154835f0135148015611be0575081600101548360200135145b8015611bf3575081600201548360400135145b905092915050565b5f815f0154826001015483600201548460030154856004015486600501548760060154604051602001611c349796959493929190613142565b604051602081830303815290604052805190602001209050919050565b5f7f19457468657265756d205369676e6564204d6573736167653a0a3332000000005f5281601c52603c5f209050919050565b5f5f5f5f611c928686611cae565b925092509250611ca28282611d03565b82935050505092915050565b5f5f5f6041845103611cee575f5f5f602087015192506040870151915060608701515f1a9050611ce088828585611e65565b955095509550505050611cfc565b5f600285515f1b9250925092505b9250925092565b5f6003811115611d1657611d156131c2565b5b826003811115611d2957611d286131c2565b5b0315611e615760016003811115611d4357611d426131c2565b5b826003811115611d5657611d556131c2565b5b03611d8d576040517ff645eedf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60026003811115611da157611da06131c2565b5b826003811115611db457611db36131c2565b5b03611df857805f1c6040517ffce698f7000000000000000000000000000000000000000000000000000000008152600401611def9190612290565b60405180910390fd5b600380811115611e0b57611e0a6131c2565b5b826003811115611e1e57611e1d6131c2565b5b03611e6057806040517fd78bce0c000000000000000000000000000000000000000000000000000000008152600401611e579190612268565b60405180910390fd5b5b5050565b5f5f5f7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0845f1c1115611ea1575f600385925092509250611f42565b5f6001888888886040515f8152602001604052604051611ec4949392919061320a565b6020604051602081039080840390855afa158015611ee4573d5f5f3e3d5ffd5b5050506020604051035190505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603611f35575f60015f5f1b93509350935050611f42565b805f5f5f1b935093509350505b9450945094915050565b5080545f8255905f5260205f2090810190611f679190611fa9565b50565b5080545f8255905f5260205f2090810190611f859190611fc4565b50565b5080545f8255600302905f5260205f2090810190611fa69190611fdf565b50565b5b80821115611fc0575f815f905550600101611faa565b5090565b5b80821115611fdb575f815f905550600101611fc5565b5090565b5b80821115612006575f5f82015f9055600182015f9055600282015f905550600301611fe0565b5090565b5f5ffd5b5f5ffd5b5f819050919050565b61202481612012565b811461202e575f5ffd5b50565b5f8135905061203f8161201b565b92915050565b5f6020828403121561205a5761205961200a565b5b5f61206784828501612031565b91505092915050565b5f819050919050565b61208281612070565b811461208c575f5ffd5b50565b5f8135905061209d81612079565b92915050565b5f602082840312156120b8576120b761200a565b5b5f6120c58482850161208f565b91505092915050565b5f5f604083850312156120e4576120e361200a565b5b5f6120f185828601612031565b92505060206121028582860161208f565b9150509250929050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6121358261210c565b9050919050565b6121458161212b565b82525050565b5f60208201905061215e5f83018461213c565b92915050565b61216d81612012565b82525050565b5f60e0820190506121865f83018a612164565b6121936020830189612164565b6121a06040830188612164565b6121ad6060830187612164565b6121ba6080830186612164565b6121c760a0830185612164565b6121d460c0830184612164565b98975050505050505050565b6121e98161212b565b81146121f3575f5ffd5b50565b5f81359050612204816121e0565b92915050565b5f6020828403121561221f5761221e61200a565b5b5f61222c848285016121f6565b91505092915050565b5f8115159050919050565b61224981612235565b82525050565b5f6020820190506122625f830184612240565b92915050565b5f60208201905061227b5f830184612164565b92915050565b61228a81612070565b82525050565b5f6020820190506122a35f830184612281565b92915050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83601f8401126122ca576122c96122a9565b5b8235905067ffffffffffffffff8111156122e7576122e66122ad565b5b602083019150836001820283011115612303576123026122b1565b5b9250929050565b5f5f5f5f606085870312156123225761232161200a565b5b5f61232f878288016121f6565b945050602061234087828801612031565b935050604085013567ffffffffffffffff8111156123615761236061200e565b5b61236d878288016122b5565b925092505092959194509250565b5f819050919050565b5f61239e6123996123948461210c565b61237b565b61210c565b9050919050565b5f6123af82612384565b9050919050565b5f6123c0826123a5565b9050919050565b6123d0816123b6565b82525050565b5f6020820190506123e95f8301846123c7565b92915050565b5f5ffd5b5f60608284031215612408576124076123ef565b5b81905092915050565b5f606082840312156124265761242561200a565b5b5f612433848285016123f3565b91505092915050565b5f60608201905061244f5f830186612164565b61245c6020830185612164565b6124696040830184612164565b949350505050565b5f5f5f5f60a085870312156124895761248861200a565b5b5f612496878288016123f3565b945050606085013567ffffffffffffffff8111156124b7576124b661200e565b5b6124c3878288016122b5565b935093505060806124d6878288016121f6565b91505092959194509250565b5f6124ec826123a5565b9050919050565b6124fc816124e2565b82525050565b5f6020820190506125155f8301846124f3565b92915050565b5f82825260208201905092915050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65725f82015250565b5f61255f60208361251b565b915061256a8261252b565b602082019050919050565b5f6020820190508181035f83015261258c81612553565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f7465652070726f6772616d20616c7265616479206578697374730000000000005f82015250565b5f6125f4601a8361251b565b91506125ff826125c0565b602082019050919050565b5f6020820190508181035f830152612621816125e8565b9050919050565b7f63616e6e6f7420757064617465206368616c6c656e67652077696e646f7720775f8201527f68696c6520617373657274696f6e2069732070656e64696e6700000000000000602082015250565b5f61268260398361251b565b915061268d82612628565b604082019050919050565b5f6020820190508181035f8301526126af81612676565b9050919050565b7f63616e6e6f742072656d6f7665207465652070726f6772616d207768696c65205f8201527f617373657274696f6e2069732070656e64696e67000000000000000000000000602082015250565b5f61271060348361251b565b915061271b826126b6565b604082019050919050565b5f6020820190508181035f83015261273d81612704565b9050919050565b7f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201527f746f6f206d616e7920617373657274696f6e7300000000000000000000000000602082015250565b5f61279e60338361251b565b91506127a982612744565b604082019050919050565b5f6020820190508181035f8301526127cb81612792565b9050919050565b5f67ffffffffffffffff82169050919050565b6127ee816127d2565b81146127f8575f5ffd5b50565b5f81519050612809816127e5565b92915050565b5f602082840312156128245761282361200a565b5b5f612831848285016127fb565b91505092915050565b7f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201527f696e73756666696369656e742074696d65206861732070617373656400000000602082015250565b5f612894603c8361251b565b915061289f8261283a565b604082019050919050565b5f6020820190508181035f8301526128c181612888565b9050919050565b5f6040820190506128db5f830185612164565b6128e86020830184612164565b9392505050565b5f815190506128fd81612079565b92915050565b5f602082840312156129185761291761200a565b5b5f612925848285016128ef565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f61296582612070565b915061297083612070565b92508282039050818111156129885761298761292e565b5b92915050565b5f8151905061299c8161201b565b92915050565b5f602082840312156129b7576129b661200a565b5b5f6129c48482850161298e565b91505092915050565b5f6129d782612070565b91506129e283612070565b92508282019050808211156129fa576129f961292e565b5b92915050565b7f746f646f3a2076616c6964617465207a6b207a6b50726f6f66000000000000005f82015250565b5f612a3460198361251b565b9150612a3f82612a00565b602082019050919050565b5f6020820190508181035f830152612a6181612a28565b9050919050565b7f6b657920616c72656164792061646465640000000000000000000000000000005f82015250565b5f612a9c60118361251b565b9150612aa782612a68565b602082019050919050565b5f6020820190508181035f830152612ac981612a90565b9050919050565b5f612ada82612070565b91505f8203612aec57612aeb61292e565b5b600182039050919050565b7f6368616c6c656e676520646f6573206e6f7420657869737400000000000000005f82015250565b5f612b2b60188361251b565b9150612b3682612af7565b602082019050919050565b5f6020820190508181035f830152612b5881612b1f565b9050919050565b5f8135612b6b8161201b565b80915050919050565b5f815f1b9050919050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff612baa84612b74565b9350801983169250808416831791505092915050565b5f612bca82612012565b9050919050565b5f815f1c9050919050565b5f612be682612bd1565b9050919050565b612bf682612bc0565b612c09612c0282612bdc565b8354612b7f565b8255505050565b5f81015f830180612c2081612b5f565b9050612c2c8184612bed565b505050600181016020830180612c4181612b5f565b9050612c4d8184612bed565b505050600281016040830180612c6281612b5f565b9050612c6e8184612bed565b5050505050565b612c7f8282612c10565b5050565b5f612c916020840184612031565b905092915050565b612ca281612012565b82525050565b60608201612cb85f830183612c83565b612cc45f850182612c99565b50612cd26020830183612c83565b612cdf6020850182612c99565b50612ced6040830183612c83565b612cfa6040850182612c99565b50505050565b5f606082019050612d135f830184612ca8565b92915050565b7f617373657274696f6e206e6f7420666f756e64000000000000000000000000005f82015250565b5f612d4d60138361251b565b9150612d5882612d19565b602082019050919050565b5f6020820190508181035f830152612d7a81612d41565b9050919050565b7f63616e6e6f742075706461746520636f6e6669672068617368207768696c65205f8201527f617373657274696f6e73206172652070656e64696e6700000000000000000000602082015250565b5f612ddb60368361251b565b9150612de682612d81565b604082019050919050565b5f6020820190508181035f830152612e0881612dcf565b9050919050565b7f696e76616c6964207369676e6174757265206c656e67746800000000000000005f82015250565b5f612e4360188361251b565b9150612e4e82612e0f565b602082019050919050565b5f6020820190508181035f830152612e7081612e37565b9050919050565b5f819050919050565b612e91612e8c82612012565b612e77565b82525050565b5f612ea28286612e80565b602082019150612eb28285612e80565b602082019150612ec28284612e80565b602082019150819050949350505050565b7f696e76616c696420746565207369676e617475726500000000000000000000005f82015250565b5f612f0760158361251b565b9150612f1282612ed3565b602082019050919050565b5f6020820190508181035f830152612f3481612efb565b9050919050565b7f617070636861696e20626c6f636b206861736820756e6368616e6765640000005f82015250565b5f612f6f601d8361251b565b9150612f7a82612f3b565b602082019050919050565b5f6020820190508181035f830152612f9c81612f63565b9050919050565b7f617373657274696f6e20616c72656164792065786973747300000000000000005f82015250565b5f612fd760188361251b565b9150612fe282612fa3565b602082019050919050565b5f6020820190508181035f83015261300481612fcb565b9050919050565b5f81905092915050565b50565b5f6130235f8361300b565b915061302e82613015565b5f82019050919050565b5f61304282613018565b9150819050919050565b7f7061796d656e74206661696c65640000000000000000000000000000000000005f82015250565b5f613080600e8361251b565b915061308b8261304c565b602082019050919050565b5f6020820190508181035f8301526130ad81613074565b9050919050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f20615f8201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b5f61310e60268361251b565b9150613119826130b4565b604082019050919050565b5f6020820190508181035f83015261313b81613102565b9050919050565b5f61314d828a612e80565b60208201915061315d8289612e80565b60208201915061316d8288612e80565b60208201915061317d8287612e80565b60208201915061318d8286612e80565b60208201915061319d8285612e80565b6020820191506131ad8284612e80565b60208201915081905098975050505050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b5f60ff82169050919050565b613204816131ef565b82525050565b5f60808201905061321d5f830187612164565b61322a60208301866131fb565b6132376040830185612164565b6132446060830184612164565b9594505050505056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xC0`@R4\x80\x15a\0\x0FW__\xFD[P`@QaB\xB08\x03\x80aB\xB0\x839\x81\x81\x01`@R\x81\x01\x90a\x001\x91\x90a\t\xF0V[a\0Ma\0Ba\x04s` \x1B` \x1CV[a\x04z` \x1B` \x1CV[_sB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xB8\x07w\xEA`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\0\xABW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\0\xCF\x91\x90a\n\xDEV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11\x80\x15a\x01gWP__\x1BsB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\t\xBDZ``@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x01AW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x01e\x91\x90a\x0B\tV[\x11[a\x01\xA6W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x01\x9D\x90a\x0B\xB4V[`@Q\x80\x91\x03\x90\xFD[_\x88s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x11a\x01\xFFW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x01\xF6\x90a\x0CBV[`@Q\x80\x91\x03\x90\xFD[\x87s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x80\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP_\x87s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xEC\xA0g\xAD`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x02}W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x02\xA1\x91\x90a\x0C\x93V[\x11a\x02\xE1W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x02\xD8\x90a\r.V[`@Q\x80\x91\x03\x90\xFD[\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\xA0\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP\x85`\x01_\x01\x81\x90UP\x84`\x01\x80\x01\x81\x90UP\x7F\xC9\x85\xBC\xCB\xD0\xC9\x0E\x19\x7FJss\x02\n3\xBAo\xF8d\xD09\x9F\xD7\xD6\\\\|2\xFF\xB0\x15\xEC\x86\x86`@Qa\x03X\x92\x91\x90a\r[V[`@Q\x80\x91\x03\x90\xA1\x83`\x01`\x02\x01\x81\x90UP\x82`\x01`\x03\x01\x81\x90UP\x7F\xB9\xEB \xB3/\xAC\x96X\x84\xCBX2a\x02%|\xAE`E\x04\xF0\xA3l\xD1\0\x8A2\x84Z\xD5\xC2\x9B\x84\x84`@Qa\x03\xA5\x92\x91\x90a\r[V[`@Q\x80\x91\x03\x90\xA1\x81`\x01`\x05\x01\x81\x90UP__\x1B\x81\x03a\x03\xFBW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x03\xF2\x90a\r\xF2V[`@Q\x80\x91\x03\x90\xFD[`\n\x81\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91PU\x7F\x9Azdi\xC2\\\xF0\x17\x89\x06\x07i^J\x14\x9C\xC7q\xF2\x94\xFD\x87\x1E \x80\xD2L\xD1\t\x03:\xB6\x81`@Qa\x04P\x91\x90a\x0E\x10V[`@Q\x80\x91\x03\x90\xA1a\x04fa\x05;` \x1B` \x1CV[PPPPPPPPa\x10-V[_3\x90P\x90V[___\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81__a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPV[`\x01`\x08\x80T\x90P\x11\x15a\x05\x84W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05{\x90a\x0E\x99V[`@Q\x80\x91\x03\x90\xFD[`\rTsB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xB8\x07w\xEA`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05\xE4W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06\x08\x91\x90a\n\xDEV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11a\x06RW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06I\x90a\x0F'V[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x11\x15a\x07vW`\x08_\x81T\x81\x10a\x06sWa\x06ra\x0FEV[[\x90_R` _ \x90`\x03\x02\x01_\x01T`\x01\x80\x01\x81\x90UP`\x08_\x81T\x81\x10a\x06\x9EWa\x06\x9Da\x0FEV[[\x90_R` _ \x90`\x03\x02\x01`\x02\x01T`\x01`\x03\x01\x81\x90UP`\x01`\x06\x01T`\x01`\x05\x01\x81\x90UP`\x80Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xDA\xEA\xB4\x12`\x08_\x81T\x81\x10a\x06\xF8Wa\x06\xF7a\x0FEV[[\x90_R` _ \x90`\x03\x02\x01_\x01T`\x08_\x81T\x81\x10a\x07\x1BWa\x07\x1Aa\x0FEV[[\x90_R` _ \x90`\x03\x02\x01`\x01\x01T`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x07H\x92\x91\x90a\r[V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x07_W__\xFD[PZ\xF1\x15\x80\x15a\x07qW=__>=_\xFD[PPPP[`\xA0Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD5q\x9D\xC2`\x01`\xA0Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xEC\xA0g\xAD`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x07\xE1W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08\x05\x91\x90a\x0C\x93V[a\x08\x0F\x91\x90a\x0F\x9FV[`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x08+\x91\x90a\x0F\xE1V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x08FW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08j\x91\x90a\x0B\tV[`\x01`\x04\x01\x81\x90UPsB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\t\xBDZ``@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x08\xD0W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08\xF4\x91\x90a\x0B\tV[`\x01`\x06\x01\x81\x90UP`\x0ETBa\t\x0B\x91\x90a\x0F\xFAV[`\r\x81\x90UPV[__\xFD[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a\t@\x82a\t\x17V[\x90P\x91\x90PV[_a\tQ\x82a\t6V[\x90P\x91\x90PV[a\ta\x81a\tGV[\x81\x14a\tkW__\xFD[PV[_\x81Q\x90Pa\t|\x81a\tXV[\x92\x91PPV[_a\t\x8C\x82a\t6V[\x90P\x91\x90PV[a\t\x9C\x81a\t\x82V[\x81\x14a\t\xA6W__\xFD[PV[_\x81Q\x90Pa\t\xB7\x81a\t\x93V[\x92\x91PPV[_\x81\x90P\x91\x90PV[a\t\xCF\x81a\t\xBDV[\x81\x14a\t\xD9W__\xFD[PV[_\x81Q\x90Pa\t\xEA\x81a\t\xC6V[\x92\x91PPV[________a\x01\0\x89\x8B\x03\x12\x15a\n\rWa\n\x0Ca\t\x13V[[_a\n\x1A\x8B\x82\x8C\x01a\tnV[\x98PP` a\n+\x8B\x82\x8C\x01a\t\xA9V[\x97PP`@a\n<\x8B\x82\x8C\x01a\t\xDCV[\x96PP``a\nM\x8B\x82\x8C\x01a\t\xDCV[\x95PP`\x80a\n^\x8B\x82\x8C\x01a\t\xDCV[\x94PP`\xA0a\no\x8B\x82\x8C\x01a\t\xDCV[\x93PP`\xC0a\n\x80\x8B\x82\x8C\x01a\t\xDCV[\x92PP`\xE0a\n\x91\x8B\x82\x8C\x01a\t\xDCV[\x91PP\x92\x95\x98P\x92\x95\x98\x90\x93\x96PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a\n\xBD\x81a\n\xA1V[\x81\x14a\n\xC7W__\xFD[PV[_\x81Q\x90Pa\n\xD8\x81a\n\xB4V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\n\xF3Wa\n\xF2a\t\x13V[[_a\x0B\0\x84\x82\x85\x01a\n\xCAV[\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x0B\x1EWa\x0B\x1Da\t\x13V[[_a\x0B+\x84\x82\x85\x01a\t\xDCV[\x91PP\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7Fchain is not an l2 bedrock rollu_\x82\x01R\x7Fp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\x0B\x9E`!\x83a\x0B4V[\x91Pa\x0B\xA9\x82a\x0BDV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x0B\xCB\x81a\x0B\x92V[\x90P\x91\x90PV[\x7Fposter address does not have any_\x82\x01R\x7F code\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\x0C,`%\x83a\x0B4V[\x91Pa\x0C7\x82a\x0B\xD2V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x0CY\x81a\x0C V[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a\x0Cr\x81a\x0C`V[\x81\x14a\x0C|W__\xFD[PV[_\x81Q\x90Pa\x0C\x8D\x81a\x0CiV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x0C\xA8Wa\x0C\xA7a\t\x13V[[_a\x0C\xB5\x84\x82\x85\x01a\x0C\x7FV[\x91PP\x92\x91PPV[\x7Finsufficient delayed messages in_\x82\x01R\x7F bridge\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\r\x18`'\x83a\x0B4V[\x91Pa\r#\x82a\x0C\xBEV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\rE\x81a\r\x0CV[\x90P\x91\x90PV[a\rU\x81a\t\xBDV[\x82RPPV[_`@\x82\x01\x90Pa\rn_\x83\x01\x85a\rLV[a\r{` \x83\x01\x84a\rLV[\x93\x92PPPV[\x7Ftee program hash must be non-zer_\x82\x01R\x7Fo\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\r\xDC`!\x83a\x0B4V[\x91Pa\r\xE7\x82a\r\x82V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x0E\t\x81a\r\xD0V[\x90P\x91\x90PV[_` \x82\x01\x90Pa\x0E#_\x83\x01\x84a\rLV[\x92\x91PPV[\x7Fcannot close challenge window - _\x82\x01R\x7Ftoo many assertions\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\x0E\x83`3\x83a\x0B4V[\x91Pa\x0E\x8E\x82a\x0E)V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x0E\xB0\x81a\x0EwV[\x90P\x91\x90PV[\x7Fcannot close challenge window - _\x82\x01R\x7Finsufficient time has passed\0\0\0\0` \x82\x01RPV[_a\x0F\x11`<\x83a\x0B4V[\x91Pa\x0F\x1C\x82a\x0E\xB7V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x0F>\x81a\x0F\x05V[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a\x0F\xA9\x82a\x0C`V[\x91Pa\x0F\xB4\x83a\x0C`V[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15a\x0F\xCCWa\x0F\xCBa\x0FrV[[\x92\x91PPV[a\x0F\xDB\x81a\x0C`V[\x82RPPV[_` \x82\x01\x90Pa\x0F\xF4_\x83\x01\x84a\x0F\xD2V[\x92\x91PPV[_a\x10\x04\x82a\x0C`V[\x91Pa\x10\x0F\x83a\x0C`V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a\x10'Wa\x10&a\x0FrV[[\x92\x91PPV[`\x80Q`\xA0Qa2Ma\x10c_9_\x81\x81a\x0C>\x01R\x81\x81a\x0C|\x01Ra\x18\xD1\x01R_\x81\x81a\x0Bp\x01Ra\x11\xBF\x01Ra2M_\xF3\xFE`\x80`@R`\x046\x10a\x01CW_5`\xE0\x1C\x80cpdn\xA2\x11a\0\xB5W\x80c\xC3\xF2\xDB\xD3\x11a\0nW\x80c\xC3\xF2\xDB\xD3\x14a\x04\"W\x80c\xE5\x0CaV\x14a\x04JW\x80c\xE7\x8C\xEA\x92\x14a\x04rW\x80c\xEE\x1C(\xB8\x14a\x04\x9CW\x80c\xF2#\x05\\\x14a\x04\xC6W\x80c\xF2\xFD\xE3\x8B\x14a\x04\xEEWa\x01JV[\x80cpdn\xA2\x14a\x03*W\x80cqP\x18\xA6\x14a\x03RW\x80c\x80\x95\x97!\x14a\x03hW\x80c\x8D\xA5\xCB[\x14a\x03\x92W\x80c\x8F\xEDU\xA3\x14a\x03\xBCW\x80c\xA5n\xC6\xCD\x14a\x03\xE4Wa\x01JV[\x80cJ\xFF\xFC\xC9\x11a\x01\x07W\x80cJ\xFF\xFC\xC9\x14a\x02FW\x80cK\xD1g\xC9\x14a\x02\x82W\x80c_p\xC4A\x14a\x02\xACW\x80ci{^b\x14a\x02\xD4W\x80clL `\x14a\x02\xFEW\x80cn\xF0\x12\x01\x14a\x03\x14Wa\x01JV[\x80c\x1C\x12B\x7F\x14a\x01NW\x80c\x1C\xAF]\x13\x14a\x01vW\x80c33\x90\x06\x14a\x01\x9EW\x80c<\xEA\xAE}\x14a\x01\xDAW\x80cGt&@\x14a\x02\nWa\x01JV[6a\x01JW\0[__\xFD[4\x80\x15a\x01YW__\xFD[Pa\x01t`\x04\x806\x03\x81\x01\x90a\x01o\x91\x90a EV[a\x05\x16V[\0[4\x80\x15a\x01\x81W__\xFD[Pa\x01\x9C`\x04\x806\x03\x81\x01\x90a\x01\x97\x91\x90a \xA3V[a\x06pV[\0[4\x80\x15a\x01\xA9W__\xFD[Pa\x01\xC4`\x04\x806\x03\x81\x01\x90a\x01\xBF\x91\x90a \xCEV[a\x07=V[`@Qa\x01\xD1\x91\x90a!KV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x01\xE5W__\xFD[Pa\x01\xEEa\x07\x85V[`@Qa\x02\x01\x97\x96\x95\x94\x93\x92\x91\x90a!sV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\x15W__\xFD[Pa\x020`\x04\x806\x03\x81\x01\x90a\x02+\x91\x90a\"\nV[a\x07\xB4V[`@Qa\x02=\x91\x90a\"OV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02QW__\xFD[Pa\x02l`\x04\x806\x03\x81\x01\x90a\x02g\x91\x90a \xA3V[a\x07\xD1V[`@Qa\x02y\x91\x90a\"hV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\x8DW__\xFD[Pa\x02\x96a\x07\xF1V[`@Qa\x02\xA3\x91\x90a\"\x90V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xB7W__\xFD[Pa\x02\xD2`\x04\x806\x03\x81\x01\x90a\x02\xCD\x91\x90a EV[a\x07\xF7V[\0[4\x80\x15a\x02\xDFW__\xFD[Pa\x02\xE8a\t\xDDV[`@Qa\x02\xF5\x91\x90a\"\x90V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\tW__\xFD[Pa\x03\x12a\t\xE3V[\0[4\x80\x15a\x03\x1FW__\xFD[Pa\x03(a\x0E\x15V[\0[4\x80\x15a\x035W__\xFD[Pa\x03P`\x04\x806\x03\x81\x01\x90a\x03K\x91\x90a#\nV[a\x0F\x11V[\0[4\x80\x15a\x03]W__\xFD[Pa\x03fa\x116V[\0[4\x80\x15a\x03sW__\xFD[Pa\x03|a\x11\xBDV[`@Qa\x03\x89\x91\x90a#\xD6V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x9DW__\xFD[Pa\x03\xA6a\x11\xE1V[`@Qa\x03\xB3\x91\x90a!KV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xC7W__\xFD[Pa\x03\xE2`\x04\x806\x03\x81\x01\x90a\x03\xDD\x91\x90a$\x11V[a\x12\x08V[\0[4\x80\x15a\x03\xEFW__\xFD[Pa\x04\n`\x04\x806\x03\x81\x01\x90a\x04\x05\x91\x90a \xA3V[a\x13\xE8V[`@Qa\x04\x19\x93\x92\x91\x90a$<V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04-W__\xFD[Pa\x04H`\x04\x806\x03\x81\x01\x90a\x04C\x91\x90a EV[a\x14\x1DV[\0[4\x80\x15a\x04UW__\xFD[Pa\x04p`\x04\x806\x03\x81\x01\x90a\x04k\x91\x90a$qV[a\x15+V[\0[4\x80\x15a\x04}W__\xFD[Pa\x04\x86a\x18\xCFV[`@Qa\x04\x93\x91\x90a%\x02V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xA7W__\xFD[Pa\x04\xB0a\x18\xF3V[`@Qa\x04\xBD\x91\x90a\"\x90V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xD1W__\xFD[Pa\x04\xEC`\x04\x806\x03\x81\x01\x90a\x04\xE7\x91\x90a EV[a\x18\xF9V[\0[4\x80\x15a\x04\xF9W__\xFD[Pa\x05\x14`\x04\x806\x03\x81\x01\x90a\x05\x0F\x91\x90a\"\nV[a\x1A\x05V[\0[a\x05\x1Ea\x1A\xFBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x05<a\x11\xE1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x05\x92W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05\x89\x90a%uV[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\n\x80T\x90P\x81\x10\x15a\x06\x0FW\x81`\n\x82\x81T\x81\x10a\x05\xB9Wa\x05\xB8a%\x93V[[\x90_R` _ \x01T\x03a\x06\x02W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05\xF9\x90a&\nV[`@Q\x80\x91\x03\x90\xFD[\x80\x80`\x01\x01\x91PPa\x05\x97V[P`\n\x81\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91PU\x7F\x9Azdi\xC2\\\xF0\x17\x89\x06\x07i^J\x14\x9C\xC7q\xF2\x94\xFD\x87\x1E \x80\xD2L\xD1\t\x03:\xB6\x81`@Qa\x06e\x91\x90a\"hV[`@Q\x80\x91\x03\x90\xA1PV[a\x06xa\x1A\xFBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x06\x96a\x11\xE1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x06\xECW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xE3\x90a%uV[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x14a\x073W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x07*\x90a&\x98V[`@Q\x80\x91\x03\x90\xFD[\x80`\x0E\x81\x90UPPV[`\x0B` R\x81_R`@_ \x81\x81T\x81\x10a\x07VW_\x80\xFD[\x90_R` _ \x01_\x91P\x91P\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[`\x01\x80_\x01T\x90\x80`\x01\x01T\x90\x80`\x02\x01T\x90\x80`\x03\x01T\x90\x80`\x04\x01T\x90\x80`\x05\x01T\x90\x80`\x06\x01T\x90P\x87V[`\x0C` R\x80_R`@_ _\x91PT\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[`\n\x81\x81T\x81\x10a\x07\xE0W_\x80\xFD[\x90_R` _ \x01_\x91P\x90PT\x81V[`\x0ET\x81V[a\x07\xFFa\x1A\xFBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x08\x1Da\x11\xE1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x08sW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08j\x90a%uV[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x14a\x08\xBAW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08\xB1\x90a'&V[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x0B_\x83\x81R` \x01\x90\x81R` \x01_ \x80T\x90P\x81\x10\x15a\t\x86W_`\x0C_`\x0B_\x86\x81R` \x01\x90\x81R` \x01_ \x84\x81T\x81\x10a\t\x02Wa\t\x01a%\x93V[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa\x08\xBFV[P`\x0B_\x82\x81R` \x01\x90\x81R` \x01_ _a\t\xA3\x91\x90a\x1FLV[\x7F&!\xC6\x1D3\x15\xF2\xA3\xD2k\"\xD7F\xBA!\xA9m$\x9FQ\xAD\xA3#\xF7\"l\xCE_\xE5\xFC=d\x81`@Qa\t\xD2\x91\x90a\"hV[`@Q\x80\x91\x03\x90\xA1PV[`\tT\x81V[`\x01`\x08\x80T\x90P\x11\x15a\n,W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\n#\x90a'\xB4V[`@Q\x80\x91\x03\x90\xFD[`\rTsB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xB8\x07w\xEA`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n\x8CW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\xB0\x91\x90a(\x0FV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11a\n\xFAW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\n\xF1\x90a(\xAAV[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x11\x15a\x0C<W`\x08_\x81T\x81\x10a\x0B\x1BWa\x0B\x1Aa%\x93V[[\x90_R` _ \x90`\x03\x02\x01_\x01T`\x01\x80\x01\x81\x90UP`\x08_\x81T\x81\x10a\x0BFWa\x0BEa%\x93V[[\x90_R` _ \x90`\x03\x02\x01`\x02\x01T`\x01`\x03\x01\x81\x90UP`\x01`\x06\x01T`\x01`\x05\x01\x81\x90UP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xDA\xEA\xB4\x12`\x08_\x81T\x81\x10a\x0B\xBEWa\x0B\xBDa%\x93V[[\x90_R` _ \x90`\x03\x02\x01_\x01T`\x08_\x81T\x81\x10a\x0B\xE1Wa\x0B\xE0a%\x93V[[\x90_R` _ \x90`\x03\x02\x01`\x01\x01T`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0C\x0E\x92\x91\x90a(\xC8V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0C%W__\xFD[PZ\xF1\x15\x80\x15a\x0C7W=__>=_\xFD[PPPP[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD5q\x9D\xC2`\x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xEC\xA0g\xAD`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0C\xE3W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r\x07\x91\x90a)\x03V[a\r\x11\x91\x90a)[V[`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\r-\x91\x90a\"\x90V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\rHW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\rl\x91\x90a)\xA2V[`\x01`\x04\x01\x81\x90UPsB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\t\xBDZ``@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\r\xD2W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r\xF6\x91\x90a)\xA2V[`\x01`\x06\x01\x81\x90UP`\x0ETBa\x0E\r\x91\x90a)\xCDV[`\r\x81\x90UPV[a\x0E\x1Da\x1A\xFBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x0E;a\x11\xE1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x0E\x91W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0E\x88\x90a%uV[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\n\x80T\x90P\x81\x10\x15a\x0E\xD5Wa\x0E\xC8`\n\x82\x81T\x81\x10a\x0E\xBAWa\x0E\xB9a%\x93V[[\x90_R` _ \x01Ta\x07\xF7V[\x80\x80`\x01\x01\x91PPa\x0E\x96V[P`\n_a\x0E\xE3\x91\x90a\x1FjV[\x7F\xEC\xA6.\0t\xA1:\x90\xD6\0\xF0\x03\xB7\xCB\x8D[\xD5\x01\0\0\x8D?9\x15\xF2UO?\x85R\xC5\xCC`@Q`@Q\x80\x91\x03\x90\xA1V[`\x01\x82\x82\x90P\x14a\x0FWW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0FN\x90a*JV[`@Q\x80\x91\x03\x90\xFD[`\x0C_\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a\x0F\xE1W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0F\xD8\x90a*\xB2V[`@Q\x80\x91\x03\x90\xFD[_`\x0B_\x85\x81R` \x01\x90\x81R` \x01_ \x80T\x90P\x03a\x10kW__\x90P_`\n\x80T\x90P\x90P[_\x81\x11\x15a\x10]W\x84`\n`\x01\x83a\x10\"\x91\x90a)[V[\x81T\x81\x10a\x103Wa\x102a%\x93V[[\x90_R` _ \x01T\x03a\x10JW`\x01\x91Pa\x10]V[\x80\x80a\x10U\x90a*\xD0V[\x91PPa\x10\nV[P\x80a\x10iWPa\x110V[P[`\x01`\x0C_\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP`\x0B_\x84\x81R` \x01\x90\x81R` \x01_ \x84\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP[PPPPV[a\x11>a\x1A\xFBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x11\\a\x11\xE1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x11\xB2W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x11\xA9\x90a%uV[`@Q\x80\x91\x03\x90\xFD[a\x11\xBB_a\x1B\x02V[V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[___\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[a\x12\x10a\x1A\xFBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x12.a\x11\xE1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x12\x84W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x12{\x90a%uV[`@Q\x80\x91\x03\x90\xFD[`\x01`\x08\x80T\x90P\x11a\x12\xCCW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x12\xC3\x90a+AV[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x08\x80T\x90P\x81\x10\x15a\x13\xA9Wa\x13\x07\x82`\x08\x83\x81T\x81\x10a\x12\xF6Wa\x12\xF5a%\x93V[[\x90_R` _ \x90`\x03\x02\x01a\x1B\xC3V[\x15a\x13\x9CW`\x08_a\x13\x19\x91\x90a\x1F\x88V[`\x08\x82\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x03\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a\x13N\x91\x90a,uV[PP_`\r\x81\x90UPa\x13_a\t\xE3V[\x7F\xE4.\xAF\x077\xE2G\x8A_Z\xED:\x06\x10\xAE{\t\xA2|\xBA\xC9\xADj\\\xC4\xD6\x8Fx\xAF\xD1B[\x82`@Qa\x13\x8E\x91\x90a-\0V[`@Q\x80\x91\x03\x90\xA1Pa\x13\xE5V[\x80\x80`\x01\x01\x91PPa\x12\xD1V[P`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\xDC\x90a-cV[`@Q\x80\x91\x03\x90\xFD[PV[`\x08\x81\x81T\x81\x10a\x13\xF7W_\x80\xFD[\x90_R` _ \x90`\x03\x02\x01_\x91P\x90P\x80_\x01T\x90\x80`\x01\x01T\x90\x80`\x02\x01T\x90P\x83V[a\x14%a\x1A\xFBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x14Ca\x11\xE1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x14\x99W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14\x90\x90a%uV[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x14a\x14\xE0W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14\xD7\x90a-\xF1V[`@Q\x80\x91\x03\x90\xFD[\x80`\x01`\x02\x01\x81\x90UP\x7F\xB9\xEB \xB3/\xAC\x96X\x84\xCBX2a\x02%|\xAE`E\x04\xF0\xA3l\xD1\0\x8A2\x84Z\xD5\xC2\x9B\x81`\x01`\x03\x01T`@Qa\x15 \x92\x91\x90a(\xC8V[`@Q\x80\x91\x03\x90\xA1PV[`A\x83\x83\x90P\x14a\x15qW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x15h\x90a.YV[`@Q\x80\x91\x03\x90\xFD[_a\x15|`\x01a\x1B\xFBV[\x85_\x015\x86` \x015`@Q` \x01a\x15\x97\x93\x92\x91\x90a.\x97V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P`\x0C_a\x16\x10\x86\x86\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x81\x84\x01R`\x1F\x19`\x1F\x82\x01\x16\x90P\x80\x83\x01\x92PPPPPPPa\x16\x02\x85a\x1CQV[a\x1C\x84\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x16\x95W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x16\x8C\x90a/\x1DV[`@Q\x80\x91\x03\x90\xFD[`\x01\x80\x01T\x85_\x015\x03a\x16\xDEW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x16\xD5\x90a/\x85V[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x08\x80T\x90P\x81\x10\x15a\x17fWa\x17\x19\x86`\x08\x83\x81T\x81\x10a\x17\x08Wa\x17\x07a%\x93V[[\x90_R` _ \x90`\x03\x02\x01a\x1B\xC3V[\x15a\x17YW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x17P\x90a/\xEDV[`@Q\x80\x91\x03\x90\xFD[\x80\x80`\x01\x01\x91PPa\x16\xE3V[P_`\x08\x80T\x90P\x03a\x17\x88W`\x0ETBa\x17\x81\x91\x90a)\xCDV[`\r\x81\x90UP[`\x08\x85\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x03\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a\x17\xBD\x91\x90a,uV[PP`\x02`\x08\x80T\x90P\x03a\x18\xC8W`\x01`\t_\x82\x82Ta\x17\xDE\x91\x90a)\xCDV[\x92PP\x81\x90UP\x7F7\xE8\xAD\xD6\x94\xC5\x92mVN\x97\x11`\xF5\x97A\x03\xCB\xBB\xC7\xC9\x07G\xC4\xC6\xF8\x02\x03\x1D5g\xA7`\tT`@Qa\x18\x16\x91\x90a\"\x90V[`@Q\x80\x91\x03\x90\xA1_\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16G`@Qa\x18C\x90a08V[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a\x18}W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x18\x82V[``\x91P[PP\x90P\x80a\x18\xC6W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x18\xBD\x90a0\x96V[`@Q\x80\x91\x03\x90\xFD[P[PPPPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`\rT\x81V[a\x19\x01a\x1A\xFBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x19\x1Fa\x11\xE1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x19uW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x19l\x90a%uV[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x14a\x19\xBCW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x19\xB3\x90a-\xF1V[`@Q\x80\x91\x03\x90\xFD[\x80`\x01_\x01\x81\x90UP\x7F\xC9\x85\xBC\xCB\xD0\xC9\x0E\x19\x7FJss\x02\n3\xBAo\xF8d\xD09\x9F\xD7\xD6\\\\|2\xFF\xB0\x15\xEC\x81`\x01\x80\x01T`@Qa\x19\xFA\x92\x91\x90a(\xC8V[`@Q\x80\x91\x03\x90\xA1PV[a\x1A\ra\x1A\xFBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1A+a\x11\xE1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1A\x81W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1Ax\x90a%uV[`@Q\x80\x91\x03\x90\xFD[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x1A\xEFW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1A\xE6\x90a1$V[`@Q\x80\x91\x03\x90\xFD[a\x1A\xF8\x81a\x1B\x02V[PV[_3\x90P\x90V[___\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81__a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPV[_\x81_\x01T\x83_\x015\x14\x80\x15a\x1B\xE0WP\x81`\x01\x01T\x83` \x015\x14[\x80\x15a\x1B\xF3WP\x81`\x02\x01T\x83`@\x015\x14[\x90P\x92\x91PPV[_\x81_\x01T\x82`\x01\x01T\x83`\x02\x01T\x84`\x03\x01T\x85`\x04\x01T\x86`\x05\x01T\x87`\x06\x01T`@Q` \x01a\x1C4\x97\x96\x95\x94\x93\x92\x91\x90a1BV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x91\x90PV[_\x7F\x19Ethereum Signed Message:\n32\0\0\0\0_R\x81`\x1CR`<_ \x90P\x91\x90PV[____a\x1C\x92\x86\x86a\x1C\xAEV[\x92P\x92P\x92Pa\x1C\xA2\x82\x82a\x1D\x03V[\x82\x93PPPP\x92\x91PPV[___`A\x84Q\x03a\x1C\xEEW___` \x87\x01Q\x92P`@\x87\x01Q\x91P``\x87\x01Q_\x1A\x90Pa\x1C\xE0\x88\x82\x85\x85a\x1EeV[\x95P\x95P\x95PPPPa\x1C\xFCV[_`\x02\x85Q_\x1B\x92P\x92P\x92P[\x92P\x92P\x92V[_`\x03\x81\x11\x15a\x1D\x16Wa\x1D\x15a1\xC2V[[\x82`\x03\x81\x11\x15a\x1D)Wa\x1D(a1\xC2V[[\x03\x15a\x1EaW`\x01`\x03\x81\x11\x15a\x1DCWa\x1DBa1\xC2V[[\x82`\x03\x81\x11\x15a\x1DVWa\x1DUa1\xC2V[[\x03a\x1D\x8DW`@Q\x7F\xF6E\xEE\xDF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`\x03\x81\x11\x15a\x1D\xA1Wa\x1D\xA0a1\xC2V[[\x82`\x03\x81\x11\x15a\x1D\xB4Wa\x1D\xB3a1\xC2V[[\x03a\x1D\xF8W\x80_\x1C`@Q\x7F\xFC\xE6\x98\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1D\xEF\x91\x90a\"\x90V[`@Q\x80\x91\x03\x90\xFD[`\x03\x80\x81\x11\x15a\x1E\x0BWa\x1E\na1\xC2V[[\x82`\x03\x81\x11\x15a\x1E\x1EWa\x1E\x1Da1\xC2V[[\x03a\x1E`W\x80`@Q\x7F\xD7\x8B\xCE\x0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1EW\x91\x90a\"hV[`@Q\x80\x91\x03\x90\xFD[[PPV[___\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0\x84_\x1C\x11\x15a\x1E\xA1W_`\x03\x85\x92P\x92P\x92Pa\x1FBV[_`\x01\x88\x88\x88\x88`@Q_\x81R` \x01`@R`@Qa\x1E\xC4\x94\x93\x92\x91\x90a2\nV[` `@Q` \x81\x03\x90\x80\x84\x03\x90\x85Z\xFA\x15\x80\x15a\x1E\xE4W=__>=_\xFD[PPP` `@Q\x03Q\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x1F5W_`\x01__\x1B\x93P\x93P\x93PPa\x1FBV[\x80___\x1B\x93P\x93P\x93PP[\x94P\x94P\x94\x91PPV[P\x80T_\x82U\x90_R` _ \x90\x81\x01\x90a\x1Fg\x91\x90a\x1F\xA9V[PV[P\x80T_\x82U\x90_R` _ \x90\x81\x01\x90a\x1F\x85\x91\x90a\x1F\xC4V[PV[P\x80T_\x82U`\x03\x02\x90_R` _ \x90\x81\x01\x90a\x1F\xA6\x91\x90a\x1F\xDFV[PV[[\x80\x82\x11\x15a\x1F\xC0W_\x81_\x90UP`\x01\x01a\x1F\xAAV[P\x90V[[\x80\x82\x11\x15a\x1F\xDBW_\x81_\x90UP`\x01\x01a\x1F\xC5V[P\x90V[[\x80\x82\x11\x15a \x06W__\x82\x01_\x90U`\x01\x82\x01_\x90U`\x02\x82\x01_\x90UP`\x03\x01a\x1F\xE0V[P\x90V[__\xFD[__\xFD[_\x81\x90P\x91\x90PV[a $\x81a \x12V[\x81\x14a .W__\xFD[PV[_\x815\x90Pa ?\x81a \x1BV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a ZWa Ya \nV[[_a g\x84\x82\x85\x01a 1V[\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[a \x82\x81a pV[\x81\x14a \x8CW__\xFD[PV[_\x815\x90Pa \x9D\x81a yV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a \xB8Wa \xB7a \nV[[_a \xC5\x84\x82\x85\x01a \x8FV[\x91PP\x92\x91PPV[__`@\x83\x85\x03\x12\x15a \xE4Wa \xE3a \nV[[_a \xF1\x85\x82\x86\x01a 1V[\x92PP` a!\x02\x85\x82\x86\x01a \x8FV[\x91PP\x92P\x92\x90PV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a!5\x82a!\x0CV[\x90P\x91\x90PV[a!E\x81a!+V[\x82RPPV[_` \x82\x01\x90Pa!^_\x83\x01\x84a!<V[\x92\x91PPV[a!m\x81a \x12V[\x82RPPV[_`\xE0\x82\x01\x90Pa!\x86_\x83\x01\x8Aa!dV[a!\x93` \x83\x01\x89a!dV[a!\xA0`@\x83\x01\x88a!dV[a!\xAD``\x83\x01\x87a!dV[a!\xBA`\x80\x83\x01\x86a!dV[a!\xC7`\xA0\x83\x01\x85a!dV[a!\xD4`\xC0\x83\x01\x84a!dV[\x98\x97PPPPPPPPV[a!\xE9\x81a!+V[\x81\x14a!\xF3W__\xFD[PV[_\x815\x90Pa\"\x04\x81a!\xE0V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\"\x1FWa\"\x1Ea \nV[[_a\",\x84\x82\x85\x01a!\xF6V[\x91PP\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[a\"I\x81a\"5V[\x82RPPV[_` \x82\x01\x90Pa\"b_\x83\x01\x84a\"@V[\x92\x91PPV[_` \x82\x01\x90Pa\"{_\x83\x01\x84a!dV[\x92\x91PPV[a\"\x8A\x81a pV[\x82RPPV[_` \x82\x01\x90Pa\"\xA3_\x83\x01\x84a\"\x81V[\x92\x91PPV[__\xFD[__\xFD[__\xFD[__\x83`\x1F\x84\x01\x12a\"\xCAWa\"\xC9a\"\xA9V[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\"\xE7Wa\"\xE6a\"\xADV[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15a#\x03Wa#\x02a\"\xB1V[[\x92P\x92\x90PV[____``\x85\x87\x03\x12\x15a#\"Wa#!a \nV[[_a#/\x87\x82\x88\x01a!\xF6V[\x94PP` a#@\x87\x82\x88\x01a 1V[\x93PP`@\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a#aWa#`a \x0EV[[a#m\x87\x82\x88\x01a\"\xB5V[\x92P\x92PP\x92\x95\x91\x94P\x92PV[_\x81\x90P\x91\x90PV[_a#\x9Ea#\x99a#\x94\x84a!\x0CV[a#{V[a!\x0CV[\x90P\x91\x90PV[_a#\xAF\x82a#\x84V[\x90P\x91\x90PV[_a#\xC0\x82a#\xA5V[\x90P\x91\x90PV[a#\xD0\x81a#\xB6V[\x82RPPV[_` \x82\x01\x90Pa#\xE9_\x83\x01\x84a#\xC7V[\x92\x91PPV[__\xFD[_``\x82\x84\x03\x12\x15a$\x08Wa$\x07a#\xEFV[[\x81\x90P\x92\x91PPV[_``\x82\x84\x03\x12\x15a$&Wa$%a \nV[[_a$3\x84\x82\x85\x01a#\xF3V[\x91PP\x92\x91PPV[_``\x82\x01\x90Pa$O_\x83\x01\x86a!dV[a$\\` \x83\x01\x85a!dV[a$i`@\x83\x01\x84a!dV[\x94\x93PPPPV[____`\xA0\x85\x87\x03\x12\x15a$\x89Wa$\x88a \nV[[_a$\x96\x87\x82\x88\x01a#\xF3V[\x94PP``\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$\xB7Wa$\xB6a \x0EV[[a$\xC3\x87\x82\x88\x01a\"\xB5V[\x93P\x93PP`\x80a$\xD6\x87\x82\x88\x01a!\xF6V[\x91PP\x92\x95\x91\x94P\x92PV[_a$\xEC\x82a#\xA5V[\x90P\x91\x90PV[a$\xFC\x81a$\xE2V[\x82RPPV[_` \x82\x01\x90Pa%\x15_\x83\x01\x84a$\xF3V[\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7FOwnable: caller is not the owner_\x82\x01RPV[_a%_` \x83a%\x1BV[\x91Pa%j\x82a%+V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra%\x8C\x81a%SV[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x7Ftee program already exists\0\0\0\0\0\0_\x82\x01RPV[_a%\xF4`\x1A\x83a%\x1BV[\x91Pa%\xFF\x82a%\xC0V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra&!\x81a%\xE8V[\x90P\x91\x90PV[\x7Fcannot update challenge window w_\x82\x01R\x7Fhile assertion is pending\0\0\0\0\0\0\0` \x82\x01RPV[_a&\x82`9\x83a%\x1BV[\x91Pa&\x8D\x82a&(V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra&\xAF\x81a&vV[\x90P\x91\x90PV[\x7Fcannot remove tee program while _\x82\x01R\x7Fassertion is pending\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a'\x10`4\x83a%\x1BV[\x91Pa'\x1B\x82a&\xB6V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra'=\x81a'\x04V[\x90P\x91\x90PV[\x7Fcannot close challenge window - _\x82\x01R\x7Ftoo many assertions\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a'\x9E`3\x83a%\x1BV[\x91Pa'\xA9\x82a'DV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra'\xCB\x81a'\x92V[\x90P\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a'\xEE\x81a'\xD2V[\x81\x14a'\xF8W__\xFD[PV[_\x81Q\x90Pa(\t\x81a'\xE5V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a($Wa(#a \nV[[_a(1\x84\x82\x85\x01a'\xFBV[\x91PP\x92\x91PPV[\x7Fcannot close challenge window - _\x82\x01R\x7Finsufficient time has passed\0\0\0\0` \x82\x01RPV[_a(\x94`<\x83a%\x1BV[\x91Pa(\x9F\x82a(:V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra(\xC1\x81a(\x88V[\x90P\x91\x90PV[_`@\x82\x01\x90Pa(\xDB_\x83\x01\x85a!dV[a(\xE8` \x83\x01\x84a!dV[\x93\x92PPPV[_\x81Q\x90Pa(\xFD\x81a yV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a)\x18Wa)\x17a \nV[[_a)%\x84\x82\x85\x01a(\xEFV[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a)e\x82a pV[\x91Pa)p\x83a pV[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15a)\x88Wa)\x87a).V[[\x92\x91PPV[_\x81Q\x90Pa)\x9C\x81a \x1BV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a)\xB7Wa)\xB6a \nV[[_a)\xC4\x84\x82\x85\x01a)\x8EV[\x91PP\x92\x91PPV[_a)\xD7\x82a pV[\x91Pa)\xE2\x83a pV[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a)\xFAWa)\xF9a).V[[\x92\x91PPV[\x7Ftodo: validate zk zkProof\0\0\0\0\0\0\0_\x82\x01RPV[_a*4`\x19\x83a%\x1BV[\x91Pa*?\x82a*\0V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra*a\x81a*(V[\x90P\x91\x90PV[\x7Fkey already added\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a*\x9C`\x11\x83a%\x1BV[\x91Pa*\xA7\x82a*hV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra*\xC9\x81a*\x90V[\x90P\x91\x90PV[_a*\xDA\x82a pV[\x91P_\x82\x03a*\xECWa*\xEBa).V[[`\x01\x82\x03\x90P\x91\x90PV[\x7Fchallenge does not exist\0\0\0\0\0\0\0\0_\x82\x01RPV[_a++`\x18\x83a%\x1BV[\x91Pa+6\x82a*\xF7V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra+X\x81a+\x1FV[\x90P\x91\x90PV[_\x815a+k\x81a \x1BV[\x80\x91PP\x91\x90PV[_\x81_\x1B\x90P\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa+\xAA\x84a+tV[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_a+\xCA\x82a \x12V[\x90P\x91\x90PV[_\x81_\x1C\x90P\x91\x90PV[_a+\xE6\x82a+\xD1V[\x90P\x91\x90PV[a+\xF6\x82a+\xC0V[a,\ta,\x02\x82a+\xDCV[\x83Ta+\x7FV[\x82UPPPV[_\x81\x01_\x83\x01\x80a, \x81a+_V[\x90Pa,,\x81\x84a+\xEDV[PPP`\x01\x81\x01` \x83\x01\x80a,A\x81a+_V[\x90Pa,M\x81\x84a+\xEDV[PPP`\x02\x81\x01`@\x83\x01\x80a,b\x81a+_V[\x90Pa,n\x81\x84a+\xEDV[PPPPPV[a,\x7F\x82\x82a,\x10V[PPV[_a,\x91` \x84\x01\x84a 1V[\x90P\x92\x91PPV[a,\xA2\x81a \x12V[\x82RPPV[``\x82\x01a,\xB8_\x83\x01\x83a,\x83V[a,\xC4_\x85\x01\x82a,\x99V[Pa,\xD2` \x83\x01\x83a,\x83V[a,\xDF` \x85\x01\x82a,\x99V[Pa,\xED`@\x83\x01\x83a,\x83V[a,\xFA`@\x85\x01\x82a,\x99V[PPPPV[_``\x82\x01\x90Pa-\x13_\x83\x01\x84a,\xA8V[\x92\x91PPV[\x7Fassertion not found\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a-M`\x13\x83a%\x1BV[\x91Pa-X\x82a-\x19V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra-z\x81a-AV[\x90P\x91\x90PV[\x7Fcannot update config hash while _\x82\x01R\x7Fassertions are pending\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a-\xDB`6\x83a%\x1BV[\x91Pa-\xE6\x82a-\x81V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra.\x08\x81a-\xCFV[\x90P\x91\x90PV[\x7Finvalid signature length\0\0\0\0\0\0\0\0_\x82\x01RPV[_a.C`\x18\x83a%\x1BV[\x91Pa.N\x82a.\x0FV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra.p\x81a.7V[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a.\x91a.\x8C\x82a \x12V[a.wV[\x82RPPV[_a.\xA2\x82\x86a.\x80V[` \x82\x01\x91Pa.\xB2\x82\x85a.\x80V[` \x82\x01\x91Pa.\xC2\x82\x84a.\x80V[` \x82\x01\x91P\x81\x90P\x94\x93PPPPV[\x7Finvalid tee signature\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a/\x07`\x15\x83a%\x1BV[\x91Pa/\x12\x82a.\xD3V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra/4\x81a.\xFBV[\x90P\x91\x90PV[\x7Fappchain block hash unchanged\0\0\0_\x82\x01RPV[_a/o`\x1D\x83a%\x1BV[\x91Pa/z\x82a/;V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra/\x9C\x81a/cV[\x90P\x91\x90PV[\x7Fassertion already exists\0\0\0\0\0\0\0\0_\x82\x01RPV[_a/\xD7`\x18\x83a%\x1BV[\x91Pa/\xE2\x82a/\xA3V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra0\x04\x81a/\xCBV[\x90P\x91\x90PV[_\x81\x90P\x92\x91PPV[PV[_a0#_\x83a0\x0BV[\x91Pa0.\x82a0\x15V[_\x82\x01\x90P\x91\x90PV[_a0B\x82a0\x18V[\x91P\x81\x90P\x91\x90PV[\x7Fpayment failed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a0\x80`\x0E\x83a%\x1BV[\x91Pa0\x8B\x82a0LV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra0\xAD\x81a0tV[\x90P\x91\x90PV[\x7FOwnable: new owner is the zero a_\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a1\x0E`&\x83a%\x1BV[\x91Pa1\x19\x82a0\xB4V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra1;\x81a1\x02V[\x90P\x91\x90PV[_a1M\x82\x8Aa.\x80V[` \x82\x01\x91Pa1]\x82\x89a.\x80V[` \x82\x01\x91Pa1m\x82\x88a.\x80V[` \x82\x01\x91Pa1}\x82\x87a.\x80V[` \x82\x01\x91Pa1\x8D\x82\x86a.\x80V[` \x82\x01\x91Pa1\x9D\x82\x85a.\x80V[` \x82\x01\x91Pa1\xAD\x82\x84a.\x80V[` \x82\x01\x91P\x81\x90P\x98\x97PPPPPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[_`\xFF\x82\x16\x90P\x91\x90PV[a2\x04\x81a1\xEFV[\x82RPPV[_`\x80\x82\x01\x90Pa2\x1D_\x83\x01\x87a!dV[a2*` \x83\x01\x86a1\xFBV[a27`@\x83\x01\x85a!dV[a2D``\x83\x01\x84a!dV[\x95\x94PPPPPV",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405260043610610143575f3560e01c806370646ea2116100b5578063c3f2dbd31161006e578063c3f2dbd314610422578063e50c61561461044a578063e78cea9214610472578063ee1c28b81461049c578063f223055c146104c6578063f2fde38b146104ee5761014a565b806370646ea21461032a578063715018a61461035257806380959721146103685780638da5cb5b146103925780638fed55a3146103bc578063a56ec6cd146103e45761014a565b80634afffcc9116101075780634afffcc9146102465780634bd167c9146102825780635f70c441146102ac578063697b5e62146102d45780636c4c2060146102fe5780636ef01201146103145761014a565b80631c12427f1461014e5780631caf5d1314610176578063333390061461019e5780633ceaae7d146101da578063477426401461020a5761014a565b3661014a57005b5f5ffd5b348015610159575f5ffd5b50610174600480360381019061016f9190612045565b610516565b005b348015610181575f5ffd5b5061019c600480360381019061019791906120a3565b610670565b005b3480156101a9575f5ffd5b506101c460048036038101906101bf91906120ce565b61073d565b6040516101d1919061214b565b60405180910390f35b3480156101e5575f5ffd5b506101ee610785565b6040516102019796959493929190612173565b60405180910390f35b348015610215575f5ffd5b50610230600480360381019061022b919061220a565b6107b4565b60405161023d919061224f565b60405180910390f35b348015610251575f5ffd5b5061026c600480360381019061026791906120a3565b6107d1565b6040516102799190612268565b60405180910390f35b34801561028d575f5ffd5b506102966107f1565b6040516102a39190612290565b60405180910390f35b3480156102b7575f5ffd5b506102d260048036038101906102cd9190612045565b6107f7565b005b3480156102df575f5ffd5b506102e86109dd565b6040516102f59190612290565b60405180910390f35b348015610309575f5ffd5b506103126109e3565b005b34801561031f575f5ffd5b50610328610e15565b005b348015610335575f5ffd5b50610350600480360381019061034b919061230a565b610f11565b005b34801561035d575f5ffd5b50610366611136565b005b348015610373575f5ffd5b5061037c6111bd565b60405161038991906123d6565b60405180910390f35b34801561039d575f5ffd5b506103a66111e1565b6040516103b3919061214b565b60405180910390f35b3480156103c7575f5ffd5b506103e260048036038101906103dd9190612411565b611208565b005b3480156103ef575f5ffd5b5061040a600480360381019061040591906120a3565b6113e8565b6040516104199392919061243c565b60405180910390f35b34801561042d575f5ffd5b5061044860048036038101906104439190612045565b61141d565b005b348015610455575f5ffd5b50610470600480360381019061046b9190612471565b61152b565b005b34801561047d575f5ffd5b506104866118cf565b6040516104939190612502565b60405180910390f35b3480156104a7575f5ffd5b506104b06118f3565b6040516104bd9190612290565b60405180910390f35b3480156104d1575f5ffd5b506104ec60048036038101906104e79190612045565b6118f9565b005b3480156104f9575f5ffd5b50610514600480360381019061050f919061220a565b611a05565b005b61051e611afb565b73ffffffffffffffffffffffffffffffffffffffff1661053c6111e1565b73ffffffffffffffffffffffffffffffffffffffff1614610592576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161058990612575565b60405180910390fd5b5f5f90505b600a8054905081101561060f5781600a82815481106105b9576105b8612593565b5b905f5260205f20015403610602576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105f99061260a565b60405180910390fd5b8080600101915050610597565b50600a81908060018154018082558091505060019003905f5260205f20015f90919091909150557f9a7a6469c25cf017890607695e4a149cc771f294fd871e2080d24cd109033ab6816040516106659190612268565b60405180910390a150565b610678611afb565b73ffffffffffffffffffffffffffffffffffffffff166106966111e1565b73ffffffffffffffffffffffffffffffffffffffff16146106ec576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106e390612575565b60405180910390fd5b5f60088054905014610733576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161072a90612698565b60405180910390fd5b80600e8190555050565b600b602052815f5260405f208181548110610756575f80fd5b905f5260205f20015f915091509054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6001805f0154908060010154908060020154908060030154908060040154908060050154908060060154905087565b600c602052805f5260405f205f915054906101000a900460ff1681565b600a81815481106107e0575f80fd5b905f5260205f20015f915090505481565b600e5481565b6107ff611afb565b73ffffffffffffffffffffffffffffffffffffffff1661081d6111e1565b73ffffffffffffffffffffffffffffffffffffffff1614610873576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161086a90612575565b60405180910390fd5b5f600880549050146108ba576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108b190612726565b60405180910390fd5b5f5f90505b600b5f8381526020019081526020015f2080549050811015610986575f600c5f600b5f8681526020019081526020015f20848154811061090257610901612593565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff02191690831515021790555080806001019150506108bf565b50600b5f8281526020019081526020015f205f6109a39190611f4c565b7f2621c61d3315f2a3d26b22d746ba21a96d249f51ada323f7226cce5fe5fc3d64816040516109d29190612268565b60405180910390a150565b60095481565b60016008805490501115610a2c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a23906127b4565b60405180910390fd5b600d5473420000000000000000000000000000000000001573ffffffffffffffffffffffffffffffffffffffff1663b80777ea6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a8c573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610ab0919061280f565b67ffffffffffffffff1611610afa576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610af1906128aa565b60405180910390fd5b5f6008805490501115610c3c5760085f81548110610b1b57610b1a612593565b5b905f5260205f2090600302015f0154600180018190555060085f81548110610b4657610b45612593565b5b905f5260205f209060030201600201546001600301819055506001600601546001600501819055507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663daeab41260085f81548110610bbe57610bbd612593565b5b905f5260205f2090600302015f015460085f81548110610be157610be0612593565b5b905f5260205f209060030201600101546040518363ffffffff1660e01b8152600401610c0e9291906128c8565b5f604051808303815f87803b158015610c25575f5ffd5b505af1158015610c37573d5f5f3e3d5ffd5b505050505b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663d5719dc260017f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663eca067ad6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ce3573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d079190612903565b610d11919061295b565b6040518263ffffffff1660e01b8152600401610d2d9190612290565b602060405180830381865afa158015610d48573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d6c91906129a2565b60016004018190555073420000000000000000000000000000000000001573ffffffffffffffffffffffffffffffffffffffff166309bd5a606040518163ffffffff1660e01b8152600401602060405180830381865afa158015610dd2573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610df691906129a2565b600160060181905550600e5442610e0d91906129cd565b600d81905550565b610e1d611afb565b73ffffffffffffffffffffffffffffffffffffffff16610e3b6111e1565b73ffffffffffffffffffffffffffffffffffffffff1614610e91576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610e8890612575565b60405180910390fd5b5f5f90505b600a80549050811015610ed557610ec8600a8281548110610eba57610eb9612593565b5b905f5260205f2001546107f7565b8080600101915050610e96565b50600a5f610ee39190611f6a565b7feca62e0074a13a90d600f003b7cb8d5bd50100008d3f3915f2554f3f8552c5cc60405160405180910390a1565b60018282905014610f57576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610f4e90612a4a565b60405180910390fd5b600c5f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1615610fe1576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610fd890612ab2565b60405180910390fd5b5f600b5f8581526020019081526020015f20805490500361106b575f5f90505f600a8054905090505b5f81111561105d5784600a600183611022919061295b565b8154811061103357611032612593565b5b905f5260205f2001540361104a576001915061105d565b808061105590612ad0565b91505061100a565b50806110695750611130565b505b6001600c5f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550600b5f8481526020019081526020015f2084908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b50505050565b61113e611afb565b73ffffffffffffffffffffffffffffffffffffffff1661115c6111e1565b73ffffffffffffffffffffffffffffffffffffffff16146111b2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016111a990612575565b60405180910390fd5b6111bb5f611b02565b565b7f000000000000000000000000000000000000000000000000000000000000000081565b5f5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b611210611afb565b73ffffffffffffffffffffffffffffffffffffffff1661122e6111e1565b73ffffffffffffffffffffffffffffffffffffffff1614611284576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161127b90612575565b60405180910390fd5b6001600880549050116112cc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016112c390612b41565b60405180910390fd5b5f5f90505b6008805490508110156113a95761130782600883815481106112f6576112f5612593565b5b905f5260205f209060030201611bc3565b1561139c5760085f6113199190611f88565b600882908060018154018082558091505060019003905f5260205f2090600302015f90919091909150818161134e9190612c75565b50505f600d8190555061135f6109e3565b7fe42eaf0737e2478a5f5aed3a0610ae7b09a27cbac9ad6a5cc4d68f78afd1425b8260405161138e9190612d00565b60405180910390a1506113e5565b80806001019150506112d1565b506040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016113dc90612d63565b60405180910390fd5b50565b600881815481106113f7575f80fd5b905f5260205f2090600302015f91509050805f0154908060010154908060020154905083565b611425611afb565b73ffffffffffffffffffffffffffffffffffffffff166114436111e1565b73ffffffffffffffffffffffffffffffffffffffff1614611499576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161149090612575565b60405180910390fd5b5f600880549050146114e0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016114d790612df1565b60405180910390fd5b806001600201819055507fb9eb20b32fac965884cb58326102257cae604504f0a36cd1008a32845ad5c29b816001600301546040516115209291906128c8565b60405180910390a150565b60418383905014611571576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161156890612e59565b60405180910390fd5b5f61157c6001611bfb565b855f0135866020013560405160200161159793929190612e97565b604051602081830303815290604052805190602001209050600c5f61161086868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f81840152601f19601f8201169050808301925050505050505061160285611c51565b611c8490919063ffffffff16565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff16611695576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161168c90612f1d565b60405180910390fd5b6001800154855f0135036116de576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016116d590612f85565b60405180910390fd5b5f5f90505b60088054905081101561176657611719866008838154811061170857611707612593565b5b905f5260205f209060030201611bc3565b15611759576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161175090612fed565b60405180910390fd5b80806001019150506116e3565b505f6008805490500361178857600e544261178191906129cd565b600d819055505b600885908060018154018082558091505060019003905f5260205f2090600302015f9091909190915081816117bd9190612c75565b50506002600880549050036118c857600160095f8282546117de91906129cd565b925050819055507f37e8add694c5926d564e971160f5974103cbbbc7c90747c4c6f802031d3567a76009546040516118169190612290565b60405180910390a15f8273ffffffffffffffffffffffffffffffffffffffff164760405161184390613038565b5f6040518083038185875af1925050503d805f811461187d576040519150601f19603f3d011682016040523d82523d5f602084013e611882565b606091505b50509050806118c6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016118bd90613096565b60405180910390fd5b505b5050505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b600d5481565b611901611afb565b73ffffffffffffffffffffffffffffffffffffffff1661191f6111e1565b73ffffffffffffffffffffffffffffffffffffffff1614611975576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161196c90612575565b60405180910390fd5b5f600880549050146119bc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016119b390612df1565b60405180910390fd5b8060015f01819055507fc985bccbd0c90e197f4a7373020a33ba6ff864d0399fd7d65c5c7c32ffb015ec8160018001546040516119fa9291906128c8565b60405180910390a150565b611a0d611afb565b73ffffffffffffffffffffffffffffffffffffffff16611a2b6111e1565b73ffffffffffffffffffffffffffffffffffffffff1614611a81576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611a7890612575565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603611aef576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611ae690613124565b60405180910390fd5b611af881611b02565b50565b5f33905090565b5f5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f5f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f815f0154835f0135148015611be0575081600101548360200135145b8015611bf3575081600201548360400135145b905092915050565b5f815f0154826001015483600201548460030154856004015486600501548760060154604051602001611c349796959493929190613142565b604051602081830303815290604052805190602001209050919050565b5f7f19457468657265756d205369676e6564204d6573736167653a0a3332000000005f5281601c52603c5f209050919050565b5f5f5f5f611c928686611cae565b925092509250611ca28282611d03565b82935050505092915050565b5f5f5f6041845103611cee575f5f5f602087015192506040870151915060608701515f1a9050611ce088828585611e65565b955095509550505050611cfc565b5f600285515f1b9250925092505b9250925092565b5f6003811115611d1657611d156131c2565b5b826003811115611d2957611d286131c2565b5b0315611e615760016003811115611d4357611d426131c2565b5b826003811115611d5657611d556131c2565b5b03611d8d576040517ff645eedf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60026003811115611da157611da06131c2565b5b826003811115611db457611db36131c2565b5b03611df857805f1c6040517ffce698f7000000000000000000000000000000000000000000000000000000008152600401611def9190612290565b60405180910390fd5b600380811115611e0b57611e0a6131c2565b5b826003811115611e1e57611e1d6131c2565b5b03611e6057806040517fd78bce0c000000000000000000000000000000000000000000000000000000008152600401611e579190612268565b60405180910390fd5b5b5050565b5f5f5f7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0845f1c1115611ea1575f600385925092509250611f42565b5f6001888888886040515f8152602001604052604051611ec4949392919061320a565b6020604051602081039080840390855afa158015611ee4573d5f5f3e3d5ffd5b5050506020604051035190505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603611f35575f60015f5f1b93509350935050611f42565b805f5f5f1b935093509350505b9450945094915050565b5080545f8255905f5260205f2090810190611f679190611fa9565b50565b5080545f8255905f5260205f2090810190611f859190611fc4565b50565b5080545f8255600302905f5260205f2090810190611fa69190611fdf565b50565b5b80821115611fc0575f815f905550600101611faa565b5090565b5b80821115611fdb575f815f905550600101611fc5565b5090565b5b80821115612006575f5f82015f9055600182015f9055600282015f905550600301611fe0565b5090565b5f5ffd5b5f5ffd5b5f819050919050565b61202481612012565b811461202e575f5ffd5b50565b5f8135905061203f8161201b565b92915050565b5f6020828403121561205a5761205961200a565b5b5f61206784828501612031565b91505092915050565b5f819050919050565b61208281612070565b811461208c575f5ffd5b50565b5f8135905061209d81612079565b92915050565b5f602082840312156120b8576120b761200a565b5b5f6120c58482850161208f565b91505092915050565b5f5f604083850312156120e4576120e361200a565b5b5f6120f185828601612031565b92505060206121028582860161208f565b9150509250929050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6121358261210c565b9050919050565b6121458161212b565b82525050565b5f60208201905061215e5f83018461213c565b92915050565b61216d81612012565b82525050565b5f60e0820190506121865f83018a612164565b6121936020830189612164565b6121a06040830188612164565b6121ad6060830187612164565b6121ba6080830186612164565b6121c760a0830185612164565b6121d460c0830184612164565b98975050505050505050565b6121e98161212b565b81146121f3575f5ffd5b50565b5f81359050612204816121e0565b92915050565b5f6020828403121561221f5761221e61200a565b5b5f61222c848285016121f6565b91505092915050565b5f8115159050919050565b61224981612235565b82525050565b5f6020820190506122625f830184612240565b92915050565b5f60208201905061227b5f830184612164565b92915050565b61228a81612070565b82525050565b5f6020820190506122a35f830184612281565b92915050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83601f8401126122ca576122c96122a9565b5b8235905067ffffffffffffffff8111156122e7576122e66122ad565b5b602083019150836001820283011115612303576123026122b1565b5b9250929050565b5f5f5f5f606085870312156123225761232161200a565b5b5f61232f878288016121f6565b945050602061234087828801612031565b935050604085013567ffffffffffffffff8111156123615761236061200e565b5b61236d878288016122b5565b925092505092959194509250565b5f819050919050565b5f61239e6123996123948461210c565b61237b565b61210c565b9050919050565b5f6123af82612384565b9050919050565b5f6123c0826123a5565b9050919050565b6123d0816123b6565b82525050565b5f6020820190506123e95f8301846123c7565b92915050565b5f5ffd5b5f60608284031215612408576124076123ef565b5b81905092915050565b5f606082840312156124265761242561200a565b5b5f612433848285016123f3565b91505092915050565b5f60608201905061244f5f830186612164565b61245c6020830185612164565b6124696040830184612164565b949350505050565b5f5f5f5f60a085870312156124895761248861200a565b5b5f612496878288016123f3565b945050606085013567ffffffffffffffff8111156124b7576124b661200e565b5b6124c3878288016122b5565b935093505060806124d6878288016121f6565b91505092959194509250565b5f6124ec826123a5565b9050919050565b6124fc816124e2565b82525050565b5f6020820190506125155f8301846124f3565b92915050565b5f82825260208201905092915050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65725f82015250565b5f61255f60208361251b565b915061256a8261252b565b602082019050919050565b5f6020820190508181035f83015261258c81612553565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f7465652070726f6772616d20616c7265616479206578697374730000000000005f82015250565b5f6125f4601a8361251b565b91506125ff826125c0565b602082019050919050565b5f6020820190508181035f830152612621816125e8565b9050919050565b7f63616e6e6f7420757064617465206368616c6c656e67652077696e646f7720775f8201527f68696c6520617373657274696f6e2069732070656e64696e6700000000000000602082015250565b5f61268260398361251b565b915061268d82612628565b604082019050919050565b5f6020820190508181035f8301526126af81612676565b9050919050565b7f63616e6e6f742072656d6f7665207465652070726f6772616d207768696c65205f8201527f617373657274696f6e2069732070656e64696e67000000000000000000000000602082015250565b5f61271060348361251b565b915061271b826126b6565b604082019050919050565b5f6020820190508181035f83015261273d81612704565b9050919050565b7f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201527f746f6f206d616e7920617373657274696f6e7300000000000000000000000000602082015250565b5f61279e60338361251b565b91506127a982612744565b604082019050919050565b5f6020820190508181035f8301526127cb81612792565b9050919050565b5f67ffffffffffffffff82169050919050565b6127ee816127d2565b81146127f8575f5ffd5b50565b5f81519050612809816127e5565b92915050565b5f602082840312156128245761282361200a565b5b5f612831848285016127fb565b91505092915050565b7f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201527f696e73756666696369656e742074696d65206861732070617373656400000000602082015250565b5f612894603c8361251b565b915061289f8261283a565b604082019050919050565b5f6020820190508181035f8301526128c181612888565b9050919050565b5f6040820190506128db5f830185612164565b6128e86020830184612164565b9392505050565b5f815190506128fd81612079565b92915050565b5f602082840312156129185761291761200a565b5b5f612925848285016128ef565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f61296582612070565b915061297083612070565b92508282039050818111156129885761298761292e565b5b92915050565b5f8151905061299c8161201b565b92915050565b5f602082840312156129b7576129b661200a565b5b5f6129c48482850161298e565b91505092915050565b5f6129d782612070565b91506129e283612070565b92508282019050808211156129fa576129f961292e565b5b92915050565b7f746f646f3a2076616c6964617465207a6b207a6b50726f6f66000000000000005f82015250565b5f612a3460198361251b565b9150612a3f82612a00565b602082019050919050565b5f6020820190508181035f830152612a6181612a28565b9050919050565b7f6b657920616c72656164792061646465640000000000000000000000000000005f82015250565b5f612a9c60118361251b565b9150612aa782612a68565b602082019050919050565b5f6020820190508181035f830152612ac981612a90565b9050919050565b5f612ada82612070565b91505f8203612aec57612aeb61292e565b5b600182039050919050565b7f6368616c6c656e676520646f6573206e6f7420657869737400000000000000005f82015250565b5f612b2b60188361251b565b9150612b3682612af7565b602082019050919050565b5f6020820190508181035f830152612b5881612b1f565b9050919050565b5f8135612b6b8161201b565b80915050919050565b5f815f1b9050919050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff612baa84612b74565b9350801983169250808416831791505092915050565b5f612bca82612012565b9050919050565b5f815f1c9050919050565b5f612be682612bd1565b9050919050565b612bf682612bc0565b612c09612c0282612bdc565b8354612b7f565b8255505050565b5f81015f830180612c2081612b5f565b9050612c2c8184612bed565b505050600181016020830180612c4181612b5f565b9050612c4d8184612bed565b505050600281016040830180612c6281612b5f565b9050612c6e8184612bed565b5050505050565b612c7f8282612c10565b5050565b5f612c916020840184612031565b905092915050565b612ca281612012565b82525050565b60608201612cb85f830183612c83565b612cc45f850182612c99565b50612cd26020830183612c83565b612cdf6020850182612c99565b50612ced6040830183612c83565b612cfa6040850182612c99565b50505050565b5f606082019050612d135f830184612ca8565b92915050565b7f617373657274696f6e206e6f7420666f756e64000000000000000000000000005f82015250565b5f612d4d60138361251b565b9150612d5882612d19565b602082019050919050565b5f6020820190508181035f830152612d7a81612d41565b9050919050565b7f63616e6e6f742075706461746520636f6e6669672068617368207768696c65205f8201527f617373657274696f6e73206172652070656e64696e6700000000000000000000602082015250565b5f612ddb60368361251b565b9150612de682612d81565b604082019050919050565b5f6020820190508181035f830152612e0881612dcf565b9050919050565b7f696e76616c6964207369676e6174757265206c656e67746800000000000000005f82015250565b5f612e4360188361251b565b9150612e4e82612e0f565b602082019050919050565b5f6020820190508181035f830152612e7081612e37565b9050919050565b5f819050919050565b612e91612e8c82612012565b612e77565b82525050565b5f612ea28286612e80565b602082019150612eb28285612e80565b602082019150612ec28284612e80565b602082019150819050949350505050565b7f696e76616c696420746565207369676e617475726500000000000000000000005f82015250565b5f612f0760158361251b565b9150612f1282612ed3565b602082019050919050565b5f6020820190508181035f830152612f3481612efb565b9050919050565b7f617070636861696e20626c6f636b206861736820756e6368616e6765640000005f82015250565b5f612f6f601d8361251b565b9150612f7a82612f3b565b602082019050919050565b5f6020820190508181035f830152612f9c81612f63565b9050919050565b7f617373657274696f6e20616c72656164792065786973747300000000000000005f82015250565b5f612fd760188361251b565b9150612fe282612fa3565b602082019050919050565b5f6020820190508181035f83015261300481612fcb565b9050919050565b5f81905092915050565b50565b5f6130235f8361300b565b915061302e82613015565b5f82019050919050565b5f61304282613018565b9150819050919050565b7f7061796d656e74206661696c65640000000000000000000000000000000000005f82015250565b5f613080600e8361251b565b915061308b8261304c565b602082019050919050565b5f6020820190508181035f8301526130ad81613074565b9050919050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f20615f8201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b5f61310e60268361251b565b9150613119826130b4565b604082019050919050565b5f6020820190508181035f83015261313b81613102565b9050919050565b5f61314d828a612e80565b60208201915061315d8289612e80565b60208201915061316d8288612e80565b60208201915061317d8287612e80565b60208201915061318d8286612e80565b60208201915061319d8285612e80565b6020820191506131ad8284612e80565b60208201915081905098975050505050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b5f60ff82169050919050565b613204816131ef565b82525050565b5f60808201905061321d5f830187612164565b61322a60208301866131fb565b6132376040830185612164565b6132446060830184612164565b9594505050505056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\x01CW_5`\xE0\x1C\x80cpdn\xA2\x11a\0\xB5W\x80c\xC3\xF2\xDB\xD3\x11a\0nW\x80c\xC3\xF2\xDB\xD3\x14a\x04\"W\x80c\xE5\x0CaV\x14a\x04JW\x80c\xE7\x8C\xEA\x92\x14a\x04rW\x80c\xEE\x1C(\xB8\x14a\x04\x9CW\x80c\xF2#\x05\\\x14a\x04\xC6W\x80c\xF2\xFD\xE3\x8B\x14a\x04\xEEWa\x01JV[\x80cpdn\xA2\x14a\x03*W\x80cqP\x18\xA6\x14a\x03RW\x80c\x80\x95\x97!\x14a\x03hW\x80c\x8D\xA5\xCB[\x14a\x03\x92W\x80c\x8F\xEDU\xA3\x14a\x03\xBCW\x80c\xA5n\xC6\xCD\x14a\x03\xE4Wa\x01JV[\x80cJ\xFF\xFC\xC9\x11a\x01\x07W\x80cJ\xFF\xFC\xC9\x14a\x02FW\x80cK\xD1g\xC9\x14a\x02\x82W\x80c_p\xC4A\x14a\x02\xACW\x80ci{^b\x14a\x02\xD4W\x80clL `\x14a\x02\xFEW\x80cn\xF0\x12\x01\x14a\x03\x14Wa\x01JV[\x80c\x1C\x12B\x7F\x14a\x01NW\x80c\x1C\xAF]\x13\x14a\x01vW\x80c33\x90\x06\x14a\x01\x9EW\x80c<\xEA\xAE}\x14a\x01\xDAW\x80cGt&@\x14a\x02\nWa\x01JV[6a\x01JW\0[__\xFD[4\x80\x15a\x01YW__\xFD[Pa\x01t`\x04\x806\x03\x81\x01\x90a\x01o\x91\x90a EV[a\x05\x16V[\0[4\x80\x15a\x01\x81W__\xFD[Pa\x01\x9C`\x04\x806\x03\x81\x01\x90a\x01\x97\x91\x90a \xA3V[a\x06pV[\0[4\x80\x15a\x01\xA9W__\xFD[Pa\x01\xC4`\x04\x806\x03\x81\x01\x90a\x01\xBF\x91\x90a \xCEV[a\x07=V[`@Qa\x01\xD1\x91\x90a!KV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x01\xE5W__\xFD[Pa\x01\xEEa\x07\x85V[`@Qa\x02\x01\x97\x96\x95\x94\x93\x92\x91\x90a!sV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\x15W__\xFD[Pa\x020`\x04\x806\x03\x81\x01\x90a\x02+\x91\x90a\"\nV[a\x07\xB4V[`@Qa\x02=\x91\x90a\"OV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02QW__\xFD[Pa\x02l`\x04\x806\x03\x81\x01\x90a\x02g\x91\x90a \xA3V[a\x07\xD1V[`@Qa\x02y\x91\x90a\"hV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\x8DW__\xFD[Pa\x02\x96a\x07\xF1V[`@Qa\x02\xA3\x91\x90a\"\x90V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xB7W__\xFD[Pa\x02\xD2`\x04\x806\x03\x81\x01\x90a\x02\xCD\x91\x90a EV[a\x07\xF7V[\0[4\x80\x15a\x02\xDFW__\xFD[Pa\x02\xE8a\t\xDDV[`@Qa\x02\xF5\x91\x90a\"\x90V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\tW__\xFD[Pa\x03\x12a\t\xE3V[\0[4\x80\x15a\x03\x1FW__\xFD[Pa\x03(a\x0E\x15V[\0[4\x80\x15a\x035W__\xFD[Pa\x03P`\x04\x806\x03\x81\x01\x90a\x03K\x91\x90a#\nV[a\x0F\x11V[\0[4\x80\x15a\x03]W__\xFD[Pa\x03fa\x116V[\0[4\x80\x15a\x03sW__\xFD[Pa\x03|a\x11\xBDV[`@Qa\x03\x89\x91\x90a#\xD6V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x9DW__\xFD[Pa\x03\xA6a\x11\xE1V[`@Qa\x03\xB3\x91\x90a!KV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xC7W__\xFD[Pa\x03\xE2`\x04\x806\x03\x81\x01\x90a\x03\xDD\x91\x90a$\x11V[a\x12\x08V[\0[4\x80\x15a\x03\xEFW__\xFD[Pa\x04\n`\x04\x806\x03\x81\x01\x90a\x04\x05\x91\x90a \xA3V[a\x13\xE8V[`@Qa\x04\x19\x93\x92\x91\x90a$<V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04-W__\xFD[Pa\x04H`\x04\x806\x03\x81\x01\x90a\x04C\x91\x90a EV[a\x14\x1DV[\0[4\x80\x15a\x04UW__\xFD[Pa\x04p`\x04\x806\x03\x81\x01\x90a\x04k\x91\x90a$qV[a\x15+V[\0[4\x80\x15a\x04}W__\xFD[Pa\x04\x86a\x18\xCFV[`@Qa\x04\x93\x91\x90a%\x02V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xA7W__\xFD[Pa\x04\xB0a\x18\xF3V[`@Qa\x04\xBD\x91\x90a\"\x90V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xD1W__\xFD[Pa\x04\xEC`\x04\x806\x03\x81\x01\x90a\x04\xE7\x91\x90a EV[a\x18\xF9V[\0[4\x80\x15a\x04\xF9W__\xFD[Pa\x05\x14`\x04\x806\x03\x81\x01\x90a\x05\x0F\x91\x90a\"\nV[a\x1A\x05V[\0[a\x05\x1Ea\x1A\xFBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x05<a\x11\xE1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x05\x92W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05\x89\x90a%uV[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\n\x80T\x90P\x81\x10\x15a\x06\x0FW\x81`\n\x82\x81T\x81\x10a\x05\xB9Wa\x05\xB8a%\x93V[[\x90_R` _ \x01T\x03a\x06\x02W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05\xF9\x90a&\nV[`@Q\x80\x91\x03\x90\xFD[\x80\x80`\x01\x01\x91PPa\x05\x97V[P`\n\x81\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91PU\x7F\x9Azdi\xC2\\\xF0\x17\x89\x06\x07i^J\x14\x9C\xC7q\xF2\x94\xFD\x87\x1E \x80\xD2L\xD1\t\x03:\xB6\x81`@Qa\x06e\x91\x90a\"hV[`@Q\x80\x91\x03\x90\xA1PV[a\x06xa\x1A\xFBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x06\x96a\x11\xE1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x06\xECW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xE3\x90a%uV[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x14a\x073W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x07*\x90a&\x98V[`@Q\x80\x91\x03\x90\xFD[\x80`\x0E\x81\x90UPPV[`\x0B` R\x81_R`@_ \x81\x81T\x81\x10a\x07VW_\x80\xFD[\x90_R` _ \x01_\x91P\x91P\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[`\x01\x80_\x01T\x90\x80`\x01\x01T\x90\x80`\x02\x01T\x90\x80`\x03\x01T\x90\x80`\x04\x01T\x90\x80`\x05\x01T\x90\x80`\x06\x01T\x90P\x87V[`\x0C` R\x80_R`@_ _\x91PT\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[`\n\x81\x81T\x81\x10a\x07\xE0W_\x80\xFD[\x90_R` _ \x01_\x91P\x90PT\x81V[`\x0ET\x81V[a\x07\xFFa\x1A\xFBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x08\x1Da\x11\xE1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x08sW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08j\x90a%uV[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x14a\x08\xBAW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08\xB1\x90a'&V[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x0B_\x83\x81R` \x01\x90\x81R` \x01_ \x80T\x90P\x81\x10\x15a\t\x86W_`\x0C_`\x0B_\x86\x81R` \x01\x90\x81R` \x01_ \x84\x81T\x81\x10a\t\x02Wa\t\x01a%\x93V[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa\x08\xBFV[P`\x0B_\x82\x81R` \x01\x90\x81R` \x01_ _a\t\xA3\x91\x90a\x1FLV[\x7F&!\xC6\x1D3\x15\xF2\xA3\xD2k\"\xD7F\xBA!\xA9m$\x9FQ\xAD\xA3#\xF7\"l\xCE_\xE5\xFC=d\x81`@Qa\t\xD2\x91\x90a\"hV[`@Q\x80\x91\x03\x90\xA1PV[`\tT\x81V[`\x01`\x08\x80T\x90P\x11\x15a\n,W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\n#\x90a'\xB4V[`@Q\x80\x91\x03\x90\xFD[`\rTsB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xB8\x07w\xEA`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n\x8CW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\xB0\x91\x90a(\x0FV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11a\n\xFAW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\n\xF1\x90a(\xAAV[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x11\x15a\x0C<W`\x08_\x81T\x81\x10a\x0B\x1BWa\x0B\x1Aa%\x93V[[\x90_R` _ \x90`\x03\x02\x01_\x01T`\x01\x80\x01\x81\x90UP`\x08_\x81T\x81\x10a\x0BFWa\x0BEa%\x93V[[\x90_R` _ \x90`\x03\x02\x01`\x02\x01T`\x01`\x03\x01\x81\x90UP`\x01`\x06\x01T`\x01`\x05\x01\x81\x90UP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xDA\xEA\xB4\x12`\x08_\x81T\x81\x10a\x0B\xBEWa\x0B\xBDa%\x93V[[\x90_R` _ \x90`\x03\x02\x01_\x01T`\x08_\x81T\x81\x10a\x0B\xE1Wa\x0B\xE0a%\x93V[[\x90_R` _ \x90`\x03\x02\x01`\x01\x01T`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0C\x0E\x92\x91\x90a(\xC8V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0C%W__\xFD[PZ\xF1\x15\x80\x15a\x0C7W=__>=_\xFD[PPPP[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD5q\x9D\xC2`\x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xEC\xA0g\xAD`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0C\xE3W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r\x07\x91\x90a)\x03V[a\r\x11\x91\x90a)[V[`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\r-\x91\x90a\"\x90V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\rHW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\rl\x91\x90a)\xA2V[`\x01`\x04\x01\x81\x90UPsB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\t\xBDZ``@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\r\xD2W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r\xF6\x91\x90a)\xA2V[`\x01`\x06\x01\x81\x90UP`\x0ETBa\x0E\r\x91\x90a)\xCDV[`\r\x81\x90UPV[a\x0E\x1Da\x1A\xFBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x0E;a\x11\xE1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x0E\x91W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0E\x88\x90a%uV[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\n\x80T\x90P\x81\x10\x15a\x0E\xD5Wa\x0E\xC8`\n\x82\x81T\x81\x10a\x0E\xBAWa\x0E\xB9a%\x93V[[\x90_R` _ \x01Ta\x07\xF7V[\x80\x80`\x01\x01\x91PPa\x0E\x96V[P`\n_a\x0E\xE3\x91\x90a\x1FjV[\x7F\xEC\xA6.\0t\xA1:\x90\xD6\0\xF0\x03\xB7\xCB\x8D[\xD5\x01\0\0\x8D?9\x15\xF2UO?\x85R\xC5\xCC`@Q`@Q\x80\x91\x03\x90\xA1V[`\x01\x82\x82\x90P\x14a\x0FWW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0FN\x90a*JV[`@Q\x80\x91\x03\x90\xFD[`\x0C_\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a\x0F\xE1W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0F\xD8\x90a*\xB2V[`@Q\x80\x91\x03\x90\xFD[_`\x0B_\x85\x81R` \x01\x90\x81R` \x01_ \x80T\x90P\x03a\x10kW__\x90P_`\n\x80T\x90P\x90P[_\x81\x11\x15a\x10]W\x84`\n`\x01\x83a\x10\"\x91\x90a)[V[\x81T\x81\x10a\x103Wa\x102a%\x93V[[\x90_R` _ \x01T\x03a\x10JW`\x01\x91Pa\x10]V[\x80\x80a\x10U\x90a*\xD0V[\x91PPa\x10\nV[P\x80a\x10iWPa\x110V[P[`\x01`\x0C_\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP`\x0B_\x84\x81R` \x01\x90\x81R` \x01_ \x84\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP[PPPPV[a\x11>a\x1A\xFBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x11\\a\x11\xE1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x11\xB2W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x11\xA9\x90a%uV[`@Q\x80\x91\x03\x90\xFD[a\x11\xBB_a\x1B\x02V[V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[___\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[a\x12\x10a\x1A\xFBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x12.a\x11\xE1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x12\x84W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x12{\x90a%uV[`@Q\x80\x91\x03\x90\xFD[`\x01`\x08\x80T\x90P\x11a\x12\xCCW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x12\xC3\x90a+AV[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x08\x80T\x90P\x81\x10\x15a\x13\xA9Wa\x13\x07\x82`\x08\x83\x81T\x81\x10a\x12\xF6Wa\x12\xF5a%\x93V[[\x90_R` _ \x90`\x03\x02\x01a\x1B\xC3V[\x15a\x13\x9CW`\x08_a\x13\x19\x91\x90a\x1F\x88V[`\x08\x82\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x03\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a\x13N\x91\x90a,uV[PP_`\r\x81\x90UPa\x13_a\t\xE3V[\x7F\xE4.\xAF\x077\xE2G\x8A_Z\xED:\x06\x10\xAE{\t\xA2|\xBA\xC9\xADj\\\xC4\xD6\x8Fx\xAF\xD1B[\x82`@Qa\x13\x8E\x91\x90a-\0V[`@Q\x80\x91\x03\x90\xA1Pa\x13\xE5V[\x80\x80`\x01\x01\x91PPa\x12\xD1V[P`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\xDC\x90a-cV[`@Q\x80\x91\x03\x90\xFD[PV[`\x08\x81\x81T\x81\x10a\x13\xF7W_\x80\xFD[\x90_R` _ \x90`\x03\x02\x01_\x91P\x90P\x80_\x01T\x90\x80`\x01\x01T\x90\x80`\x02\x01T\x90P\x83V[a\x14%a\x1A\xFBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x14Ca\x11\xE1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x14\x99W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14\x90\x90a%uV[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x14a\x14\xE0W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14\xD7\x90a-\xF1V[`@Q\x80\x91\x03\x90\xFD[\x80`\x01`\x02\x01\x81\x90UP\x7F\xB9\xEB \xB3/\xAC\x96X\x84\xCBX2a\x02%|\xAE`E\x04\xF0\xA3l\xD1\0\x8A2\x84Z\xD5\xC2\x9B\x81`\x01`\x03\x01T`@Qa\x15 \x92\x91\x90a(\xC8V[`@Q\x80\x91\x03\x90\xA1PV[`A\x83\x83\x90P\x14a\x15qW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x15h\x90a.YV[`@Q\x80\x91\x03\x90\xFD[_a\x15|`\x01a\x1B\xFBV[\x85_\x015\x86` \x015`@Q` \x01a\x15\x97\x93\x92\x91\x90a.\x97V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P`\x0C_a\x16\x10\x86\x86\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x81\x84\x01R`\x1F\x19`\x1F\x82\x01\x16\x90P\x80\x83\x01\x92PPPPPPPa\x16\x02\x85a\x1CQV[a\x1C\x84\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x16\x95W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x16\x8C\x90a/\x1DV[`@Q\x80\x91\x03\x90\xFD[`\x01\x80\x01T\x85_\x015\x03a\x16\xDEW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x16\xD5\x90a/\x85V[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x08\x80T\x90P\x81\x10\x15a\x17fWa\x17\x19\x86`\x08\x83\x81T\x81\x10a\x17\x08Wa\x17\x07a%\x93V[[\x90_R` _ \x90`\x03\x02\x01a\x1B\xC3V[\x15a\x17YW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x17P\x90a/\xEDV[`@Q\x80\x91\x03\x90\xFD[\x80\x80`\x01\x01\x91PPa\x16\xE3V[P_`\x08\x80T\x90P\x03a\x17\x88W`\x0ETBa\x17\x81\x91\x90a)\xCDV[`\r\x81\x90UP[`\x08\x85\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x03\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a\x17\xBD\x91\x90a,uV[PP`\x02`\x08\x80T\x90P\x03a\x18\xC8W`\x01`\t_\x82\x82Ta\x17\xDE\x91\x90a)\xCDV[\x92PP\x81\x90UP\x7F7\xE8\xAD\xD6\x94\xC5\x92mVN\x97\x11`\xF5\x97A\x03\xCB\xBB\xC7\xC9\x07G\xC4\xC6\xF8\x02\x03\x1D5g\xA7`\tT`@Qa\x18\x16\x91\x90a\"\x90V[`@Q\x80\x91\x03\x90\xA1_\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16G`@Qa\x18C\x90a08V[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a\x18}W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x18\x82V[``\x91P[PP\x90P\x80a\x18\xC6W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x18\xBD\x90a0\x96V[`@Q\x80\x91\x03\x90\xFD[P[PPPPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`\rT\x81V[a\x19\x01a\x1A\xFBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x19\x1Fa\x11\xE1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x19uW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x19l\x90a%uV[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x14a\x19\xBCW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x19\xB3\x90a-\xF1V[`@Q\x80\x91\x03\x90\xFD[\x80`\x01_\x01\x81\x90UP\x7F\xC9\x85\xBC\xCB\xD0\xC9\x0E\x19\x7FJss\x02\n3\xBAo\xF8d\xD09\x9F\xD7\xD6\\\\|2\xFF\xB0\x15\xEC\x81`\x01\x80\x01T`@Qa\x19\xFA\x92\x91\x90a(\xC8V[`@Q\x80\x91\x03\x90\xA1PV[a\x1A\ra\x1A\xFBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1A+a\x11\xE1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1A\x81W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1Ax\x90a%uV[`@Q\x80\x91\x03\x90\xFD[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x1A\xEFW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1A\xE6\x90a1$V[`@Q\x80\x91\x03\x90\xFD[a\x1A\xF8\x81a\x1B\x02V[PV[_3\x90P\x90V[___\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81__a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPV[_\x81_\x01T\x83_\x015\x14\x80\x15a\x1B\xE0WP\x81`\x01\x01T\x83` \x015\x14[\x80\x15a\x1B\xF3WP\x81`\x02\x01T\x83`@\x015\x14[\x90P\x92\x91PPV[_\x81_\x01T\x82`\x01\x01T\x83`\x02\x01T\x84`\x03\x01T\x85`\x04\x01T\x86`\x05\x01T\x87`\x06\x01T`@Q` \x01a\x1C4\x97\x96\x95\x94\x93\x92\x91\x90a1BV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x91\x90PV[_\x7F\x19Ethereum Signed Message:\n32\0\0\0\0_R\x81`\x1CR`<_ \x90P\x91\x90PV[____a\x1C\x92\x86\x86a\x1C\xAEV[\x92P\x92P\x92Pa\x1C\xA2\x82\x82a\x1D\x03V[\x82\x93PPPP\x92\x91PPV[___`A\x84Q\x03a\x1C\xEEW___` \x87\x01Q\x92P`@\x87\x01Q\x91P``\x87\x01Q_\x1A\x90Pa\x1C\xE0\x88\x82\x85\x85a\x1EeV[\x95P\x95P\x95PPPPa\x1C\xFCV[_`\x02\x85Q_\x1B\x92P\x92P\x92P[\x92P\x92P\x92V[_`\x03\x81\x11\x15a\x1D\x16Wa\x1D\x15a1\xC2V[[\x82`\x03\x81\x11\x15a\x1D)Wa\x1D(a1\xC2V[[\x03\x15a\x1EaW`\x01`\x03\x81\x11\x15a\x1DCWa\x1DBa1\xC2V[[\x82`\x03\x81\x11\x15a\x1DVWa\x1DUa1\xC2V[[\x03a\x1D\x8DW`@Q\x7F\xF6E\xEE\xDF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`\x03\x81\x11\x15a\x1D\xA1Wa\x1D\xA0a1\xC2V[[\x82`\x03\x81\x11\x15a\x1D\xB4Wa\x1D\xB3a1\xC2V[[\x03a\x1D\xF8W\x80_\x1C`@Q\x7F\xFC\xE6\x98\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1D\xEF\x91\x90a\"\x90V[`@Q\x80\x91\x03\x90\xFD[`\x03\x80\x81\x11\x15a\x1E\x0BWa\x1E\na1\xC2V[[\x82`\x03\x81\x11\x15a\x1E\x1EWa\x1E\x1Da1\xC2V[[\x03a\x1E`W\x80`@Q\x7F\xD7\x8B\xCE\x0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1EW\x91\x90a\"hV[`@Q\x80\x91\x03\x90\xFD[[PPV[___\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0\x84_\x1C\x11\x15a\x1E\xA1W_`\x03\x85\x92P\x92P\x92Pa\x1FBV[_`\x01\x88\x88\x88\x88`@Q_\x81R` \x01`@R`@Qa\x1E\xC4\x94\x93\x92\x91\x90a2\nV[` `@Q` \x81\x03\x90\x80\x84\x03\x90\x85Z\xFA\x15\x80\x15a\x1E\xE4W=__>=_\xFD[PPP` `@Q\x03Q\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x1F5W_`\x01__\x1B\x93P\x93P\x93PPa\x1FBV[\x80___\x1B\x93P\x93P\x93PP[\x94P\x94P\x94\x91PPV[P\x80T_\x82U\x90_R` _ \x90\x81\x01\x90a\x1Fg\x91\x90a\x1F\xA9V[PV[P\x80T_\x82U\x90_R` _ \x90\x81\x01\x90a\x1F\x85\x91\x90a\x1F\xC4V[PV[P\x80T_\x82U`\x03\x02\x90_R` _ \x90\x81\x01\x90a\x1F\xA6\x91\x90a\x1F\xDFV[PV[[\x80\x82\x11\x15a\x1F\xC0W_\x81_\x90UP`\x01\x01a\x1F\xAAV[P\x90V[[\x80\x82\x11\x15a\x1F\xDBW_\x81_\x90UP`\x01\x01a\x1F\xC5V[P\x90V[[\x80\x82\x11\x15a \x06W__\x82\x01_\x90U`\x01\x82\x01_\x90U`\x02\x82\x01_\x90UP`\x03\x01a\x1F\xE0V[P\x90V[__\xFD[__\xFD[_\x81\x90P\x91\x90PV[a $\x81a \x12V[\x81\x14a .W__\xFD[PV[_\x815\x90Pa ?\x81a \x1BV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a ZWa Ya \nV[[_a g\x84\x82\x85\x01a 1V[\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[a \x82\x81a pV[\x81\x14a \x8CW__\xFD[PV[_\x815\x90Pa \x9D\x81a yV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a \xB8Wa \xB7a \nV[[_a \xC5\x84\x82\x85\x01a \x8FV[\x91PP\x92\x91PPV[__`@\x83\x85\x03\x12\x15a \xE4Wa \xE3a \nV[[_a \xF1\x85\x82\x86\x01a 1V[\x92PP` a!\x02\x85\x82\x86\x01a \x8FV[\x91PP\x92P\x92\x90PV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a!5\x82a!\x0CV[\x90P\x91\x90PV[a!E\x81a!+V[\x82RPPV[_` \x82\x01\x90Pa!^_\x83\x01\x84a!<V[\x92\x91PPV[a!m\x81a \x12V[\x82RPPV[_`\xE0\x82\x01\x90Pa!\x86_\x83\x01\x8Aa!dV[a!\x93` \x83\x01\x89a!dV[a!\xA0`@\x83\x01\x88a!dV[a!\xAD``\x83\x01\x87a!dV[a!\xBA`\x80\x83\x01\x86a!dV[a!\xC7`\xA0\x83\x01\x85a!dV[a!\xD4`\xC0\x83\x01\x84a!dV[\x98\x97PPPPPPPPV[a!\xE9\x81a!+V[\x81\x14a!\xF3W__\xFD[PV[_\x815\x90Pa\"\x04\x81a!\xE0V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\"\x1FWa\"\x1Ea \nV[[_a\",\x84\x82\x85\x01a!\xF6V[\x91PP\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[a\"I\x81a\"5V[\x82RPPV[_` \x82\x01\x90Pa\"b_\x83\x01\x84a\"@V[\x92\x91PPV[_` \x82\x01\x90Pa\"{_\x83\x01\x84a!dV[\x92\x91PPV[a\"\x8A\x81a pV[\x82RPPV[_` \x82\x01\x90Pa\"\xA3_\x83\x01\x84a\"\x81V[\x92\x91PPV[__\xFD[__\xFD[__\xFD[__\x83`\x1F\x84\x01\x12a\"\xCAWa\"\xC9a\"\xA9V[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\"\xE7Wa\"\xE6a\"\xADV[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15a#\x03Wa#\x02a\"\xB1V[[\x92P\x92\x90PV[____``\x85\x87\x03\x12\x15a#\"Wa#!a \nV[[_a#/\x87\x82\x88\x01a!\xF6V[\x94PP` a#@\x87\x82\x88\x01a 1V[\x93PP`@\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a#aWa#`a \x0EV[[a#m\x87\x82\x88\x01a\"\xB5V[\x92P\x92PP\x92\x95\x91\x94P\x92PV[_\x81\x90P\x91\x90PV[_a#\x9Ea#\x99a#\x94\x84a!\x0CV[a#{V[a!\x0CV[\x90P\x91\x90PV[_a#\xAF\x82a#\x84V[\x90P\x91\x90PV[_a#\xC0\x82a#\xA5V[\x90P\x91\x90PV[a#\xD0\x81a#\xB6V[\x82RPPV[_` \x82\x01\x90Pa#\xE9_\x83\x01\x84a#\xC7V[\x92\x91PPV[__\xFD[_``\x82\x84\x03\x12\x15a$\x08Wa$\x07a#\xEFV[[\x81\x90P\x92\x91PPV[_``\x82\x84\x03\x12\x15a$&Wa$%a \nV[[_a$3\x84\x82\x85\x01a#\xF3V[\x91PP\x92\x91PPV[_``\x82\x01\x90Pa$O_\x83\x01\x86a!dV[a$\\` \x83\x01\x85a!dV[a$i`@\x83\x01\x84a!dV[\x94\x93PPPPV[____`\xA0\x85\x87\x03\x12\x15a$\x89Wa$\x88a \nV[[_a$\x96\x87\x82\x88\x01a#\xF3V[\x94PP``\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$\xB7Wa$\xB6a \x0EV[[a$\xC3\x87\x82\x88\x01a\"\xB5V[\x93P\x93PP`\x80a$\xD6\x87\x82\x88\x01a!\xF6V[\x91PP\x92\x95\x91\x94P\x92PV[_a$\xEC\x82a#\xA5V[\x90P\x91\x90PV[a$\xFC\x81a$\xE2V[\x82RPPV[_` \x82\x01\x90Pa%\x15_\x83\x01\x84a$\xF3V[\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7FOwnable: caller is not the owner_\x82\x01RPV[_a%_` \x83a%\x1BV[\x91Pa%j\x82a%+V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra%\x8C\x81a%SV[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x7Ftee program already exists\0\0\0\0\0\0_\x82\x01RPV[_a%\xF4`\x1A\x83a%\x1BV[\x91Pa%\xFF\x82a%\xC0V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra&!\x81a%\xE8V[\x90P\x91\x90PV[\x7Fcannot update challenge window w_\x82\x01R\x7Fhile assertion is pending\0\0\0\0\0\0\0` \x82\x01RPV[_a&\x82`9\x83a%\x1BV[\x91Pa&\x8D\x82a&(V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra&\xAF\x81a&vV[\x90P\x91\x90PV[\x7Fcannot remove tee program while _\x82\x01R\x7Fassertion is pending\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a'\x10`4\x83a%\x1BV[\x91Pa'\x1B\x82a&\xB6V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra'=\x81a'\x04V[\x90P\x91\x90PV[\x7Fcannot close challenge window - _\x82\x01R\x7Ftoo many assertions\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a'\x9E`3\x83a%\x1BV[\x91Pa'\xA9\x82a'DV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra'\xCB\x81a'\x92V[\x90P\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a'\xEE\x81a'\xD2V[\x81\x14a'\xF8W__\xFD[PV[_\x81Q\x90Pa(\t\x81a'\xE5V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a($Wa(#a \nV[[_a(1\x84\x82\x85\x01a'\xFBV[\x91PP\x92\x91PPV[\x7Fcannot close challenge window - _\x82\x01R\x7Finsufficient time has passed\0\0\0\0` \x82\x01RPV[_a(\x94`<\x83a%\x1BV[\x91Pa(\x9F\x82a(:V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra(\xC1\x81a(\x88V[\x90P\x91\x90PV[_`@\x82\x01\x90Pa(\xDB_\x83\x01\x85a!dV[a(\xE8` \x83\x01\x84a!dV[\x93\x92PPPV[_\x81Q\x90Pa(\xFD\x81a yV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a)\x18Wa)\x17a \nV[[_a)%\x84\x82\x85\x01a(\xEFV[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a)e\x82a pV[\x91Pa)p\x83a pV[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15a)\x88Wa)\x87a).V[[\x92\x91PPV[_\x81Q\x90Pa)\x9C\x81a \x1BV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a)\xB7Wa)\xB6a \nV[[_a)\xC4\x84\x82\x85\x01a)\x8EV[\x91PP\x92\x91PPV[_a)\xD7\x82a pV[\x91Pa)\xE2\x83a pV[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a)\xFAWa)\xF9a).V[[\x92\x91PPV[\x7Ftodo: validate zk zkProof\0\0\0\0\0\0\0_\x82\x01RPV[_a*4`\x19\x83a%\x1BV[\x91Pa*?\x82a*\0V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra*a\x81a*(V[\x90P\x91\x90PV[\x7Fkey already added\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a*\x9C`\x11\x83a%\x1BV[\x91Pa*\xA7\x82a*hV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra*\xC9\x81a*\x90V[\x90P\x91\x90PV[_a*\xDA\x82a pV[\x91P_\x82\x03a*\xECWa*\xEBa).V[[`\x01\x82\x03\x90P\x91\x90PV[\x7Fchallenge does not exist\0\0\0\0\0\0\0\0_\x82\x01RPV[_a++`\x18\x83a%\x1BV[\x91Pa+6\x82a*\xF7V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra+X\x81a+\x1FV[\x90P\x91\x90PV[_\x815a+k\x81a \x1BV[\x80\x91PP\x91\x90PV[_\x81_\x1B\x90P\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa+\xAA\x84a+tV[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_a+\xCA\x82a \x12V[\x90P\x91\x90PV[_\x81_\x1C\x90P\x91\x90PV[_a+\xE6\x82a+\xD1V[\x90P\x91\x90PV[a+\xF6\x82a+\xC0V[a,\ta,\x02\x82a+\xDCV[\x83Ta+\x7FV[\x82UPPPV[_\x81\x01_\x83\x01\x80a, \x81a+_V[\x90Pa,,\x81\x84a+\xEDV[PPP`\x01\x81\x01` \x83\x01\x80a,A\x81a+_V[\x90Pa,M\x81\x84a+\xEDV[PPP`\x02\x81\x01`@\x83\x01\x80a,b\x81a+_V[\x90Pa,n\x81\x84a+\xEDV[PPPPPV[a,\x7F\x82\x82a,\x10V[PPV[_a,\x91` \x84\x01\x84a 1V[\x90P\x92\x91PPV[a,\xA2\x81a \x12V[\x82RPPV[``\x82\x01a,\xB8_\x83\x01\x83a,\x83V[a,\xC4_\x85\x01\x82a,\x99V[Pa,\xD2` \x83\x01\x83a,\x83V[a,\xDF` \x85\x01\x82a,\x99V[Pa,\xED`@\x83\x01\x83a,\x83V[a,\xFA`@\x85\x01\x82a,\x99V[PPPPV[_``\x82\x01\x90Pa-\x13_\x83\x01\x84a,\xA8V[\x92\x91PPV[\x7Fassertion not found\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a-M`\x13\x83a%\x1BV[\x91Pa-X\x82a-\x19V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra-z\x81a-AV[\x90P\x91\x90PV[\x7Fcannot update config hash while _\x82\x01R\x7Fassertions are pending\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a-\xDB`6\x83a%\x1BV[\x91Pa-\xE6\x82a-\x81V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra.\x08\x81a-\xCFV[\x90P\x91\x90PV[\x7Finvalid signature length\0\0\0\0\0\0\0\0_\x82\x01RPV[_a.C`\x18\x83a%\x1BV[\x91Pa.N\x82a.\x0FV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra.p\x81a.7V[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a.\x91a.\x8C\x82a \x12V[a.wV[\x82RPPV[_a.\xA2\x82\x86a.\x80V[` \x82\x01\x91Pa.\xB2\x82\x85a.\x80V[` \x82\x01\x91Pa.\xC2\x82\x84a.\x80V[` \x82\x01\x91P\x81\x90P\x94\x93PPPPV[\x7Finvalid tee signature\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a/\x07`\x15\x83a%\x1BV[\x91Pa/\x12\x82a.\xD3V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra/4\x81a.\xFBV[\x90P\x91\x90PV[\x7Fappchain block hash unchanged\0\0\0_\x82\x01RPV[_a/o`\x1D\x83a%\x1BV[\x91Pa/z\x82a/;V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra/\x9C\x81a/cV[\x90P\x91\x90PV[\x7Fassertion already exists\0\0\0\0\0\0\0\0_\x82\x01RPV[_a/\xD7`\x18\x83a%\x1BV[\x91Pa/\xE2\x82a/\xA3V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra0\x04\x81a/\xCBV[\x90P\x91\x90PV[_\x81\x90P\x92\x91PPV[PV[_a0#_\x83a0\x0BV[\x91Pa0.\x82a0\x15V[_\x82\x01\x90P\x91\x90PV[_a0B\x82a0\x18V[\x91P\x81\x90P\x91\x90PV[\x7Fpayment failed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a0\x80`\x0E\x83a%\x1BV[\x91Pa0\x8B\x82a0LV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra0\xAD\x81a0tV[\x90P\x91\x90PV[\x7FOwnable: new owner is the zero a_\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a1\x0E`&\x83a%\x1BV[\x91Pa1\x19\x82a0\xB4V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra1;\x81a1\x02V[\x90P\x91\x90PV[_a1M\x82\x8Aa.\x80V[` \x82\x01\x91Pa1]\x82\x89a.\x80V[` \x82\x01\x91Pa1m\x82\x88a.\x80V[` \x82\x01\x91Pa1}\x82\x87a.\x80V[` \x82\x01\x91Pa1\x8D\x82\x86a.\x80V[` \x82\x01\x91Pa1\x9D\x82\x85a.\x80V[` \x82\x01\x91Pa1\xAD\x82\x84a.\x80V[` \x82\x01\x91P\x81\x90P\x98\x97PPPPPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[_`\xFF\x82\x16\x90P\x91\x90PV[a2\x04\x81a1\xEFV[\x82RPPV[_`\x80\x82\x01\x90Pa2\x1D_\x83\x01\x87a!dV[a2*` \x83\x01\x86a1\xFBV[a27`@\x83\x01\x85a!dV[a2D``\x83\x01\x84a!dV[\x95\x94PPPPPV",
    );
    /**```solidity
struct PendingAssertion { bytes32 blockHash; bytes32 sendRoot; bytes32 seqBlockHash; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PendingAssertion {
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sendRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqBlockHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PendingAssertion> for UnderlyingRustTuple<'_> {
            fn from(value: PendingAssertion) -> Self {
                (value.blockHash, value.sendRoot, value.seqBlockHash)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PendingAssertion {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    blockHash: tuple.0,
                    sendRoot: tuple.1,
                    seqBlockHash: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for PendingAssertion {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for PendingAssertion {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.sendRoot),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.seqBlockHash),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for PendingAssertion {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for PendingAssertion {
            const NAME: &'static str = "PendingAssertion";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "PendingAssertion(bytes32 blockHash,bytes32 sendRoot,bytes32 seqBlockHash)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.blockHash)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.sendRoot)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.seqBlockHash)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for PendingAssertion {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.blockHash,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sendRoot,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.seqBlockHash,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.blockHash,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sendRoot,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.seqBlockHash,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignature()` and selector `0xf645eedf`.
```solidity
error ECDSAInvalidSignature();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignature {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignature()";
            const SELECTOR: [u8; 4] = [246u8, 69u8, 238u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureLength(uint256)` and selector `0xfce698f7`.
```solidity
error ECDSAInvalidSignatureLength(uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureLength {
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureLength) -> Self {
                (value.length,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ECDSAInvalidSignatureLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { length: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureLength(uint256)";
            const SELECTOR: [u8; 4] = [252u8, 230u8, 152u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureS(bytes32)` and selector `0xd78bce0c`.
```solidity
error ECDSAInvalidSignatureS(bytes32 s);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureS {
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureS> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureS) -> Self {
                (value.s,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignatureS {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { s: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureS {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureS(bytes32)";
            const SELECTOR: [u8; 4] = [215u8, 139u8, 206u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
        }
    };
    /**Event with signature `ChallengeResolved((bytes32,bytes32,bytes32))` and selector `0xe42eaf0737e2478a5f5aed3a0610ae7b09a27cbac9ad6a5cc4d68f78afd1425b`.
```solidity
event ChallengeResolved(PendingAssertion);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ChallengeResolved {
        #[allow(missing_docs)]
        pub _0: <PendingAssertion as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ChallengeResolved {
            type DataTuple<'a> = (PendingAssertion,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ChallengeResolved((bytes32,bytes32,bytes32))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                228u8,
                46u8,
                175u8,
                7u8,
                55u8,
                226u8,
                71u8,
                138u8,
                95u8,
                90u8,
                237u8,
                58u8,
                6u8,
                16u8,
                174u8,
                123u8,
                9u8,
                162u8,
                124u8,
                186u8,
                201u8,
                173u8,
                106u8,
                92u8,
                196u8,
                214u8,
                143u8,
                120u8,
                175u8,
                209u8,
                66u8,
                91u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { _0: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (<PendingAssertion as alloy_sol_types::SolType>::tokenize(&self._0),)
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ChallengeResolved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ChallengeResolved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ChallengeResolved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeAppchainConfigHash(bytes32,bytes32)` and selector `0xc985bccbd0c90e197f4a7373020a33ba6ff864d0399fd7d65c5c7c32ffb015ec`.
```solidity
event TeeAppchainConfigHash(bytes32 configHash, bytes32 blockHash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeAppchainConfigHash {
        #[allow(missing_docs)]
        pub configHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeAppchainConfigHash {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeAppchainConfigHash(bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                201u8,
                133u8,
                188u8,
                203u8,
                208u8,
                201u8,
                14u8,
                25u8,
                127u8,
                74u8,
                115u8,
                115u8,
                2u8,
                10u8,
                51u8,
                186u8,
                111u8,
                248u8,
                100u8,
                208u8,
                57u8,
                159u8,
                215u8,
                214u8,
                92u8,
                92u8,
                124u8,
                50u8,
                255u8,
                176u8,
                21u8,
                236u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    configHash: data.0,
                    blockHash: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.configHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockHash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeAppchainConfigHash {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeAppchainConfigHash> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeAppchainConfigHash) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeHacked(uint256)` and selector `0x37e8add694c5926d564e971160f5974103cbbbc7c90747c4c6f802031d3567a7`.
```solidity
event TeeHacked(uint256);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeHacked {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeHacked {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeHacked(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                55u8,
                232u8,
                173u8,
                214u8,
                148u8,
                197u8,
                146u8,
                109u8,
                86u8,
                78u8,
                151u8,
                17u8,
                96u8,
                245u8,
                151u8,
                65u8,
                3u8,
                203u8,
                187u8,
                199u8,
                201u8,
                7u8,
                71u8,
                196u8,
                198u8,
                248u8,
                2u8,
                3u8,
                29u8,
                53u8,
                103u8,
                167u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { _0: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeHacked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeHacked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeHacked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeKeysRevoked()` and selector `0xeca62e0074a13a90d600f003b7cb8d5bd50100008d3f3915f2554f3f8552c5cc`.
```solidity
event TeeKeysRevoked();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeKeysRevoked {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeKeysRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeKeysRevoked()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                236u8,
                166u8,
                46u8,
                0u8,
                116u8,
                161u8,
                58u8,
                144u8,
                214u8,
                0u8,
                240u8,
                3u8,
                183u8,
                203u8,
                141u8,
                91u8,
                213u8,
                1u8,
                0u8,
                0u8,
                141u8,
                63u8,
                57u8,
                21u8,
                242u8,
                85u8,
                79u8,
                63u8,
                133u8,
                82u8,
                197u8,
                204u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeKeysRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeKeysRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeKeysRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeProgramAdded(bytes32)` and selector `0x9a7a6469c25cf017890607695e4a149cc771f294fd871e2080d24cd109033ab6`.
```solidity
event TeeProgramAdded(bytes32 hash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeProgramAdded {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeProgramAdded {
            type DataTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeProgramAdded(bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                154u8,
                122u8,
                100u8,
                105u8,
                194u8,
                92u8,
                240u8,
                23u8,
                137u8,
                6u8,
                7u8,
                105u8,
                94u8,
                74u8,
                20u8,
                156u8,
                199u8,
                113u8,
                242u8,
                148u8,
                253u8,
                135u8,
                30u8,
                32u8,
                128u8,
                210u8,
                76u8,
                209u8,
                9u8,
                3u8,
                58u8,
                182u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { hash: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeProgramAdded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeProgramAdded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeProgramAdded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeProgramRemoved(bytes32)` and selector `0x2621c61d3315f2a3d26b22d746ba21a96d249f51ada323f7226cce5fe5fc3d64`.
```solidity
event TeeProgramRemoved(bytes32 hash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeProgramRemoved {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeProgramRemoved {
            type DataTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeProgramRemoved(bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                38u8,
                33u8,
                198u8,
                29u8,
                51u8,
                21u8,
                242u8,
                163u8,
                210u8,
                107u8,
                34u8,
                215u8,
                70u8,
                186u8,
                33u8,
                169u8,
                109u8,
                36u8,
                159u8,
                81u8,
                173u8,
                163u8,
                35u8,
                247u8,
                34u8,
                108u8,
                206u8,
                95u8,
                229u8,
                252u8,
                61u8,
                100u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { hash: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeProgramRemoved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeProgramRemoved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeProgramRemoved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeSeqConfigHash(bytes32,bytes32)` and selector `0xb9eb20b32fac965884cb58326102257cae604504f0a36cd1008a32845ad5c29b`.
```solidity
event TeeSeqConfigHash(bytes32 configHash, bytes32 blockHash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeSeqConfigHash {
        #[allow(missing_docs)]
        pub configHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeSeqConfigHash {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeSeqConfigHash(bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                185u8,
                235u8,
                32u8,
                179u8,
                47u8,
                172u8,
                150u8,
                88u8,
                132u8,
                203u8,
                88u8,
                50u8,
                97u8,
                2u8,
                37u8,
                124u8,
                174u8,
                96u8,
                69u8,
                4u8,
                240u8,
                163u8,
                108u8,
                209u8,
                0u8,
                138u8,
                50u8,
                132u8,
                90u8,
                213u8,
                194u8,
                155u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    configHash: data.0,
                    blockHash: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.configHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockHash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeSeqConfigHash {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeSeqConfigHash> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeSeqConfigHash) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address poster_, address bridge_, bytes32 appchainConfigHash_, bytes32 appchainStartBlockHash_, bytes32 seqConfigHash_, bytes32 seqStartBlockHash_, bytes32 l1StartBlockHash_, bytes32 teeProgram);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub poster_: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub bridge_: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub appchainStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1StartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub teeProgram: alloy::sol_types::private::FixedBytes<32>,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value.poster_,
                        value.bridge_,
                        value.appchainConfigHash_,
                        value.appchainStartBlockHash_,
                        value.seqConfigHash_,
                        value.seqStartBlockHash_,
                        value.l1StartBlockHash_,
                        value.teeProgram,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        poster_: tuple.0,
                        bridge_: tuple.1,
                        appchainConfigHash_: tuple.2,
                        appchainStartBlockHash_: tuple.3,
                        seqConfigHash_: tuple.4,
                        seqStartBlockHash_: tuple.5,
                        l1StartBlockHash_: tuple.6,
                        teeProgram: tuple.7,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.poster_,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge_,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainConfigHash_),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.appchainStartBlockHash_,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.seqConfigHash_),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.seqStartBlockHash_),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.l1StartBlockHash_),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.teeProgram),
                )
            }
        }
    };
    /**Function with signature `addTeeKey(address,bytes32,bytes)` and selector `0x70646ea2`.
```solidity
function addTeeKey(address publicKey, bytes32 programHash, bytes memory zkProof) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addTeeKeyCall {
        #[allow(missing_docs)]
        pub publicKey: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub programHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub zkProof: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`addTeeKey(address,bytes32,bytes)`](addTeeKeyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addTeeKeyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addTeeKeyCall> for UnderlyingRustTuple<'_> {
                fn from(value: addTeeKeyCall) -> Self {
                    (value.publicKey, value.programHash, value.zkProof)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addTeeKeyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        publicKey: tuple.0,
                        programHash: tuple.1,
                        zkProof: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addTeeKeyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addTeeKeyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addTeeKeyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addTeeKeyCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addTeeKeyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addTeeKey(address,bytes32,bytes)";
            const SELECTOR: [u8; 4] = [112u8, 100u8, 110u8, 162u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.publicKey,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.programHash),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.zkProof,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `addTeeProgram(bytes32)` and selector `0x1c12427f`.
```solidity
function addTeeProgram(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addTeeProgramCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`addTeeProgram(bytes32)`](addTeeProgramCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addTeeProgramReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addTeeProgramCall> for UnderlyingRustTuple<'_> {
                fn from(value: addTeeProgramCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addTeeProgramCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addTeeProgramReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addTeeProgramReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addTeeProgramReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addTeeProgramCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addTeeProgramReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addTeeProgram(bytes32)";
            const SELECTOR: [u8; 4] = [28u8, 18u8, 66u8, 127u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridge()` and selector `0xe78cea92`.
```solidity
function bridge() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeCall {}
    ///Container type for the return parameters of the [`bridge()`](bridgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridge()";
            const SELECTOR: [u8; 4] = [231u8, 140u8, 234u8, 146u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `challengeWindowDuration()` and selector `0x4bd167c9`.
```solidity
function challengeWindowDuration() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowDurationCall {}
    ///Container type for the return parameters of the [`challengeWindowDuration()`](challengeWindowDurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowDurationReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowDurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowDurationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowDurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowDurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowDurationReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowDurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for challengeWindowDurationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = challengeWindowDurationReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "challengeWindowDuration()";
            const SELECTOR: [u8; 4] = [75u8, 209u8, 103u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `challengeWindowEnd()` and selector `0xee1c28b8`.
```solidity
function challengeWindowEnd() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowEndCall {}
    ///Container type for the return parameters of the [`challengeWindowEnd()`](challengeWindowEndCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowEndReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowEndCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowEndCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowEndCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowEndReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowEndReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowEndReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for challengeWindowEndCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = challengeWindowEndReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "challengeWindowEnd()";
            const SELECTOR: [u8; 4] = [238u8, 28u8, 40u8, 184u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `closeChallengeWindow()` and selector `0x6c4c2060`.
```solidity
function closeChallengeWindow() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct closeChallengeWindowCall {}
    ///Container type for the return parameters of the [`closeChallengeWindow()`](closeChallengeWindowCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct closeChallengeWindowReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<closeChallengeWindowCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: closeChallengeWindowCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for closeChallengeWindowCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<closeChallengeWindowReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: closeChallengeWindowReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for closeChallengeWindowReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for closeChallengeWindowCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = closeChallengeWindowReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "closeChallengeWindow()";
            const SELECTOR: [u8; 4] = [108u8, 76u8, 32u8, 96u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isTeeKey(address)` and selector `0x47742640`.
```solidity
function isTeeKey(address) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isTeeKeyCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isTeeKey(address)`](isTeeKeyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isTeeKeyReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isTeeKeyCall> for UnderlyingRustTuple<'_> {
                fn from(value: isTeeKeyCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isTeeKeyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isTeeKeyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isTeeKeyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isTeeKeyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isTeeKeyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isTeeKeyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isTeeKey(address)";
            const SELECTOR: [u8; 4] = [71u8, 116u8, 38u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall {}
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pendingAssertions(uint256)` and selector `0xa56ec6cd`.
```solidity
function pendingAssertions(uint256) external view returns (bytes32 blockHash, bytes32 sendRoot, bytes32 seqBlockHash);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingAssertionsCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`pendingAssertions(uint256)`](pendingAssertionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingAssertionsReturn {
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sendRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqBlockHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingAssertionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: pendingAssertionsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pendingAssertionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingAssertionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: pendingAssertionsReturn) -> Self {
                    (value.blockHash, value.sendRoot, value.seqBlockHash)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pendingAssertionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blockHash: tuple.0,
                        sendRoot: tuple.1,
                        seqBlockHash: tuple.2,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pendingAssertionsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pendingAssertionsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pendingAssertions(uint256)";
            const SELECTOR: [u8; 4] = [165u8, 110u8, 198u8, 205u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `poster()` and selector `0x80959721`.
```solidity
function poster() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct posterCall {}
    ///Container type for the return parameters of the [`poster()`](posterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct posterReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<posterCall> for UnderlyingRustTuple<'_> {
                fn from(value: posterCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for posterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<posterReturn> for UnderlyingRustTuple<'_> {
                fn from(value: posterReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for posterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for posterCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = posterReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "poster()";
            const SELECTOR: [u8; 4] = [128u8, 149u8, 151u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeTeeProgram(bytes32)` and selector `0x5f70c441`.
```solidity
function removeTeeProgram(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeTeeProgramCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`removeTeeProgram(bytes32)`](removeTeeProgramCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeTeeProgramReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeTeeProgramCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeTeeProgramCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeTeeProgramCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeTeeProgramReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeTeeProgramReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeTeeProgramReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeTeeProgramCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeTeeProgramReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeTeeProgram(bytes32)";
            const SELECTOR: [u8; 4] = [95u8, 112u8, 196u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall {}
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `resolveChallenge((bytes32,bytes32,bytes32))` and selector `0x8fed55a3`.
```solidity
function resolveChallenge(PendingAssertion memory assertion) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolveChallengeCall {
        #[allow(missing_docs)]
        pub assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`resolveChallenge((bytes32,bytes32,bytes32))`](resolveChallengeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolveChallengeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (PendingAssertion,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PendingAssertion as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolveChallengeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: resolveChallengeCall) -> Self {
                    (value.assertion,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resolveChallengeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { assertion: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolveChallengeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: resolveChallengeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resolveChallengeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for resolveChallengeCall {
            type Parameters<'a> = (PendingAssertion,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = resolveChallengeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "resolveChallenge((bytes32,bytes32,bytes32))";
            const SELECTOR: [u8; 4] = [143u8, 237u8, 85u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PendingAssertion as alloy_sol_types::SolType>::tokenize(
                        &self.assertion,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeAllTeeKeys()` and selector `0x6ef01201`.
```solidity
function revokeAllTeeKeys() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeAllTeeKeysCall {}
    ///Container type for the return parameters of the [`revokeAllTeeKeys()`](revokeAllTeeKeysCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeAllTeeKeysReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeAllTeeKeysCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: revokeAllTeeKeysCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for revokeAllTeeKeysCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeAllTeeKeysReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: revokeAllTeeKeysReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for revokeAllTeeKeysReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeAllTeeKeysCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeAllTeeKeysReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeAllTeeKeys()";
            const SELECTOR: [u8; 4] = [110u8, 240u8, 18u8, 1u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setAppchainConfigHash(bytes32)` and selector `0xf223055c`.
```solidity
function setAppchainConfigHash(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAppchainConfigHashCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`setAppchainConfigHash(bytes32)`](setAppchainConfigHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAppchainConfigHashReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAppchainConfigHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAppchainConfigHashCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAppchainConfigHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAppchainConfigHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAppchainConfigHashReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAppchainConfigHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setAppchainConfigHashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setAppchainConfigHashReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setAppchainConfigHash(bytes32)";
            const SELECTOR: [u8; 4] = [242u8, 35u8, 5u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setChallengeWindowDuration(uint256)` and selector `0x1caf5d13`.
```solidity
function setChallengeWindowDuration(uint256 duration) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setChallengeWindowDurationCall {
        #[allow(missing_docs)]
        pub duration: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setChallengeWindowDuration(uint256)`](setChallengeWindowDurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setChallengeWindowDurationReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setChallengeWindowDurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setChallengeWindowDurationCall) -> Self {
                    (value.duration,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setChallengeWindowDurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { duration: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setChallengeWindowDurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setChallengeWindowDurationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setChallengeWindowDurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setChallengeWindowDurationCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setChallengeWindowDurationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setChallengeWindowDuration(uint256)";
            const SELECTOR: [u8; 4] = [28u8, 175u8, 93u8, 19u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.duration),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setSeqConfigHash(bytes32)` and selector `0xc3f2dbd3`.
```solidity
function setSeqConfigHash(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSeqConfigHashCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`setSeqConfigHash(bytes32)`](setSeqConfigHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSeqConfigHashReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSeqConfigHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setSeqConfigHashCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setSeqConfigHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSeqConfigHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setSeqConfigHashReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setSeqConfigHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setSeqConfigHashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setSeqConfigHashReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setSeqConfigHash(bytes32)";
            const SELECTOR: [u8; 4] = [195u8, 242u8, 219u8, 211u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `submitAssertion((bytes32,bytes32,bytes32),bytes,address)` and selector `0xe50c6156`.
```solidity
function submitAssertion(PendingAssertion memory assertion, bytes memory signature, address rewardAddr) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitAssertionCall {
        #[allow(missing_docs)]
        pub assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub signature: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub rewardAddr: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`submitAssertion((bytes32,bytes32,bytes32),bytes,address)`](submitAssertionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitAssertionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                PendingAssertion,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PendingAssertion as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitAssertionCall> for UnderlyingRustTuple<'_> {
                fn from(value: submitAssertionCall) -> Self {
                    (value.assertion, value.signature, value.rewardAddr)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for submitAssertionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        assertion: tuple.0,
                        signature: tuple.1,
                        rewardAddr: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitAssertionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: submitAssertionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for submitAssertionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for submitAssertionCall {
            type Parameters<'a> = (
                PendingAssertion,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = submitAssertionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "submitAssertion((bytes32,bytes32,bytes32),bytes,address)";
            const SELECTOR: [u8; 4] = [229u8, 12u8, 97u8, 86u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PendingAssertion as alloy_sol_types::SolType>::tokenize(
                        &self.assertion,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.signature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rewardAddr,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teeHackCount()` and selector `0x697b5e62`.
```solidity
function teeHackCount() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeHackCountCall {}
    ///Container type for the return parameters of the [`teeHackCount()`](teeHackCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeHackCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeHackCountCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeHackCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeHackCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeHackCountReturn> for UnderlyingRustTuple<'_> {
                fn from(value: teeHackCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeHackCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeHackCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeHackCountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teeHackCount()";
            const SELECTOR: [u8; 4] = [105u8, 123u8, 94u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teeProgramKeys(bytes32,uint256)` and selector `0x33339006`.
```solidity
function teeProgramKeys(bytes32, uint256) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeProgramKeysCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`teeProgramKeys(bytes32,uint256)`](teeProgramKeysCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeProgramKeysReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeProgramKeysCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeProgramKeysCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeProgramKeysCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeProgramKeysReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: teeProgramKeysReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for teeProgramKeysReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeProgramKeysCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeProgramKeysReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teeProgramKeys(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [51u8, 51u8, 144u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teePrograms(uint256)` and selector `0x4afffcc9`.
```solidity
function teePrograms(uint256) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeProgramsCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`teePrograms(uint256)`](teeProgramsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeProgramsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeProgramsCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeProgramsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeProgramsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeProgramsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: teeProgramsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeProgramsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeProgramsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeProgramsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teePrograms(uint256)";
            const SELECTOR: [u8; 4] = [74u8, 255u8, 252u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teeTrustedInput()` and selector `0x3ceaae7d`.
```solidity
function teeTrustedInput() external view returns (bytes32 appchainConfigHash, bytes32 appchainStartBlockHash, bytes32 seqConfigHash, bytes32 seqStartBlockHash, bytes32 setDelayedMessageAcc, bytes32 l1StartBlockHash, bytes32 l1EndBlockHash);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeTrustedInputCall {}
    ///Container type for the return parameters of the [`teeTrustedInput()`](teeTrustedInputCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeTrustedInputReturn {
        #[allow(missing_docs)]
        pub appchainConfigHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub appchainStartBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqConfigHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqStartBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub setDelayedMessageAcc: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1StartBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1EndBlockHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeTrustedInputCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeTrustedInputCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeTrustedInputCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeTrustedInputReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: teeTrustedInputReturn) -> Self {
                    (
                        value.appchainConfigHash,
                        value.appchainStartBlockHash,
                        value.seqConfigHash,
                        value.seqStartBlockHash,
                        value.setDelayedMessageAcc,
                        value.l1StartBlockHash,
                        value.l1EndBlockHash,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for teeTrustedInputReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        appchainConfigHash: tuple.0,
                        appchainStartBlockHash: tuple.1,
                        seqConfigHash: tuple.2,
                        seqStartBlockHash: tuple.3,
                        setDelayedMessageAcc: tuple.4,
                        l1StartBlockHash: tuple.5,
                        l1EndBlockHash: tuple.6,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeTrustedInputCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeTrustedInputReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teeTrustedInput()";
            const SELECTOR: [u8; 4] = [60u8, 234u8, 174u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`TeeModule`](self) function calls.
    pub enum TeeModuleCalls {
        #[allow(missing_docs)]
        addTeeKey(addTeeKeyCall),
        #[allow(missing_docs)]
        addTeeProgram(addTeeProgramCall),
        #[allow(missing_docs)]
        bridge(bridgeCall),
        #[allow(missing_docs)]
        challengeWindowDuration(challengeWindowDurationCall),
        #[allow(missing_docs)]
        challengeWindowEnd(challengeWindowEndCall),
        #[allow(missing_docs)]
        closeChallengeWindow(closeChallengeWindowCall),
        #[allow(missing_docs)]
        isTeeKey(isTeeKeyCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        pendingAssertions(pendingAssertionsCall),
        #[allow(missing_docs)]
        poster(posterCall),
        #[allow(missing_docs)]
        removeTeeProgram(removeTeeProgramCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        resolveChallenge(resolveChallengeCall),
        #[allow(missing_docs)]
        revokeAllTeeKeys(revokeAllTeeKeysCall),
        #[allow(missing_docs)]
        setAppchainConfigHash(setAppchainConfigHashCall),
        #[allow(missing_docs)]
        setChallengeWindowDuration(setChallengeWindowDurationCall),
        #[allow(missing_docs)]
        setSeqConfigHash(setSeqConfigHashCall),
        #[allow(missing_docs)]
        submitAssertion(submitAssertionCall),
        #[allow(missing_docs)]
        teeHackCount(teeHackCountCall),
        #[allow(missing_docs)]
        teeProgramKeys(teeProgramKeysCall),
        #[allow(missing_docs)]
        teePrograms(teeProgramsCall),
        #[allow(missing_docs)]
        teeTrustedInput(teeTrustedInputCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
    }
    #[automatically_derived]
    impl TeeModuleCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [28u8, 18u8, 66u8, 127u8],
            [28u8, 175u8, 93u8, 19u8],
            [51u8, 51u8, 144u8, 6u8],
            [60u8, 234u8, 174u8, 125u8],
            [71u8, 116u8, 38u8, 64u8],
            [74u8, 255u8, 252u8, 201u8],
            [75u8, 209u8, 103u8, 201u8],
            [95u8, 112u8, 196u8, 65u8],
            [105u8, 123u8, 94u8, 98u8],
            [108u8, 76u8, 32u8, 96u8],
            [110u8, 240u8, 18u8, 1u8],
            [112u8, 100u8, 110u8, 162u8],
            [113u8, 80u8, 24u8, 166u8],
            [128u8, 149u8, 151u8, 33u8],
            [141u8, 165u8, 203u8, 91u8],
            [143u8, 237u8, 85u8, 163u8],
            [165u8, 110u8, 198u8, 205u8],
            [195u8, 242u8, 219u8, 211u8],
            [229u8, 12u8, 97u8, 86u8],
            [231u8, 140u8, 234u8, 146u8],
            [238u8, 28u8, 40u8, 184u8],
            [242u8, 35u8, 5u8, 92u8],
            [242u8, 253u8, 227u8, 139u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for TeeModuleCalls {
        const NAME: &'static str = "TeeModuleCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 23usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::addTeeKey(_) => {
                    <addTeeKeyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addTeeProgram(_) => {
                    <addTeeProgramCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridge(_) => <bridgeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::challengeWindowDuration(_) => {
                    <challengeWindowDurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::challengeWindowEnd(_) => {
                    <challengeWindowEndCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::closeChallengeWindow(_) => {
                    <closeChallengeWindowCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isTeeKey(_) => <isTeeKeyCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pendingAssertions(_) => {
                    <pendingAssertionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::poster(_) => <posterCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::removeTeeProgram(_) => {
                    <removeTeeProgramCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::resolveChallenge(_) => {
                    <resolveChallengeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeAllTeeKeys(_) => {
                    <revokeAllTeeKeysCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setAppchainConfigHash(_) => {
                    <setAppchainConfigHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setChallengeWindowDuration(_) => {
                    <setChallengeWindowDurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setSeqConfigHash(_) => {
                    <setSeqConfigHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::submitAssertion(_) => {
                    <submitAssertionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::teeHackCount(_) => {
                    <teeHackCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::teeProgramKeys(_) => {
                    <teeProgramKeysCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::teePrograms(_) => {
                    <teeProgramsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::teeTrustedInput(_) => {
                    <teeTrustedInputCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<TeeModuleCalls>] = &[
                {
                    fn addTeeProgram(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <addTeeProgramCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::addTeeProgram)
                    }
                    addTeeProgram
                },
                {
                    fn setChallengeWindowDuration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <setChallengeWindowDurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::setChallengeWindowDuration)
                    }
                    setChallengeWindowDuration
                },
                {
                    fn teeProgramKeys(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeProgramKeysCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teeProgramKeys)
                    }
                    teeProgramKeys
                },
                {
                    fn teeTrustedInput(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeTrustedInputCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teeTrustedInput)
                    }
                    teeTrustedInput
                },
                {
                    fn isTeeKey(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <isTeeKeyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::isTeeKey)
                    }
                    isTeeKey
                },
                {
                    fn teePrograms(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeProgramsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teePrograms)
                    }
                    teePrograms
                },
                {
                    fn challengeWindowDuration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <challengeWindowDurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::challengeWindowDuration)
                    }
                    challengeWindowDuration
                },
                {
                    fn removeTeeProgram(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <removeTeeProgramCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::removeTeeProgram)
                    }
                    removeTeeProgram
                },
                {
                    fn teeHackCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeHackCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teeHackCount)
                    }
                    teeHackCount
                },
                {
                    fn closeChallengeWindow(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <closeChallengeWindowCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::closeChallengeWindow)
                    }
                    closeChallengeWindow
                },
                {
                    fn revokeAllTeeKeys(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <revokeAllTeeKeysCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::revokeAllTeeKeys)
                    }
                    revokeAllTeeKeys
                },
                {
                    fn addTeeKey(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <addTeeKeyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::addTeeKey)
                    }
                    addTeeKey
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn poster(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <posterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::poster)
                    }
                    poster
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::owner)
                    }
                    owner
                },
                {
                    fn resolveChallenge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <resolveChallengeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::resolveChallenge)
                    }
                    resolveChallenge
                },
                {
                    fn pendingAssertions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <pendingAssertionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::pendingAssertions)
                    }
                    pendingAssertions
                },
                {
                    fn setSeqConfigHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <setSeqConfigHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::setSeqConfigHash)
                    }
                    setSeqConfigHash
                },
                {
                    fn submitAssertion(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <submitAssertionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::submitAssertion)
                    }
                    submitAssertion
                },
                {
                    fn bridge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <bridgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::bridge)
                    }
                    bridge
                },
                {
                    fn challengeWindowEnd(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <challengeWindowEndCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::challengeWindowEnd)
                    }
                    challengeWindowEnd
                },
                {
                    fn setAppchainConfigHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <setAppchainConfigHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::setAppchainConfigHash)
                    }
                    setAppchainConfigHash
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::transferOwnership)
                    }
                    transferOwnership
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::addTeeKey(inner) => {
                    <addTeeKeyCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::addTeeProgram(inner) => {
                    <addTeeProgramCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridge(inner) => {
                    <bridgeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::challengeWindowDuration(inner) => {
                    <challengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::challengeWindowEnd(inner) => {
                    <challengeWindowEndCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::closeChallengeWindow(inner) => {
                    <closeChallengeWindowCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isTeeKey(inner) => {
                    <isTeeKeyCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pendingAssertions(inner) => {
                    <pendingAssertionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::poster(inner) => {
                    <posterCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::removeTeeProgram(inner) => {
                    <removeTeeProgramCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::resolveChallenge(inner) => {
                    <resolveChallengeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeAllTeeKeys(inner) => {
                    <revokeAllTeeKeysCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setAppchainConfigHash(inner) => {
                    <setAppchainConfigHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setChallengeWindowDuration(inner) => {
                    <setChallengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setSeqConfigHash(inner) => {
                    <setSeqConfigHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::submitAssertion(inner) => {
                    <submitAssertionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::teeHackCount(inner) => {
                    <teeHackCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::teeProgramKeys(inner) => {
                    <teeProgramKeysCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::teePrograms(inner) => {
                    <teeProgramsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::teeTrustedInput(inner) => {
                    <teeTrustedInputCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::addTeeKey(inner) => {
                    <addTeeKeyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addTeeProgram(inner) => {
                    <addTeeProgramCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridge(inner) => {
                    <bridgeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::challengeWindowDuration(inner) => {
                    <challengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::challengeWindowEnd(inner) => {
                    <challengeWindowEndCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::closeChallengeWindow(inner) => {
                    <closeChallengeWindowCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isTeeKey(inner) => {
                    <isTeeKeyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pendingAssertions(inner) => {
                    <pendingAssertionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::poster(inner) => {
                    <posterCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::removeTeeProgram(inner) => {
                    <removeTeeProgramCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::resolveChallenge(inner) => {
                    <resolveChallengeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeAllTeeKeys(inner) => {
                    <revokeAllTeeKeysCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setAppchainConfigHash(inner) => {
                    <setAppchainConfigHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setChallengeWindowDuration(inner) => {
                    <setChallengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setSeqConfigHash(inner) => {
                    <setSeqConfigHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::submitAssertion(inner) => {
                    <submitAssertionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::teeHackCount(inner) => {
                    <teeHackCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::teeProgramKeys(inner) => {
                    <teeProgramKeysCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::teePrograms(inner) => {
                    <teeProgramsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::teeTrustedInput(inner) => {
                    <teeTrustedInputCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`TeeModule`](self) custom errors.
    pub enum TeeModuleErrors {
        #[allow(missing_docs)]
        ECDSAInvalidSignature(ECDSAInvalidSignature),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureLength(ECDSAInvalidSignatureLength),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureS(ECDSAInvalidSignatureS),
    }
    #[automatically_derived]
    impl TeeModuleErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [215u8, 139u8, 206u8, 12u8],
            [246u8, 69u8, 238u8, 223u8],
            [252u8, 230u8, 152u8, 247u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for TeeModuleErrors {
        const NAME: &'static str = "TeeModuleErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 3usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ECDSAInvalidSignature(_) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureLength(_) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureS(_) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<TeeModuleErrors>] = &[
                {
                    fn ECDSAInvalidSignatureS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::ECDSAInvalidSignatureS)
                    }
                    ECDSAInvalidSignatureS
                },
                {
                    fn ECDSAInvalidSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::ECDSAInvalidSignature)
                    }
                    ECDSAInvalidSignature
                },
                {
                    fn ECDSAInvalidSignatureLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::ECDSAInvalidSignatureLength)
                    }
                    ECDSAInvalidSignatureLength
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`TeeModule`](self) events.
    pub enum TeeModuleEvents {
        #[allow(missing_docs)]
        ChallengeResolved(ChallengeResolved),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
        #[allow(missing_docs)]
        TeeAppchainConfigHash(TeeAppchainConfigHash),
        #[allow(missing_docs)]
        TeeHacked(TeeHacked),
        #[allow(missing_docs)]
        TeeKeysRevoked(TeeKeysRevoked),
        #[allow(missing_docs)]
        TeeProgramAdded(TeeProgramAdded),
        #[allow(missing_docs)]
        TeeProgramRemoved(TeeProgramRemoved),
        #[allow(missing_docs)]
        TeeSeqConfigHash(TeeSeqConfigHash),
    }
    #[automatically_derived]
    impl TeeModuleEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                38u8,
                33u8,
                198u8,
                29u8,
                51u8,
                21u8,
                242u8,
                163u8,
                210u8,
                107u8,
                34u8,
                215u8,
                70u8,
                186u8,
                33u8,
                169u8,
                109u8,
                36u8,
                159u8,
                81u8,
                173u8,
                163u8,
                35u8,
                247u8,
                34u8,
                108u8,
                206u8,
                95u8,
                229u8,
                252u8,
                61u8,
                100u8,
            ],
            [
                55u8,
                232u8,
                173u8,
                214u8,
                148u8,
                197u8,
                146u8,
                109u8,
                86u8,
                78u8,
                151u8,
                17u8,
                96u8,
                245u8,
                151u8,
                65u8,
                3u8,
                203u8,
                187u8,
                199u8,
                201u8,
                7u8,
                71u8,
                196u8,
                198u8,
                248u8,
                2u8,
                3u8,
                29u8,
                53u8,
                103u8,
                167u8,
            ],
            [
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ],
            [
                154u8,
                122u8,
                100u8,
                105u8,
                194u8,
                92u8,
                240u8,
                23u8,
                137u8,
                6u8,
                7u8,
                105u8,
                94u8,
                74u8,
                20u8,
                156u8,
                199u8,
                113u8,
                242u8,
                148u8,
                253u8,
                135u8,
                30u8,
                32u8,
                128u8,
                210u8,
                76u8,
                209u8,
                9u8,
                3u8,
                58u8,
                182u8,
            ],
            [
                185u8,
                235u8,
                32u8,
                179u8,
                47u8,
                172u8,
                150u8,
                88u8,
                132u8,
                203u8,
                88u8,
                50u8,
                97u8,
                2u8,
                37u8,
                124u8,
                174u8,
                96u8,
                69u8,
                4u8,
                240u8,
                163u8,
                108u8,
                209u8,
                0u8,
                138u8,
                50u8,
                132u8,
                90u8,
                213u8,
                194u8,
                155u8,
            ],
            [
                201u8,
                133u8,
                188u8,
                203u8,
                208u8,
                201u8,
                14u8,
                25u8,
                127u8,
                74u8,
                115u8,
                115u8,
                2u8,
                10u8,
                51u8,
                186u8,
                111u8,
                248u8,
                100u8,
                208u8,
                57u8,
                159u8,
                215u8,
                214u8,
                92u8,
                92u8,
                124u8,
                50u8,
                255u8,
                176u8,
                21u8,
                236u8,
            ],
            [
                228u8,
                46u8,
                175u8,
                7u8,
                55u8,
                226u8,
                71u8,
                138u8,
                95u8,
                90u8,
                237u8,
                58u8,
                6u8,
                16u8,
                174u8,
                123u8,
                9u8,
                162u8,
                124u8,
                186u8,
                201u8,
                173u8,
                106u8,
                92u8,
                196u8,
                214u8,
                143u8,
                120u8,
                175u8,
                209u8,
                66u8,
                91u8,
            ],
            [
                236u8,
                166u8,
                46u8,
                0u8,
                116u8,
                161u8,
                58u8,
                144u8,
                214u8,
                0u8,
                240u8,
                3u8,
                183u8,
                203u8,
                141u8,
                91u8,
                213u8,
                1u8,
                0u8,
                0u8,
                141u8,
                63u8,
                57u8,
                21u8,
                242u8,
                85u8,
                79u8,
                63u8,
                133u8,
                82u8,
                197u8,
                204u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for TeeModuleEvents {
        const NAME: &'static str = "TeeModuleEvents";
        const COUNT: usize = 8usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <ChallengeResolved as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ChallengeResolved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ChallengeResolved)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(
                    <TeeAppchainConfigHash as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <TeeAppchainConfigHash as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeAppchainConfigHash)
                }
                Some(<TeeHacked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TeeHacked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeHacked)
                }
                Some(<TeeKeysRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TeeKeysRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeKeysRevoked)
                }
                Some(<TeeProgramAdded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TeeProgramAdded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeProgramAdded)
                }
                Some(
                    <TeeProgramRemoved as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <TeeProgramRemoved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeProgramRemoved)
                }
                Some(<TeeSeqConfigHash as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TeeSeqConfigHash as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeSeqConfigHash)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for TeeModuleEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChallengeResolved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeAppchainConfigHash(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeHacked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeKeysRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeProgramAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeProgramRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeSeqConfigHash(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChallengeResolved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeAppchainConfigHash(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeHacked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeKeysRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeProgramAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeProgramRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeSeqConfigHash(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`TeeModule`](self) contract instance.

See the [wrapper's documentation](`TeeModuleInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> TeeModuleInstance<T, P, N> {
        TeeModuleInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        poster_: alloy::sol_types::private::Address,
        bridge_: alloy::sol_types::private::Address,
        appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        appchainStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        seqConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        seqStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        l1StartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        teeProgram: alloy::sol_types::private::FixedBytes<32>,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<TeeModuleInstance<T, P, N>>,
    > {
        TeeModuleInstance::<
            T,
            P,
            N,
        >::deploy(
            provider,
            poster_,
            bridge_,
            appchainConfigHash_,
            appchainStartBlockHash_,
            seqConfigHash_,
            seqStartBlockHash_,
            l1StartBlockHash_,
            teeProgram,
        )
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        poster_: alloy::sol_types::private::Address,
        bridge_: alloy::sol_types::private::Address,
        appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        appchainStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        seqConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        seqStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        l1StartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        teeProgram: alloy::sol_types::private::FixedBytes<32>,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        TeeModuleInstance::<
            T,
            P,
            N,
        >::deploy_builder(
            provider,
            poster_,
            bridge_,
            appchainConfigHash_,
            appchainStartBlockHash_,
            seqConfigHash_,
            seqStartBlockHash_,
            l1StartBlockHash_,
            teeProgram,
        )
    }
    /**A [`TeeModule`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`TeeModule`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct TeeModuleInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for TeeModuleInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("TeeModuleInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TeeModuleInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`TeeModule`](self) contract instance.

See the [wrapper's documentation](`TeeModuleInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            poster_: alloy::sol_types::private::Address,
            bridge_: alloy::sol_types::private::Address,
            appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
            appchainStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            seqConfigHash_: alloy::sol_types::private::FixedBytes<32>,
            seqStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            l1StartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            teeProgram: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::Result<TeeModuleInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                poster_,
                bridge_,
                appchainConfigHash_,
                appchainStartBlockHash_,
                seqConfigHash_,
                seqStartBlockHash_,
                l1StartBlockHash_,
                teeProgram,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            poster_: alloy::sol_types::private::Address,
            bridge_: alloy::sol_types::private::Address,
            appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
            appchainStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            seqConfigHash_: alloy::sol_types::private::FixedBytes<32>,
            seqStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            l1StartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            teeProgram: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            poster_,
                            bridge_,
                            appchainConfigHash_,
                            appchainStartBlockHash_,
                            seqConfigHash_,
                            seqStartBlockHash_,
                            l1StartBlockHash_,
                            teeProgram,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> TeeModuleInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> TeeModuleInstance<T, P, N> {
            TeeModuleInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TeeModuleInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`addTeeKey`] function.
        pub fn addTeeKey(
            &self,
            publicKey: alloy::sol_types::private::Address,
            programHash: alloy::sol_types::private::FixedBytes<32>,
            zkProof: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, addTeeKeyCall, N> {
            self.call_builder(
                &addTeeKeyCall {
                    publicKey,
                    programHash,
                    zkProof,
                },
            )
        }
        ///Creates a new call builder for the [`addTeeProgram`] function.
        pub fn addTeeProgram(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, addTeeProgramCall, N> {
            self.call_builder(&addTeeProgramCall { hash })
        }
        ///Creates a new call builder for the [`bridge`] function.
        pub fn bridge(&self) -> alloy_contract::SolCallBuilder<T, &P, bridgeCall, N> {
            self.call_builder(&bridgeCall {})
        }
        ///Creates a new call builder for the [`challengeWindowDuration`] function.
        pub fn challengeWindowDuration(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, challengeWindowDurationCall, N> {
            self.call_builder(&challengeWindowDurationCall {})
        }
        ///Creates a new call builder for the [`challengeWindowEnd`] function.
        pub fn challengeWindowEnd(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, challengeWindowEndCall, N> {
            self.call_builder(&challengeWindowEndCall {})
        }
        ///Creates a new call builder for the [`closeChallengeWindow`] function.
        pub fn closeChallengeWindow(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, closeChallengeWindowCall, N> {
            self.call_builder(&closeChallengeWindowCall {})
        }
        ///Creates a new call builder for the [`isTeeKey`] function.
        pub fn isTeeKey(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isTeeKeyCall, N> {
            self.call_builder(&isTeeKeyCall { _0 })
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        ///Creates a new call builder for the [`pendingAssertions`] function.
        pub fn pendingAssertions(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, pendingAssertionsCall, N> {
            self.call_builder(&pendingAssertionsCall { _0 })
        }
        ///Creates a new call builder for the [`poster`] function.
        pub fn poster(&self) -> alloy_contract::SolCallBuilder<T, &P, posterCall, N> {
            self.call_builder(&posterCall {})
        }
        ///Creates a new call builder for the [`removeTeeProgram`] function.
        pub fn removeTeeProgram(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeTeeProgramCall, N> {
            self.call_builder(&removeTeeProgramCall { hash })
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall {})
        }
        ///Creates a new call builder for the [`resolveChallenge`] function.
        pub fn resolveChallenge(
            &self,
            assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, resolveChallengeCall, N> {
            self.call_builder(&resolveChallengeCall { assertion })
        }
        ///Creates a new call builder for the [`revokeAllTeeKeys`] function.
        pub fn revokeAllTeeKeys(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, revokeAllTeeKeysCall, N> {
            self.call_builder(&revokeAllTeeKeysCall {})
        }
        ///Creates a new call builder for the [`setAppchainConfigHash`] function.
        pub fn setAppchainConfigHash(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setAppchainConfigHashCall, N> {
            self.call_builder(&setAppchainConfigHashCall { hash })
        }
        ///Creates a new call builder for the [`setChallengeWindowDuration`] function.
        pub fn setChallengeWindowDuration(
            &self,
            duration: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setChallengeWindowDurationCall, N> {
            self.call_builder(
                &setChallengeWindowDurationCall {
                    duration,
                },
            )
        }
        ///Creates a new call builder for the [`setSeqConfigHash`] function.
        pub fn setSeqConfigHash(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setSeqConfigHashCall, N> {
            self.call_builder(&setSeqConfigHashCall { hash })
        }
        ///Creates a new call builder for the [`submitAssertion`] function.
        pub fn submitAssertion(
            &self,
            assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
            signature: alloy::sol_types::private::Bytes,
            rewardAddr: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, submitAssertionCall, N> {
            self.call_builder(
                &submitAssertionCall {
                    assertion,
                    signature,
                    rewardAddr,
                },
            )
        }
        ///Creates a new call builder for the [`teeHackCount`] function.
        pub fn teeHackCount(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeHackCountCall, N> {
            self.call_builder(&teeHackCountCall {})
        }
        ///Creates a new call builder for the [`teeProgramKeys`] function.
        pub fn teeProgramKeys(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
            _1: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeProgramKeysCall, N> {
            self.call_builder(&teeProgramKeysCall { _0, _1 })
        }
        ///Creates a new call builder for the [`teePrograms`] function.
        pub fn teePrograms(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeProgramsCall, N> {
            self.call_builder(&teeProgramsCall { _0 })
        }
        ///Creates a new call builder for the [`teeTrustedInput`] function.
        pub fn teeTrustedInput(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeTrustedInputCall, N> {
            self.call_builder(&teeTrustedInputCall {})
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TeeModuleInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`ChallengeResolved`] event.
        pub fn ChallengeResolved_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ChallengeResolved, N> {
            self.event_filter::<ChallengeResolved>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`TeeAppchainConfigHash`] event.
        pub fn TeeAppchainConfigHash_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeAppchainConfigHash, N> {
            self.event_filter::<TeeAppchainConfigHash>()
        }
        ///Creates a new event filter for the [`TeeHacked`] event.
        pub fn TeeHacked_filter(&self) -> alloy_contract::Event<T, &P, TeeHacked, N> {
            self.event_filter::<TeeHacked>()
        }
        ///Creates a new event filter for the [`TeeKeysRevoked`] event.
        pub fn TeeKeysRevoked_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeKeysRevoked, N> {
            self.event_filter::<TeeKeysRevoked>()
        }
        ///Creates a new event filter for the [`TeeProgramAdded`] event.
        pub fn TeeProgramAdded_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeProgramAdded, N> {
            self.event_filter::<TeeProgramAdded>()
        }
        ///Creates a new event filter for the [`TeeProgramRemoved`] event.
        pub fn TeeProgramRemoved_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeProgramRemoved, N> {
            self.event_filter::<TeeProgramRemoved>()
        }
        ///Creates a new event filter for the [`TeeSeqConfigHash`] event.
        pub fn TeeSeqConfigHash_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeSeqConfigHash, N> {
            self.event_filter::<TeeSeqConfigHash>()
        }
    }
}
