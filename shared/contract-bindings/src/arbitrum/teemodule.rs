/**

Generated by the following Solidity interface...
```solidity
interface TeeModule {
    struct AssertionPayload {
        bytes32 teeTrustedInputHash;
        PendingAssertion assertion;
    }
    struct PendingAssertion {
        bytes32 blockHash;
        bytes32 sendRoot;
    }

    error ECDSAInvalidSignature();
    error ECDSAInvalidSignatureLength(uint256 length);
    error ECDSAInvalidSignatureS(bytes32 s);

    event ChallengeResolved(PendingAssertion);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event TeeAppchainConfigHash(bytes32 hash);
    event TeeHacked(uint256);
    event TeeKeysRevoked();
    event TeeProgramHashAdded(bytes32 hash);
    event TeeProgramHashRemoved(bytes32 hash);

    constructor(address poster_, bytes32 appchainConfigHash_);

    function addTeeKey(address publicKey, bytes memory zkProof) external;
    function addTeeProgramHash(bytes32 hash) external;
    function challengeWindowDuration() external view returns (uint256);
    function challengeWindowEnd() external view returns (uint256);
    function closeChallengeWindow() external;
    function isTeeKey(address) external view returns (bool);
    function isTeeProgramHash(bytes32) external view returns (bool);
    function owner() external view returns (address);
    function pendingAssertions(uint256) external view returns (bytes32 blockHash, bytes32 sendRoot);
    function poster() external view returns (address);
    function removeTeeProgramHash(bytes32 hash) external;
    function renounceOwnership() external;
    function resolveChallenge(PendingAssertion memory assertion) external;
    function revokeAllTeeKeys() external;
    function setAppchainConfigHash(bytes32 hash) external;
    function setChallengeWindowDuration(uint256 duration) external;
    function submitAssertion(AssertionPayload memory payload, bytes memory signature, address rewardAddr) external;
    function teeHackCount() external view returns (uint256);
    function teeKeys(uint256) external view returns (address);
    function teeTrustedInput() external view returns (bytes32 appchainConfigHash, bytes32 setEndBlockHash, bytes32 l1EndBlockHash, bytes32 appchainStartBlockHash);
    function transferOwnership(address newOwner) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "poster_",
        "type": "address",
        "internalType": "contract AssertionPoster"
      },
      {
        "name": "appchainConfigHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addTeeKey",
    "inputs": [
      {
        "name": "publicKey",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "zkProof",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addTeeProgramHash",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "challengeWindowDuration",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "challengeWindowEnd",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "closeChallengeWindow",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "isTeeKey",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isTeeProgramHash",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pendingAssertions",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "blockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "sendRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "poster",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract AssertionPoster"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "removeTeeProgramHash",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "resolveChallenge",
    "inputs": [
      {
        "name": "assertion",
        "type": "tuple",
        "internalType": "struct PendingAssertion",
        "components": [
          {
            "name": "blockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "sendRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeAllTeeKeys",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setAppchainConfigHash",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setChallengeWindowDuration",
    "inputs": [
      {
        "name": "duration",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "submitAssertion",
    "inputs": [
      {
        "name": "payload",
        "type": "tuple",
        "internalType": "struct AssertionPayload",
        "components": [
          {
            "name": "teeTrustedInputHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "assertion",
            "type": "tuple",
            "internalType": "struct PendingAssertion",
            "components": [
              {
                "name": "blockHash",
                "type": "bytes32",
                "internalType": "bytes32"
              },
              {
                "name": "sendRoot",
                "type": "bytes32",
                "internalType": "bytes32"
              }
            ]
          }
        ]
      },
      {
        "name": "signature",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "rewardAddr",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "teeHackCount",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "teeKeys",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "teeTrustedInput",
    "inputs": [],
    "outputs": [
      {
        "name": "appchainConfigHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "setEndBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "l1EndBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "appchainStartBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "ChallengeResolved",
    "inputs": [
      {
        "name": "",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct PendingAssertion",
        "components": [
          {
            "name": "blockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "sendRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeAppchainConfigHash",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeHacked",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeKeysRevoked",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeProgramHashAdded",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeProgramHashRemoved",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureLength",
    "inputs": [
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureS",
    "inputs": [
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod TeeModule {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a060405234801561000f575f5ffd5b5060405161293e38038061293e83398181016040528101906100319190610232565b61004d6100426100c860201b60201c565b6100cf60201b60201c565b8173ffffffffffffffffffffffffffffffffffffffff1660808173ffffffffffffffffffffffffffffffffffffffff16815250508060015f01819055507fb7a180228497ed95c6896fc1b081a016999116f98ab95b52123659efea259764816040516100b9919061027f565b60405180910390a15050610298565b5f33905090565b5f5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f5f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f5ffd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6101bd82610194565b9050919050565b5f6101ce826101b3565b9050919050565b6101de816101c4565b81146101e8575f5ffd5b50565b5f815190506101f9816101d5565b92915050565b5f819050919050565b610211816101ff565b811461021b575f5ffd5b50565b5f8151905061022c81610208565b92915050565b5f5f6040838503121561024857610247610190565b5b5f610255858286016101eb565b92505060206102668582860161021e565b9150509250929050565b610279816101ff565b82525050565b5f6020820190506102925f830184610270565b92915050565b6080516126876102b75f395f8181610e3001526111c901526126875ff3fe608060405234801561000f575f5ffd5b5060043610610135575f3560e01c80636c4c2060116100b65780638da5cb5b1161007a5780638da5cb5b146102da578063a380ef87146102f8578063a56ec6cd14610328578063ee1c28b814610359578063f223055c14610377578063f2fde38b1461039357610135565b80636c4c20601461026e5780636ebed0f0146102785780636ef01201146102a8578063715018a6146102b257806380959721146102bc57610135565b806347742640116100fd57806347742640146101ca5780634bd167c9146101fa5780635d4bedc3146102185780636070e78e14610234578063697b5e621461025057610135565b80630ad195ab146101395780630b7c0241146101555780631caf5d13146101715780633ceaae7d1461018d57806343de5f33146101ae575b5f5ffd5b610153600480360381019061014e91906118fe565b6103af565b005b61016f600480360381019061016a919061194b565b61048d565b005b61018b600480360381019061018691906119a9565b61066d565b005b6101956106f3565b6040516101a594939291906119e3565b60405180910390f35b6101c860048036038101906101c391906118fe565b610710565b005b6101e460048036038101906101df9190611a80565b6107ef565b6040516101f19190611ac5565b60405180910390f35b61020261080c565b60405161020f9190611aed565b60405180910390f35b610232600480360381019061022d9190611b67565b610812565b005b61024e60048036038101906102499190611be2565b61092f565b005b610258610cde565b6040516102659190611aed565b60405180910390f35b610276610ce4565b005b610292600480360381019061028d91906119a9565b610f9f565b60405161029f9190611c62565b60405180910390f35b6102b0610fda565b005b6102ba611140565b005b6102c46111c7565b6040516102d19190611cd6565b60405180910390f35b6102e26111eb565b6040516102ef9190611c62565b60405180910390f35b610312600480360381019061030d91906118fe565b611212565b60405161031f9190611ac5565b60405180910390f35b610342600480360381019061033d91906119a9565b61122f565b604051610350929190611cef565b60405180910390f35b61036161125e565b60405161036e9190611aed565b60405180910390f35b610391600480360381019061038c91906118fe565b611264565b005b6103ad60048036038101906103a89190611a80565b611323565b005b6103b7611419565b73ffffffffffffffffffffffffffffffffffffffff166103d56111eb565b73ffffffffffffffffffffffffffffffffffffffff161461042b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161042290611d70565b60405180910390fd5b5f60095f8381526020019081526020015f205f6101000a81548160ff0219169083151502179055507f0db166bb4e47a660aafc32f78bbacdda0b90b0735e45b2134aeec3a5ea5655ab816040516104829190611d8e565b60405180910390a150565b610495611419565b73ffffffffffffffffffffffffffffffffffffffff166104b36111eb565b73ffffffffffffffffffffffffffffffffffffffff1614610509576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161050090611d70565b60405180910390fd5b600160058054905011610551576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161054890611df1565b60405180910390fd5b5f5f90505b60058054905081101561062e5761058c826005838154811061057b5761057a611e0f565b5b905f5260205f209060020201611420565b156106215760055f61059e9190611845565b600582908060018154018082558091505060019003905f5260205f2090600202015f9091909190915081816105d39190611f31565b50505f600a819055506105e4610ce4565b7f114e9c798e3c6d158b5d1dd711ce1e22785f3d94898ddb1ce7f9bc75173175d3826040516106139190611fa1565b60405180910390a15061066a565b8080600101915050610556565b506040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161066190612004565b60405180910390fd5b50565b610675611419565b73ffffffffffffffffffffffffffffffffffffffff166106936111eb565b73ffffffffffffffffffffffffffffffffffffffff16146106e9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106e090611d70565b60405180910390fd5b80600b8190555050565b6001805f0154908060010154908060020154908060030154905084565b610718611419565b73ffffffffffffffffffffffffffffffffffffffff166107366111eb565b73ffffffffffffffffffffffffffffffffffffffff161461078c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161078390611d70565b60405180910390fd5b600160095f8381526020019081526020015f205f6101000a81548160ff0219169083151502179055507f43885026c59ecbb824d102785fee5f9593e695bb9a8490864d9830952524e5d5816040516107e49190611d8e565b60405180910390a150565b6008602052805f5260405f205f915054906101000a900460ff1681565b600b5481565b6001828290501461082657610825612022565b5b60085f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1661092a57600160085f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550600783908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b505050565b60418383905014610975576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161096c90612099565b60405180910390fd5b61097f6001611445565b845f0135146109c3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109ba90612101565b60405180910390fd5b5f845f0135856020015f013586602001602001356040516020016109e99392919061213f565b60405160208183030381529060405280519060200120905060085f610a6286868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f81840152601f19601f82011690508083019250505050505050610a5485611489565b6114bc90919063ffffffff16565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff16610ae7576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ade906121c5565b60405180910390fd5b5f5f90505b600580549050811015610b7257610b258660200160058381548110610b1457610b13611e0f565b5b905f5260205f209060020201611420565b15610b65576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b5c9061222d565b60405180910390fd5b8080600101915050610aec565b505f60058054905003610b9457600b5442610b8d9190612278565b600a819055505b600585602001908060018154018082558091505060019003905f5260205f2090600202015f909190919091508181610bcc9190611f31565b5050600260058054905003610cd757600160065f828254610bed9190612278565b925050819055507f37e8add694c5926d564e971160f5974103cbbbc7c90747c4c6f802031d3567a7600654604051610c259190611aed565b60405180910390a15f8273ffffffffffffffffffffffffffffffffffffffff1647604051610c52906122d8565b5f6040518083038185875af1925050503d805f8114610c8c576040519150601f19603f3d011682016040523d82523d5f602084013e610c91565b606091505b5050905080610cd5576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ccc90612336565b60405180910390fd5b505b5050505050565b60065481565b5f734200000000000000000000000000000000000015905060016005805490501115610d45576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d3c906123c4565b60405180910390fd5b600a548173ffffffffffffffffffffffffffffffffffffffff1663b80777ea6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610d91573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610db591906123f6565b11610df5576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610dec90612491565b60405180910390fd5b5f6005805490501115610efc5760055f81548110610e1657610e15611e0f565b5b905f5260205f2090600202015f01546001600301819055507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663daeab41260055f81548110610e7e57610e7d611e0f565b5b905f5260205f2090600202015f015460055f81548110610ea157610ea0611e0f565b5b905f5260205f209060020201600101546040518363ffffffff1660e01b8152600401610ece929190611cef565b5f604051808303815f87803b158015610ee5575f5ffd5b505af1158015610ef7573d5f5f3e3d5ffd5b505050505b600143610f0991906124af565b4060018001819055508073ffffffffffffffffffffffffffffffffffffffff166309bd5a606040518163ffffffff1660e01b8152600401602060405180830381865afa158015610f5b573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610f7f91906124f6565b600160020181905550600b5442610f969190612278565b600a8190555050565b60078181548110610fae575f80fd5b905f5260205f20015f915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b610fe2611419565b73ffffffffffffffffffffffffffffffffffffffff166110006111eb565b73ffffffffffffffffffffffffffffffffffffffff1614611056576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161104d90611d70565b60405180910390fd5b5f5f90505b600780549050811015611104575f60085f600784815481106110805761107f611e0f565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550808060010191505061105b565b5060075f6111129190611866565b7feca62e0074a13a90d600f003b7cb8d5bd50100008d3f3915f2554f3f8552c5cc60405160405180910390a1565b611148611419565b73ffffffffffffffffffffffffffffffffffffffff166111666111eb565b73ffffffffffffffffffffffffffffffffffffffff16146111bc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016111b390611d70565b60405180910390fd5b6111c55f6114e6565b565b7f000000000000000000000000000000000000000000000000000000000000000081565b5f5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b6009602052805f5260405f205f915054906101000a900460ff1681565b6005818154811061123e575f80fd5b905f5260205f2090600202015f91509050805f0154908060010154905082565b600a5481565b61126c611419565b73ffffffffffffffffffffffffffffffffffffffff1661128a6111eb565b73ffffffffffffffffffffffffffffffffffffffff16146112e0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016112d790611d70565b60405180910390fd5b8060015f01819055507fb7a180228497ed95c6896fc1b081a016999116f98ab95b52123659efea259764816040516113189190611d8e565b60405180910390a150565b61132b611419565b73ffffffffffffffffffffffffffffffffffffffff166113496111eb565b73ffffffffffffffffffffffffffffffffffffffff161461139f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161139690611d70565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff160361140d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161140490612591565b60405180910390fd5b611416816114e6565b50565b5f33905090565b5f815f0154835f013514801561143d575081600101548360200135145b905092915050565b5f815f015482600101548360020154846003015460405160200161146c94939291906125af565b604051602081830303815290604052805190602001209050919050565b5f7f19457468657265756d205369676e6564204d6573736167653a0a3332000000005f5281601c52603c5f209050919050565b5f5f5f5f6114ca86866115a7565b9250925092506114da82826115fc565b82935050505092915050565b5f5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f5f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f5f5f60418451036115e7575f5f5f602087015192506040870151915060608701515f1a90506115d98882858561175e565b9550955095505050506115f5565b5f600285515f1b9250925092505b9250925092565b5f600381111561160f5761160e6125fc565b5b826003811115611622576116216125fc565b5b031561175a576001600381111561163c5761163b6125fc565b5b82600381111561164f5761164e6125fc565b5b03611686576040517ff645eedf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6002600381111561169a576116996125fc565b5b8260038111156116ad576116ac6125fc565b5b036116f157805f1c6040517ffce698f70000000000000000000000000000000000000000000000000000000081526004016116e89190611aed565b60405180910390fd5b600380811115611704576117036125fc565b5b826003811115611717576117166125fc565b5b0361175957806040517fd78bce0c0000000000000000000000000000000000000000000000000000000081526004016117509190611d8e565b60405180910390fd5b5b5050565b5f5f5f7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0845f1c111561179a575f60038592509250925061183b565b5f6001888888886040515f81526020016040526040516117bd9493929190612644565b6020604051602081039080840390855afa1580156117dd573d5f5f3e3d5ffd5b5050506020604051035190505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff160361182e575f60015f5f1b9350935093505061183b565b805f5f5f1b935093509350505b9450945094915050565b5080545f8255600202905f5260205f20908101906118639190611884565b50565b5080545f8255905f5260205f209081019061188191906118a8565b50565b5b808211156118a4575f5f82015f9055600182015f905550600201611885565b5090565b5b808211156118bf575f815f9055506001016118a9565b5090565b5f5ffd5b5f5ffd5b5f819050919050565b6118dd816118cb565b81146118e7575f5ffd5b50565b5f813590506118f8816118d4565b92915050565b5f60208284031215611913576119126118c3565b5b5f611920848285016118ea565b91505092915050565b5f5ffd5b5f6040828403121561194257611941611929565b5b81905092915050565b5f604082840312156119605761195f6118c3565b5b5f61196d8482850161192d565b91505092915050565b5f819050919050565b61198881611976565b8114611992575f5ffd5b50565b5f813590506119a38161197f565b92915050565b5f602082840312156119be576119bd6118c3565b5b5f6119cb84828501611995565b91505092915050565b6119dd816118cb565b82525050565b5f6080820190506119f65f8301876119d4565b611a0360208301866119d4565b611a1060408301856119d4565b611a1d60608301846119d4565b95945050505050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f611a4f82611a26565b9050919050565b611a5f81611a45565b8114611a69575f5ffd5b50565b5f81359050611a7a81611a56565b92915050565b5f60208284031215611a9557611a946118c3565b5b5f611aa284828501611a6c565b91505092915050565b5f8115159050919050565b611abf81611aab565b82525050565b5f602082019050611ad85f830184611ab6565b92915050565b611ae781611976565b82525050565b5f602082019050611b005f830184611ade565b92915050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83601f840112611b2757611b26611b06565b5b8235905067ffffffffffffffff811115611b4457611b43611b0a565b5b602083019150836001820283011115611b6057611b5f611b0e565b5b9250929050565b5f5f5f60408486031215611b7e57611b7d6118c3565b5b5f611b8b86828701611a6c565b935050602084013567ffffffffffffffff811115611bac57611bab6118c7565b5b611bb886828701611b12565b92509250509250925092565b5f60608284031215611bd957611bd8611929565b5b81905092915050565b5f5f5f5f60a08587031215611bfa57611bf96118c3565b5b5f611c0787828801611bc4565b945050606085013567ffffffffffffffff811115611c2857611c276118c7565b5b611c3487828801611b12565b93509350506080611c4787828801611a6c565b91505092959194509250565b611c5c81611a45565b82525050565b5f602082019050611c755f830184611c53565b92915050565b5f819050919050565b5f611c9e611c99611c9484611a26565b611c7b565b611a26565b9050919050565b5f611caf82611c84565b9050919050565b5f611cc082611ca5565b9050919050565b611cd081611cb6565b82525050565b5f602082019050611ce95f830184611cc7565b92915050565b5f604082019050611d025f8301856119d4565b611d0f60208301846119d4565b9392505050565b5f82825260208201905092915050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65725f82015250565b5f611d5a602083611d16565b9150611d6582611d26565b602082019050919050565b5f6020820190508181035f830152611d8781611d4e565b9050919050565b5f602082019050611da15f8301846119d4565b92915050565b7f6368616c6c656e676520646f6573206e6f7420657869737400000000000000005f82015250565b5f611ddb601883611d16565b9150611de682611da7565b602082019050919050565b5f6020820190508181035f830152611e0881611dcf565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f8135611e48816118d4565b80915050919050565b5f815f1b9050919050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff611e8784611e51565b9350801983169250808416831791505092915050565b5f611ea7826118cb565b9050919050565b5f815f1c9050919050565b5f611ec382611eae565b9050919050565b611ed382611e9d565b611ee6611edf82611eb9565b8354611e5c565b8255505050565b5f81015f830180611efd81611e3c565b9050611f098184611eca565b505050600181016020830180611f1e81611e3c565b9050611f2a8184611eca565b5050505050565b611f3b8282611eed565b5050565b5f611f4d60208401846118ea565b905092915050565b611f5e816118cb565b82525050565b60408201611f745f830183611f3f565b611f805f850182611f55565b50611f8e6020830183611f3f565b611f9b6020850182611f55565b50505050565b5f604082019050611fb45f830184611f64565b92915050565b7f617373657274696f6e206e6f7420666f756e64000000000000000000000000005f82015250565b5f611fee601383611d16565b9150611ff982611fba565b602082019050919050565b5f6020820190508181035f83015261201b81611fe2565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52600160045260245ffd5b7f696e76616c6964207369676e6174757265206c656e67746800000000000000005f82015250565b5f612083601883611d16565b915061208e8261204f565b602082019050919050565b5f6020820190508181035f8301526120b081612077565b9050919050565b7f696e76616c69642074656520696e7075740000000000000000000000000000005f82015250565b5f6120eb601183611d16565b91506120f6826120b7565b602082019050919050565b5f6020820190508181035f830152612118816120df565b9050919050565b5f819050919050565b612139612134826118cb565b61211f565b82525050565b5f61214a8286612128565b60208201915061215a8285612128565b60208201915061216a8284612128565b602082019150819050949350505050565b7f696e76616c696420746565207369676e617475726500000000000000000000005f82015250565b5f6121af601583611d16565b91506121ba8261217b565b602082019050919050565b5f6020820190508181035f8301526121dc816121a3565b9050919050565b7f617373657274696f6e20616c72656164792065786973747300000000000000005f82015250565b5f612217601883611d16565b9150612222826121e3565b602082019050919050565b5f6020820190508181035f8301526122448161220b565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f61228282611976565b915061228d83611976565b92508282019050808211156122a5576122a461224b565b5b92915050565b5f81905092915050565b50565b5f6122c35f836122ab565b91506122ce826122b5565b5f82019050919050565b5f6122e2826122b8565b9150819050919050565b7f7061796d656e74206661696c65640000000000000000000000000000000000005f82015250565b5f612320600e83611d16565b915061232b826122ec565b602082019050919050565b5f6020820190508181035f83015261234d81612314565b9050919050565b7f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201527f746f6f206d616e7920617373657274696f6e7300000000000000000000000000602082015250565b5f6123ae603383611d16565b91506123b982612354565b604082019050919050565b5f6020820190508181035f8301526123db816123a2565b9050919050565b5f815190506123f08161197f565b92915050565b5f6020828403121561240b5761240a6118c3565b5b5f612418848285016123e2565b91505092915050565b7f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201527f696e73756666696369656e742074696d65206861732070617373656400000000602082015250565b5f61247b603c83611d16565b915061248682612421565b604082019050919050565b5f6020820190508181035f8301526124a88161246f565b9050919050565b5f6124b982611976565b91506124c483611976565b92508282039050818111156124dc576124db61224b565b5b92915050565b5f815190506124f0816118d4565b92915050565b5f6020828403121561250b5761250a6118c3565b5b5f612518848285016124e2565b91505092915050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f20615f8201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b5f61257b602683611d16565b915061258682612521565b604082019050919050565b5f6020820190508181035f8301526125a88161256f565b9050919050565b5f6125ba8287612128565b6020820191506125ca8286612128565b6020820191506125da8285612128565b6020820191506125ea8284612128565b60208201915081905095945050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b5f60ff82169050919050565b61263e81612629565b82525050565b5f6080820190506126575f8301876119d4565b6126646020830186612635565b61267160408301856119d4565b61267e60608301846119d4565b9594505050505056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R4\x80\x15a\0\x0FW__\xFD[P`@Qa)>8\x03\x80a)>\x839\x81\x81\x01`@R\x81\x01\x90a\x001\x91\x90a\x022V[a\0Ma\0Ba\0\xC8` \x1B` \x1CV[a\0\xCF` \x1B` \x1CV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x80\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP\x80`\x01_\x01\x81\x90UP\x7F\xB7\xA1\x80\"\x84\x97\xED\x95\xC6\x89o\xC1\xB0\x81\xA0\x16\x99\x91\x16\xF9\x8A\xB9[R\x126Y\xEF\xEA%\x97d\x81`@Qa\0\xB9\x91\x90a\x02\x7FV[`@Q\x80\x91\x03\x90\xA1PPa\x02\x98V[_3\x90P\x90V[___\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81__a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPV[__\xFD[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a\x01\xBD\x82a\x01\x94V[\x90P\x91\x90PV[_a\x01\xCE\x82a\x01\xB3V[\x90P\x91\x90PV[a\x01\xDE\x81a\x01\xC4V[\x81\x14a\x01\xE8W__\xFD[PV[_\x81Q\x90Pa\x01\xF9\x81a\x01\xD5V[\x92\x91PPV[_\x81\x90P\x91\x90PV[a\x02\x11\x81a\x01\xFFV[\x81\x14a\x02\x1BW__\xFD[PV[_\x81Q\x90Pa\x02,\x81a\x02\x08V[\x92\x91PPV[__`@\x83\x85\x03\x12\x15a\x02HWa\x02Ga\x01\x90V[[_a\x02U\x85\x82\x86\x01a\x01\xEBV[\x92PP` a\x02f\x85\x82\x86\x01a\x02\x1EV[\x91PP\x92P\x92\x90PV[a\x02y\x81a\x01\xFFV[\x82RPPV[_` \x82\x01\x90Pa\x02\x92_\x83\x01\x84a\x02pV[\x92\x91PPV[`\x80Qa&\x87a\x02\xB7_9_\x81\x81a\x0E0\x01Ra\x11\xC9\x01Ra&\x87_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x015W_5`\xE0\x1C\x80clL `\x11a\0\xB6W\x80c\x8D\xA5\xCB[\x11a\0zW\x80c\x8D\xA5\xCB[\x14a\x02\xDAW\x80c\xA3\x80\xEF\x87\x14a\x02\xF8W\x80c\xA5n\xC6\xCD\x14a\x03(W\x80c\xEE\x1C(\xB8\x14a\x03YW\x80c\xF2#\x05\\\x14a\x03wW\x80c\xF2\xFD\xE3\x8B\x14a\x03\x93Wa\x015V[\x80clL `\x14a\x02nW\x80cn\xBE\xD0\xF0\x14a\x02xW\x80cn\xF0\x12\x01\x14a\x02\xA8W\x80cqP\x18\xA6\x14a\x02\xB2W\x80c\x80\x95\x97!\x14a\x02\xBCWa\x015V[\x80cGt&@\x11a\0\xFDW\x80cGt&@\x14a\x01\xCAW\x80cK\xD1g\xC9\x14a\x01\xFAW\x80c]K\xED\xC3\x14a\x02\x18W\x80c`p\xE7\x8E\x14a\x024W\x80ci{^b\x14a\x02PWa\x015V[\x80c\n\xD1\x95\xAB\x14a\x019W\x80c\x0B|\x02A\x14a\x01UW\x80c\x1C\xAF]\x13\x14a\x01qW\x80c<\xEA\xAE}\x14a\x01\x8DW\x80cC\xDE_3\x14a\x01\xAEW[__\xFD[a\x01S`\x04\x806\x03\x81\x01\x90a\x01N\x91\x90a\x18\xFEV[a\x03\xAFV[\0[a\x01o`\x04\x806\x03\x81\x01\x90a\x01j\x91\x90a\x19KV[a\x04\x8DV[\0[a\x01\x8B`\x04\x806\x03\x81\x01\x90a\x01\x86\x91\x90a\x19\xA9V[a\x06mV[\0[a\x01\x95a\x06\xF3V[`@Qa\x01\xA5\x94\x93\x92\x91\x90a\x19\xE3V[`@Q\x80\x91\x03\x90\xF3[a\x01\xC8`\x04\x806\x03\x81\x01\x90a\x01\xC3\x91\x90a\x18\xFEV[a\x07\x10V[\0[a\x01\xE4`\x04\x806\x03\x81\x01\x90a\x01\xDF\x91\x90a\x1A\x80V[a\x07\xEFV[`@Qa\x01\xF1\x91\x90a\x1A\xC5V[`@Q\x80\x91\x03\x90\xF3[a\x02\x02a\x08\x0CV[`@Qa\x02\x0F\x91\x90a\x1A\xEDV[`@Q\x80\x91\x03\x90\xF3[a\x022`\x04\x806\x03\x81\x01\x90a\x02-\x91\x90a\x1BgV[a\x08\x12V[\0[a\x02N`\x04\x806\x03\x81\x01\x90a\x02I\x91\x90a\x1B\xE2V[a\t/V[\0[a\x02Xa\x0C\xDEV[`@Qa\x02e\x91\x90a\x1A\xEDV[`@Q\x80\x91\x03\x90\xF3[a\x02va\x0C\xE4V[\0[a\x02\x92`\x04\x806\x03\x81\x01\x90a\x02\x8D\x91\x90a\x19\xA9V[a\x0F\x9FV[`@Qa\x02\x9F\x91\x90a\x1CbV[`@Q\x80\x91\x03\x90\xF3[a\x02\xB0a\x0F\xDAV[\0[a\x02\xBAa\x11@V[\0[a\x02\xC4a\x11\xC7V[`@Qa\x02\xD1\x91\x90a\x1C\xD6V[`@Q\x80\x91\x03\x90\xF3[a\x02\xE2a\x11\xEBV[`@Qa\x02\xEF\x91\x90a\x1CbV[`@Q\x80\x91\x03\x90\xF3[a\x03\x12`\x04\x806\x03\x81\x01\x90a\x03\r\x91\x90a\x18\xFEV[a\x12\x12V[`@Qa\x03\x1F\x91\x90a\x1A\xC5V[`@Q\x80\x91\x03\x90\xF3[a\x03B`\x04\x806\x03\x81\x01\x90a\x03=\x91\x90a\x19\xA9V[a\x12/V[`@Qa\x03P\x92\x91\x90a\x1C\xEFV[`@Q\x80\x91\x03\x90\xF3[a\x03aa\x12^V[`@Qa\x03n\x91\x90a\x1A\xEDV[`@Q\x80\x91\x03\x90\xF3[a\x03\x91`\x04\x806\x03\x81\x01\x90a\x03\x8C\x91\x90a\x18\xFEV[a\x12dV[\0[a\x03\xAD`\x04\x806\x03\x81\x01\x90a\x03\xA8\x91\x90a\x1A\x80V[a\x13#V[\0[a\x03\xB7a\x14\x19V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x03\xD5a\x11\xEBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x04+W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x04\"\x90a\x1DpV[`@Q\x80\x91\x03\x90\xFD[_`\t_\x83\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\r\xB1f\xBBNG\xA6`\xAA\xFC2\xF7\x8B\xBA\xCD\xDA\x0B\x90\xB0s^E\xB2\x13J\xEE\xC3\xA5\xEAVU\xAB\x81`@Qa\x04\x82\x91\x90a\x1D\x8EV[`@Q\x80\x91\x03\x90\xA1PV[a\x04\x95a\x14\x19V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x04\xB3a\x11\xEBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x05\tW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05\0\x90a\x1DpV[`@Q\x80\x91\x03\x90\xFD[`\x01`\x05\x80T\x90P\x11a\x05QW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05H\x90a\x1D\xF1V[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x05\x80T\x90P\x81\x10\x15a\x06.Wa\x05\x8C\x82`\x05\x83\x81T\x81\x10a\x05{Wa\x05za\x1E\x0FV[[\x90_R` _ \x90`\x02\x02\x01a\x14 V[\x15a\x06!W`\x05_a\x05\x9E\x91\x90a\x18EV[`\x05\x82\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x02\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a\x05\xD3\x91\x90a\x1F1V[PP_`\n\x81\x90UPa\x05\xE4a\x0C\xE4V[\x7F\x11N\x9Cy\x8E<m\x15\x8B]\x1D\xD7\x11\xCE\x1E\"x_=\x94\x89\x8D\xDB\x1C\xE7\xF9\xBCu\x171u\xD3\x82`@Qa\x06\x13\x91\x90a\x1F\xA1V[`@Q\x80\x91\x03\x90\xA1Pa\x06jV[\x80\x80`\x01\x01\x91PPa\x05VV[P`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06a\x90a \x04V[`@Q\x80\x91\x03\x90\xFD[PV[a\x06ua\x14\x19V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x06\x93a\x11\xEBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x06\xE9W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xE0\x90a\x1DpV[`@Q\x80\x91\x03\x90\xFD[\x80`\x0B\x81\x90UPPV[`\x01\x80_\x01T\x90\x80`\x01\x01T\x90\x80`\x02\x01T\x90\x80`\x03\x01T\x90P\x84V[a\x07\x18a\x14\x19V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x076a\x11\xEBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x07\x8CW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x07\x83\x90a\x1DpV[`@Q\x80\x91\x03\x90\xFD[`\x01`\t_\x83\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7FC\x88P&\xC5\x9E\xCB\xB8$\xD1\x02x_\xEE_\x95\x93\xE6\x95\xBB\x9A\x84\x90\x86M\x980\x95%$\xE5\xD5\x81`@Qa\x07\xE4\x91\x90a\x1D\x8EV[`@Q\x80\x91\x03\x90\xA1PV[`\x08` R\x80_R`@_ _\x91PT\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[`\x0BT\x81V[`\x01\x82\x82\x90P\x14a\x08&Wa\x08%a \"V[[`\x08_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\t*W`\x01`\x08_\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP`\x07\x83\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP[PPPV[`A\x83\x83\x90P\x14a\tuW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\tl\x90a \x99V[`@Q\x80\x91\x03\x90\xFD[a\t\x7F`\x01a\x14EV[\x84_\x015\x14a\t\xC3W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\t\xBA\x90a!\x01V[`@Q\x80\x91\x03\x90\xFD[_\x84_\x015\x85` \x01_\x015\x86` \x01` \x015`@Q` \x01a\t\xE9\x93\x92\x91\x90a!?V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P`\x08_a\nb\x86\x86\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x81\x84\x01R`\x1F\x19`\x1F\x82\x01\x16\x90P\x80\x83\x01\x92PPPPPPPa\nT\x85a\x14\x89V[a\x14\xBC\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\n\xE7W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\n\xDE\x90a!\xC5V[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x05\x80T\x90P\x81\x10\x15a\x0BrWa\x0B%\x86` \x01`\x05\x83\x81T\x81\x10a\x0B\x14Wa\x0B\x13a\x1E\x0FV[[\x90_R` _ \x90`\x02\x02\x01a\x14 V[\x15a\x0BeW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0B\\\x90a\"-V[`@Q\x80\x91\x03\x90\xFD[\x80\x80`\x01\x01\x91PPa\n\xECV[P_`\x05\x80T\x90P\x03a\x0B\x94W`\x0BTBa\x0B\x8D\x91\x90a\"xV[`\n\x81\x90UP[`\x05\x85` \x01\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x02\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a\x0B\xCC\x91\x90a\x1F1V[PP`\x02`\x05\x80T\x90P\x03a\x0C\xD7W`\x01`\x06_\x82\x82Ta\x0B\xED\x91\x90a\"xV[\x92PP\x81\x90UP\x7F7\xE8\xAD\xD6\x94\xC5\x92mVN\x97\x11`\xF5\x97A\x03\xCB\xBB\xC7\xC9\x07G\xC4\xC6\xF8\x02\x03\x1D5g\xA7`\x06T`@Qa\x0C%\x91\x90a\x1A\xEDV[`@Q\x80\x91\x03\x90\xA1_\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16G`@Qa\x0CR\x90a\"\xD8V[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a\x0C\x8CW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x0C\x91V[``\x91P[PP\x90P\x80a\x0C\xD5W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0C\xCC\x90a#6V[`@Q\x80\x91\x03\x90\xFD[P[PPPPPV[`\x06T\x81V[_sB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\x90P`\x01`\x05\x80T\x90P\x11\x15a\rEW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\r<\x90a#\xC4V[`@Q\x80\x91\x03\x90\xFD[`\nT\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xB8\x07w\xEA`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\r\x91W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r\xB5\x91\x90a#\xF6V[\x11a\r\xF5W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\r\xEC\x90a$\x91V[`@Q\x80\x91\x03\x90\xFD[_`\x05\x80T\x90P\x11\x15a\x0E\xFCW`\x05_\x81T\x81\x10a\x0E\x16Wa\x0E\x15a\x1E\x0FV[[\x90_R` _ \x90`\x02\x02\x01_\x01T`\x01`\x03\x01\x81\x90UP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xDA\xEA\xB4\x12`\x05_\x81T\x81\x10a\x0E~Wa\x0E}a\x1E\x0FV[[\x90_R` _ \x90`\x02\x02\x01_\x01T`\x05_\x81T\x81\x10a\x0E\xA1Wa\x0E\xA0a\x1E\x0FV[[\x90_R` _ \x90`\x02\x02\x01`\x01\x01T`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0E\xCE\x92\x91\x90a\x1C\xEFV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0E\xE5W__\xFD[PZ\xF1\x15\x80\x15a\x0E\xF7W=__>=_\xFD[PPPP[`\x01Ca\x0F\t\x91\x90a$\xAFV[@`\x01\x80\x01\x81\x90UP\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\t\xBDZ``@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0F[W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0F\x7F\x91\x90a$\xF6V[`\x01`\x02\x01\x81\x90UP`\x0BTBa\x0F\x96\x91\x90a\"xV[`\n\x81\x90UPPV[`\x07\x81\x81T\x81\x10a\x0F\xAEW_\x80\xFD[\x90_R` _ \x01_\x91PT\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[a\x0F\xE2a\x14\x19V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x10\0a\x11\xEBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x10VW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x10M\x90a\x1DpV[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x07\x80T\x90P\x81\x10\x15a\x11\x04W_`\x08_`\x07\x84\x81T\x81\x10a\x10\x80Wa\x10\x7Fa\x1E\x0FV[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa\x10[V[P`\x07_a\x11\x12\x91\x90a\x18fV[\x7F\xEC\xA6.\0t\xA1:\x90\xD6\0\xF0\x03\xB7\xCB\x8D[\xD5\x01\0\0\x8D?9\x15\xF2UO?\x85R\xC5\xCC`@Q`@Q\x80\x91\x03\x90\xA1V[a\x11Ha\x14\x19V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x11fa\x11\xEBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x11\xBCW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x11\xB3\x90a\x1DpV[`@Q\x80\x91\x03\x90\xFD[a\x11\xC5_a\x14\xE6V[V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[___\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[`\t` R\x80_R`@_ _\x91PT\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[`\x05\x81\x81T\x81\x10a\x12>W_\x80\xFD[\x90_R` _ \x90`\x02\x02\x01_\x91P\x90P\x80_\x01T\x90\x80`\x01\x01T\x90P\x82V[`\nT\x81V[a\x12la\x14\x19V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x12\x8Aa\x11\xEBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x12\xE0W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x12\xD7\x90a\x1DpV[`@Q\x80\x91\x03\x90\xFD[\x80`\x01_\x01\x81\x90UP\x7F\xB7\xA1\x80\"\x84\x97\xED\x95\xC6\x89o\xC1\xB0\x81\xA0\x16\x99\x91\x16\xF9\x8A\xB9[R\x126Y\xEF\xEA%\x97d\x81`@Qa\x13\x18\x91\x90a\x1D\x8EV[`@Q\x80\x91\x03\x90\xA1PV[a\x13+a\x14\x19V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x13Ia\x11\xEBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x13\x9FW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\x96\x90a\x1DpV[`@Q\x80\x91\x03\x90\xFD[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x14\rW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14\x04\x90a%\x91V[`@Q\x80\x91\x03\x90\xFD[a\x14\x16\x81a\x14\xE6V[PV[_3\x90P\x90V[_\x81_\x01T\x83_\x015\x14\x80\x15a\x14=WP\x81`\x01\x01T\x83` \x015\x14[\x90P\x92\x91PPV[_\x81_\x01T\x82`\x01\x01T\x83`\x02\x01T\x84`\x03\x01T`@Q` \x01a\x14l\x94\x93\x92\x91\x90a%\xAFV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x91\x90PV[_\x7F\x19Ethereum Signed Message:\n32\0\0\0\0_R\x81`\x1CR`<_ \x90P\x91\x90PV[____a\x14\xCA\x86\x86a\x15\xA7V[\x92P\x92P\x92Pa\x14\xDA\x82\x82a\x15\xFCV[\x82\x93PPPP\x92\x91PPV[___\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81__a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPV[___`A\x84Q\x03a\x15\xE7W___` \x87\x01Q\x92P`@\x87\x01Q\x91P``\x87\x01Q_\x1A\x90Pa\x15\xD9\x88\x82\x85\x85a\x17^V[\x95P\x95P\x95PPPPa\x15\xF5V[_`\x02\x85Q_\x1B\x92P\x92P\x92P[\x92P\x92P\x92V[_`\x03\x81\x11\x15a\x16\x0FWa\x16\x0Ea%\xFCV[[\x82`\x03\x81\x11\x15a\x16\"Wa\x16!a%\xFCV[[\x03\x15a\x17ZW`\x01`\x03\x81\x11\x15a\x16<Wa\x16;a%\xFCV[[\x82`\x03\x81\x11\x15a\x16OWa\x16Na%\xFCV[[\x03a\x16\x86W`@Q\x7F\xF6E\xEE\xDF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`\x03\x81\x11\x15a\x16\x9AWa\x16\x99a%\xFCV[[\x82`\x03\x81\x11\x15a\x16\xADWa\x16\xACa%\xFCV[[\x03a\x16\xF1W\x80_\x1C`@Q\x7F\xFC\xE6\x98\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x16\xE8\x91\x90a\x1A\xEDV[`@Q\x80\x91\x03\x90\xFD[`\x03\x80\x81\x11\x15a\x17\x04Wa\x17\x03a%\xFCV[[\x82`\x03\x81\x11\x15a\x17\x17Wa\x17\x16a%\xFCV[[\x03a\x17YW\x80`@Q\x7F\xD7\x8B\xCE\x0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x17P\x91\x90a\x1D\x8EV[`@Q\x80\x91\x03\x90\xFD[[PPV[___\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0\x84_\x1C\x11\x15a\x17\x9AW_`\x03\x85\x92P\x92P\x92Pa\x18;V[_`\x01\x88\x88\x88\x88`@Q_\x81R` \x01`@R`@Qa\x17\xBD\x94\x93\x92\x91\x90a&DV[` `@Q` \x81\x03\x90\x80\x84\x03\x90\x85Z\xFA\x15\x80\x15a\x17\xDDW=__>=_\xFD[PPP` `@Q\x03Q\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x18.W_`\x01__\x1B\x93P\x93P\x93PPa\x18;V[\x80___\x1B\x93P\x93P\x93PP[\x94P\x94P\x94\x91PPV[P\x80T_\x82U`\x02\x02\x90_R` _ \x90\x81\x01\x90a\x18c\x91\x90a\x18\x84V[PV[P\x80T_\x82U\x90_R` _ \x90\x81\x01\x90a\x18\x81\x91\x90a\x18\xA8V[PV[[\x80\x82\x11\x15a\x18\xA4W__\x82\x01_\x90U`\x01\x82\x01_\x90UP`\x02\x01a\x18\x85V[P\x90V[[\x80\x82\x11\x15a\x18\xBFW_\x81_\x90UP`\x01\x01a\x18\xA9V[P\x90V[__\xFD[__\xFD[_\x81\x90P\x91\x90PV[a\x18\xDD\x81a\x18\xCBV[\x81\x14a\x18\xE7W__\xFD[PV[_\x815\x90Pa\x18\xF8\x81a\x18\xD4V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x19\x13Wa\x19\x12a\x18\xC3V[[_a\x19 \x84\x82\x85\x01a\x18\xEAV[\x91PP\x92\x91PPV[__\xFD[_`@\x82\x84\x03\x12\x15a\x19BWa\x19Aa\x19)V[[\x81\x90P\x92\x91PPV[_`@\x82\x84\x03\x12\x15a\x19`Wa\x19_a\x18\xC3V[[_a\x19m\x84\x82\x85\x01a\x19-V[\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[a\x19\x88\x81a\x19vV[\x81\x14a\x19\x92W__\xFD[PV[_\x815\x90Pa\x19\xA3\x81a\x19\x7FV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x19\xBEWa\x19\xBDa\x18\xC3V[[_a\x19\xCB\x84\x82\x85\x01a\x19\x95V[\x91PP\x92\x91PPV[a\x19\xDD\x81a\x18\xCBV[\x82RPPV[_`\x80\x82\x01\x90Pa\x19\xF6_\x83\x01\x87a\x19\xD4V[a\x1A\x03` \x83\x01\x86a\x19\xD4V[a\x1A\x10`@\x83\x01\x85a\x19\xD4V[a\x1A\x1D``\x83\x01\x84a\x19\xD4V[\x95\x94PPPPPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a\x1AO\x82a\x1A&V[\x90P\x91\x90PV[a\x1A_\x81a\x1AEV[\x81\x14a\x1AiW__\xFD[PV[_\x815\x90Pa\x1Az\x81a\x1AVV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x1A\x95Wa\x1A\x94a\x18\xC3V[[_a\x1A\xA2\x84\x82\x85\x01a\x1AlV[\x91PP\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[a\x1A\xBF\x81a\x1A\xABV[\x82RPPV[_` \x82\x01\x90Pa\x1A\xD8_\x83\x01\x84a\x1A\xB6V[\x92\x91PPV[a\x1A\xE7\x81a\x19vV[\x82RPPV[_` \x82\x01\x90Pa\x1B\0_\x83\x01\x84a\x1A\xDEV[\x92\x91PPV[__\xFD[__\xFD[__\xFD[__\x83`\x1F\x84\x01\x12a\x1B'Wa\x1B&a\x1B\x06V[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1BDWa\x1BCa\x1B\nV[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15a\x1B`Wa\x1B_a\x1B\x0EV[[\x92P\x92\x90PV[___`@\x84\x86\x03\x12\x15a\x1B~Wa\x1B}a\x18\xC3V[[_a\x1B\x8B\x86\x82\x87\x01a\x1AlV[\x93PP` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1B\xACWa\x1B\xABa\x18\xC7V[[a\x1B\xB8\x86\x82\x87\x01a\x1B\x12V[\x92P\x92PP\x92P\x92P\x92V[_``\x82\x84\x03\x12\x15a\x1B\xD9Wa\x1B\xD8a\x19)V[[\x81\x90P\x92\x91PPV[____`\xA0\x85\x87\x03\x12\x15a\x1B\xFAWa\x1B\xF9a\x18\xC3V[[_a\x1C\x07\x87\x82\x88\x01a\x1B\xC4V[\x94PP``\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1C(Wa\x1C'a\x18\xC7V[[a\x1C4\x87\x82\x88\x01a\x1B\x12V[\x93P\x93PP`\x80a\x1CG\x87\x82\x88\x01a\x1AlV[\x91PP\x92\x95\x91\x94P\x92PV[a\x1C\\\x81a\x1AEV[\x82RPPV[_` \x82\x01\x90Pa\x1Cu_\x83\x01\x84a\x1CSV[\x92\x91PPV[_\x81\x90P\x91\x90PV[_a\x1C\x9Ea\x1C\x99a\x1C\x94\x84a\x1A&V[a\x1C{V[a\x1A&V[\x90P\x91\x90PV[_a\x1C\xAF\x82a\x1C\x84V[\x90P\x91\x90PV[_a\x1C\xC0\x82a\x1C\xA5V[\x90P\x91\x90PV[a\x1C\xD0\x81a\x1C\xB6V[\x82RPPV[_` \x82\x01\x90Pa\x1C\xE9_\x83\x01\x84a\x1C\xC7V[\x92\x91PPV[_`@\x82\x01\x90Pa\x1D\x02_\x83\x01\x85a\x19\xD4V[a\x1D\x0F` \x83\x01\x84a\x19\xD4V[\x93\x92PPPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7FOwnable: caller is not the owner_\x82\x01RPV[_a\x1DZ` \x83a\x1D\x16V[\x91Pa\x1De\x82a\x1D&V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x1D\x87\x81a\x1DNV[\x90P\x91\x90PV[_` \x82\x01\x90Pa\x1D\xA1_\x83\x01\x84a\x19\xD4V[\x92\x91PPV[\x7Fchallenge does not exist\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x1D\xDB`\x18\x83a\x1D\x16V[\x91Pa\x1D\xE6\x82a\x1D\xA7V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x1E\x08\x81a\x1D\xCFV[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[_\x815a\x1EH\x81a\x18\xD4V[\x80\x91PP\x91\x90PV[_\x81_\x1B\x90P\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x1E\x87\x84a\x1EQV[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_a\x1E\xA7\x82a\x18\xCBV[\x90P\x91\x90PV[_\x81_\x1C\x90P\x91\x90PV[_a\x1E\xC3\x82a\x1E\xAEV[\x90P\x91\x90PV[a\x1E\xD3\x82a\x1E\x9DV[a\x1E\xE6a\x1E\xDF\x82a\x1E\xB9V[\x83Ta\x1E\\V[\x82UPPPV[_\x81\x01_\x83\x01\x80a\x1E\xFD\x81a\x1E<V[\x90Pa\x1F\t\x81\x84a\x1E\xCAV[PPP`\x01\x81\x01` \x83\x01\x80a\x1F\x1E\x81a\x1E<V[\x90Pa\x1F*\x81\x84a\x1E\xCAV[PPPPPV[a\x1F;\x82\x82a\x1E\xEDV[PPV[_a\x1FM` \x84\x01\x84a\x18\xEAV[\x90P\x92\x91PPV[a\x1F^\x81a\x18\xCBV[\x82RPPV[`@\x82\x01a\x1Ft_\x83\x01\x83a\x1F?V[a\x1F\x80_\x85\x01\x82a\x1FUV[Pa\x1F\x8E` \x83\x01\x83a\x1F?V[a\x1F\x9B` \x85\x01\x82a\x1FUV[PPPPV[_`@\x82\x01\x90Pa\x1F\xB4_\x83\x01\x84a\x1FdV[\x92\x91PPV[\x7Fassertion not found\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x1F\xEE`\x13\x83a\x1D\x16V[\x91Pa\x1F\xF9\x82a\x1F\xBAV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra \x1B\x81a\x1F\xE2V[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x01`\x04R`$_\xFD[\x7Finvalid signature length\0\0\0\0\0\0\0\0_\x82\x01RPV[_a \x83`\x18\x83a\x1D\x16V[\x91Pa \x8E\x82a OV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra \xB0\x81a wV[\x90P\x91\x90PV[\x7Finvalid tee input\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a \xEB`\x11\x83a\x1D\x16V[\x91Pa \xF6\x82a \xB7V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra!\x18\x81a \xDFV[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a!9a!4\x82a\x18\xCBV[a!\x1FV[\x82RPPV[_a!J\x82\x86a!(V[` \x82\x01\x91Pa!Z\x82\x85a!(V[` \x82\x01\x91Pa!j\x82\x84a!(V[` \x82\x01\x91P\x81\x90P\x94\x93PPPPV[\x7Finvalid tee signature\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a!\xAF`\x15\x83a\x1D\x16V[\x91Pa!\xBA\x82a!{V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra!\xDC\x81a!\xA3V[\x90P\x91\x90PV[\x7Fassertion already exists\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\"\x17`\x18\x83a\x1D\x16V[\x91Pa\"\"\x82a!\xE3V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\"D\x81a\"\x0BV[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a\"\x82\x82a\x19vV[\x91Pa\"\x8D\x83a\x19vV[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a\"\xA5Wa\"\xA4a\"KV[[\x92\x91PPV[_\x81\x90P\x92\x91PPV[PV[_a\"\xC3_\x83a\"\xABV[\x91Pa\"\xCE\x82a\"\xB5V[_\x82\x01\x90P\x91\x90PV[_a\"\xE2\x82a\"\xB8V[\x91P\x81\x90P\x91\x90PV[\x7Fpayment failed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a# `\x0E\x83a\x1D\x16V[\x91Pa#+\x82a\"\xECV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra#M\x81a#\x14V[\x90P\x91\x90PV[\x7Fcannot close challenge window - _\x82\x01R\x7Ftoo many assertions\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a#\xAE`3\x83a\x1D\x16V[\x91Pa#\xB9\x82a#TV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra#\xDB\x81a#\xA2V[\x90P\x91\x90PV[_\x81Q\x90Pa#\xF0\x81a\x19\x7FV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a$\x0BWa$\na\x18\xC3V[[_a$\x18\x84\x82\x85\x01a#\xE2V[\x91PP\x92\x91PPV[\x7Fcannot close challenge window - _\x82\x01R\x7Finsufficient time has passed\0\0\0\0` \x82\x01RPV[_a${`<\x83a\x1D\x16V[\x91Pa$\x86\x82a$!V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra$\xA8\x81a$oV[\x90P\x91\x90PV[_a$\xB9\x82a\x19vV[\x91Pa$\xC4\x83a\x19vV[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15a$\xDCWa$\xDBa\"KV[[\x92\x91PPV[_\x81Q\x90Pa$\xF0\x81a\x18\xD4V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a%\x0BWa%\na\x18\xC3V[[_a%\x18\x84\x82\x85\x01a$\xE2V[\x91PP\x92\x91PPV[\x7FOwnable: new owner is the zero a_\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a%{`&\x83a\x1D\x16V[\x91Pa%\x86\x82a%!V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra%\xA8\x81a%oV[\x90P\x91\x90PV[_a%\xBA\x82\x87a!(V[` \x82\x01\x91Pa%\xCA\x82\x86a!(V[` \x82\x01\x91Pa%\xDA\x82\x85a!(V[` \x82\x01\x91Pa%\xEA\x82\x84a!(V[` \x82\x01\x91P\x81\x90P\x95\x94PPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[_`\xFF\x82\x16\x90P\x91\x90PV[a&>\x81a&)V[\x82RPPV[_`\x80\x82\x01\x90Pa&W_\x83\x01\x87a\x19\xD4V[a&d` \x83\x01\x86a&5V[a&q`@\x83\x01\x85a\x19\xD4V[a&~``\x83\x01\x84a\x19\xD4V[\x95\x94PPPPPV",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b5060043610610135575f3560e01c80636c4c2060116100b65780638da5cb5b1161007a5780638da5cb5b146102da578063a380ef87146102f8578063a56ec6cd14610328578063ee1c28b814610359578063f223055c14610377578063f2fde38b1461039357610135565b80636c4c20601461026e5780636ebed0f0146102785780636ef01201146102a8578063715018a6146102b257806380959721146102bc57610135565b806347742640116100fd57806347742640146101ca5780634bd167c9146101fa5780635d4bedc3146102185780636070e78e14610234578063697b5e621461025057610135565b80630ad195ab146101395780630b7c0241146101555780631caf5d13146101715780633ceaae7d1461018d57806343de5f33146101ae575b5f5ffd5b610153600480360381019061014e91906118fe565b6103af565b005b61016f600480360381019061016a919061194b565b61048d565b005b61018b600480360381019061018691906119a9565b61066d565b005b6101956106f3565b6040516101a594939291906119e3565b60405180910390f35b6101c860048036038101906101c391906118fe565b610710565b005b6101e460048036038101906101df9190611a80565b6107ef565b6040516101f19190611ac5565b60405180910390f35b61020261080c565b60405161020f9190611aed565b60405180910390f35b610232600480360381019061022d9190611b67565b610812565b005b61024e60048036038101906102499190611be2565b61092f565b005b610258610cde565b6040516102659190611aed565b60405180910390f35b610276610ce4565b005b610292600480360381019061028d91906119a9565b610f9f565b60405161029f9190611c62565b60405180910390f35b6102b0610fda565b005b6102ba611140565b005b6102c46111c7565b6040516102d19190611cd6565b60405180910390f35b6102e26111eb565b6040516102ef9190611c62565b60405180910390f35b610312600480360381019061030d91906118fe565b611212565b60405161031f9190611ac5565b60405180910390f35b610342600480360381019061033d91906119a9565b61122f565b604051610350929190611cef565b60405180910390f35b61036161125e565b60405161036e9190611aed565b60405180910390f35b610391600480360381019061038c91906118fe565b611264565b005b6103ad60048036038101906103a89190611a80565b611323565b005b6103b7611419565b73ffffffffffffffffffffffffffffffffffffffff166103d56111eb565b73ffffffffffffffffffffffffffffffffffffffff161461042b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161042290611d70565b60405180910390fd5b5f60095f8381526020019081526020015f205f6101000a81548160ff0219169083151502179055507f0db166bb4e47a660aafc32f78bbacdda0b90b0735e45b2134aeec3a5ea5655ab816040516104829190611d8e565b60405180910390a150565b610495611419565b73ffffffffffffffffffffffffffffffffffffffff166104b36111eb565b73ffffffffffffffffffffffffffffffffffffffff1614610509576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161050090611d70565b60405180910390fd5b600160058054905011610551576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161054890611df1565b60405180910390fd5b5f5f90505b60058054905081101561062e5761058c826005838154811061057b5761057a611e0f565b5b905f5260205f209060020201611420565b156106215760055f61059e9190611845565b600582908060018154018082558091505060019003905f5260205f2090600202015f9091909190915081816105d39190611f31565b50505f600a819055506105e4610ce4565b7f114e9c798e3c6d158b5d1dd711ce1e22785f3d94898ddb1ce7f9bc75173175d3826040516106139190611fa1565b60405180910390a15061066a565b8080600101915050610556565b506040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161066190612004565b60405180910390fd5b50565b610675611419565b73ffffffffffffffffffffffffffffffffffffffff166106936111eb565b73ffffffffffffffffffffffffffffffffffffffff16146106e9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106e090611d70565b60405180910390fd5b80600b8190555050565b6001805f0154908060010154908060020154908060030154905084565b610718611419565b73ffffffffffffffffffffffffffffffffffffffff166107366111eb565b73ffffffffffffffffffffffffffffffffffffffff161461078c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161078390611d70565b60405180910390fd5b600160095f8381526020019081526020015f205f6101000a81548160ff0219169083151502179055507f43885026c59ecbb824d102785fee5f9593e695bb9a8490864d9830952524e5d5816040516107e49190611d8e565b60405180910390a150565b6008602052805f5260405f205f915054906101000a900460ff1681565b600b5481565b6001828290501461082657610825612022565b5b60085f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1661092a57600160085f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550600783908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b505050565b60418383905014610975576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161096c90612099565b60405180910390fd5b61097f6001611445565b845f0135146109c3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109ba90612101565b60405180910390fd5b5f845f0135856020015f013586602001602001356040516020016109e99392919061213f565b60405160208183030381529060405280519060200120905060085f610a6286868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f81840152601f19601f82011690508083019250505050505050610a5485611489565b6114bc90919063ffffffff16565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff16610ae7576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ade906121c5565b60405180910390fd5b5f5f90505b600580549050811015610b7257610b258660200160058381548110610b1457610b13611e0f565b5b905f5260205f209060020201611420565b15610b65576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b5c9061222d565b60405180910390fd5b8080600101915050610aec565b505f60058054905003610b9457600b5442610b8d9190612278565b600a819055505b600585602001908060018154018082558091505060019003905f5260205f2090600202015f909190919091508181610bcc9190611f31565b5050600260058054905003610cd757600160065f828254610bed9190612278565b925050819055507f37e8add694c5926d564e971160f5974103cbbbc7c90747c4c6f802031d3567a7600654604051610c259190611aed565b60405180910390a15f8273ffffffffffffffffffffffffffffffffffffffff1647604051610c52906122d8565b5f6040518083038185875af1925050503d805f8114610c8c576040519150601f19603f3d011682016040523d82523d5f602084013e610c91565b606091505b5050905080610cd5576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ccc90612336565b60405180910390fd5b505b5050505050565b60065481565b5f734200000000000000000000000000000000000015905060016005805490501115610d45576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d3c906123c4565b60405180910390fd5b600a548173ffffffffffffffffffffffffffffffffffffffff1663b80777ea6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610d91573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610db591906123f6565b11610df5576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610dec90612491565b60405180910390fd5b5f6005805490501115610efc5760055f81548110610e1657610e15611e0f565b5b905f5260205f2090600202015f01546001600301819055507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663daeab41260055f81548110610e7e57610e7d611e0f565b5b905f5260205f2090600202015f015460055f81548110610ea157610ea0611e0f565b5b905f5260205f209060020201600101546040518363ffffffff1660e01b8152600401610ece929190611cef565b5f604051808303815f87803b158015610ee5575f5ffd5b505af1158015610ef7573d5f5f3e3d5ffd5b505050505b600143610f0991906124af565b4060018001819055508073ffffffffffffffffffffffffffffffffffffffff166309bd5a606040518163ffffffff1660e01b8152600401602060405180830381865afa158015610f5b573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610f7f91906124f6565b600160020181905550600b5442610f969190612278565b600a8190555050565b60078181548110610fae575f80fd5b905f5260205f20015f915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b610fe2611419565b73ffffffffffffffffffffffffffffffffffffffff166110006111eb565b73ffffffffffffffffffffffffffffffffffffffff1614611056576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161104d90611d70565b60405180910390fd5b5f5f90505b600780549050811015611104575f60085f600784815481106110805761107f611e0f565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550808060010191505061105b565b5060075f6111129190611866565b7feca62e0074a13a90d600f003b7cb8d5bd50100008d3f3915f2554f3f8552c5cc60405160405180910390a1565b611148611419565b73ffffffffffffffffffffffffffffffffffffffff166111666111eb565b73ffffffffffffffffffffffffffffffffffffffff16146111bc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016111b390611d70565b60405180910390fd5b6111c55f6114e6565b565b7f000000000000000000000000000000000000000000000000000000000000000081565b5f5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b6009602052805f5260405f205f915054906101000a900460ff1681565b6005818154811061123e575f80fd5b905f5260205f2090600202015f91509050805f0154908060010154905082565b600a5481565b61126c611419565b73ffffffffffffffffffffffffffffffffffffffff1661128a6111eb565b73ffffffffffffffffffffffffffffffffffffffff16146112e0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016112d790611d70565b60405180910390fd5b8060015f01819055507fb7a180228497ed95c6896fc1b081a016999116f98ab95b52123659efea259764816040516113189190611d8e565b60405180910390a150565b61132b611419565b73ffffffffffffffffffffffffffffffffffffffff166113496111eb565b73ffffffffffffffffffffffffffffffffffffffff161461139f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161139690611d70565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff160361140d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161140490612591565b60405180910390fd5b611416816114e6565b50565b5f33905090565b5f815f0154835f013514801561143d575081600101548360200135145b905092915050565b5f815f015482600101548360020154846003015460405160200161146c94939291906125af565b604051602081830303815290604052805190602001209050919050565b5f7f19457468657265756d205369676e6564204d6573736167653a0a3332000000005f5281601c52603c5f209050919050565b5f5f5f5f6114ca86866115a7565b9250925092506114da82826115fc565b82935050505092915050565b5f5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f5f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f5f5f60418451036115e7575f5f5f602087015192506040870151915060608701515f1a90506115d98882858561175e565b9550955095505050506115f5565b5f600285515f1b9250925092505b9250925092565b5f600381111561160f5761160e6125fc565b5b826003811115611622576116216125fc565b5b031561175a576001600381111561163c5761163b6125fc565b5b82600381111561164f5761164e6125fc565b5b03611686576040517ff645eedf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6002600381111561169a576116996125fc565b5b8260038111156116ad576116ac6125fc565b5b036116f157805f1c6040517ffce698f70000000000000000000000000000000000000000000000000000000081526004016116e89190611aed565b60405180910390fd5b600380811115611704576117036125fc565b5b826003811115611717576117166125fc565b5b0361175957806040517fd78bce0c0000000000000000000000000000000000000000000000000000000081526004016117509190611d8e565b60405180910390fd5b5b5050565b5f5f5f7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0845f1c111561179a575f60038592509250925061183b565b5f6001888888886040515f81526020016040526040516117bd9493929190612644565b6020604051602081039080840390855afa1580156117dd573d5f5f3e3d5ffd5b5050506020604051035190505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff160361182e575f60015f5f1b9350935093505061183b565b805f5f5f1b935093509350505b9450945094915050565b5080545f8255600202905f5260205f20908101906118639190611884565b50565b5080545f8255905f5260205f209081019061188191906118a8565b50565b5b808211156118a4575f5f82015f9055600182015f905550600201611885565b5090565b5b808211156118bf575f815f9055506001016118a9565b5090565b5f5ffd5b5f5ffd5b5f819050919050565b6118dd816118cb565b81146118e7575f5ffd5b50565b5f813590506118f8816118d4565b92915050565b5f60208284031215611913576119126118c3565b5b5f611920848285016118ea565b91505092915050565b5f5ffd5b5f6040828403121561194257611941611929565b5b81905092915050565b5f604082840312156119605761195f6118c3565b5b5f61196d8482850161192d565b91505092915050565b5f819050919050565b61198881611976565b8114611992575f5ffd5b50565b5f813590506119a38161197f565b92915050565b5f602082840312156119be576119bd6118c3565b5b5f6119cb84828501611995565b91505092915050565b6119dd816118cb565b82525050565b5f6080820190506119f65f8301876119d4565b611a0360208301866119d4565b611a1060408301856119d4565b611a1d60608301846119d4565b95945050505050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f611a4f82611a26565b9050919050565b611a5f81611a45565b8114611a69575f5ffd5b50565b5f81359050611a7a81611a56565b92915050565b5f60208284031215611a9557611a946118c3565b5b5f611aa284828501611a6c565b91505092915050565b5f8115159050919050565b611abf81611aab565b82525050565b5f602082019050611ad85f830184611ab6565b92915050565b611ae781611976565b82525050565b5f602082019050611b005f830184611ade565b92915050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83601f840112611b2757611b26611b06565b5b8235905067ffffffffffffffff811115611b4457611b43611b0a565b5b602083019150836001820283011115611b6057611b5f611b0e565b5b9250929050565b5f5f5f60408486031215611b7e57611b7d6118c3565b5b5f611b8b86828701611a6c565b935050602084013567ffffffffffffffff811115611bac57611bab6118c7565b5b611bb886828701611b12565b92509250509250925092565b5f60608284031215611bd957611bd8611929565b5b81905092915050565b5f5f5f5f60a08587031215611bfa57611bf96118c3565b5b5f611c0787828801611bc4565b945050606085013567ffffffffffffffff811115611c2857611c276118c7565b5b611c3487828801611b12565b93509350506080611c4787828801611a6c565b91505092959194509250565b611c5c81611a45565b82525050565b5f602082019050611c755f830184611c53565b92915050565b5f819050919050565b5f611c9e611c99611c9484611a26565b611c7b565b611a26565b9050919050565b5f611caf82611c84565b9050919050565b5f611cc082611ca5565b9050919050565b611cd081611cb6565b82525050565b5f602082019050611ce95f830184611cc7565b92915050565b5f604082019050611d025f8301856119d4565b611d0f60208301846119d4565b9392505050565b5f82825260208201905092915050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65725f82015250565b5f611d5a602083611d16565b9150611d6582611d26565b602082019050919050565b5f6020820190508181035f830152611d8781611d4e565b9050919050565b5f602082019050611da15f8301846119d4565b92915050565b7f6368616c6c656e676520646f6573206e6f7420657869737400000000000000005f82015250565b5f611ddb601883611d16565b9150611de682611da7565b602082019050919050565b5f6020820190508181035f830152611e0881611dcf565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f8135611e48816118d4565b80915050919050565b5f815f1b9050919050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff611e8784611e51565b9350801983169250808416831791505092915050565b5f611ea7826118cb565b9050919050565b5f815f1c9050919050565b5f611ec382611eae565b9050919050565b611ed382611e9d565b611ee6611edf82611eb9565b8354611e5c565b8255505050565b5f81015f830180611efd81611e3c565b9050611f098184611eca565b505050600181016020830180611f1e81611e3c565b9050611f2a8184611eca565b5050505050565b611f3b8282611eed565b5050565b5f611f4d60208401846118ea565b905092915050565b611f5e816118cb565b82525050565b60408201611f745f830183611f3f565b611f805f850182611f55565b50611f8e6020830183611f3f565b611f9b6020850182611f55565b50505050565b5f604082019050611fb45f830184611f64565b92915050565b7f617373657274696f6e206e6f7420666f756e64000000000000000000000000005f82015250565b5f611fee601383611d16565b9150611ff982611fba565b602082019050919050565b5f6020820190508181035f83015261201b81611fe2565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52600160045260245ffd5b7f696e76616c6964207369676e6174757265206c656e67746800000000000000005f82015250565b5f612083601883611d16565b915061208e8261204f565b602082019050919050565b5f6020820190508181035f8301526120b081612077565b9050919050565b7f696e76616c69642074656520696e7075740000000000000000000000000000005f82015250565b5f6120eb601183611d16565b91506120f6826120b7565b602082019050919050565b5f6020820190508181035f830152612118816120df565b9050919050565b5f819050919050565b612139612134826118cb565b61211f565b82525050565b5f61214a8286612128565b60208201915061215a8285612128565b60208201915061216a8284612128565b602082019150819050949350505050565b7f696e76616c696420746565207369676e617475726500000000000000000000005f82015250565b5f6121af601583611d16565b91506121ba8261217b565b602082019050919050565b5f6020820190508181035f8301526121dc816121a3565b9050919050565b7f617373657274696f6e20616c72656164792065786973747300000000000000005f82015250565b5f612217601883611d16565b9150612222826121e3565b602082019050919050565b5f6020820190508181035f8301526122448161220b565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f61228282611976565b915061228d83611976565b92508282019050808211156122a5576122a461224b565b5b92915050565b5f81905092915050565b50565b5f6122c35f836122ab565b91506122ce826122b5565b5f82019050919050565b5f6122e2826122b8565b9150819050919050565b7f7061796d656e74206661696c65640000000000000000000000000000000000005f82015250565b5f612320600e83611d16565b915061232b826122ec565b602082019050919050565b5f6020820190508181035f83015261234d81612314565b9050919050565b7f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201527f746f6f206d616e7920617373657274696f6e7300000000000000000000000000602082015250565b5f6123ae603383611d16565b91506123b982612354565b604082019050919050565b5f6020820190508181035f8301526123db816123a2565b9050919050565b5f815190506123f08161197f565b92915050565b5f6020828403121561240b5761240a6118c3565b5b5f612418848285016123e2565b91505092915050565b7f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201527f696e73756666696369656e742074696d65206861732070617373656400000000602082015250565b5f61247b603c83611d16565b915061248682612421565b604082019050919050565b5f6020820190508181035f8301526124a88161246f565b9050919050565b5f6124b982611976565b91506124c483611976565b92508282039050818111156124dc576124db61224b565b5b92915050565b5f815190506124f0816118d4565b92915050565b5f6020828403121561250b5761250a6118c3565b5b5f612518848285016124e2565b91505092915050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f20615f8201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b5f61257b602683611d16565b915061258682612521565b604082019050919050565b5f6020820190508181035f8301526125a88161256f565b9050919050565b5f6125ba8287612128565b6020820191506125ca8286612128565b6020820191506125da8285612128565b6020820191506125ea8284612128565b60208201915081905095945050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b5f60ff82169050919050565b61263e81612629565b82525050565b5f6080820190506126575f8301876119d4565b6126646020830186612635565b61267160408301856119d4565b61267e60608301846119d4565b9594505050505056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x015W_5`\xE0\x1C\x80clL `\x11a\0\xB6W\x80c\x8D\xA5\xCB[\x11a\0zW\x80c\x8D\xA5\xCB[\x14a\x02\xDAW\x80c\xA3\x80\xEF\x87\x14a\x02\xF8W\x80c\xA5n\xC6\xCD\x14a\x03(W\x80c\xEE\x1C(\xB8\x14a\x03YW\x80c\xF2#\x05\\\x14a\x03wW\x80c\xF2\xFD\xE3\x8B\x14a\x03\x93Wa\x015V[\x80clL `\x14a\x02nW\x80cn\xBE\xD0\xF0\x14a\x02xW\x80cn\xF0\x12\x01\x14a\x02\xA8W\x80cqP\x18\xA6\x14a\x02\xB2W\x80c\x80\x95\x97!\x14a\x02\xBCWa\x015V[\x80cGt&@\x11a\0\xFDW\x80cGt&@\x14a\x01\xCAW\x80cK\xD1g\xC9\x14a\x01\xFAW\x80c]K\xED\xC3\x14a\x02\x18W\x80c`p\xE7\x8E\x14a\x024W\x80ci{^b\x14a\x02PWa\x015V[\x80c\n\xD1\x95\xAB\x14a\x019W\x80c\x0B|\x02A\x14a\x01UW\x80c\x1C\xAF]\x13\x14a\x01qW\x80c<\xEA\xAE}\x14a\x01\x8DW\x80cC\xDE_3\x14a\x01\xAEW[__\xFD[a\x01S`\x04\x806\x03\x81\x01\x90a\x01N\x91\x90a\x18\xFEV[a\x03\xAFV[\0[a\x01o`\x04\x806\x03\x81\x01\x90a\x01j\x91\x90a\x19KV[a\x04\x8DV[\0[a\x01\x8B`\x04\x806\x03\x81\x01\x90a\x01\x86\x91\x90a\x19\xA9V[a\x06mV[\0[a\x01\x95a\x06\xF3V[`@Qa\x01\xA5\x94\x93\x92\x91\x90a\x19\xE3V[`@Q\x80\x91\x03\x90\xF3[a\x01\xC8`\x04\x806\x03\x81\x01\x90a\x01\xC3\x91\x90a\x18\xFEV[a\x07\x10V[\0[a\x01\xE4`\x04\x806\x03\x81\x01\x90a\x01\xDF\x91\x90a\x1A\x80V[a\x07\xEFV[`@Qa\x01\xF1\x91\x90a\x1A\xC5V[`@Q\x80\x91\x03\x90\xF3[a\x02\x02a\x08\x0CV[`@Qa\x02\x0F\x91\x90a\x1A\xEDV[`@Q\x80\x91\x03\x90\xF3[a\x022`\x04\x806\x03\x81\x01\x90a\x02-\x91\x90a\x1BgV[a\x08\x12V[\0[a\x02N`\x04\x806\x03\x81\x01\x90a\x02I\x91\x90a\x1B\xE2V[a\t/V[\0[a\x02Xa\x0C\xDEV[`@Qa\x02e\x91\x90a\x1A\xEDV[`@Q\x80\x91\x03\x90\xF3[a\x02va\x0C\xE4V[\0[a\x02\x92`\x04\x806\x03\x81\x01\x90a\x02\x8D\x91\x90a\x19\xA9V[a\x0F\x9FV[`@Qa\x02\x9F\x91\x90a\x1CbV[`@Q\x80\x91\x03\x90\xF3[a\x02\xB0a\x0F\xDAV[\0[a\x02\xBAa\x11@V[\0[a\x02\xC4a\x11\xC7V[`@Qa\x02\xD1\x91\x90a\x1C\xD6V[`@Q\x80\x91\x03\x90\xF3[a\x02\xE2a\x11\xEBV[`@Qa\x02\xEF\x91\x90a\x1CbV[`@Q\x80\x91\x03\x90\xF3[a\x03\x12`\x04\x806\x03\x81\x01\x90a\x03\r\x91\x90a\x18\xFEV[a\x12\x12V[`@Qa\x03\x1F\x91\x90a\x1A\xC5V[`@Q\x80\x91\x03\x90\xF3[a\x03B`\x04\x806\x03\x81\x01\x90a\x03=\x91\x90a\x19\xA9V[a\x12/V[`@Qa\x03P\x92\x91\x90a\x1C\xEFV[`@Q\x80\x91\x03\x90\xF3[a\x03aa\x12^V[`@Qa\x03n\x91\x90a\x1A\xEDV[`@Q\x80\x91\x03\x90\xF3[a\x03\x91`\x04\x806\x03\x81\x01\x90a\x03\x8C\x91\x90a\x18\xFEV[a\x12dV[\0[a\x03\xAD`\x04\x806\x03\x81\x01\x90a\x03\xA8\x91\x90a\x1A\x80V[a\x13#V[\0[a\x03\xB7a\x14\x19V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x03\xD5a\x11\xEBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x04+W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x04\"\x90a\x1DpV[`@Q\x80\x91\x03\x90\xFD[_`\t_\x83\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\r\xB1f\xBBNG\xA6`\xAA\xFC2\xF7\x8B\xBA\xCD\xDA\x0B\x90\xB0s^E\xB2\x13J\xEE\xC3\xA5\xEAVU\xAB\x81`@Qa\x04\x82\x91\x90a\x1D\x8EV[`@Q\x80\x91\x03\x90\xA1PV[a\x04\x95a\x14\x19V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x04\xB3a\x11\xEBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x05\tW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05\0\x90a\x1DpV[`@Q\x80\x91\x03\x90\xFD[`\x01`\x05\x80T\x90P\x11a\x05QW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05H\x90a\x1D\xF1V[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x05\x80T\x90P\x81\x10\x15a\x06.Wa\x05\x8C\x82`\x05\x83\x81T\x81\x10a\x05{Wa\x05za\x1E\x0FV[[\x90_R` _ \x90`\x02\x02\x01a\x14 V[\x15a\x06!W`\x05_a\x05\x9E\x91\x90a\x18EV[`\x05\x82\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x02\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a\x05\xD3\x91\x90a\x1F1V[PP_`\n\x81\x90UPa\x05\xE4a\x0C\xE4V[\x7F\x11N\x9Cy\x8E<m\x15\x8B]\x1D\xD7\x11\xCE\x1E\"x_=\x94\x89\x8D\xDB\x1C\xE7\xF9\xBCu\x171u\xD3\x82`@Qa\x06\x13\x91\x90a\x1F\xA1V[`@Q\x80\x91\x03\x90\xA1Pa\x06jV[\x80\x80`\x01\x01\x91PPa\x05VV[P`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06a\x90a \x04V[`@Q\x80\x91\x03\x90\xFD[PV[a\x06ua\x14\x19V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x06\x93a\x11\xEBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x06\xE9W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xE0\x90a\x1DpV[`@Q\x80\x91\x03\x90\xFD[\x80`\x0B\x81\x90UPPV[`\x01\x80_\x01T\x90\x80`\x01\x01T\x90\x80`\x02\x01T\x90\x80`\x03\x01T\x90P\x84V[a\x07\x18a\x14\x19V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x076a\x11\xEBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x07\x8CW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x07\x83\x90a\x1DpV[`@Q\x80\x91\x03\x90\xFD[`\x01`\t_\x83\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7FC\x88P&\xC5\x9E\xCB\xB8$\xD1\x02x_\xEE_\x95\x93\xE6\x95\xBB\x9A\x84\x90\x86M\x980\x95%$\xE5\xD5\x81`@Qa\x07\xE4\x91\x90a\x1D\x8EV[`@Q\x80\x91\x03\x90\xA1PV[`\x08` R\x80_R`@_ _\x91PT\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[`\x0BT\x81V[`\x01\x82\x82\x90P\x14a\x08&Wa\x08%a \"V[[`\x08_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\t*W`\x01`\x08_\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP`\x07\x83\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP[PPPV[`A\x83\x83\x90P\x14a\tuW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\tl\x90a \x99V[`@Q\x80\x91\x03\x90\xFD[a\t\x7F`\x01a\x14EV[\x84_\x015\x14a\t\xC3W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\t\xBA\x90a!\x01V[`@Q\x80\x91\x03\x90\xFD[_\x84_\x015\x85` \x01_\x015\x86` \x01` \x015`@Q` \x01a\t\xE9\x93\x92\x91\x90a!?V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P`\x08_a\nb\x86\x86\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x81\x84\x01R`\x1F\x19`\x1F\x82\x01\x16\x90P\x80\x83\x01\x92PPPPPPPa\nT\x85a\x14\x89V[a\x14\xBC\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\n\xE7W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\n\xDE\x90a!\xC5V[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x05\x80T\x90P\x81\x10\x15a\x0BrWa\x0B%\x86` \x01`\x05\x83\x81T\x81\x10a\x0B\x14Wa\x0B\x13a\x1E\x0FV[[\x90_R` _ \x90`\x02\x02\x01a\x14 V[\x15a\x0BeW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0B\\\x90a\"-V[`@Q\x80\x91\x03\x90\xFD[\x80\x80`\x01\x01\x91PPa\n\xECV[P_`\x05\x80T\x90P\x03a\x0B\x94W`\x0BTBa\x0B\x8D\x91\x90a\"xV[`\n\x81\x90UP[`\x05\x85` \x01\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x02\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a\x0B\xCC\x91\x90a\x1F1V[PP`\x02`\x05\x80T\x90P\x03a\x0C\xD7W`\x01`\x06_\x82\x82Ta\x0B\xED\x91\x90a\"xV[\x92PP\x81\x90UP\x7F7\xE8\xAD\xD6\x94\xC5\x92mVN\x97\x11`\xF5\x97A\x03\xCB\xBB\xC7\xC9\x07G\xC4\xC6\xF8\x02\x03\x1D5g\xA7`\x06T`@Qa\x0C%\x91\x90a\x1A\xEDV[`@Q\x80\x91\x03\x90\xA1_\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16G`@Qa\x0CR\x90a\"\xD8V[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a\x0C\x8CW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x0C\x91V[``\x91P[PP\x90P\x80a\x0C\xD5W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0C\xCC\x90a#6V[`@Q\x80\x91\x03\x90\xFD[P[PPPPPV[`\x06T\x81V[_sB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\x90P`\x01`\x05\x80T\x90P\x11\x15a\rEW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\r<\x90a#\xC4V[`@Q\x80\x91\x03\x90\xFD[`\nT\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xB8\x07w\xEA`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\r\x91W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r\xB5\x91\x90a#\xF6V[\x11a\r\xF5W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\r\xEC\x90a$\x91V[`@Q\x80\x91\x03\x90\xFD[_`\x05\x80T\x90P\x11\x15a\x0E\xFCW`\x05_\x81T\x81\x10a\x0E\x16Wa\x0E\x15a\x1E\x0FV[[\x90_R` _ \x90`\x02\x02\x01_\x01T`\x01`\x03\x01\x81\x90UP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xDA\xEA\xB4\x12`\x05_\x81T\x81\x10a\x0E~Wa\x0E}a\x1E\x0FV[[\x90_R` _ \x90`\x02\x02\x01_\x01T`\x05_\x81T\x81\x10a\x0E\xA1Wa\x0E\xA0a\x1E\x0FV[[\x90_R` _ \x90`\x02\x02\x01`\x01\x01T`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0E\xCE\x92\x91\x90a\x1C\xEFV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0E\xE5W__\xFD[PZ\xF1\x15\x80\x15a\x0E\xF7W=__>=_\xFD[PPPP[`\x01Ca\x0F\t\x91\x90a$\xAFV[@`\x01\x80\x01\x81\x90UP\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\t\xBDZ``@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0F[W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0F\x7F\x91\x90a$\xF6V[`\x01`\x02\x01\x81\x90UP`\x0BTBa\x0F\x96\x91\x90a\"xV[`\n\x81\x90UPPV[`\x07\x81\x81T\x81\x10a\x0F\xAEW_\x80\xFD[\x90_R` _ \x01_\x91PT\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[a\x0F\xE2a\x14\x19V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x10\0a\x11\xEBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x10VW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x10M\x90a\x1DpV[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x07\x80T\x90P\x81\x10\x15a\x11\x04W_`\x08_`\x07\x84\x81T\x81\x10a\x10\x80Wa\x10\x7Fa\x1E\x0FV[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa\x10[V[P`\x07_a\x11\x12\x91\x90a\x18fV[\x7F\xEC\xA6.\0t\xA1:\x90\xD6\0\xF0\x03\xB7\xCB\x8D[\xD5\x01\0\0\x8D?9\x15\xF2UO?\x85R\xC5\xCC`@Q`@Q\x80\x91\x03\x90\xA1V[a\x11Ha\x14\x19V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x11fa\x11\xEBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x11\xBCW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x11\xB3\x90a\x1DpV[`@Q\x80\x91\x03\x90\xFD[a\x11\xC5_a\x14\xE6V[V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[___\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[`\t` R\x80_R`@_ _\x91PT\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[`\x05\x81\x81T\x81\x10a\x12>W_\x80\xFD[\x90_R` _ \x90`\x02\x02\x01_\x91P\x90P\x80_\x01T\x90\x80`\x01\x01T\x90P\x82V[`\nT\x81V[a\x12la\x14\x19V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x12\x8Aa\x11\xEBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x12\xE0W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x12\xD7\x90a\x1DpV[`@Q\x80\x91\x03\x90\xFD[\x80`\x01_\x01\x81\x90UP\x7F\xB7\xA1\x80\"\x84\x97\xED\x95\xC6\x89o\xC1\xB0\x81\xA0\x16\x99\x91\x16\xF9\x8A\xB9[R\x126Y\xEF\xEA%\x97d\x81`@Qa\x13\x18\x91\x90a\x1D\x8EV[`@Q\x80\x91\x03\x90\xA1PV[a\x13+a\x14\x19V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x13Ia\x11\xEBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x13\x9FW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\x96\x90a\x1DpV[`@Q\x80\x91\x03\x90\xFD[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x14\rW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14\x04\x90a%\x91V[`@Q\x80\x91\x03\x90\xFD[a\x14\x16\x81a\x14\xE6V[PV[_3\x90P\x90V[_\x81_\x01T\x83_\x015\x14\x80\x15a\x14=WP\x81`\x01\x01T\x83` \x015\x14[\x90P\x92\x91PPV[_\x81_\x01T\x82`\x01\x01T\x83`\x02\x01T\x84`\x03\x01T`@Q` \x01a\x14l\x94\x93\x92\x91\x90a%\xAFV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x91\x90PV[_\x7F\x19Ethereum Signed Message:\n32\0\0\0\0_R\x81`\x1CR`<_ \x90P\x91\x90PV[____a\x14\xCA\x86\x86a\x15\xA7V[\x92P\x92P\x92Pa\x14\xDA\x82\x82a\x15\xFCV[\x82\x93PPPP\x92\x91PPV[___\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81__a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPV[___`A\x84Q\x03a\x15\xE7W___` \x87\x01Q\x92P`@\x87\x01Q\x91P``\x87\x01Q_\x1A\x90Pa\x15\xD9\x88\x82\x85\x85a\x17^V[\x95P\x95P\x95PPPPa\x15\xF5V[_`\x02\x85Q_\x1B\x92P\x92P\x92P[\x92P\x92P\x92V[_`\x03\x81\x11\x15a\x16\x0FWa\x16\x0Ea%\xFCV[[\x82`\x03\x81\x11\x15a\x16\"Wa\x16!a%\xFCV[[\x03\x15a\x17ZW`\x01`\x03\x81\x11\x15a\x16<Wa\x16;a%\xFCV[[\x82`\x03\x81\x11\x15a\x16OWa\x16Na%\xFCV[[\x03a\x16\x86W`@Q\x7F\xF6E\xEE\xDF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`\x03\x81\x11\x15a\x16\x9AWa\x16\x99a%\xFCV[[\x82`\x03\x81\x11\x15a\x16\xADWa\x16\xACa%\xFCV[[\x03a\x16\xF1W\x80_\x1C`@Q\x7F\xFC\xE6\x98\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x16\xE8\x91\x90a\x1A\xEDV[`@Q\x80\x91\x03\x90\xFD[`\x03\x80\x81\x11\x15a\x17\x04Wa\x17\x03a%\xFCV[[\x82`\x03\x81\x11\x15a\x17\x17Wa\x17\x16a%\xFCV[[\x03a\x17YW\x80`@Q\x7F\xD7\x8B\xCE\x0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x17P\x91\x90a\x1D\x8EV[`@Q\x80\x91\x03\x90\xFD[[PPV[___\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0\x84_\x1C\x11\x15a\x17\x9AW_`\x03\x85\x92P\x92P\x92Pa\x18;V[_`\x01\x88\x88\x88\x88`@Q_\x81R` \x01`@R`@Qa\x17\xBD\x94\x93\x92\x91\x90a&DV[` `@Q` \x81\x03\x90\x80\x84\x03\x90\x85Z\xFA\x15\x80\x15a\x17\xDDW=__>=_\xFD[PPP` `@Q\x03Q\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x18.W_`\x01__\x1B\x93P\x93P\x93PPa\x18;V[\x80___\x1B\x93P\x93P\x93PP[\x94P\x94P\x94\x91PPV[P\x80T_\x82U`\x02\x02\x90_R` _ \x90\x81\x01\x90a\x18c\x91\x90a\x18\x84V[PV[P\x80T_\x82U\x90_R` _ \x90\x81\x01\x90a\x18\x81\x91\x90a\x18\xA8V[PV[[\x80\x82\x11\x15a\x18\xA4W__\x82\x01_\x90U`\x01\x82\x01_\x90UP`\x02\x01a\x18\x85V[P\x90V[[\x80\x82\x11\x15a\x18\xBFW_\x81_\x90UP`\x01\x01a\x18\xA9V[P\x90V[__\xFD[__\xFD[_\x81\x90P\x91\x90PV[a\x18\xDD\x81a\x18\xCBV[\x81\x14a\x18\xE7W__\xFD[PV[_\x815\x90Pa\x18\xF8\x81a\x18\xD4V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x19\x13Wa\x19\x12a\x18\xC3V[[_a\x19 \x84\x82\x85\x01a\x18\xEAV[\x91PP\x92\x91PPV[__\xFD[_`@\x82\x84\x03\x12\x15a\x19BWa\x19Aa\x19)V[[\x81\x90P\x92\x91PPV[_`@\x82\x84\x03\x12\x15a\x19`Wa\x19_a\x18\xC3V[[_a\x19m\x84\x82\x85\x01a\x19-V[\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[a\x19\x88\x81a\x19vV[\x81\x14a\x19\x92W__\xFD[PV[_\x815\x90Pa\x19\xA3\x81a\x19\x7FV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x19\xBEWa\x19\xBDa\x18\xC3V[[_a\x19\xCB\x84\x82\x85\x01a\x19\x95V[\x91PP\x92\x91PPV[a\x19\xDD\x81a\x18\xCBV[\x82RPPV[_`\x80\x82\x01\x90Pa\x19\xF6_\x83\x01\x87a\x19\xD4V[a\x1A\x03` \x83\x01\x86a\x19\xD4V[a\x1A\x10`@\x83\x01\x85a\x19\xD4V[a\x1A\x1D``\x83\x01\x84a\x19\xD4V[\x95\x94PPPPPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a\x1AO\x82a\x1A&V[\x90P\x91\x90PV[a\x1A_\x81a\x1AEV[\x81\x14a\x1AiW__\xFD[PV[_\x815\x90Pa\x1Az\x81a\x1AVV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x1A\x95Wa\x1A\x94a\x18\xC3V[[_a\x1A\xA2\x84\x82\x85\x01a\x1AlV[\x91PP\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[a\x1A\xBF\x81a\x1A\xABV[\x82RPPV[_` \x82\x01\x90Pa\x1A\xD8_\x83\x01\x84a\x1A\xB6V[\x92\x91PPV[a\x1A\xE7\x81a\x19vV[\x82RPPV[_` \x82\x01\x90Pa\x1B\0_\x83\x01\x84a\x1A\xDEV[\x92\x91PPV[__\xFD[__\xFD[__\xFD[__\x83`\x1F\x84\x01\x12a\x1B'Wa\x1B&a\x1B\x06V[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1BDWa\x1BCa\x1B\nV[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15a\x1B`Wa\x1B_a\x1B\x0EV[[\x92P\x92\x90PV[___`@\x84\x86\x03\x12\x15a\x1B~Wa\x1B}a\x18\xC3V[[_a\x1B\x8B\x86\x82\x87\x01a\x1AlV[\x93PP` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1B\xACWa\x1B\xABa\x18\xC7V[[a\x1B\xB8\x86\x82\x87\x01a\x1B\x12V[\x92P\x92PP\x92P\x92P\x92V[_``\x82\x84\x03\x12\x15a\x1B\xD9Wa\x1B\xD8a\x19)V[[\x81\x90P\x92\x91PPV[____`\xA0\x85\x87\x03\x12\x15a\x1B\xFAWa\x1B\xF9a\x18\xC3V[[_a\x1C\x07\x87\x82\x88\x01a\x1B\xC4V[\x94PP``\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1C(Wa\x1C'a\x18\xC7V[[a\x1C4\x87\x82\x88\x01a\x1B\x12V[\x93P\x93PP`\x80a\x1CG\x87\x82\x88\x01a\x1AlV[\x91PP\x92\x95\x91\x94P\x92PV[a\x1C\\\x81a\x1AEV[\x82RPPV[_` \x82\x01\x90Pa\x1Cu_\x83\x01\x84a\x1CSV[\x92\x91PPV[_\x81\x90P\x91\x90PV[_a\x1C\x9Ea\x1C\x99a\x1C\x94\x84a\x1A&V[a\x1C{V[a\x1A&V[\x90P\x91\x90PV[_a\x1C\xAF\x82a\x1C\x84V[\x90P\x91\x90PV[_a\x1C\xC0\x82a\x1C\xA5V[\x90P\x91\x90PV[a\x1C\xD0\x81a\x1C\xB6V[\x82RPPV[_` \x82\x01\x90Pa\x1C\xE9_\x83\x01\x84a\x1C\xC7V[\x92\x91PPV[_`@\x82\x01\x90Pa\x1D\x02_\x83\x01\x85a\x19\xD4V[a\x1D\x0F` \x83\x01\x84a\x19\xD4V[\x93\x92PPPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7FOwnable: caller is not the owner_\x82\x01RPV[_a\x1DZ` \x83a\x1D\x16V[\x91Pa\x1De\x82a\x1D&V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x1D\x87\x81a\x1DNV[\x90P\x91\x90PV[_` \x82\x01\x90Pa\x1D\xA1_\x83\x01\x84a\x19\xD4V[\x92\x91PPV[\x7Fchallenge does not exist\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x1D\xDB`\x18\x83a\x1D\x16V[\x91Pa\x1D\xE6\x82a\x1D\xA7V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x1E\x08\x81a\x1D\xCFV[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[_\x815a\x1EH\x81a\x18\xD4V[\x80\x91PP\x91\x90PV[_\x81_\x1B\x90P\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x1E\x87\x84a\x1EQV[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_a\x1E\xA7\x82a\x18\xCBV[\x90P\x91\x90PV[_\x81_\x1C\x90P\x91\x90PV[_a\x1E\xC3\x82a\x1E\xAEV[\x90P\x91\x90PV[a\x1E\xD3\x82a\x1E\x9DV[a\x1E\xE6a\x1E\xDF\x82a\x1E\xB9V[\x83Ta\x1E\\V[\x82UPPPV[_\x81\x01_\x83\x01\x80a\x1E\xFD\x81a\x1E<V[\x90Pa\x1F\t\x81\x84a\x1E\xCAV[PPP`\x01\x81\x01` \x83\x01\x80a\x1F\x1E\x81a\x1E<V[\x90Pa\x1F*\x81\x84a\x1E\xCAV[PPPPPV[a\x1F;\x82\x82a\x1E\xEDV[PPV[_a\x1FM` \x84\x01\x84a\x18\xEAV[\x90P\x92\x91PPV[a\x1F^\x81a\x18\xCBV[\x82RPPV[`@\x82\x01a\x1Ft_\x83\x01\x83a\x1F?V[a\x1F\x80_\x85\x01\x82a\x1FUV[Pa\x1F\x8E` \x83\x01\x83a\x1F?V[a\x1F\x9B` \x85\x01\x82a\x1FUV[PPPPV[_`@\x82\x01\x90Pa\x1F\xB4_\x83\x01\x84a\x1FdV[\x92\x91PPV[\x7Fassertion not found\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x1F\xEE`\x13\x83a\x1D\x16V[\x91Pa\x1F\xF9\x82a\x1F\xBAV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra \x1B\x81a\x1F\xE2V[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x01`\x04R`$_\xFD[\x7Finvalid signature length\0\0\0\0\0\0\0\0_\x82\x01RPV[_a \x83`\x18\x83a\x1D\x16V[\x91Pa \x8E\x82a OV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra \xB0\x81a wV[\x90P\x91\x90PV[\x7Finvalid tee input\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a \xEB`\x11\x83a\x1D\x16V[\x91Pa \xF6\x82a \xB7V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra!\x18\x81a \xDFV[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a!9a!4\x82a\x18\xCBV[a!\x1FV[\x82RPPV[_a!J\x82\x86a!(V[` \x82\x01\x91Pa!Z\x82\x85a!(V[` \x82\x01\x91Pa!j\x82\x84a!(V[` \x82\x01\x91P\x81\x90P\x94\x93PPPPV[\x7Finvalid tee signature\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a!\xAF`\x15\x83a\x1D\x16V[\x91Pa!\xBA\x82a!{V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra!\xDC\x81a!\xA3V[\x90P\x91\x90PV[\x7Fassertion already exists\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\"\x17`\x18\x83a\x1D\x16V[\x91Pa\"\"\x82a!\xE3V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\"D\x81a\"\x0BV[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a\"\x82\x82a\x19vV[\x91Pa\"\x8D\x83a\x19vV[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a\"\xA5Wa\"\xA4a\"KV[[\x92\x91PPV[_\x81\x90P\x92\x91PPV[PV[_a\"\xC3_\x83a\"\xABV[\x91Pa\"\xCE\x82a\"\xB5V[_\x82\x01\x90P\x91\x90PV[_a\"\xE2\x82a\"\xB8V[\x91P\x81\x90P\x91\x90PV[\x7Fpayment failed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a# `\x0E\x83a\x1D\x16V[\x91Pa#+\x82a\"\xECV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra#M\x81a#\x14V[\x90P\x91\x90PV[\x7Fcannot close challenge window - _\x82\x01R\x7Ftoo many assertions\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a#\xAE`3\x83a\x1D\x16V[\x91Pa#\xB9\x82a#TV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra#\xDB\x81a#\xA2V[\x90P\x91\x90PV[_\x81Q\x90Pa#\xF0\x81a\x19\x7FV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a$\x0BWa$\na\x18\xC3V[[_a$\x18\x84\x82\x85\x01a#\xE2V[\x91PP\x92\x91PPV[\x7Fcannot close challenge window - _\x82\x01R\x7Finsufficient time has passed\0\0\0\0` \x82\x01RPV[_a${`<\x83a\x1D\x16V[\x91Pa$\x86\x82a$!V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra$\xA8\x81a$oV[\x90P\x91\x90PV[_a$\xB9\x82a\x19vV[\x91Pa$\xC4\x83a\x19vV[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15a$\xDCWa$\xDBa\"KV[[\x92\x91PPV[_\x81Q\x90Pa$\xF0\x81a\x18\xD4V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a%\x0BWa%\na\x18\xC3V[[_a%\x18\x84\x82\x85\x01a$\xE2V[\x91PP\x92\x91PPV[\x7FOwnable: new owner is the zero a_\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a%{`&\x83a\x1D\x16V[\x91Pa%\x86\x82a%!V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra%\xA8\x81a%oV[\x90P\x91\x90PV[_a%\xBA\x82\x87a!(V[` \x82\x01\x91Pa%\xCA\x82\x86a!(V[` \x82\x01\x91Pa%\xDA\x82\x85a!(V[` \x82\x01\x91Pa%\xEA\x82\x84a!(V[` \x82\x01\x91P\x81\x90P\x95\x94PPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[_`\xFF\x82\x16\x90P\x91\x90PV[a&>\x81a&)V[\x82RPPV[_`\x80\x82\x01\x90Pa&W_\x83\x01\x87a\x19\xD4V[a&d` \x83\x01\x86a&5V[a&q`@\x83\x01\x85a\x19\xD4V[a&~``\x83\x01\x84a\x19\xD4V[\x95\x94PPPPPV",
    );
    /**```solidity
struct AssertionPayload { bytes32 teeTrustedInputHash; PendingAssertion assertion; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssertionPayload {
        #[allow(missing_docs)]
        pub teeTrustedInputHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            PendingAssertion,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            <PendingAssertion as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssertionPayload> for UnderlyingRustTuple<'_> {
            fn from(value: AssertionPayload) -> Self {
                (value.teeTrustedInputHash, value.assertion)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssertionPayload {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    teeTrustedInputHash: tuple.0,
                    assertion: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for AssertionPayload {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for AssertionPayload {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.teeTrustedInputHash),
                    <PendingAssertion as alloy_sol_types::SolType>::tokenize(
                        &self.assertion,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for AssertionPayload {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for AssertionPayload {
            const NAME: &'static str = "AssertionPayload";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "AssertionPayload(bytes32 teeTrustedInputHash,PendingAssertion assertion)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <PendingAssertion as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <PendingAssertion as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.teeTrustedInputHash,
                        )
                        .0,
                    <PendingAssertion as alloy_sol_types::SolType>::eip712_data_word(
                            &self.assertion,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for AssertionPayload {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.teeTrustedInputHash,
                    )
                    + <PendingAssertion as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.assertion,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.teeTrustedInputHash,
                    out,
                );
                <PendingAssertion as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.assertion,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct PendingAssertion { bytes32 blockHash; bytes32 sendRoot; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PendingAssertion {
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sendRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PendingAssertion> for UnderlyingRustTuple<'_> {
            fn from(value: PendingAssertion) -> Self {
                (value.blockHash, value.sendRoot)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PendingAssertion {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    blockHash: tuple.0,
                    sendRoot: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for PendingAssertion {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for PendingAssertion {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.sendRoot),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for PendingAssertion {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for PendingAssertion {
            const NAME: &'static str = "PendingAssertion";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "PendingAssertion(bytes32 blockHash,bytes32 sendRoot)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.blockHash)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.sendRoot)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for PendingAssertion {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.blockHash,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sendRoot,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.blockHash,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sendRoot,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignature()` and selector `0xf645eedf`.
```solidity
error ECDSAInvalidSignature();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignature {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignature()";
            const SELECTOR: [u8; 4] = [246u8, 69u8, 238u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureLength(uint256)` and selector `0xfce698f7`.
```solidity
error ECDSAInvalidSignatureLength(uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureLength {
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureLength) -> Self {
                (value.length,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ECDSAInvalidSignatureLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { length: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureLength(uint256)";
            const SELECTOR: [u8; 4] = [252u8, 230u8, 152u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureS(bytes32)` and selector `0xd78bce0c`.
```solidity
error ECDSAInvalidSignatureS(bytes32 s);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureS {
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureS> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureS) -> Self {
                (value.s,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignatureS {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { s: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureS {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureS(bytes32)";
            const SELECTOR: [u8; 4] = [215u8, 139u8, 206u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
        }
    };
    /**Event with signature `ChallengeResolved((bytes32,bytes32))` and selector `0x114e9c798e3c6d158b5d1dd711ce1e22785f3d94898ddb1ce7f9bc75173175d3`.
```solidity
event ChallengeResolved(PendingAssertion);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ChallengeResolved {
        #[allow(missing_docs)]
        pub _0: <PendingAssertion as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ChallengeResolved {
            type DataTuple<'a> = (PendingAssertion,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ChallengeResolved((bytes32,bytes32))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                17u8,
                78u8,
                156u8,
                121u8,
                142u8,
                60u8,
                109u8,
                21u8,
                139u8,
                93u8,
                29u8,
                215u8,
                17u8,
                206u8,
                30u8,
                34u8,
                120u8,
                95u8,
                61u8,
                148u8,
                137u8,
                141u8,
                219u8,
                28u8,
                231u8,
                249u8,
                188u8,
                117u8,
                23u8,
                49u8,
                117u8,
                211u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { _0: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (<PendingAssertion as alloy_sol_types::SolType>::tokenize(&self._0),)
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ChallengeResolved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ChallengeResolved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ChallengeResolved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeAppchainConfigHash(bytes32)` and selector `0xb7a180228497ed95c6896fc1b081a016999116f98ab95b52123659efea259764`.
```solidity
event TeeAppchainConfigHash(bytes32 hash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeAppchainConfigHash {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeAppchainConfigHash {
            type DataTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeAppchainConfigHash(bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                183u8,
                161u8,
                128u8,
                34u8,
                132u8,
                151u8,
                237u8,
                149u8,
                198u8,
                137u8,
                111u8,
                193u8,
                176u8,
                129u8,
                160u8,
                22u8,
                153u8,
                145u8,
                22u8,
                249u8,
                138u8,
                185u8,
                91u8,
                82u8,
                18u8,
                54u8,
                89u8,
                239u8,
                234u8,
                37u8,
                151u8,
                100u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { hash: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeAppchainConfigHash {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeAppchainConfigHash> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeAppchainConfigHash) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeHacked(uint256)` and selector `0x37e8add694c5926d564e971160f5974103cbbbc7c90747c4c6f802031d3567a7`.
```solidity
event TeeHacked(uint256);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeHacked {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeHacked {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeHacked(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                55u8,
                232u8,
                173u8,
                214u8,
                148u8,
                197u8,
                146u8,
                109u8,
                86u8,
                78u8,
                151u8,
                17u8,
                96u8,
                245u8,
                151u8,
                65u8,
                3u8,
                203u8,
                187u8,
                199u8,
                201u8,
                7u8,
                71u8,
                196u8,
                198u8,
                248u8,
                2u8,
                3u8,
                29u8,
                53u8,
                103u8,
                167u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { _0: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeHacked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeHacked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeHacked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeKeysRevoked()` and selector `0xeca62e0074a13a90d600f003b7cb8d5bd50100008d3f3915f2554f3f8552c5cc`.
```solidity
event TeeKeysRevoked();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeKeysRevoked {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeKeysRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeKeysRevoked()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                236u8,
                166u8,
                46u8,
                0u8,
                116u8,
                161u8,
                58u8,
                144u8,
                214u8,
                0u8,
                240u8,
                3u8,
                183u8,
                203u8,
                141u8,
                91u8,
                213u8,
                1u8,
                0u8,
                0u8,
                141u8,
                63u8,
                57u8,
                21u8,
                242u8,
                85u8,
                79u8,
                63u8,
                133u8,
                82u8,
                197u8,
                204u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeKeysRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeKeysRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeKeysRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeProgramHashAdded(bytes32)` and selector `0x43885026c59ecbb824d102785fee5f9593e695bb9a8490864d9830952524e5d5`.
```solidity
event TeeProgramHashAdded(bytes32 hash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeProgramHashAdded {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeProgramHashAdded {
            type DataTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeProgramHashAdded(bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                67u8,
                136u8,
                80u8,
                38u8,
                197u8,
                158u8,
                203u8,
                184u8,
                36u8,
                209u8,
                2u8,
                120u8,
                95u8,
                238u8,
                95u8,
                149u8,
                147u8,
                230u8,
                149u8,
                187u8,
                154u8,
                132u8,
                144u8,
                134u8,
                77u8,
                152u8,
                48u8,
                149u8,
                37u8,
                36u8,
                229u8,
                213u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { hash: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeProgramHashAdded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeProgramHashAdded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeProgramHashAdded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeProgramHashRemoved(bytes32)` and selector `0x0db166bb4e47a660aafc32f78bbacdda0b90b0735e45b2134aeec3a5ea5655ab`.
```solidity
event TeeProgramHashRemoved(bytes32 hash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeProgramHashRemoved {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeProgramHashRemoved {
            type DataTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeProgramHashRemoved(bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                13u8,
                177u8,
                102u8,
                187u8,
                78u8,
                71u8,
                166u8,
                96u8,
                170u8,
                252u8,
                50u8,
                247u8,
                139u8,
                186u8,
                205u8,
                218u8,
                11u8,
                144u8,
                176u8,
                115u8,
                94u8,
                69u8,
                178u8,
                19u8,
                74u8,
                238u8,
                195u8,
                165u8,
                234u8,
                86u8,
                85u8,
                171u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { hash: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeProgramHashRemoved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeProgramHashRemoved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeProgramHashRemoved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address poster_, bytes32 appchainConfigHash_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub poster_: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value.poster_, value.appchainConfigHash_)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        poster_: tuple.0,
                        appchainConfigHash_: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.poster_,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainConfigHash_),
                )
            }
        }
    };
    /**Function with signature `addTeeKey(address,bytes)` and selector `0x5d4bedc3`.
```solidity
function addTeeKey(address publicKey, bytes memory zkProof) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addTeeKeyCall {
        #[allow(missing_docs)]
        pub publicKey: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub zkProof: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`addTeeKey(address,bytes)`](addTeeKeyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addTeeKeyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addTeeKeyCall> for UnderlyingRustTuple<'_> {
                fn from(value: addTeeKeyCall) -> Self {
                    (value.publicKey, value.zkProof)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addTeeKeyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        publicKey: tuple.0,
                        zkProof: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addTeeKeyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addTeeKeyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addTeeKeyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addTeeKeyCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addTeeKeyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addTeeKey(address,bytes)";
            const SELECTOR: [u8; 4] = [93u8, 75u8, 237u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.publicKey,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.zkProof,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `addTeeProgramHash(bytes32)` and selector `0x43de5f33`.
```solidity
function addTeeProgramHash(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addTeeProgramHashCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`addTeeProgramHash(bytes32)`](addTeeProgramHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addTeeProgramHashReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addTeeProgramHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: addTeeProgramHashCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for addTeeProgramHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addTeeProgramHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: addTeeProgramHashReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for addTeeProgramHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addTeeProgramHashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addTeeProgramHashReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addTeeProgramHash(bytes32)";
            const SELECTOR: [u8; 4] = [67u8, 222u8, 95u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `challengeWindowDuration()` and selector `0x4bd167c9`.
```solidity
function challengeWindowDuration() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowDurationCall {}
    ///Container type for the return parameters of the [`challengeWindowDuration()`](challengeWindowDurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowDurationReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowDurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowDurationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowDurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowDurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowDurationReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowDurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for challengeWindowDurationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = challengeWindowDurationReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "challengeWindowDuration()";
            const SELECTOR: [u8; 4] = [75u8, 209u8, 103u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `challengeWindowEnd()` and selector `0xee1c28b8`.
```solidity
function challengeWindowEnd() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowEndCall {}
    ///Container type for the return parameters of the [`challengeWindowEnd()`](challengeWindowEndCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowEndReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowEndCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowEndCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowEndCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowEndReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowEndReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowEndReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for challengeWindowEndCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = challengeWindowEndReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "challengeWindowEnd()";
            const SELECTOR: [u8; 4] = [238u8, 28u8, 40u8, 184u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `closeChallengeWindow()` and selector `0x6c4c2060`.
```solidity
function closeChallengeWindow() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct closeChallengeWindowCall {}
    ///Container type for the return parameters of the [`closeChallengeWindow()`](closeChallengeWindowCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct closeChallengeWindowReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<closeChallengeWindowCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: closeChallengeWindowCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for closeChallengeWindowCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<closeChallengeWindowReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: closeChallengeWindowReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for closeChallengeWindowReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for closeChallengeWindowCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = closeChallengeWindowReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "closeChallengeWindow()";
            const SELECTOR: [u8; 4] = [108u8, 76u8, 32u8, 96u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isTeeKey(address)` and selector `0x47742640`.
```solidity
function isTeeKey(address) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isTeeKeyCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isTeeKey(address)`](isTeeKeyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isTeeKeyReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isTeeKeyCall> for UnderlyingRustTuple<'_> {
                fn from(value: isTeeKeyCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isTeeKeyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isTeeKeyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isTeeKeyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isTeeKeyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isTeeKeyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isTeeKeyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isTeeKey(address)";
            const SELECTOR: [u8; 4] = [71u8, 116u8, 38u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isTeeProgramHash(bytes32)` and selector `0xa380ef87`.
```solidity
function isTeeProgramHash(bytes32) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isTeeProgramHashCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`isTeeProgramHash(bytes32)`](isTeeProgramHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isTeeProgramHashReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isTeeProgramHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isTeeProgramHashCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isTeeProgramHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isTeeProgramHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isTeeProgramHashReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isTeeProgramHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isTeeProgramHashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isTeeProgramHashReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isTeeProgramHash(bytes32)";
            const SELECTOR: [u8; 4] = [163u8, 128u8, 239u8, 135u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall {}
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pendingAssertions(uint256)` and selector `0xa56ec6cd`.
```solidity
function pendingAssertions(uint256) external view returns (bytes32 blockHash, bytes32 sendRoot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingAssertionsCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`pendingAssertions(uint256)`](pendingAssertionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingAssertionsReturn {
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sendRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingAssertionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: pendingAssertionsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pendingAssertionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingAssertionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: pendingAssertionsReturn) -> Self {
                    (value.blockHash, value.sendRoot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pendingAssertionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blockHash: tuple.0,
                        sendRoot: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pendingAssertionsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pendingAssertionsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pendingAssertions(uint256)";
            const SELECTOR: [u8; 4] = [165u8, 110u8, 198u8, 205u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `poster()` and selector `0x80959721`.
```solidity
function poster() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct posterCall {}
    ///Container type for the return parameters of the [`poster()`](posterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct posterReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<posterCall> for UnderlyingRustTuple<'_> {
                fn from(value: posterCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for posterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<posterReturn> for UnderlyingRustTuple<'_> {
                fn from(value: posterReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for posterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for posterCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = posterReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "poster()";
            const SELECTOR: [u8; 4] = [128u8, 149u8, 151u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeTeeProgramHash(bytes32)` and selector `0x0ad195ab`.
```solidity
function removeTeeProgramHash(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeTeeProgramHashCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`removeTeeProgramHash(bytes32)`](removeTeeProgramHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeTeeProgramHashReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeTeeProgramHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeTeeProgramHashCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeTeeProgramHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeTeeProgramHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeTeeProgramHashReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeTeeProgramHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeTeeProgramHashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeTeeProgramHashReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeTeeProgramHash(bytes32)";
            const SELECTOR: [u8; 4] = [10u8, 209u8, 149u8, 171u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall {}
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `resolveChallenge((bytes32,bytes32))` and selector `0x0b7c0241`.
```solidity
function resolveChallenge(PendingAssertion memory assertion) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolveChallengeCall {
        #[allow(missing_docs)]
        pub assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`resolveChallenge((bytes32,bytes32))`](resolveChallengeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolveChallengeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (PendingAssertion,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PendingAssertion as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolveChallengeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: resolveChallengeCall) -> Self {
                    (value.assertion,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resolveChallengeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { assertion: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolveChallengeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: resolveChallengeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resolveChallengeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for resolveChallengeCall {
            type Parameters<'a> = (PendingAssertion,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = resolveChallengeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "resolveChallenge((bytes32,bytes32))";
            const SELECTOR: [u8; 4] = [11u8, 124u8, 2u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PendingAssertion as alloy_sol_types::SolType>::tokenize(
                        &self.assertion,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeAllTeeKeys()` and selector `0x6ef01201`.
```solidity
function revokeAllTeeKeys() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeAllTeeKeysCall {}
    ///Container type for the return parameters of the [`revokeAllTeeKeys()`](revokeAllTeeKeysCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeAllTeeKeysReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeAllTeeKeysCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: revokeAllTeeKeysCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for revokeAllTeeKeysCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeAllTeeKeysReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: revokeAllTeeKeysReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for revokeAllTeeKeysReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeAllTeeKeysCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeAllTeeKeysReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeAllTeeKeys()";
            const SELECTOR: [u8; 4] = [110u8, 240u8, 18u8, 1u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setAppchainConfigHash(bytes32)` and selector `0xf223055c`.
```solidity
function setAppchainConfigHash(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAppchainConfigHashCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`setAppchainConfigHash(bytes32)`](setAppchainConfigHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAppchainConfigHashReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAppchainConfigHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAppchainConfigHashCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAppchainConfigHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAppchainConfigHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAppchainConfigHashReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAppchainConfigHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setAppchainConfigHashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setAppchainConfigHashReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setAppchainConfigHash(bytes32)";
            const SELECTOR: [u8; 4] = [242u8, 35u8, 5u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setChallengeWindowDuration(uint256)` and selector `0x1caf5d13`.
```solidity
function setChallengeWindowDuration(uint256 duration) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setChallengeWindowDurationCall {
        #[allow(missing_docs)]
        pub duration: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setChallengeWindowDuration(uint256)`](setChallengeWindowDurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setChallengeWindowDurationReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setChallengeWindowDurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setChallengeWindowDurationCall) -> Self {
                    (value.duration,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setChallengeWindowDurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { duration: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setChallengeWindowDurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setChallengeWindowDurationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setChallengeWindowDurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setChallengeWindowDurationCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setChallengeWindowDurationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setChallengeWindowDuration(uint256)";
            const SELECTOR: [u8; 4] = [28u8, 175u8, 93u8, 19u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.duration),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `submitAssertion((bytes32,(bytes32,bytes32)),bytes,address)` and selector `0x6070e78e`.
```solidity
function submitAssertion(AssertionPayload memory payload, bytes memory signature, address rewardAddr) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitAssertionCall {
        #[allow(missing_docs)]
        pub payload: <AssertionPayload as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub signature: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub rewardAddr: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`submitAssertion((bytes32,(bytes32,bytes32)),bytes,address)`](submitAssertionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitAssertionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                AssertionPayload,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <AssertionPayload as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitAssertionCall> for UnderlyingRustTuple<'_> {
                fn from(value: submitAssertionCall) -> Self {
                    (value.payload, value.signature, value.rewardAddr)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for submitAssertionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        payload: tuple.0,
                        signature: tuple.1,
                        rewardAddr: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitAssertionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: submitAssertionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for submitAssertionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for submitAssertionCall {
            type Parameters<'a> = (
                AssertionPayload,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = submitAssertionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "submitAssertion((bytes32,(bytes32,bytes32)),bytes,address)";
            const SELECTOR: [u8; 4] = [96u8, 112u8, 231u8, 142u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <AssertionPayload as alloy_sol_types::SolType>::tokenize(
                        &self.payload,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.signature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rewardAddr,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teeHackCount()` and selector `0x697b5e62`.
```solidity
function teeHackCount() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeHackCountCall {}
    ///Container type for the return parameters of the [`teeHackCount()`](teeHackCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeHackCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeHackCountCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeHackCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeHackCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeHackCountReturn> for UnderlyingRustTuple<'_> {
                fn from(value: teeHackCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeHackCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeHackCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeHackCountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teeHackCount()";
            const SELECTOR: [u8; 4] = [105u8, 123u8, 94u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teeKeys(uint256)` and selector `0x6ebed0f0`.
```solidity
function teeKeys(uint256) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeKeysCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`teeKeys(uint256)`](teeKeysCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeKeysReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeKeysCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeKeysCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeKeysCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeKeysReturn> for UnderlyingRustTuple<'_> {
                fn from(value: teeKeysReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeKeysReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeKeysCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeKeysReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teeKeys(uint256)";
            const SELECTOR: [u8; 4] = [110u8, 190u8, 208u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teeTrustedInput()` and selector `0x3ceaae7d`.
```solidity
function teeTrustedInput() external view returns (bytes32 appchainConfigHash, bytes32 setEndBlockHash, bytes32 l1EndBlockHash, bytes32 appchainStartBlockHash);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeTrustedInputCall {}
    ///Container type for the return parameters of the [`teeTrustedInput()`](teeTrustedInputCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeTrustedInputReturn {
        #[allow(missing_docs)]
        pub appchainConfigHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub setEndBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1EndBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub appchainStartBlockHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeTrustedInputCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeTrustedInputCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeTrustedInputCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeTrustedInputReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: teeTrustedInputReturn) -> Self {
                    (
                        value.appchainConfigHash,
                        value.setEndBlockHash,
                        value.l1EndBlockHash,
                        value.appchainStartBlockHash,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for teeTrustedInputReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        appchainConfigHash: tuple.0,
                        setEndBlockHash: tuple.1,
                        l1EndBlockHash: tuple.2,
                        appchainStartBlockHash: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeTrustedInputCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeTrustedInputReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teeTrustedInput()";
            const SELECTOR: [u8; 4] = [60u8, 234u8, 174u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`TeeModule`](self) function calls.
    pub enum TeeModuleCalls {
        #[allow(missing_docs)]
        addTeeKey(addTeeKeyCall),
        #[allow(missing_docs)]
        addTeeProgramHash(addTeeProgramHashCall),
        #[allow(missing_docs)]
        challengeWindowDuration(challengeWindowDurationCall),
        #[allow(missing_docs)]
        challengeWindowEnd(challengeWindowEndCall),
        #[allow(missing_docs)]
        closeChallengeWindow(closeChallengeWindowCall),
        #[allow(missing_docs)]
        isTeeKey(isTeeKeyCall),
        #[allow(missing_docs)]
        isTeeProgramHash(isTeeProgramHashCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        pendingAssertions(pendingAssertionsCall),
        #[allow(missing_docs)]
        poster(posterCall),
        #[allow(missing_docs)]
        removeTeeProgramHash(removeTeeProgramHashCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        resolveChallenge(resolveChallengeCall),
        #[allow(missing_docs)]
        revokeAllTeeKeys(revokeAllTeeKeysCall),
        #[allow(missing_docs)]
        setAppchainConfigHash(setAppchainConfigHashCall),
        #[allow(missing_docs)]
        setChallengeWindowDuration(setChallengeWindowDurationCall),
        #[allow(missing_docs)]
        submitAssertion(submitAssertionCall),
        #[allow(missing_docs)]
        teeHackCount(teeHackCountCall),
        #[allow(missing_docs)]
        teeKeys(teeKeysCall),
        #[allow(missing_docs)]
        teeTrustedInput(teeTrustedInputCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
    }
    #[automatically_derived]
    impl TeeModuleCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [10u8, 209u8, 149u8, 171u8],
            [11u8, 124u8, 2u8, 65u8],
            [28u8, 175u8, 93u8, 19u8],
            [60u8, 234u8, 174u8, 125u8],
            [67u8, 222u8, 95u8, 51u8],
            [71u8, 116u8, 38u8, 64u8],
            [75u8, 209u8, 103u8, 201u8],
            [93u8, 75u8, 237u8, 195u8],
            [96u8, 112u8, 231u8, 142u8],
            [105u8, 123u8, 94u8, 98u8],
            [108u8, 76u8, 32u8, 96u8],
            [110u8, 190u8, 208u8, 240u8],
            [110u8, 240u8, 18u8, 1u8],
            [113u8, 80u8, 24u8, 166u8],
            [128u8, 149u8, 151u8, 33u8],
            [141u8, 165u8, 203u8, 91u8],
            [163u8, 128u8, 239u8, 135u8],
            [165u8, 110u8, 198u8, 205u8],
            [238u8, 28u8, 40u8, 184u8],
            [242u8, 35u8, 5u8, 92u8],
            [242u8, 253u8, 227u8, 139u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for TeeModuleCalls {
        const NAME: &'static str = "TeeModuleCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 21usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::addTeeKey(_) => {
                    <addTeeKeyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addTeeProgramHash(_) => {
                    <addTeeProgramHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::challengeWindowDuration(_) => {
                    <challengeWindowDurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::challengeWindowEnd(_) => {
                    <challengeWindowEndCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::closeChallengeWindow(_) => {
                    <closeChallengeWindowCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isTeeKey(_) => <isTeeKeyCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isTeeProgramHash(_) => {
                    <isTeeProgramHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pendingAssertions(_) => {
                    <pendingAssertionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::poster(_) => <posterCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::removeTeeProgramHash(_) => {
                    <removeTeeProgramHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::resolveChallenge(_) => {
                    <resolveChallengeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeAllTeeKeys(_) => {
                    <revokeAllTeeKeysCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setAppchainConfigHash(_) => {
                    <setAppchainConfigHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setChallengeWindowDuration(_) => {
                    <setChallengeWindowDurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::submitAssertion(_) => {
                    <submitAssertionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::teeHackCount(_) => {
                    <teeHackCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::teeKeys(_) => <teeKeysCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::teeTrustedInput(_) => {
                    <teeTrustedInputCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<TeeModuleCalls>] = &[
                {
                    fn removeTeeProgramHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <removeTeeProgramHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::removeTeeProgramHash)
                    }
                    removeTeeProgramHash
                },
                {
                    fn resolveChallenge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <resolveChallengeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::resolveChallenge)
                    }
                    resolveChallenge
                },
                {
                    fn setChallengeWindowDuration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <setChallengeWindowDurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::setChallengeWindowDuration)
                    }
                    setChallengeWindowDuration
                },
                {
                    fn teeTrustedInput(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeTrustedInputCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teeTrustedInput)
                    }
                    teeTrustedInput
                },
                {
                    fn addTeeProgramHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <addTeeProgramHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::addTeeProgramHash)
                    }
                    addTeeProgramHash
                },
                {
                    fn isTeeKey(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <isTeeKeyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::isTeeKey)
                    }
                    isTeeKey
                },
                {
                    fn challengeWindowDuration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <challengeWindowDurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::challengeWindowDuration)
                    }
                    challengeWindowDuration
                },
                {
                    fn addTeeKey(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <addTeeKeyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::addTeeKey)
                    }
                    addTeeKey
                },
                {
                    fn submitAssertion(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <submitAssertionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::submitAssertion)
                    }
                    submitAssertion
                },
                {
                    fn teeHackCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeHackCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teeHackCount)
                    }
                    teeHackCount
                },
                {
                    fn closeChallengeWindow(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <closeChallengeWindowCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::closeChallengeWindow)
                    }
                    closeChallengeWindow
                },
                {
                    fn teeKeys(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeKeysCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teeKeys)
                    }
                    teeKeys
                },
                {
                    fn revokeAllTeeKeys(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <revokeAllTeeKeysCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::revokeAllTeeKeys)
                    }
                    revokeAllTeeKeys
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn poster(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <posterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::poster)
                    }
                    poster
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::owner)
                    }
                    owner
                },
                {
                    fn isTeeProgramHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <isTeeProgramHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::isTeeProgramHash)
                    }
                    isTeeProgramHash
                },
                {
                    fn pendingAssertions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <pendingAssertionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::pendingAssertions)
                    }
                    pendingAssertions
                },
                {
                    fn challengeWindowEnd(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <challengeWindowEndCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::challengeWindowEnd)
                    }
                    challengeWindowEnd
                },
                {
                    fn setAppchainConfigHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <setAppchainConfigHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::setAppchainConfigHash)
                    }
                    setAppchainConfigHash
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::transferOwnership)
                    }
                    transferOwnership
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::addTeeKey(inner) => {
                    <addTeeKeyCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::addTeeProgramHash(inner) => {
                    <addTeeProgramHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::challengeWindowDuration(inner) => {
                    <challengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::challengeWindowEnd(inner) => {
                    <challengeWindowEndCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::closeChallengeWindow(inner) => {
                    <closeChallengeWindowCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isTeeKey(inner) => {
                    <isTeeKeyCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isTeeProgramHash(inner) => {
                    <isTeeProgramHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pendingAssertions(inner) => {
                    <pendingAssertionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::poster(inner) => {
                    <posterCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::removeTeeProgramHash(inner) => {
                    <removeTeeProgramHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::resolveChallenge(inner) => {
                    <resolveChallengeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeAllTeeKeys(inner) => {
                    <revokeAllTeeKeysCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setAppchainConfigHash(inner) => {
                    <setAppchainConfigHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setChallengeWindowDuration(inner) => {
                    <setChallengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::submitAssertion(inner) => {
                    <submitAssertionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::teeHackCount(inner) => {
                    <teeHackCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::teeKeys(inner) => {
                    <teeKeysCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::teeTrustedInput(inner) => {
                    <teeTrustedInputCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::addTeeKey(inner) => {
                    <addTeeKeyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addTeeProgramHash(inner) => {
                    <addTeeProgramHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::challengeWindowDuration(inner) => {
                    <challengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::challengeWindowEnd(inner) => {
                    <challengeWindowEndCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::closeChallengeWindow(inner) => {
                    <closeChallengeWindowCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isTeeKey(inner) => {
                    <isTeeKeyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isTeeProgramHash(inner) => {
                    <isTeeProgramHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pendingAssertions(inner) => {
                    <pendingAssertionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::poster(inner) => {
                    <posterCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::removeTeeProgramHash(inner) => {
                    <removeTeeProgramHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::resolveChallenge(inner) => {
                    <resolveChallengeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeAllTeeKeys(inner) => {
                    <revokeAllTeeKeysCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setAppchainConfigHash(inner) => {
                    <setAppchainConfigHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setChallengeWindowDuration(inner) => {
                    <setChallengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::submitAssertion(inner) => {
                    <submitAssertionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::teeHackCount(inner) => {
                    <teeHackCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::teeKeys(inner) => {
                    <teeKeysCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::teeTrustedInput(inner) => {
                    <teeTrustedInputCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`TeeModule`](self) custom errors.
    pub enum TeeModuleErrors {
        #[allow(missing_docs)]
        ECDSAInvalidSignature(ECDSAInvalidSignature),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureLength(ECDSAInvalidSignatureLength),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureS(ECDSAInvalidSignatureS),
    }
    #[automatically_derived]
    impl TeeModuleErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [215u8, 139u8, 206u8, 12u8],
            [246u8, 69u8, 238u8, 223u8],
            [252u8, 230u8, 152u8, 247u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for TeeModuleErrors {
        const NAME: &'static str = "TeeModuleErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 3usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ECDSAInvalidSignature(_) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureLength(_) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureS(_) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<TeeModuleErrors>] = &[
                {
                    fn ECDSAInvalidSignatureS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::ECDSAInvalidSignatureS)
                    }
                    ECDSAInvalidSignatureS
                },
                {
                    fn ECDSAInvalidSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::ECDSAInvalidSignature)
                    }
                    ECDSAInvalidSignature
                },
                {
                    fn ECDSAInvalidSignatureLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::ECDSAInvalidSignatureLength)
                    }
                    ECDSAInvalidSignatureLength
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`TeeModule`](self) events.
    pub enum TeeModuleEvents {
        #[allow(missing_docs)]
        ChallengeResolved(ChallengeResolved),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
        #[allow(missing_docs)]
        TeeAppchainConfigHash(TeeAppchainConfigHash),
        #[allow(missing_docs)]
        TeeHacked(TeeHacked),
        #[allow(missing_docs)]
        TeeKeysRevoked(TeeKeysRevoked),
        #[allow(missing_docs)]
        TeeProgramHashAdded(TeeProgramHashAdded),
        #[allow(missing_docs)]
        TeeProgramHashRemoved(TeeProgramHashRemoved),
    }
    #[automatically_derived]
    impl TeeModuleEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                13u8,
                177u8,
                102u8,
                187u8,
                78u8,
                71u8,
                166u8,
                96u8,
                170u8,
                252u8,
                50u8,
                247u8,
                139u8,
                186u8,
                205u8,
                218u8,
                11u8,
                144u8,
                176u8,
                115u8,
                94u8,
                69u8,
                178u8,
                19u8,
                74u8,
                238u8,
                195u8,
                165u8,
                234u8,
                86u8,
                85u8,
                171u8,
            ],
            [
                17u8,
                78u8,
                156u8,
                121u8,
                142u8,
                60u8,
                109u8,
                21u8,
                139u8,
                93u8,
                29u8,
                215u8,
                17u8,
                206u8,
                30u8,
                34u8,
                120u8,
                95u8,
                61u8,
                148u8,
                137u8,
                141u8,
                219u8,
                28u8,
                231u8,
                249u8,
                188u8,
                117u8,
                23u8,
                49u8,
                117u8,
                211u8,
            ],
            [
                55u8,
                232u8,
                173u8,
                214u8,
                148u8,
                197u8,
                146u8,
                109u8,
                86u8,
                78u8,
                151u8,
                17u8,
                96u8,
                245u8,
                151u8,
                65u8,
                3u8,
                203u8,
                187u8,
                199u8,
                201u8,
                7u8,
                71u8,
                196u8,
                198u8,
                248u8,
                2u8,
                3u8,
                29u8,
                53u8,
                103u8,
                167u8,
            ],
            [
                67u8,
                136u8,
                80u8,
                38u8,
                197u8,
                158u8,
                203u8,
                184u8,
                36u8,
                209u8,
                2u8,
                120u8,
                95u8,
                238u8,
                95u8,
                149u8,
                147u8,
                230u8,
                149u8,
                187u8,
                154u8,
                132u8,
                144u8,
                134u8,
                77u8,
                152u8,
                48u8,
                149u8,
                37u8,
                36u8,
                229u8,
                213u8,
            ],
            [
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ],
            [
                183u8,
                161u8,
                128u8,
                34u8,
                132u8,
                151u8,
                237u8,
                149u8,
                198u8,
                137u8,
                111u8,
                193u8,
                176u8,
                129u8,
                160u8,
                22u8,
                153u8,
                145u8,
                22u8,
                249u8,
                138u8,
                185u8,
                91u8,
                82u8,
                18u8,
                54u8,
                89u8,
                239u8,
                234u8,
                37u8,
                151u8,
                100u8,
            ],
            [
                236u8,
                166u8,
                46u8,
                0u8,
                116u8,
                161u8,
                58u8,
                144u8,
                214u8,
                0u8,
                240u8,
                3u8,
                183u8,
                203u8,
                141u8,
                91u8,
                213u8,
                1u8,
                0u8,
                0u8,
                141u8,
                63u8,
                57u8,
                21u8,
                242u8,
                85u8,
                79u8,
                63u8,
                133u8,
                82u8,
                197u8,
                204u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for TeeModuleEvents {
        const NAME: &'static str = "TeeModuleEvents";
        const COUNT: usize = 7usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <ChallengeResolved as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ChallengeResolved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ChallengeResolved)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(
                    <TeeAppchainConfigHash as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <TeeAppchainConfigHash as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeAppchainConfigHash)
                }
                Some(<TeeHacked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TeeHacked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeHacked)
                }
                Some(<TeeKeysRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TeeKeysRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeKeysRevoked)
                }
                Some(
                    <TeeProgramHashAdded as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <TeeProgramHashAdded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeProgramHashAdded)
                }
                Some(
                    <TeeProgramHashRemoved as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <TeeProgramHashRemoved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeProgramHashRemoved)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for TeeModuleEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChallengeResolved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeAppchainConfigHash(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeHacked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeKeysRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeProgramHashAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeProgramHashRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChallengeResolved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeAppchainConfigHash(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeHacked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeKeysRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeProgramHashAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeProgramHashRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`TeeModule`](self) contract instance.

See the [wrapper's documentation](`TeeModuleInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> TeeModuleInstance<T, P, N> {
        TeeModuleInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        poster_: alloy::sol_types::private::Address,
        appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<TeeModuleInstance<T, P, N>>,
    > {
        TeeModuleInstance::<T, P, N>::deploy(provider, poster_, appchainConfigHash_)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        poster_: alloy::sol_types::private::Address,
        appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        TeeModuleInstance::<
            T,
            P,
            N,
        >::deploy_builder(provider, poster_, appchainConfigHash_)
    }
    /**A [`TeeModule`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`TeeModule`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct TeeModuleInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for TeeModuleInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("TeeModuleInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TeeModuleInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`TeeModule`](self) contract instance.

See the [wrapper's documentation](`TeeModuleInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            poster_: alloy::sol_types::private::Address,
            appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::Result<TeeModuleInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                poster_,
                appchainConfigHash_,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            poster_: alloy::sol_types::private::Address,
            appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            poster_,
                            appchainConfigHash_,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> TeeModuleInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> TeeModuleInstance<T, P, N> {
            TeeModuleInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TeeModuleInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`addTeeKey`] function.
        pub fn addTeeKey(
            &self,
            publicKey: alloy::sol_types::private::Address,
            zkProof: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, addTeeKeyCall, N> {
            self.call_builder(
                &addTeeKeyCall {
                    publicKey,
                    zkProof,
                },
            )
        }
        ///Creates a new call builder for the [`addTeeProgramHash`] function.
        pub fn addTeeProgramHash(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, addTeeProgramHashCall, N> {
            self.call_builder(&addTeeProgramHashCall { hash })
        }
        ///Creates a new call builder for the [`challengeWindowDuration`] function.
        pub fn challengeWindowDuration(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, challengeWindowDurationCall, N> {
            self.call_builder(&challengeWindowDurationCall {})
        }
        ///Creates a new call builder for the [`challengeWindowEnd`] function.
        pub fn challengeWindowEnd(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, challengeWindowEndCall, N> {
            self.call_builder(&challengeWindowEndCall {})
        }
        ///Creates a new call builder for the [`closeChallengeWindow`] function.
        pub fn closeChallengeWindow(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, closeChallengeWindowCall, N> {
            self.call_builder(&closeChallengeWindowCall {})
        }
        ///Creates a new call builder for the [`isTeeKey`] function.
        pub fn isTeeKey(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isTeeKeyCall, N> {
            self.call_builder(&isTeeKeyCall { _0 })
        }
        ///Creates a new call builder for the [`isTeeProgramHash`] function.
        pub fn isTeeProgramHash(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, isTeeProgramHashCall, N> {
            self.call_builder(&isTeeProgramHashCall { _0 })
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        ///Creates a new call builder for the [`pendingAssertions`] function.
        pub fn pendingAssertions(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, pendingAssertionsCall, N> {
            self.call_builder(&pendingAssertionsCall { _0 })
        }
        ///Creates a new call builder for the [`poster`] function.
        pub fn poster(&self) -> alloy_contract::SolCallBuilder<T, &P, posterCall, N> {
            self.call_builder(&posterCall {})
        }
        ///Creates a new call builder for the [`removeTeeProgramHash`] function.
        pub fn removeTeeProgramHash(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeTeeProgramHashCall, N> {
            self.call_builder(&removeTeeProgramHashCall { hash })
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall {})
        }
        ///Creates a new call builder for the [`resolveChallenge`] function.
        pub fn resolveChallenge(
            &self,
            assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, resolveChallengeCall, N> {
            self.call_builder(&resolveChallengeCall { assertion })
        }
        ///Creates a new call builder for the [`revokeAllTeeKeys`] function.
        pub fn revokeAllTeeKeys(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, revokeAllTeeKeysCall, N> {
            self.call_builder(&revokeAllTeeKeysCall {})
        }
        ///Creates a new call builder for the [`setAppchainConfigHash`] function.
        pub fn setAppchainConfigHash(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setAppchainConfigHashCall, N> {
            self.call_builder(&setAppchainConfigHashCall { hash })
        }
        ///Creates a new call builder for the [`setChallengeWindowDuration`] function.
        pub fn setChallengeWindowDuration(
            &self,
            duration: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setChallengeWindowDurationCall, N> {
            self.call_builder(
                &setChallengeWindowDurationCall {
                    duration,
                },
            )
        }
        ///Creates a new call builder for the [`submitAssertion`] function.
        pub fn submitAssertion(
            &self,
            payload: <AssertionPayload as alloy::sol_types::SolType>::RustType,
            signature: alloy::sol_types::private::Bytes,
            rewardAddr: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, submitAssertionCall, N> {
            self.call_builder(
                &submitAssertionCall {
                    payload,
                    signature,
                    rewardAddr,
                },
            )
        }
        ///Creates a new call builder for the [`teeHackCount`] function.
        pub fn teeHackCount(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeHackCountCall, N> {
            self.call_builder(&teeHackCountCall {})
        }
        ///Creates a new call builder for the [`teeKeys`] function.
        pub fn teeKeys(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeKeysCall, N> {
            self.call_builder(&teeKeysCall { _0 })
        }
        ///Creates a new call builder for the [`teeTrustedInput`] function.
        pub fn teeTrustedInput(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeTrustedInputCall, N> {
            self.call_builder(&teeTrustedInputCall {})
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TeeModuleInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`ChallengeResolved`] event.
        pub fn ChallengeResolved_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ChallengeResolved, N> {
            self.event_filter::<ChallengeResolved>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`TeeAppchainConfigHash`] event.
        pub fn TeeAppchainConfigHash_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeAppchainConfigHash, N> {
            self.event_filter::<TeeAppchainConfigHash>()
        }
        ///Creates a new event filter for the [`TeeHacked`] event.
        pub fn TeeHacked_filter(&self) -> alloy_contract::Event<T, &P, TeeHacked, N> {
            self.event_filter::<TeeHacked>()
        }
        ///Creates a new event filter for the [`TeeKeysRevoked`] event.
        pub fn TeeKeysRevoked_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeKeysRevoked, N> {
            self.event_filter::<TeeKeysRevoked>()
        }
        ///Creates a new event filter for the [`TeeProgramHashAdded`] event.
        pub fn TeeProgramHashAdded_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeProgramHashAdded, N> {
            self.event_filter::<TeeProgramHashAdded>()
        }
        ///Creates a new event filter for the [`TeeProgramHashRemoved`] event.
        pub fn TeeProgramHashRemoved_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeProgramHashRemoved, N> {
            self.event_filter::<TeeProgramHashRemoved>()
        }
    }
}
