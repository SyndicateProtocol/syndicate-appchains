/**

Generated by the following Solidity interface...
```solidity
interface TeeModule {
    struct PendingAssertion {
        bytes32 blockHash;
        bytes32 sendRoot;
        bytes32 seqBlockHash;
    }

    error ECDSAInvalidSignature();
    error ECDSAInvalidSignatureLength(uint256 length);
    error ECDSAInvalidSignatureS(bytes32 s);

    event ChallengeResolved(PendingAssertion);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event TeeAppchainConfigHash(bytes32 configHash, bytes32 blockHash);
    event TeeHacked(uint256);
    event TeeKeysRevoked();
    event TeeProgramAdded(bytes32 hash);
    event TeeProgramRemoved(bytes32 hash);
    event TeeSeqConfigHash(bytes32 configHash, bytes32 blockHash);

    constructor(address poster_, address bridge_, bytes32 appchainConfigHash_, bytes32 appchainStartBlockHash_, bytes32 seqConfigHash_, bytes32 seqStartBlockHash_, bytes32 l1StartBlockHash_, address l1block_, uint64 challengeWindowDuration_, bytes32 teeProgram);

    receive() external payable;

    function addTeeKey(address publicKey, bytes32 programHash, bytes memory zkProof) external;
    function addTeeProgram(bytes32 hash) external;
    function bridge() external view returns (address);
    function challengeWindowDuration() external view returns (uint64);
    function challengeWindowEnd() external view returns (uint64);
    function closeChallengeWindow() external;
    function isTeeKey(address) external view returns (bool);
    function l1block() external view returns (address);
    function owner() external view returns (address);
    function pendingAssertions(uint256) external view returns (bytes32 blockHash, bytes32 sendRoot, bytes32 seqBlockHash);
    function poster() external view returns (address);
    function removeTeeProgram(bytes32 hash) external;
    function renounceOwnership() external;
    function resolveChallenge(PendingAssertion memory assertion) external;
    function revokeAllTeeKeys() external;
    function setAppchainConfigHash(bytes32 hash) external;
    function setChallengeWindowDuration(uint64 duration) external;
    function setSeqConfigHash(bytes32 hash) external;
    function submitAssertion(PendingAssertion memory assertion, bytes memory signature, address rewardAddr) external;
    function teeHackCount() external view returns (uint256);
    function teeProgramKeys(bytes32, uint256) external view returns (address);
    function teePrograms(uint256) external view returns (bytes32);
    function teeTrustedInput() external view returns (bytes32 appchainConfigHash, bytes32 appchainStartBlockHash, bytes32 seqConfigHash, bytes32 seqStartBlockHash, bytes32 setDelayedMessageAcc, bytes32 l1StartBlockHash, bytes32 l1EndBlockHash);
    function transferOwnership(address newOwner) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "poster_",
        "type": "address",
        "internalType": "contract AssertionPoster"
      },
      {
        "name": "bridge_",
        "type": "address",
        "internalType": "contract IBridge"
      },
      {
        "name": "appchainConfigHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "appchainStartBlockHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "seqConfigHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "seqStartBlockHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "l1StartBlockHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "l1block_",
        "type": "address",
        "internalType": "contract IL1Block"
      },
      {
        "name": "challengeWindowDuration_",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "teeProgram",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "receive",
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "addTeeKey",
    "inputs": [
      {
        "name": "publicKey",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "programHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "zkProof",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addTeeProgram",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "bridge",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IBridge"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "challengeWindowDuration",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "challengeWindowEnd",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "closeChallengeWindow",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "isTeeKey",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "l1block",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IL1Block"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pendingAssertions",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "blockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "sendRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "seqBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "poster",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract AssertionPoster"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "removeTeeProgram",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "resolveChallenge",
    "inputs": [
      {
        "name": "assertion",
        "type": "tuple",
        "internalType": "struct PendingAssertion",
        "components": [
          {
            "name": "blockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "sendRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "seqBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeAllTeeKeys",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setAppchainConfigHash",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setChallengeWindowDuration",
    "inputs": [
      {
        "name": "duration",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setSeqConfigHash",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "submitAssertion",
    "inputs": [
      {
        "name": "assertion",
        "type": "tuple",
        "internalType": "struct PendingAssertion",
        "components": [
          {
            "name": "blockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "sendRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "seqBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      },
      {
        "name": "signature",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "rewardAddr",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "teeHackCount",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "teeProgramKeys",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "teePrograms",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "teeTrustedInput",
    "inputs": [],
    "outputs": [
      {
        "name": "appchainConfigHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "appchainStartBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "seqConfigHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "seqStartBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "setDelayedMessageAcc",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "l1StartBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "l1EndBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "ChallengeResolved",
    "inputs": [
      {
        "name": "",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct PendingAssertion",
        "components": [
          {
            "name": "blockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "sendRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "seqBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeAppchainConfigHash",
    "inputs": [
      {
        "name": "configHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "blockHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeHacked",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeKeysRevoked",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeProgramAdded",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeProgramRemoved",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeSeqConfigHash",
    "inputs": [
      {
        "name": "configHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "blockHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureLength",
    "inputs": [
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureS",
    "inputs": [
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod TeeModule {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60e060405234801561000f575f5ffd5b5060405161473838038061473883398181016040528101906100319190610b88565b61004d6100426104e060201b60201c565b6104e760201b60201c565b81600d60086101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055505f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16148061019e57505f8373ffffffffffffffffffffffffffffffffffffffff1663b80777ea6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156100f5573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906101199190610c61565b67ffffffffffffffff1611801561019d57505f5f1b8373ffffffffffffffffffffffffffffffffffffffff166309bd5a606040518163ffffffff1660e01b8152600401602060405180830381865afa158015610177573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061019b9190610c8c565b115b5b6101dd576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016101d490610d11565b60405180910390fd5b8273ffffffffffffffffffffffffffffffffffffffff1660c08173ffffffffffffffffffffffffffffffffffffffff16815250505f8a73ffffffffffffffffffffffffffffffffffffffff163b1161026a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161026190610d9f565b60405180910390fd5b8973ffffffffffffffffffffffffffffffffffffffff1660808173ffffffffffffffffffffffffffffffffffffffff16815250505f8973ffffffffffffffffffffffffffffffffffffffff1663eca067ad6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156102e8573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061030c9190610df0565b1161034c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161034390610e8b565b60405180910390fd5b8873ffffffffffffffffffffffffffffffffffffffff1660a08173ffffffffffffffffffffffffffffffffffffffff16815250508760015f01819055508660018001819055507fc985bccbd0c90e197f4a7373020a33ba6ff864d0399fd7d65c5c7c32ffb015ec88886040516103c3929190610eb8565b60405180910390a185600160020181905550846001600301819055507fb9eb20b32fac965884cb58326102257cae604504f0a36cd1008a32845ad5c29b8686604051610410929190610eb8565b60405180910390a1836001600501819055505f5f1b8103610466576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161045d90610f4f565b60405180910390fd5b600a81908060018154018082558091505060019003905f5260205f20015f90919091909150557f9a7a6469c25cf017890607695e4a149cc771f294fd871e2080d24cd109033ab6816040516104bb9190610f6d565b60405180910390a16104d16105a860201b60201c565b50505050505050505050611192565b5f33905090565b5f5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f5f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b600160088054905011156105f1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105e890610ff6565b60405180910390fd5b600d5f9054906101000a900467ffffffffffffffff1667ffffffffffffffff165f73ffffffffffffffffffffffffffffffffffffffff1660c05173ffffffffffffffffffffffffffffffffffffffff16146106ba5760c05173ffffffffffffffffffffffffffffffffffffffff1663b80777ea6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610691573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906106b59190610c61565b6106bc565b425b67ffffffffffffffff1611610706576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106fd90611084565b60405180910390fd5b5f600880549050111561082a5760085f81548110610727576107266110a2565b5b905f5260205f2090600302015f0154600180018190555060085f81548110610752576107516110a2565b5b905f5260205f2090600302016002015460016003018190555060016006015460016005018190555060805173ffffffffffffffffffffffffffffffffffffffff1663daeab41260085f815481106107ac576107ab6110a2565b5b905f5260205f2090600302015f015460085f815481106107cf576107ce6110a2565b5b905f5260205f209060030201600101546040518363ffffffff1660e01b81526004016107fc929190610eb8565b5f604051808303815f87803b158015610813575f5ffd5b505af1158015610825573d5f5f3e3d5ffd5b505050505b60a05173ffffffffffffffffffffffffffffffffffffffff1663d5719dc2600160a05173ffffffffffffffffffffffffffffffffffffffff1663eca067ad6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610895573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906108b99190610df0565b6108c391906110fc565b6040518263ffffffff1660e01b81526004016108df919061113e565b602060405180830381865afa1580156108fa573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061091e9190610c8c565b6001600401819055505f73ffffffffffffffffffffffffffffffffffffffff1660c05173ffffffffffffffffffffffffffffffffffffffff16146109d05760c05173ffffffffffffffffffffffffffffffffffffffff166309bd5a606040518163ffffffff1660e01b8152600401602060405180830381865afa1580156109a7573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906109cb9190610c8c565b6109df565b6001436109dd91906110fc565b405b600160060181905550600d60089054906101000a900467ffffffffffffffff1642610a0a9190611157565b600d5f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550565b5f5ffd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f610a6082610a37565b9050919050565b5f610a7182610a56565b9050919050565b610a8181610a67565b8114610a8b575f5ffd5b50565b5f81519050610a9c81610a78565b92915050565b5f610aac82610a56565b9050919050565b610abc81610aa2565b8114610ac6575f5ffd5b50565b5f81519050610ad781610ab3565b92915050565b5f819050919050565b610aef81610add565b8114610af9575f5ffd5b50565b5f81519050610b0a81610ae6565b92915050565b5f610b1a82610a56565b9050919050565b610b2a81610b10565b8114610b34575f5ffd5b50565b5f81519050610b4581610b21565b92915050565b5f67ffffffffffffffff82169050919050565b610b6781610b4b565b8114610b71575f5ffd5b50565b5f81519050610b8281610b5e565b92915050565b5f5f5f5f5f5f5f5f5f5f6101408b8d031215610ba757610ba6610a33565b5b5f610bb48d828e01610a8e565b9a50506020610bc58d828e01610ac9565b9950506040610bd68d828e01610afc565b9850506060610be78d828e01610afc565b9750506080610bf88d828e01610afc565b96505060a0610c098d828e01610afc565b95505060c0610c1a8d828e01610afc565b94505060e0610c2b8d828e01610b37565b935050610100610c3d8d828e01610b74565b925050610120610c4f8d828e01610afc565b9150509295989b9194979a5092959850565b5f60208284031215610c7657610c75610a33565b5b5f610c8384828501610b74565b91505092915050565b5f60208284031215610ca157610ca0610a33565b5b5f610cae84828501610afc565b91505092915050565b5f82825260208201905092915050565b7f6c3120636f6e747261637420696e76616c6964000000000000000000000000005f82015250565b5f610cfb601383610cb7565b9150610d0682610cc7565b602082019050919050565b5f6020820190508181035f830152610d2881610cef565b9050919050565b7f706f73746572206164647265737320646f6573206e6f74206861766520616e795f8201527f20636f6465000000000000000000000000000000000000000000000000000000602082015250565b5f610d89602583610cb7565b9150610d9482610d2f565b604082019050919050565b5f6020820190508181035f830152610db681610d7d565b9050919050565b5f819050919050565b610dcf81610dbd565b8114610dd9575f5ffd5b50565b5f81519050610dea81610dc6565b92915050565b5f60208284031215610e0557610e04610a33565b5b5f610e1284828501610ddc565b91505092915050565b7f696e73756666696369656e742064656c61796564206d6573736167657320696e5f8201527f2062726964676500000000000000000000000000000000000000000000000000602082015250565b5f610e75602783610cb7565b9150610e8082610e1b565b604082019050919050565b5f6020820190508181035f830152610ea281610e69565b9050919050565b610eb281610add565b82525050565b5f604082019050610ecb5f830185610ea9565b610ed86020830184610ea9565b9392505050565b7f7465652070726f6772616d2068617368206d757374206265206e6f6e2d7a65725f8201527f6f00000000000000000000000000000000000000000000000000000000000000602082015250565b5f610f39602183610cb7565b9150610f4482610edf565b604082019050919050565b5f6020820190508181035f830152610f6681610f2d565b9050919050565b5f602082019050610f805f830184610ea9565b92915050565b7f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201527f746f6f206d616e7920617373657274696f6e7300000000000000000000000000602082015250565b5f610fe0603383610cb7565b9150610feb82610f86565b604082019050919050565b5f6020820190508181035f83015261100d81610fd4565b9050919050565b7f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201527f696e73756666696369656e742074696d65206861732070617373656400000000602082015250565b5f61106e603c83610cb7565b915061107982611014565b604082019050919050565b5f6020820190508181035f83015261109b81611062565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f61110682610dbd565b915061111183610dbd565b9250828203905081811115611129576111286110cf565b5b92915050565b61113881610dbd565b82525050565b5f6020820190506111515f83018461112f565b92915050565b5f61116182610b4b565b915061116c83610b4b565b9250828201905067ffffffffffffffff81111561118c5761118b6110cf565b5b92915050565b60805160a05160c05161354b6111ed5f395f818161071e01528181610a0501528181610a4101528181610db10152610ded01525f8181610c6101528181610c9f01526119f201525f8181610b93015261128a015261354b5ff3fe60806040526004361061014e575f3560e01c8063715018a6116100b5578063e50c61561161006e578063e50c615614610457578063e78cea921461047f578063eb60553a146104a9578063ee1c28b8146104d1578063f223055c146104fb578063f2fde38b1461052357610155565b8063715018a61461035f57806380959721146103755780638da5cb5b1461039f5780638fed55a3146103c9578063a56ec6cd146103f1578063c3f2dbd31461042f57610155565b80634bd167c9116101075780634bd167c91461028f5780635f70c441146102b9578063697b5e62146102e15780636c4c20601461030b5780636ef012011461032157806370646ea21461033757610155565b80631c12427f1461015957806333339006146101815780633ceaae7d146101bd578063420caf3a146101ed57806347742640146102175780634afffcc91461025357610155565b3661015557005b5f5ffd5b348015610164575f5ffd5b5061017f600480360381019061017a9190612268565b61054b565b005b34801561018c575f5ffd5b506101a760048036038101906101a291906122c6565b6106a5565b6040516101b49190612343565b60405180910390f35b3480156101c8575f5ffd5b506101d16106ed565b6040516101e4979695949392919061236b565b60405180910390f35b3480156101f8575f5ffd5b5061020161071c565b60405161020e9190612433565b60405180910390f35b348015610222575f5ffd5b5061023d60048036038101906102389190612476565b610740565b60405161024a91906124bb565b60405180910390f35b34801561025e575f5ffd5b50610279600480360381019061027491906124d4565b61075d565b60405161028691906124ff565b60405180910390f35b34801561029a575f5ffd5b506102a361077d565b6040516102b0919061253a565b60405180910390f35b3480156102c4575f5ffd5b506102df60048036038101906102da9190612268565b610797565b005b3480156102ec575f5ffd5b506102f561097d565b6040516103029190612562565b60405180910390f35b348015610316575f5ffd5b5061031f610983565b005b34801561032c575f5ffd5b50610335610ee0565b005b348015610342575f5ffd5b5061035d600480360381019061035891906125dc565b610fdc565b005b34801561036a575f5ffd5b50610373611201565b005b348015610380575f5ffd5b50610389611288565b604051610396919061266d565b60405180910390f35b3480156103aa575f5ffd5b506103b36112ac565b6040516103c09190612343565b60405180910390f35b3480156103d4575f5ffd5b506103ef60048036038101906103ea91906126a8565b6112d3565b005b3480156103fc575f5ffd5b50610417600480360381019061041291906124d4565b6114d4565b604051610426939291906126d3565b60405180910390f35b34801561043a575f5ffd5b5061045560048036038101906104509190612268565b611509565b005b348015610462575f5ffd5b5061047d60048036038101906104789190612708565b611617565b005b34801561048a575f5ffd5b506104936119f0565b6040516104a09190612799565b60405180910390f35b3480156104b4575f5ffd5b506104cf60048036038101906104ca91906127dc565b611a14565b005b3480156104dc575f5ffd5b506104e5611b03565b6040516104f2919061253a565b60405180910390f35b348015610506575f5ffd5b50610521600480360381019061051c9190612268565b611b1c565b005b34801561052e575f5ffd5b5061054960048036038101906105449190612476565b611c28565b005b610553611d1e565b73ffffffffffffffffffffffffffffffffffffffff166105716112ac565b73ffffffffffffffffffffffffffffffffffffffff16146105c7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105be90612861565b60405180910390fd5b5f5f90505b600a805490508110156106445781600a82815481106105ee576105ed61287f565b5b905f5260205f20015403610637576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161062e906128f6565b60405180910390fd5b80806001019150506105cc565b50600a81908060018154018082558091505060019003905f5260205f20015f90919091909150557f9a7a6469c25cf017890607695e4a149cc771f294fd871e2080d24cd109033ab68160405161069a91906124ff565b60405180910390a150565b600b602052815f5260405f2081815481106106be575f80fd5b905f5260205f20015f915091509054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6001805f0154908060010154908060020154908060030154908060040154908060050154908060060154905087565b7f000000000000000000000000000000000000000000000000000000000000000081565b600c602052805f5260405f205f915054906101000a900460ff1681565b600a818154811061076c575f80fd5b905f5260205f20015f915090505481565b600d60089054906101000a900467ffffffffffffffff1681565b61079f611d1e565b73ffffffffffffffffffffffffffffffffffffffff166107bd6112ac565b73ffffffffffffffffffffffffffffffffffffffff1614610813576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161080a90612861565b60405180910390fd5b5f6008805490501461085a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161085190612984565b60405180910390fd5b5f5f90505b600b5f8381526020019081526020015f2080549050811015610926575f600c5f600b5f8681526020019081526020015f2084815481106108a2576108a161287f565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550808060010191505061085f565b50600b5f8281526020019081526020015f205f610943919061216f565b7f2621c61d3315f2a3d26b22d746ba21a96d249f51ada323f7226cce5fe5fc3d648160405161097291906124ff565b60405180910390a150565b60095481565b600160088054905011156109cc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109c390612a12565b60405180910390fd5b600d5f9054906101000a900467ffffffffffffffff1667ffffffffffffffff165f73ffffffffffffffffffffffffffffffffffffffff167f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1614610ad1577f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663b80777ea6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610aa8573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610acc9190612a44565b610ad3565b425b67ffffffffffffffff1611610b1d576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b1490612adf565b60405180910390fd5b5f6008805490501115610c5f5760085f81548110610b3e57610b3d61287f565b5b905f5260205f2090600302015f0154600180018190555060085f81548110610b6957610b6861287f565b5b905f5260205f209060030201600201546001600301819055506001600601546001600501819055507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663daeab41260085f81548110610be157610be061287f565b5b905f5260205f2090600302015f015460085f81548110610c0457610c0361287f565b5b905f5260205f209060030201600101546040518363ffffffff1660e01b8152600401610c31929190612afd565b5f604051808303815f87803b158015610c48575f5ffd5b505af1158015610c5a573d5f5f3e3d5ffd5b505050505b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663d5719dc260017f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663eca067ad6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610d06573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d2a9190612b38565b610d349190612b90565b6040518263ffffffff1660e01b8152600401610d509190612562565b602060405180830381865afa158015610d6b573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d8f9190612bd7565b6001600401819055505f73ffffffffffffffffffffffffffffffffffffffff167f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1614610e7d577f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166309bd5a606040518163ffffffff1660e01b8152600401602060405180830381865afa158015610e54573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610e789190612bd7565b610e8c565b600143610e8a9190612b90565b405b600160060181905550600d60089054906101000a900467ffffffffffffffff1642610eb79190612c02565b600d5f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550565b610ee8611d1e565b73ffffffffffffffffffffffffffffffffffffffff16610f066112ac565b73ffffffffffffffffffffffffffffffffffffffff1614610f5c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610f5390612861565b60405180910390fd5b5f5f90505b600a80549050811015610fa057610f93600a8281548110610f8557610f8461287f565b5b905f5260205f200154610797565b8080600101915050610f61565b50600a5f610fae919061218d565b7feca62e0074a13a90d600f003b7cb8d5bd50100008d3f3915f2554f3f8552c5cc60405160405180910390a1565b60018282905014611022576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161101990612c87565b60405180910390fd5b600c5f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff16156110ac576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016110a390612cef565b60405180910390fd5b5f600b5f8581526020019081526020015f208054905003611136575f5f90505f600a8054905090505b5f8111156111285784600a6001836110ed9190612b90565b815481106110fe576110fd61287f565b5b905f5260205f200154036111155760019150611128565b808061112090612d0d565b9150506110d5565b508061113457506111fb565b505b6001600c5f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550600b5f8481526020019081526020015f2084908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b50505050565b611209611d1e565b73ffffffffffffffffffffffffffffffffffffffff166112276112ac565b73ffffffffffffffffffffffffffffffffffffffff161461127d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161127490612861565b60405180910390fd5b6112865f611d25565b565b7f000000000000000000000000000000000000000000000000000000000000000081565b5f5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b6112db611d1e565b73ffffffffffffffffffffffffffffffffffffffff166112f96112ac565b73ffffffffffffffffffffffffffffffffffffffff161461134f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161134690612861565b60405180910390fd5b600160088054905011611397576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161138e90612d7e565b60405180910390fd5b5f5f90505b600880549050811015611495576113d282600883815481106113c1576113c061287f565b5b905f5260205f209060030201611de6565b156114885760085f6113e491906121ab565b600882908060018154018082558091505060019003905f5260205f2090600302015f9091909190915081816114199190612eb2565b50505f600d5f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff16021790555061144b610983565b7fe42eaf0737e2478a5f5aed3a0610ae7b09a27cbac9ad6a5cc4d68f78afd1425b8260405161147a9190612f3d565b60405180910390a1506114d1565b808060010191505061139c565b506040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016114c890612fa0565b60405180910390fd5b50565b600881815481106114e3575f80fd5b905f5260205f2090600302015f91509050805f0154908060010154908060020154905083565b611511611d1e565b73ffffffffffffffffffffffffffffffffffffffff1661152f6112ac565b73ffffffffffffffffffffffffffffffffffffffff1614611585576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161157c90612861565b60405180910390fd5b5f600880549050146115cc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016115c39061302e565b60405180910390fd5b806001600201819055507fb9eb20b32fac965884cb58326102257cae604504f0a36cd1008a32845ad5c29b8160016003015460405161160c929190612afd565b60405180910390a150565b6041838390501461165d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161165490613096565b60405180910390fd5b5f6116686001611e1e565b855f01358660200135604051602001611683939291906130d4565b604051602081830303815290604052805190602001209050600c5f6116fc86868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f81840152601f19601f820116905080830192505050505050506116ee85611e74565b611ea790919063ffffffff16565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff16611781576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016117789061315a565b60405180910390fd5b6001800154855f0135036117ca576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016117c1906131c2565b60405180910390fd5b5f5f90505b6008805490508110156118525761180586600883815481106117f4576117f361287f565b5b905f5260205f209060030201611de6565b15611845576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161183c9061322a565b60405180910390fd5b80806001019150506117cf565b505f600880549050036118a957600d60089054906101000a900467ffffffffffffffff16426118819190612c02565b600d5f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055505b600885908060018154018082558091505060019003905f5260205f2090600302015f9091909190915081816118de9190612eb2565b50506002600880549050036119e957600160095f8282546118ff9190613248565b925050819055507f37e8add694c5926d564e971160f5974103cbbbc7c90747c4c6f802031d3567a76009546040516119379190612562565b60405180910390a15f8273ffffffffffffffffffffffffffffffffffffffff1647604051611964906132a8565b5f6040518083038185875af1925050503d805f811461199e576040519150601f19603f3d011682016040523d82523d5f602084013e6119a3565b606091505b50509050806119e7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016119de90613306565b60405180910390fd5b505b5050505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b611a1c611d1e565b73ffffffffffffffffffffffffffffffffffffffff16611a3a6112ac565b73ffffffffffffffffffffffffffffffffffffffff1614611a90576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611a8790612861565b60405180910390fd5b5f60088054905014611ad7576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611ace90613394565b60405180910390fd5b80600d60086101000a81548167ffffffffffffffff021916908367ffffffffffffffff16021790555050565b600d5f9054906101000a900467ffffffffffffffff1681565b611b24611d1e565b73ffffffffffffffffffffffffffffffffffffffff16611b426112ac565b73ffffffffffffffffffffffffffffffffffffffff1614611b98576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611b8f90612861565b60405180910390fd5b5f60088054905014611bdf576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611bd69061302e565b60405180910390fd5b8060015f01819055507fc985bccbd0c90e197f4a7373020a33ba6ff864d0399fd7d65c5c7c32ffb015ec816001800154604051611c1d929190612afd565b60405180910390a150565b611c30611d1e565b73ffffffffffffffffffffffffffffffffffffffff16611c4e6112ac565b73ffffffffffffffffffffffffffffffffffffffff1614611ca4576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611c9b90612861565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603611d12576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611d0990613422565b60405180910390fd5b611d1b81611d25565b50565b5f33905090565b5f5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f5f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f815f0154835f0135148015611e03575081600101548360200135145b8015611e16575081600201548360400135145b905092915050565b5f815f0154826001015483600201548460030154856004015486600501548760060154604051602001611e579796959493929190613440565b604051602081830303815290604052805190602001209050919050565b5f7f19457468657265756d205369676e6564204d6573736167653a0a3332000000005f5281601c52603c5f209050919050565b5f5f5f5f611eb58686611ed1565b925092509250611ec58282611f26565b82935050505092915050565b5f5f5f6041845103611f11575f5f5f602087015192506040870151915060608701515f1a9050611f0388828585612088565b955095509550505050611f1f565b5f600285515f1b9250925092505b9250925092565b5f6003811115611f3957611f386134c0565b5b826003811115611f4c57611f4b6134c0565b5b03156120845760016003811115611f6657611f656134c0565b5b826003811115611f7957611f786134c0565b5b03611fb0576040517ff645eedf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60026003811115611fc457611fc36134c0565b5b826003811115611fd757611fd66134c0565b5b0361201b57805f1c6040517ffce698f70000000000000000000000000000000000000000000000000000000081526004016120129190612562565b60405180910390fd5b60038081111561202e5761202d6134c0565b5b826003811115612041576120406134c0565b5b0361208357806040517fd78bce0c00000000000000000000000000000000000000000000000000000000815260040161207a91906124ff565b60405180910390fd5b5b5050565b5f5f5f7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0845f1c11156120c4575f600385925092509250612165565b5f6001888888886040515f81526020016040526040516120e79493929190613508565b6020604051602081039080840390855afa158015612107573d5f5f3e3d5ffd5b5050506020604051035190505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603612158575f60015f5f1b93509350935050612165565b805f5f5f1b935093509350505b9450945094915050565b5080545f8255905f5260205f209081019061218a91906121cc565b50565b5080545f8255905f5260205f20908101906121a891906121e7565b50565b5080545f8255600302905f5260205f20908101906121c99190612202565b50565b5b808211156121e3575f815f9055506001016121cd565b5090565b5b808211156121fe575f815f9055506001016121e8565b5090565b5b80821115612229575f5f82015f9055600182015f9055600282015f905550600301612203565b5090565b5f5ffd5b5f5ffd5b5f819050919050565b61224781612235565b8114612251575f5ffd5b50565b5f813590506122628161223e565b92915050565b5f6020828403121561227d5761227c61222d565b5b5f61228a84828501612254565b91505092915050565b5f819050919050565b6122a581612293565b81146122af575f5ffd5b50565b5f813590506122c08161229c565b92915050565b5f5f604083850312156122dc576122db61222d565b5b5f6122e985828601612254565b92505060206122fa858286016122b2565b9150509250929050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f61232d82612304565b9050919050565b61233d81612323565b82525050565b5f6020820190506123565f830184612334565b92915050565b61236581612235565b82525050565b5f60e08201905061237e5f83018a61235c565b61238b602083018961235c565b612398604083018861235c565b6123a5606083018761235c565b6123b2608083018661235c565b6123bf60a083018561235c565b6123cc60c083018461235c565b98975050505050505050565b5f819050919050565b5f6123fb6123f66123f184612304565b6123d8565b612304565b9050919050565b5f61240c826123e1565b9050919050565b5f61241d82612402565b9050919050565b61242d81612413565b82525050565b5f6020820190506124465f830184612424565b92915050565b61245581612323565b811461245f575f5ffd5b50565b5f813590506124708161244c565b92915050565b5f6020828403121561248b5761248a61222d565b5b5f61249884828501612462565b91505092915050565b5f8115159050919050565b6124b5816124a1565b82525050565b5f6020820190506124ce5f8301846124ac565b92915050565b5f602082840312156124e9576124e861222d565b5b5f6124f6848285016122b2565b91505092915050565b5f6020820190506125125f83018461235c565b92915050565b5f67ffffffffffffffff82169050919050565b61253481612518565b82525050565b5f60208201905061254d5f83018461252b565b92915050565b61255c81612293565b82525050565b5f6020820190506125755f830184612553565b92915050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83601f84011261259c5761259b61257b565b5b8235905067ffffffffffffffff8111156125b9576125b861257f565b5b6020830191508360018202830111156125d5576125d4612583565b5b9250929050565b5f5f5f5f606085870312156125f4576125f361222d565b5b5f61260187828801612462565b945050602061261287828801612254565b935050604085013567ffffffffffffffff81111561263357612632612231565b5b61263f87828801612587565b925092505092959194509250565b5f61265782612402565b9050919050565b6126678161264d565b82525050565b5f6020820190506126805f83018461265e565b92915050565b5f5ffd5b5f6060828403121561269f5761269e612686565b5b81905092915050565b5f606082840312156126bd576126bc61222d565b5b5f6126ca8482850161268a565b91505092915050565b5f6060820190506126e65f83018661235c565b6126f3602083018561235c565b612700604083018461235c565b949350505050565b5f5f5f5f60a085870312156127205761271f61222d565b5b5f61272d8782880161268a565b945050606085013567ffffffffffffffff81111561274e5761274d612231565b5b61275a87828801612587565b9350935050608061276d87828801612462565b91505092959194509250565b5f61278382612402565b9050919050565b61279381612779565b82525050565b5f6020820190506127ac5f83018461278a565b92915050565b6127bb81612518565b81146127c5575f5ffd5b50565b5f813590506127d6816127b2565b92915050565b5f602082840312156127f1576127f061222d565b5b5f6127fe848285016127c8565b91505092915050565b5f82825260208201905092915050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65725f82015250565b5f61284b602083612807565b915061285682612817565b602082019050919050565b5f6020820190508181035f8301526128788161283f565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f7465652070726f6772616d20616c7265616479206578697374730000000000005f82015250565b5f6128e0601a83612807565b91506128eb826128ac565b602082019050919050565b5f6020820190508181035f83015261290d816128d4565b9050919050565b7f63616e6e6f742072656d6f7665207465652070726f6772616d207768696c65205f8201527f617373657274696f6e2069732070656e64696e67000000000000000000000000602082015250565b5f61296e603483612807565b915061297982612914565b604082019050919050565b5f6020820190508181035f83015261299b81612962565b9050919050565b7f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201527f746f6f206d616e7920617373657274696f6e7300000000000000000000000000602082015250565b5f6129fc603383612807565b9150612a07826129a2565b604082019050919050565b5f6020820190508181035f830152612a29816129f0565b9050919050565b5f81519050612a3e816127b2565b92915050565b5f60208284031215612a5957612a5861222d565b5b5f612a6684828501612a30565b91505092915050565b7f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201527f696e73756666696369656e742074696d65206861732070617373656400000000602082015250565b5f612ac9603c83612807565b9150612ad482612a6f565b604082019050919050565b5f6020820190508181035f830152612af681612abd565b9050919050565b5f604082019050612b105f83018561235c565b612b1d602083018461235c565b9392505050565b5f81519050612b328161229c565b92915050565b5f60208284031215612b4d57612b4c61222d565b5b5f612b5a84828501612b24565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f612b9a82612293565b9150612ba583612293565b9250828203905081811115612bbd57612bbc612b63565b5b92915050565b5f81519050612bd18161223e565b92915050565b5f60208284031215612bec57612beb61222d565b5b5f612bf984828501612bc3565b91505092915050565b5f612c0c82612518565b9150612c1783612518565b9250828201905067ffffffffffffffff811115612c3757612c36612b63565b5b92915050565b7f746f646f3a2076616c6964617465207a6b207a6b50726f6f66000000000000005f82015250565b5f612c71601983612807565b9150612c7c82612c3d565b602082019050919050565b5f6020820190508181035f830152612c9e81612c65565b9050919050565b7f6b657920616c72656164792061646465640000000000000000000000000000005f82015250565b5f612cd9601183612807565b9150612ce482612ca5565b602082019050919050565b5f6020820190508181035f830152612d0681612ccd565b9050919050565b5f612d1782612293565b91505f8203612d2957612d28612b63565b5b600182039050919050565b7f6368616c6c656e676520646f6573206e6f7420657869737400000000000000005f82015250565b5f612d68601883612807565b9150612d7382612d34565b602082019050919050565b5f6020820190508181035f830152612d9581612d5c565b9050919050565b5f8135612da88161223e565b80915050919050565b5f815f1b9050919050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff612de784612db1565b9350801983169250808416831791505092915050565b5f612e0782612235565b9050919050565b5f815f1c9050919050565b5f612e2382612e0e565b9050919050565b612e3382612dfd565b612e46612e3f82612e19565b8354612dbc565b8255505050565b5f81015f830180612e5d81612d9c565b9050612e698184612e2a565b505050600181016020830180612e7e81612d9c565b9050612e8a8184612e2a565b505050600281016040830180612e9f81612d9c565b9050612eab8184612e2a565b5050505050565b612ebc8282612e4d565b5050565b5f612ece6020840184612254565b905092915050565b612edf81612235565b82525050565b60608201612ef55f830183612ec0565b612f015f850182612ed6565b50612f0f6020830183612ec0565b612f1c6020850182612ed6565b50612f2a6040830183612ec0565b612f376040850182612ed6565b50505050565b5f606082019050612f505f830184612ee5565b92915050565b7f617373657274696f6e206e6f7420666f756e64000000000000000000000000005f82015250565b5f612f8a601383612807565b9150612f9582612f56565b602082019050919050565b5f6020820190508181035f830152612fb781612f7e565b9050919050565b7f63616e6e6f742075706461746520636f6e6669672068617368207768696c65205f8201527f617373657274696f6e73206172652070656e64696e6700000000000000000000602082015250565b5f613018603683612807565b915061302382612fbe565b604082019050919050565b5f6020820190508181035f8301526130458161300c565b9050919050565b7f696e76616c6964207369676e6174757265206c656e67746800000000000000005f82015250565b5f613080601883612807565b915061308b8261304c565b602082019050919050565b5f6020820190508181035f8301526130ad81613074565b9050919050565b5f819050919050565b6130ce6130c982612235565b6130b4565b82525050565b5f6130df82866130bd565b6020820191506130ef82856130bd565b6020820191506130ff82846130bd565b602082019150819050949350505050565b7f696e76616c696420746565207369676e617475726500000000000000000000005f82015250565b5f613144601583612807565b915061314f82613110565b602082019050919050565b5f6020820190508181035f83015261317181613138565b9050919050565b7f617070636861696e20626c6f636b206861736820756e6368616e6765640000005f82015250565b5f6131ac601d83612807565b91506131b782613178565b602082019050919050565b5f6020820190508181035f8301526131d9816131a0565b9050919050565b7f617373657274696f6e20616c72656164792065786973747300000000000000005f82015250565b5f613214601883612807565b915061321f826131e0565b602082019050919050565b5f6020820190508181035f83015261324181613208565b9050919050565b5f61325282612293565b915061325d83612293565b925082820190508082111561327557613274612b63565b5b92915050565b5f81905092915050565b50565b5f6132935f8361327b565b915061329e82613285565b5f82019050919050565b5f6132b282613288565b9150819050919050565b7f7061796d656e74206661696c65640000000000000000000000000000000000005f82015250565b5f6132f0600e83612807565b91506132fb826132bc565b602082019050919050565b5f6020820190508181035f83015261331d816132e4565b9050919050565b7f63616e6e6f7420757064617465206368616c6c656e67652077696e646f7720775f8201527f68696c6520617373657274696f6e2069732070656e64696e6700000000000000602082015250565b5f61337e603983612807565b915061338982613324565b604082019050919050565b5f6020820190508181035f8301526133ab81613372565b9050919050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f20615f8201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b5f61340c602683612807565b9150613417826133b2565b604082019050919050565b5f6020820190508181035f83015261343981613400565b9050919050565b5f61344b828a6130bd565b60208201915061345b82896130bd565b60208201915061346b82886130bd565b60208201915061347b82876130bd565b60208201915061348b82866130bd565b60208201915061349b82856130bd565b6020820191506134ab82846130bd565b60208201915081905098975050505050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b5f60ff82169050919050565b613502816134ed565b82525050565b5f60808201905061351b5f83018761235c565b61352860208301866134f9565b613535604083018561235c565b613542606083018461235c565b9594505050505056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xE0`@R4\x80\x15a\0\x0FW__\xFD[P`@QaG88\x03\x80aG8\x839\x81\x81\x01`@R\x81\x01\x90a\x001\x91\x90a\x0B\x88V[a\0Ma\0Ba\x04\xE0` \x1B` \x1CV[a\x04\xE7` \x1B` \x1CV[\x81`\r`\x08a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80a\x01\x9EWP_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xB8\x07w\xEA`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\0\xF5W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x01\x19\x91\x90a\x0CaV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11\x80\x15a\x01\x9DWP__\x1B\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\t\xBDZ``@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x01wW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x01\x9B\x91\x90a\x0C\x8CV[\x11[[a\x01\xDDW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x01\xD4\x90a\r\x11V[`@Q\x80\x91\x03\x90\xFD[\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\xC0\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP_\x8As\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x11a\x02jW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x02a\x90a\r\x9FV[`@Q\x80\x91\x03\x90\xFD[\x89s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x80\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP_\x89s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xEC\xA0g\xAD`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x02\xE8W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x03\x0C\x91\x90a\r\xF0V[\x11a\x03LW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x03C\x90a\x0E\x8BV[`@Q\x80\x91\x03\x90\xFD[\x88s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\xA0\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP\x87`\x01_\x01\x81\x90UP\x86`\x01\x80\x01\x81\x90UP\x7F\xC9\x85\xBC\xCB\xD0\xC9\x0E\x19\x7FJss\x02\n3\xBAo\xF8d\xD09\x9F\xD7\xD6\\\\|2\xFF\xB0\x15\xEC\x88\x88`@Qa\x03\xC3\x92\x91\x90a\x0E\xB8V[`@Q\x80\x91\x03\x90\xA1\x85`\x01`\x02\x01\x81\x90UP\x84`\x01`\x03\x01\x81\x90UP\x7F\xB9\xEB \xB3/\xAC\x96X\x84\xCBX2a\x02%|\xAE`E\x04\xF0\xA3l\xD1\0\x8A2\x84Z\xD5\xC2\x9B\x86\x86`@Qa\x04\x10\x92\x91\x90a\x0E\xB8V[`@Q\x80\x91\x03\x90\xA1\x83`\x01`\x05\x01\x81\x90UP__\x1B\x81\x03a\x04fW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x04]\x90a\x0FOV[`@Q\x80\x91\x03\x90\xFD[`\n\x81\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91PU\x7F\x9Azdi\xC2\\\xF0\x17\x89\x06\x07i^J\x14\x9C\xC7q\xF2\x94\xFD\x87\x1E \x80\xD2L\xD1\t\x03:\xB6\x81`@Qa\x04\xBB\x91\x90a\x0FmV[`@Q\x80\x91\x03\x90\xA1a\x04\xD1a\x05\xA8` \x1B` \x1CV[PPPPPPPPPPa\x11\x92V[_3\x90P\x90V[___\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81__a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPV[`\x01`\x08\x80T\x90P\x11\x15a\x05\xF1W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05\xE8\x90a\x0F\xF6V[`@Q\x80\x91\x03\x90\xFD[`\r_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\xC0Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x06\xBAW`\xC0Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xB8\x07w\xEA`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x06\x91W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06\xB5\x91\x90a\x0CaV[a\x06\xBCV[B[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11a\x07\x06W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xFD\x90a\x10\x84V[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x11\x15a\x08*W`\x08_\x81T\x81\x10a\x07'Wa\x07&a\x10\xA2V[[\x90_R` _ \x90`\x03\x02\x01_\x01T`\x01\x80\x01\x81\x90UP`\x08_\x81T\x81\x10a\x07RWa\x07Qa\x10\xA2V[[\x90_R` _ \x90`\x03\x02\x01`\x02\x01T`\x01`\x03\x01\x81\x90UP`\x01`\x06\x01T`\x01`\x05\x01\x81\x90UP`\x80Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xDA\xEA\xB4\x12`\x08_\x81T\x81\x10a\x07\xACWa\x07\xABa\x10\xA2V[[\x90_R` _ \x90`\x03\x02\x01_\x01T`\x08_\x81T\x81\x10a\x07\xCFWa\x07\xCEa\x10\xA2V[[\x90_R` _ \x90`\x03\x02\x01`\x01\x01T`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x07\xFC\x92\x91\x90a\x0E\xB8V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x08\x13W__\xFD[PZ\xF1\x15\x80\x15a\x08%W=__>=_\xFD[PPPP[`\xA0Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD5q\x9D\xC2`\x01`\xA0Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xEC\xA0g\xAD`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x08\x95W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08\xB9\x91\x90a\r\xF0V[a\x08\xC3\x91\x90a\x10\xFCV[`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x08\xDF\x91\x90a\x11>V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x08\xFAW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\t\x1E\x91\x90a\x0C\x8CV[`\x01`\x04\x01\x81\x90UP_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\xC0Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\t\xD0W`\xC0Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\t\xBDZ``@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\t\xA7W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\t\xCB\x91\x90a\x0C\x8CV[a\t\xDFV[`\x01Ca\t\xDD\x91\x90a\x10\xFCV[@[`\x01`\x06\x01\x81\x90UP`\r`\x08\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16Ba\n\n\x91\x90a\x11WV[`\r_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPV[__\xFD[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a\n`\x82a\n7V[\x90P\x91\x90PV[_a\nq\x82a\nVV[\x90P\x91\x90PV[a\n\x81\x81a\ngV[\x81\x14a\n\x8BW__\xFD[PV[_\x81Q\x90Pa\n\x9C\x81a\nxV[\x92\x91PPV[_a\n\xAC\x82a\nVV[\x90P\x91\x90PV[a\n\xBC\x81a\n\xA2V[\x81\x14a\n\xC6W__\xFD[PV[_\x81Q\x90Pa\n\xD7\x81a\n\xB3V[\x92\x91PPV[_\x81\x90P\x91\x90PV[a\n\xEF\x81a\n\xDDV[\x81\x14a\n\xF9W__\xFD[PV[_\x81Q\x90Pa\x0B\n\x81a\n\xE6V[\x92\x91PPV[_a\x0B\x1A\x82a\nVV[\x90P\x91\x90PV[a\x0B*\x81a\x0B\x10V[\x81\x14a\x0B4W__\xFD[PV[_\x81Q\x90Pa\x0BE\x81a\x0B!V[\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a\x0Bg\x81a\x0BKV[\x81\x14a\x0BqW__\xFD[PV[_\x81Q\x90Pa\x0B\x82\x81a\x0B^V[\x92\x91PPV[__________a\x01@\x8B\x8D\x03\x12\x15a\x0B\xA7Wa\x0B\xA6a\n3V[[_a\x0B\xB4\x8D\x82\x8E\x01a\n\x8EV[\x9APP` a\x0B\xC5\x8D\x82\x8E\x01a\n\xC9V[\x99PP`@a\x0B\xD6\x8D\x82\x8E\x01a\n\xFCV[\x98PP``a\x0B\xE7\x8D\x82\x8E\x01a\n\xFCV[\x97PP`\x80a\x0B\xF8\x8D\x82\x8E\x01a\n\xFCV[\x96PP`\xA0a\x0C\t\x8D\x82\x8E\x01a\n\xFCV[\x95PP`\xC0a\x0C\x1A\x8D\x82\x8E\x01a\n\xFCV[\x94PP`\xE0a\x0C+\x8D\x82\x8E\x01a\x0B7V[\x93PPa\x01\0a\x0C=\x8D\x82\x8E\x01a\x0BtV[\x92PPa\x01 a\x0CO\x8D\x82\x8E\x01a\n\xFCV[\x91PP\x92\x95\x98\x9B\x91\x94\x97\x9AP\x92\x95\x98PV[_` \x82\x84\x03\x12\x15a\x0CvWa\x0Cua\n3V[[_a\x0C\x83\x84\x82\x85\x01a\x0BtV[\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x0C\xA1Wa\x0C\xA0a\n3V[[_a\x0C\xAE\x84\x82\x85\x01a\n\xFCV[\x91PP\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7Fl1 contract invalid\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a\x0C\xFB`\x13\x83a\x0C\xB7V[\x91Pa\r\x06\x82a\x0C\xC7V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\r(\x81a\x0C\xEFV[\x90P\x91\x90PV[\x7Fposter address does not have any_\x82\x01R\x7F code\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\r\x89`%\x83a\x0C\xB7V[\x91Pa\r\x94\x82a\r/V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\r\xB6\x81a\r}V[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a\r\xCF\x81a\r\xBDV[\x81\x14a\r\xD9W__\xFD[PV[_\x81Q\x90Pa\r\xEA\x81a\r\xC6V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x0E\x05Wa\x0E\x04a\n3V[[_a\x0E\x12\x84\x82\x85\x01a\r\xDCV[\x91PP\x92\x91PPV[\x7Finsufficient delayed messages in_\x82\x01R\x7F bridge\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\x0Eu`'\x83a\x0C\xB7V[\x91Pa\x0E\x80\x82a\x0E\x1BV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x0E\xA2\x81a\x0EiV[\x90P\x91\x90PV[a\x0E\xB2\x81a\n\xDDV[\x82RPPV[_`@\x82\x01\x90Pa\x0E\xCB_\x83\x01\x85a\x0E\xA9V[a\x0E\xD8` \x83\x01\x84a\x0E\xA9V[\x93\x92PPPV[\x7Ftee program hash must be non-zer_\x82\x01R\x7Fo\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\x0F9`!\x83a\x0C\xB7V[\x91Pa\x0FD\x82a\x0E\xDFV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x0Ff\x81a\x0F-V[\x90P\x91\x90PV[_` \x82\x01\x90Pa\x0F\x80_\x83\x01\x84a\x0E\xA9V[\x92\x91PPV[\x7Fcannot close challenge window - _\x82\x01R\x7Ftoo many assertions\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a\x0F\xE0`3\x83a\x0C\xB7V[\x91Pa\x0F\xEB\x82a\x0F\x86V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x10\r\x81a\x0F\xD4V[\x90P\x91\x90PV[\x7Fcannot close challenge window - _\x82\x01R\x7Finsufficient time has passed\0\0\0\0` \x82\x01RPV[_a\x10n`<\x83a\x0C\xB7V[\x91Pa\x10y\x82a\x10\x14V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\x10\x9B\x81a\x10bV[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a\x11\x06\x82a\r\xBDV[\x91Pa\x11\x11\x83a\r\xBDV[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15a\x11)Wa\x11(a\x10\xCFV[[\x92\x91PPV[a\x118\x81a\r\xBDV[\x82RPPV[_` \x82\x01\x90Pa\x11Q_\x83\x01\x84a\x11/V[\x92\x91PPV[_a\x11a\x82a\x0BKV[\x91Pa\x11l\x83a\x0BKV[\x92P\x82\x82\x01\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x11\x8CWa\x11\x8Ba\x10\xCFV[[\x92\x91PPV[`\x80Q`\xA0Q`\xC0Qa5Ka\x11\xED_9_\x81\x81a\x07\x1E\x01R\x81\x81a\n\x05\x01R\x81\x81a\nA\x01R\x81\x81a\r\xB1\x01Ra\r\xED\x01R_\x81\x81a\x0Ca\x01R\x81\x81a\x0C\x9F\x01Ra\x19\xF2\x01R_\x81\x81a\x0B\x93\x01Ra\x12\x8A\x01Ra5K_\xF3\xFE`\x80`@R`\x046\x10a\x01NW_5`\xE0\x1C\x80cqP\x18\xA6\x11a\0\xB5W\x80c\xE5\x0CaV\x11a\0nW\x80c\xE5\x0CaV\x14a\x04WW\x80c\xE7\x8C\xEA\x92\x14a\x04\x7FW\x80c\xEB`U:\x14a\x04\xA9W\x80c\xEE\x1C(\xB8\x14a\x04\xD1W\x80c\xF2#\x05\\\x14a\x04\xFBW\x80c\xF2\xFD\xE3\x8B\x14a\x05#Wa\x01UV[\x80cqP\x18\xA6\x14a\x03_W\x80c\x80\x95\x97!\x14a\x03uW\x80c\x8D\xA5\xCB[\x14a\x03\x9FW\x80c\x8F\xEDU\xA3\x14a\x03\xC9W\x80c\xA5n\xC6\xCD\x14a\x03\xF1W\x80c\xC3\xF2\xDB\xD3\x14a\x04/Wa\x01UV[\x80cK\xD1g\xC9\x11a\x01\x07W\x80cK\xD1g\xC9\x14a\x02\x8FW\x80c_p\xC4A\x14a\x02\xB9W\x80ci{^b\x14a\x02\xE1W\x80clL `\x14a\x03\x0BW\x80cn\xF0\x12\x01\x14a\x03!W\x80cpdn\xA2\x14a\x037Wa\x01UV[\x80c\x1C\x12B\x7F\x14a\x01YW\x80c33\x90\x06\x14a\x01\x81W\x80c<\xEA\xAE}\x14a\x01\xBDW\x80cB\x0C\xAF:\x14a\x01\xEDW\x80cGt&@\x14a\x02\x17W\x80cJ\xFF\xFC\xC9\x14a\x02SWa\x01UV[6a\x01UW\0[__\xFD[4\x80\x15a\x01dW__\xFD[Pa\x01\x7F`\x04\x806\x03\x81\x01\x90a\x01z\x91\x90a\"hV[a\x05KV[\0[4\x80\x15a\x01\x8CW__\xFD[Pa\x01\xA7`\x04\x806\x03\x81\x01\x90a\x01\xA2\x91\x90a\"\xC6V[a\x06\xA5V[`@Qa\x01\xB4\x91\x90a#CV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x01\xC8W__\xFD[Pa\x01\xD1a\x06\xEDV[`@Qa\x01\xE4\x97\x96\x95\x94\x93\x92\x91\x90a#kV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x01\xF8W__\xFD[Pa\x02\x01a\x07\x1CV[`@Qa\x02\x0E\x91\x90a$3V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\"W__\xFD[Pa\x02=`\x04\x806\x03\x81\x01\x90a\x028\x91\x90a$vV[a\x07@V[`@Qa\x02J\x91\x90a$\xBBV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02^W__\xFD[Pa\x02y`\x04\x806\x03\x81\x01\x90a\x02t\x91\x90a$\xD4V[a\x07]V[`@Qa\x02\x86\x91\x90a$\xFFV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\x9AW__\xFD[Pa\x02\xA3a\x07}V[`@Qa\x02\xB0\x91\x90a%:V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xC4W__\xFD[Pa\x02\xDF`\x04\x806\x03\x81\x01\x90a\x02\xDA\x91\x90a\"hV[a\x07\x97V[\0[4\x80\x15a\x02\xECW__\xFD[Pa\x02\xF5a\t}V[`@Qa\x03\x02\x91\x90a%bV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x16W__\xFD[Pa\x03\x1Fa\t\x83V[\0[4\x80\x15a\x03,W__\xFD[Pa\x035a\x0E\xE0V[\0[4\x80\x15a\x03BW__\xFD[Pa\x03]`\x04\x806\x03\x81\x01\x90a\x03X\x91\x90a%\xDCV[a\x0F\xDCV[\0[4\x80\x15a\x03jW__\xFD[Pa\x03sa\x12\x01V[\0[4\x80\x15a\x03\x80W__\xFD[Pa\x03\x89a\x12\x88V[`@Qa\x03\x96\x91\x90a&mV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xAAW__\xFD[Pa\x03\xB3a\x12\xACV[`@Qa\x03\xC0\x91\x90a#CV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xD4W__\xFD[Pa\x03\xEF`\x04\x806\x03\x81\x01\x90a\x03\xEA\x91\x90a&\xA8V[a\x12\xD3V[\0[4\x80\x15a\x03\xFCW__\xFD[Pa\x04\x17`\x04\x806\x03\x81\x01\x90a\x04\x12\x91\x90a$\xD4V[a\x14\xD4V[`@Qa\x04&\x93\x92\x91\x90a&\xD3V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04:W__\xFD[Pa\x04U`\x04\x806\x03\x81\x01\x90a\x04P\x91\x90a\"hV[a\x15\tV[\0[4\x80\x15a\x04bW__\xFD[Pa\x04}`\x04\x806\x03\x81\x01\x90a\x04x\x91\x90a'\x08V[a\x16\x17V[\0[4\x80\x15a\x04\x8AW__\xFD[Pa\x04\x93a\x19\xF0V[`@Qa\x04\xA0\x91\x90a'\x99V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xB4W__\xFD[Pa\x04\xCF`\x04\x806\x03\x81\x01\x90a\x04\xCA\x91\x90a'\xDCV[a\x1A\x14V[\0[4\x80\x15a\x04\xDCW__\xFD[Pa\x04\xE5a\x1B\x03V[`@Qa\x04\xF2\x91\x90a%:V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\x06W__\xFD[Pa\x05!`\x04\x806\x03\x81\x01\x90a\x05\x1C\x91\x90a\"hV[a\x1B\x1CV[\0[4\x80\x15a\x05.W__\xFD[Pa\x05I`\x04\x806\x03\x81\x01\x90a\x05D\x91\x90a$vV[a\x1C(V[\0[a\x05Sa\x1D\x1EV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x05qa\x12\xACV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x05\xC7W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05\xBE\x90a(aV[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\n\x80T\x90P\x81\x10\x15a\x06DW\x81`\n\x82\x81T\x81\x10a\x05\xEEWa\x05\xEDa(\x7FV[[\x90_R` _ \x01T\x03a\x067W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06.\x90a(\xF6V[`@Q\x80\x91\x03\x90\xFD[\x80\x80`\x01\x01\x91PPa\x05\xCCV[P`\n\x81\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91PU\x7F\x9Azdi\xC2\\\xF0\x17\x89\x06\x07i^J\x14\x9C\xC7q\xF2\x94\xFD\x87\x1E \x80\xD2L\xD1\t\x03:\xB6\x81`@Qa\x06\x9A\x91\x90a$\xFFV[`@Q\x80\x91\x03\x90\xA1PV[`\x0B` R\x81_R`@_ \x81\x81T\x81\x10a\x06\xBEW_\x80\xFD[\x90_R` _ \x01_\x91P\x91P\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[`\x01\x80_\x01T\x90\x80`\x01\x01T\x90\x80`\x02\x01T\x90\x80`\x03\x01T\x90\x80`\x04\x01T\x90\x80`\x05\x01T\x90\x80`\x06\x01T\x90P\x87V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`\x0C` R\x80_R`@_ _\x91PT\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[`\n\x81\x81T\x81\x10a\x07lW_\x80\xFD[\x90_R` _ \x01_\x91P\x90PT\x81V[`\r`\x08\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[a\x07\x9Fa\x1D\x1EV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x07\xBDa\x12\xACV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x08\x13W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08\n\x90a(aV[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x14a\x08ZW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08Q\x90a)\x84V[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x0B_\x83\x81R` \x01\x90\x81R` \x01_ \x80T\x90P\x81\x10\x15a\t&W_`\x0C_`\x0B_\x86\x81R` \x01\x90\x81R` \x01_ \x84\x81T\x81\x10a\x08\xA2Wa\x08\xA1a(\x7FV[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa\x08_V[P`\x0B_\x82\x81R` \x01\x90\x81R` \x01_ _a\tC\x91\x90a!oV[\x7F&!\xC6\x1D3\x15\xF2\xA3\xD2k\"\xD7F\xBA!\xA9m$\x9FQ\xAD\xA3#\xF7\"l\xCE_\xE5\xFC=d\x81`@Qa\tr\x91\x90a$\xFFV[`@Q\x80\x91\x03\x90\xA1PV[`\tT\x81V[`\x01`\x08\x80T\x90P\x11\x15a\t\xCCW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\t\xC3\x90a*\x12V[`@Q\x80\x91\x03\x90\xFD[`\r_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\n\xD1W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xB8\x07w\xEA`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n\xA8W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\xCC\x91\x90a*DV[a\n\xD3V[B[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11a\x0B\x1DW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0B\x14\x90a*\xDFV[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x11\x15a\x0C_W`\x08_\x81T\x81\x10a\x0B>Wa\x0B=a(\x7FV[[\x90_R` _ \x90`\x03\x02\x01_\x01T`\x01\x80\x01\x81\x90UP`\x08_\x81T\x81\x10a\x0BiWa\x0Bha(\x7FV[[\x90_R` _ \x90`\x03\x02\x01`\x02\x01T`\x01`\x03\x01\x81\x90UP`\x01`\x06\x01T`\x01`\x05\x01\x81\x90UP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xDA\xEA\xB4\x12`\x08_\x81T\x81\x10a\x0B\xE1Wa\x0B\xE0a(\x7FV[[\x90_R` _ \x90`\x03\x02\x01_\x01T`\x08_\x81T\x81\x10a\x0C\x04Wa\x0C\x03a(\x7FV[[\x90_R` _ \x90`\x03\x02\x01`\x01\x01T`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0C1\x92\x91\x90a*\xFDV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0CHW__\xFD[PZ\xF1\x15\x80\x15a\x0CZW=__>=_\xFD[PPPP[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD5q\x9D\xC2`\x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xEC\xA0g\xAD`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\r\x06W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r*\x91\x90a+8V[a\r4\x91\x90a+\x90V[`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\rP\x91\x90a%bV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\rkW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r\x8F\x91\x90a+\xD7V[`\x01`\x04\x01\x81\x90UP_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x0E}W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\t\xBDZ``@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0ETW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0Ex\x91\x90a+\xD7V[a\x0E\x8CV[`\x01Ca\x0E\x8A\x91\x90a+\x90V[@[`\x01`\x06\x01\x81\x90UP`\r`\x08\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16Ba\x0E\xB7\x91\x90a,\x02V[`\r_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPV[a\x0E\xE8a\x1D\x1EV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x0F\x06a\x12\xACV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x0F\\W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0FS\x90a(aV[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\n\x80T\x90P\x81\x10\x15a\x0F\xA0Wa\x0F\x93`\n\x82\x81T\x81\x10a\x0F\x85Wa\x0F\x84a(\x7FV[[\x90_R` _ \x01Ta\x07\x97V[\x80\x80`\x01\x01\x91PPa\x0FaV[P`\n_a\x0F\xAE\x91\x90a!\x8DV[\x7F\xEC\xA6.\0t\xA1:\x90\xD6\0\xF0\x03\xB7\xCB\x8D[\xD5\x01\0\0\x8D?9\x15\xF2UO?\x85R\xC5\xCC`@Q`@Q\x80\x91\x03\x90\xA1V[`\x01\x82\x82\x90P\x14a\x10\"W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x10\x19\x90a,\x87V[`@Q\x80\x91\x03\x90\xFD[`\x0C_\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a\x10\xACW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x10\xA3\x90a,\xEFV[`@Q\x80\x91\x03\x90\xFD[_`\x0B_\x85\x81R` \x01\x90\x81R` \x01_ \x80T\x90P\x03a\x116W__\x90P_`\n\x80T\x90P\x90P[_\x81\x11\x15a\x11(W\x84`\n`\x01\x83a\x10\xED\x91\x90a+\x90V[\x81T\x81\x10a\x10\xFEWa\x10\xFDa(\x7FV[[\x90_R` _ \x01T\x03a\x11\x15W`\x01\x91Pa\x11(V[\x80\x80a\x11 \x90a-\rV[\x91PPa\x10\xD5V[P\x80a\x114WPa\x11\xFBV[P[`\x01`\x0C_\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP`\x0B_\x84\x81R` \x01\x90\x81R` \x01_ \x84\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP[PPPPV[a\x12\ta\x1D\x1EV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x12'a\x12\xACV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x12}W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x12t\x90a(aV[`@Q\x80\x91\x03\x90\xFD[a\x12\x86_a\x1D%V[V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[___\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[a\x12\xDBa\x1D\x1EV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x12\xF9a\x12\xACV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x13OW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13F\x90a(aV[`@Q\x80\x91\x03\x90\xFD[`\x01`\x08\x80T\x90P\x11a\x13\x97W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\x8E\x90a-~V[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x08\x80T\x90P\x81\x10\x15a\x14\x95Wa\x13\xD2\x82`\x08\x83\x81T\x81\x10a\x13\xC1Wa\x13\xC0a(\x7FV[[\x90_R` _ \x90`\x03\x02\x01a\x1D\xE6V[\x15a\x14\x88W`\x08_a\x13\xE4\x91\x90a!\xABV[`\x08\x82\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x03\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a\x14\x19\x91\x90a.\xB2V[PP_`\r_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPa\x14Ka\t\x83V[\x7F\xE4.\xAF\x077\xE2G\x8A_Z\xED:\x06\x10\xAE{\t\xA2|\xBA\xC9\xADj\\\xC4\xD6\x8Fx\xAF\xD1B[\x82`@Qa\x14z\x91\x90a/=V[`@Q\x80\x91\x03\x90\xA1Pa\x14\xD1V[\x80\x80`\x01\x01\x91PPa\x13\x9CV[P`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14\xC8\x90a/\xA0V[`@Q\x80\x91\x03\x90\xFD[PV[`\x08\x81\x81T\x81\x10a\x14\xE3W_\x80\xFD[\x90_R` _ \x90`\x03\x02\x01_\x91P\x90P\x80_\x01T\x90\x80`\x01\x01T\x90\x80`\x02\x01T\x90P\x83V[a\x15\x11a\x1D\x1EV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x15/a\x12\xACV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x15\x85W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x15|\x90a(aV[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x14a\x15\xCCW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x15\xC3\x90a0.V[`@Q\x80\x91\x03\x90\xFD[\x80`\x01`\x02\x01\x81\x90UP\x7F\xB9\xEB \xB3/\xAC\x96X\x84\xCBX2a\x02%|\xAE`E\x04\xF0\xA3l\xD1\0\x8A2\x84Z\xD5\xC2\x9B\x81`\x01`\x03\x01T`@Qa\x16\x0C\x92\x91\x90a*\xFDV[`@Q\x80\x91\x03\x90\xA1PV[`A\x83\x83\x90P\x14a\x16]W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x16T\x90a0\x96V[`@Q\x80\x91\x03\x90\xFD[_a\x16h`\x01a\x1E\x1EV[\x85_\x015\x86` \x015`@Q` \x01a\x16\x83\x93\x92\x91\x90a0\xD4V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P`\x0C_a\x16\xFC\x86\x86\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x81\x84\x01R`\x1F\x19`\x1F\x82\x01\x16\x90P\x80\x83\x01\x92PPPPPPPa\x16\xEE\x85a\x1EtV[a\x1E\xA7\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x17\x81W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x17x\x90a1ZV[`@Q\x80\x91\x03\x90\xFD[`\x01\x80\x01T\x85_\x015\x03a\x17\xCAW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x17\xC1\x90a1\xC2V[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x08\x80T\x90P\x81\x10\x15a\x18RWa\x18\x05\x86`\x08\x83\x81T\x81\x10a\x17\xF4Wa\x17\xF3a(\x7FV[[\x90_R` _ \x90`\x03\x02\x01a\x1D\xE6V[\x15a\x18EW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x18<\x90a2*V[`@Q\x80\x91\x03\x90\xFD[\x80\x80`\x01\x01\x91PPa\x17\xCFV[P_`\x08\x80T\x90P\x03a\x18\xA9W`\r`\x08\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16Ba\x18\x81\x91\x90a,\x02V[`\r_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP[`\x08\x85\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x03\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a\x18\xDE\x91\x90a.\xB2V[PP`\x02`\x08\x80T\x90P\x03a\x19\xE9W`\x01`\t_\x82\x82Ta\x18\xFF\x91\x90a2HV[\x92PP\x81\x90UP\x7F7\xE8\xAD\xD6\x94\xC5\x92mVN\x97\x11`\xF5\x97A\x03\xCB\xBB\xC7\xC9\x07G\xC4\xC6\xF8\x02\x03\x1D5g\xA7`\tT`@Qa\x197\x91\x90a%bV[`@Q\x80\x91\x03\x90\xA1_\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16G`@Qa\x19d\x90a2\xA8V[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a\x19\x9EW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x19\xA3V[``\x91P[PP\x90P\x80a\x19\xE7W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x19\xDE\x90a3\x06V[`@Q\x80\x91\x03\x90\xFD[P[PPPPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x1A\x1Ca\x1D\x1EV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1A:a\x12\xACV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1A\x90W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1A\x87\x90a(aV[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x14a\x1A\xD7W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1A\xCE\x90a3\x94V[`@Q\x80\x91\x03\x90\xFD[\x80`\r`\x08a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[`\r_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[a\x1B$a\x1D\x1EV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1BBa\x12\xACV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1B\x98W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1B\x8F\x90a(aV[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x14a\x1B\xDFW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1B\xD6\x90a0.V[`@Q\x80\x91\x03\x90\xFD[\x80`\x01_\x01\x81\x90UP\x7F\xC9\x85\xBC\xCB\xD0\xC9\x0E\x19\x7FJss\x02\n3\xBAo\xF8d\xD09\x9F\xD7\xD6\\\\|2\xFF\xB0\x15\xEC\x81`\x01\x80\x01T`@Qa\x1C\x1D\x92\x91\x90a*\xFDV[`@Q\x80\x91\x03\x90\xA1PV[a\x1C0a\x1D\x1EV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1CNa\x12\xACV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1C\xA4W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1C\x9B\x90a(aV[`@Q\x80\x91\x03\x90\xFD[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x1D\x12W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1D\t\x90a4\"V[`@Q\x80\x91\x03\x90\xFD[a\x1D\x1B\x81a\x1D%V[PV[_3\x90P\x90V[___\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81__a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPV[_\x81_\x01T\x83_\x015\x14\x80\x15a\x1E\x03WP\x81`\x01\x01T\x83` \x015\x14[\x80\x15a\x1E\x16WP\x81`\x02\x01T\x83`@\x015\x14[\x90P\x92\x91PPV[_\x81_\x01T\x82`\x01\x01T\x83`\x02\x01T\x84`\x03\x01T\x85`\x04\x01T\x86`\x05\x01T\x87`\x06\x01T`@Q` \x01a\x1EW\x97\x96\x95\x94\x93\x92\x91\x90a4@V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x91\x90PV[_\x7F\x19Ethereum Signed Message:\n32\0\0\0\0_R\x81`\x1CR`<_ \x90P\x91\x90PV[____a\x1E\xB5\x86\x86a\x1E\xD1V[\x92P\x92P\x92Pa\x1E\xC5\x82\x82a\x1F&V[\x82\x93PPPP\x92\x91PPV[___`A\x84Q\x03a\x1F\x11W___` \x87\x01Q\x92P`@\x87\x01Q\x91P``\x87\x01Q_\x1A\x90Pa\x1F\x03\x88\x82\x85\x85a \x88V[\x95P\x95P\x95PPPPa\x1F\x1FV[_`\x02\x85Q_\x1B\x92P\x92P\x92P[\x92P\x92P\x92V[_`\x03\x81\x11\x15a\x1F9Wa\x1F8a4\xC0V[[\x82`\x03\x81\x11\x15a\x1FLWa\x1FKa4\xC0V[[\x03\x15a \x84W`\x01`\x03\x81\x11\x15a\x1FfWa\x1Fea4\xC0V[[\x82`\x03\x81\x11\x15a\x1FyWa\x1Fxa4\xC0V[[\x03a\x1F\xB0W`@Q\x7F\xF6E\xEE\xDF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`\x03\x81\x11\x15a\x1F\xC4Wa\x1F\xC3a4\xC0V[[\x82`\x03\x81\x11\x15a\x1F\xD7Wa\x1F\xD6a4\xC0V[[\x03a \x1BW\x80_\x1C`@Q\x7F\xFC\xE6\x98\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a \x12\x91\x90a%bV[`@Q\x80\x91\x03\x90\xFD[`\x03\x80\x81\x11\x15a .Wa -a4\xC0V[[\x82`\x03\x81\x11\x15a AWa @a4\xC0V[[\x03a \x83W\x80`@Q\x7F\xD7\x8B\xCE\x0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a z\x91\x90a$\xFFV[`@Q\x80\x91\x03\x90\xFD[[PPV[___\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0\x84_\x1C\x11\x15a \xC4W_`\x03\x85\x92P\x92P\x92Pa!eV[_`\x01\x88\x88\x88\x88`@Q_\x81R` \x01`@R`@Qa \xE7\x94\x93\x92\x91\x90a5\x08V[` `@Q` \x81\x03\x90\x80\x84\x03\x90\x85Z\xFA\x15\x80\x15a!\x07W=__>=_\xFD[PPP` `@Q\x03Q\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a!XW_`\x01__\x1B\x93P\x93P\x93PPa!eV[\x80___\x1B\x93P\x93P\x93PP[\x94P\x94P\x94\x91PPV[P\x80T_\x82U\x90_R` _ \x90\x81\x01\x90a!\x8A\x91\x90a!\xCCV[PV[P\x80T_\x82U\x90_R` _ \x90\x81\x01\x90a!\xA8\x91\x90a!\xE7V[PV[P\x80T_\x82U`\x03\x02\x90_R` _ \x90\x81\x01\x90a!\xC9\x91\x90a\"\x02V[PV[[\x80\x82\x11\x15a!\xE3W_\x81_\x90UP`\x01\x01a!\xCDV[P\x90V[[\x80\x82\x11\x15a!\xFEW_\x81_\x90UP`\x01\x01a!\xE8V[P\x90V[[\x80\x82\x11\x15a\")W__\x82\x01_\x90U`\x01\x82\x01_\x90U`\x02\x82\x01_\x90UP`\x03\x01a\"\x03V[P\x90V[__\xFD[__\xFD[_\x81\x90P\x91\x90PV[a\"G\x81a\"5V[\x81\x14a\"QW__\xFD[PV[_\x815\x90Pa\"b\x81a\">V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\"}Wa\"|a\"-V[[_a\"\x8A\x84\x82\x85\x01a\"TV[\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[a\"\xA5\x81a\"\x93V[\x81\x14a\"\xAFW__\xFD[PV[_\x815\x90Pa\"\xC0\x81a\"\x9CV[\x92\x91PPV[__`@\x83\x85\x03\x12\x15a\"\xDCWa\"\xDBa\"-V[[_a\"\xE9\x85\x82\x86\x01a\"TV[\x92PP` a\"\xFA\x85\x82\x86\x01a\"\xB2V[\x91PP\x92P\x92\x90PV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a#-\x82a#\x04V[\x90P\x91\x90PV[a#=\x81a##V[\x82RPPV[_` \x82\x01\x90Pa#V_\x83\x01\x84a#4V[\x92\x91PPV[a#e\x81a\"5V[\x82RPPV[_`\xE0\x82\x01\x90Pa#~_\x83\x01\x8Aa#\\V[a#\x8B` \x83\x01\x89a#\\V[a#\x98`@\x83\x01\x88a#\\V[a#\xA5``\x83\x01\x87a#\\V[a#\xB2`\x80\x83\x01\x86a#\\V[a#\xBF`\xA0\x83\x01\x85a#\\V[a#\xCC`\xC0\x83\x01\x84a#\\V[\x98\x97PPPPPPPPV[_\x81\x90P\x91\x90PV[_a#\xFBa#\xF6a#\xF1\x84a#\x04V[a#\xD8V[a#\x04V[\x90P\x91\x90PV[_a$\x0C\x82a#\xE1V[\x90P\x91\x90PV[_a$\x1D\x82a$\x02V[\x90P\x91\x90PV[a$-\x81a$\x13V[\x82RPPV[_` \x82\x01\x90Pa$F_\x83\x01\x84a$$V[\x92\x91PPV[a$U\x81a##V[\x81\x14a$_W__\xFD[PV[_\x815\x90Pa$p\x81a$LV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a$\x8BWa$\x8Aa\"-V[[_a$\x98\x84\x82\x85\x01a$bV[\x91PP\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[a$\xB5\x81a$\xA1V[\x82RPPV[_` \x82\x01\x90Pa$\xCE_\x83\x01\x84a$\xACV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a$\xE9Wa$\xE8a\"-V[[_a$\xF6\x84\x82\x85\x01a\"\xB2V[\x91PP\x92\x91PPV[_` \x82\x01\x90Pa%\x12_\x83\x01\x84a#\\V[\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a%4\x81a%\x18V[\x82RPPV[_` \x82\x01\x90Pa%M_\x83\x01\x84a%+V[\x92\x91PPV[a%\\\x81a\"\x93V[\x82RPPV[_` \x82\x01\x90Pa%u_\x83\x01\x84a%SV[\x92\x91PPV[__\xFD[__\xFD[__\xFD[__\x83`\x1F\x84\x01\x12a%\x9CWa%\x9Ba%{V[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a%\xB9Wa%\xB8a%\x7FV[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15a%\xD5Wa%\xD4a%\x83V[[\x92P\x92\x90PV[____``\x85\x87\x03\x12\x15a%\xF4Wa%\xF3a\"-V[[_a&\x01\x87\x82\x88\x01a$bV[\x94PP` a&\x12\x87\x82\x88\x01a\"TV[\x93PP`@\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a&3Wa&2a\"1V[[a&?\x87\x82\x88\x01a%\x87V[\x92P\x92PP\x92\x95\x91\x94P\x92PV[_a&W\x82a$\x02V[\x90P\x91\x90PV[a&g\x81a&MV[\x82RPPV[_` \x82\x01\x90Pa&\x80_\x83\x01\x84a&^V[\x92\x91PPV[__\xFD[_``\x82\x84\x03\x12\x15a&\x9FWa&\x9Ea&\x86V[[\x81\x90P\x92\x91PPV[_``\x82\x84\x03\x12\x15a&\xBDWa&\xBCa\"-V[[_a&\xCA\x84\x82\x85\x01a&\x8AV[\x91PP\x92\x91PPV[_``\x82\x01\x90Pa&\xE6_\x83\x01\x86a#\\V[a&\xF3` \x83\x01\x85a#\\V[a'\0`@\x83\x01\x84a#\\V[\x94\x93PPPPV[____`\xA0\x85\x87\x03\x12\x15a' Wa'\x1Fa\"-V[[_a'-\x87\x82\x88\x01a&\x8AV[\x94PP``\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a'NWa'Ma\"1V[[a'Z\x87\x82\x88\x01a%\x87V[\x93P\x93PP`\x80a'm\x87\x82\x88\x01a$bV[\x91PP\x92\x95\x91\x94P\x92PV[_a'\x83\x82a$\x02V[\x90P\x91\x90PV[a'\x93\x81a'yV[\x82RPPV[_` \x82\x01\x90Pa'\xAC_\x83\x01\x84a'\x8AV[\x92\x91PPV[a'\xBB\x81a%\x18V[\x81\x14a'\xC5W__\xFD[PV[_\x815\x90Pa'\xD6\x81a'\xB2V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a'\xF1Wa'\xF0a\"-V[[_a'\xFE\x84\x82\x85\x01a'\xC8V[\x91PP\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7FOwnable: caller is not the owner_\x82\x01RPV[_a(K` \x83a(\x07V[\x91Pa(V\x82a(\x17V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra(x\x81a(?V[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x7Ftee program already exists\0\0\0\0\0\0_\x82\x01RPV[_a(\xE0`\x1A\x83a(\x07V[\x91Pa(\xEB\x82a(\xACV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra)\r\x81a(\xD4V[\x90P\x91\x90PV[\x7Fcannot remove tee program while _\x82\x01R\x7Fassertion is pending\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a)n`4\x83a(\x07V[\x91Pa)y\x82a)\x14V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra)\x9B\x81a)bV[\x90P\x91\x90PV[\x7Fcannot close challenge window - _\x82\x01R\x7Ftoo many assertions\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a)\xFC`3\x83a(\x07V[\x91Pa*\x07\x82a)\xA2V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra*)\x81a)\xF0V[\x90P\x91\x90PV[_\x81Q\x90Pa*>\x81a'\xB2V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a*YWa*Xa\"-V[[_a*f\x84\x82\x85\x01a*0V[\x91PP\x92\x91PPV[\x7Fcannot close challenge window - _\x82\x01R\x7Finsufficient time has passed\0\0\0\0` \x82\x01RPV[_a*\xC9`<\x83a(\x07V[\x91Pa*\xD4\x82a*oV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra*\xF6\x81a*\xBDV[\x90P\x91\x90PV[_`@\x82\x01\x90Pa+\x10_\x83\x01\x85a#\\V[a+\x1D` \x83\x01\x84a#\\V[\x93\x92PPPV[_\x81Q\x90Pa+2\x81a\"\x9CV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a+MWa+La\"-V[[_a+Z\x84\x82\x85\x01a+$V[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a+\x9A\x82a\"\x93V[\x91Pa+\xA5\x83a\"\x93V[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15a+\xBDWa+\xBCa+cV[[\x92\x91PPV[_\x81Q\x90Pa+\xD1\x81a\">V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a+\xECWa+\xEBa\"-V[[_a+\xF9\x84\x82\x85\x01a+\xC3V[\x91PP\x92\x91PPV[_a,\x0C\x82a%\x18V[\x91Pa,\x17\x83a%\x18V[\x92P\x82\x82\x01\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a,7Wa,6a+cV[[\x92\x91PPV[\x7Ftodo: validate zk zkProof\0\0\0\0\0\0\0_\x82\x01RPV[_a,q`\x19\x83a(\x07V[\x91Pa,|\x82a,=V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra,\x9E\x81a,eV[\x90P\x91\x90PV[\x7Fkey already added\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a,\xD9`\x11\x83a(\x07V[\x91Pa,\xE4\x82a,\xA5V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra-\x06\x81a,\xCDV[\x90P\x91\x90PV[_a-\x17\x82a\"\x93V[\x91P_\x82\x03a-)Wa-(a+cV[[`\x01\x82\x03\x90P\x91\x90PV[\x7Fchallenge does not exist\0\0\0\0\0\0\0\0_\x82\x01RPV[_a-h`\x18\x83a(\x07V[\x91Pa-s\x82a-4V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra-\x95\x81a-\\V[\x90P\x91\x90PV[_\x815a-\xA8\x81a\">V[\x80\x91PP\x91\x90PV[_\x81_\x1B\x90P\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa-\xE7\x84a-\xB1V[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_a.\x07\x82a\"5V[\x90P\x91\x90PV[_\x81_\x1C\x90P\x91\x90PV[_a.#\x82a.\x0EV[\x90P\x91\x90PV[a.3\x82a-\xFDV[a.Fa.?\x82a.\x19V[\x83Ta-\xBCV[\x82UPPPV[_\x81\x01_\x83\x01\x80a.]\x81a-\x9CV[\x90Pa.i\x81\x84a.*V[PPP`\x01\x81\x01` \x83\x01\x80a.~\x81a-\x9CV[\x90Pa.\x8A\x81\x84a.*V[PPP`\x02\x81\x01`@\x83\x01\x80a.\x9F\x81a-\x9CV[\x90Pa.\xAB\x81\x84a.*V[PPPPPV[a.\xBC\x82\x82a.MV[PPV[_a.\xCE` \x84\x01\x84a\"TV[\x90P\x92\x91PPV[a.\xDF\x81a\"5V[\x82RPPV[``\x82\x01a.\xF5_\x83\x01\x83a.\xC0V[a/\x01_\x85\x01\x82a.\xD6V[Pa/\x0F` \x83\x01\x83a.\xC0V[a/\x1C` \x85\x01\x82a.\xD6V[Pa/*`@\x83\x01\x83a.\xC0V[a/7`@\x85\x01\x82a.\xD6V[PPPPV[_``\x82\x01\x90Pa/P_\x83\x01\x84a.\xE5V[\x92\x91PPV[\x7Fassertion not found\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a/\x8A`\x13\x83a(\x07V[\x91Pa/\x95\x82a/VV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra/\xB7\x81a/~V[\x90P\x91\x90PV[\x7Fcannot update config hash while _\x82\x01R\x7Fassertions are pending\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a0\x18`6\x83a(\x07V[\x91Pa0#\x82a/\xBEV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra0E\x81a0\x0CV[\x90P\x91\x90PV[\x7Finvalid signature length\0\0\0\0\0\0\0\0_\x82\x01RPV[_a0\x80`\x18\x83a(\x07V[\x91Pa0\x8B\x82a0LV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra0\xAD\x81a0tV[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a0\xCEa0\xC9\x82a\"5V[a0\xB4V[\x82RPPV[_a0\xDF\x82\x86a0\xBDV[` \x82\x01\x91Pa0\xEF\x82\x85a0\xBDV[` \x82\x01\x91Pa0\xFF\x82\x84a0\xBDV[` \x82\x01\x91P\x81\x90P\x94\x93PPPPV[\x7Finvalid tee signature\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a1D`\x15\x83a(\x07V[\x91Pa1O\x82a1\x10V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra1q\x81a18V[\x90P\x91\x90PV[\x7Fappchain block hash unchanged\0\0\0_\x82\x01RPV[_a1\xAC`\x1D\x83a(\x07V[\x91Pa1\xB7\x82a1xV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra1\xD9\x81a1\xA0V[\x90P\x91\x90PV[\x7Fassertion already exists\0\0\0\0\0\0\0\0_\x82\x01RPV[_a2\x14`\x18\x83a(\x07V[\x91Pa2\x1F\x82a1\xE0V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra2A\x81a2\x08V[\x90P\x91\x90PV[_a2R\x82a\"\x93V[\x91Pa2]\x83a\"\x93V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a2uWa2ta+cV[[\x92\x91PPV[_\x81\x90P\x92\x91PPV[PV[_a2\x93_\x83a2{V[\x91Pa2\x9E\x82a2\x85V[_\x82\x01\x90P\x91\x90PV[_a2\xB2\x82a2\x88V[\x91P\x81\x90P\x91\x90PV[\x7Fpayment failed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a2\xF0`\x0E\x83a(\x07V[\x91Pa2\xFB\x82a2\xBCV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra3\x1D\x81a2\xE4V[\x90P\x91\x90PV[\x7Fcannot update challenge window w_\x82\x01R\x7Fhile assertion is pending\0\0\0\0\0\0\0` \x82\x01RPV[_a3~`9\x83a(\x07V[\x91Pa3\x89\x82a3$V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra3\xAB\x81a3rV[\x90P\x91\x90PV[\x7FOwnable: new owner is the zero a_\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a4\x0C`&\x83a(\x07V[\x91Pa4\x17\x82a3\xB2V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra49\x81a4\0V[\x90P\x91\x90PV[_a4K\x82\x8Aa0\xBDV[` \x82\x01\x91Pa4[\x82\x89a0\xBDV[` \x82\x01\x91Pa4k\x82\x88a0\xBDV[` \x82\x01\x91Pa4{\x82\x87a0\xBDV[` \x82\x01\x91Pa4\x8B\x82\x86a0\xBDV[` \x82\x01\x91Pa4\x9B\x82\x85a0\xBDV[` \x82\x01\x91Pa4\xAB\x82\x84a0\xBDV[` \x82\x01\x91P\x81\x90P\x98\x97PPPPPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[_`\xFF\x82\x16\x90P\x91\x90PV[a5\x02\x81a4\xEDV[\x82RPPV[_`\x80\x82\x01\x90Pa5\x1B_\x83\x01\x87a#\\V[a5(` \x83\x01\x86a4\xF9V[a55`@\x83\x01\x85a#\\V[a5B``\x83\x01\x84a#\\V[\x95\x94PPPPPV",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361061014e575f3560e01c8063715018a6116100b5578063e50c61561161006e578063e50c615614610457578063e78cea921461047f578063eb60553a146104a9578063ee1c28b8146104d1578063f223055c146104fb578063f2fde38b1461052357610155565b8063715018a61461035f57806380959721146103755780638da5cb5b1461039f5780638fed55a3146103c9578063a56ec6cd146103f1578063c3f2dbd31461042f57610155565b80634bd167c9116101075780634bd167c91461028f5780635f70c441146102b9578063697b5e62146102e15780636c4c20601461030b5780636ef012011461032157806370646ea21461033757610155565b80631c12427f1461015957806333339006146101815780633ceaae7d146101bd578063420caf3a146101ed57806347742640146102175780634afffcc91461025357610155565b3661015557005b5f5ffd5b348015610164575f5ffd5b5061017f600480360381019061017a9190612268565b61054b565b005b34801561018c575f5ffd5b506101a760048036038101906101a291906122c6565b6106a5565b6040516101b49190612343565b60405180910390f35b3480156101c8575f5ffd5b506101d16106ed565b6040516101e4979695949392919061236b565b60405180910390f35b3480156101f8575f5ffd5b5061020161071c565b60405161020e9190612433565b60405180910390f35b348015610222575f5ffd5b5061023d60048036038101906102389190612476565b610740565b60405161024a91906124bb565b60405180910390f35b34801561025e575f5ffd5b50610279600480360381019061027491906124d4565b61075d565b60405161028691906124ff565b60405180910390f35b34801561029a575f5ffd5b506102a361077d565b6040516102b0919061253a565b60405180910390f35b3480156102c4575f5ffd5b506102df60048036038101906102da9190612268565b610797565b005b3480156102ec575f5ffd5b506102f561097d565b6040516103029190612562565b60405180910390f35b348015610316575f5ffd5b5061031f610983565b005b34801561032c575f5ffd5b50610335610ee0565b005b348015610342575f5ffd5b5061035d600480360381019061035891906125dc565b610fdc565b005b34801561036a575f5ffd5b50610373611201565b005b348015610380575f5ffd5b50610389611288565b604051610396919061266d565b60405180910390f35b3480156103aa575f5ffd5b506103b36112ac565b6040516103c09190612343565b60405180910390f35b3480156103d4575f5ffd5b506103ef60048036038101906103ea91906126a8565b6112d3565b005b3480156103fc575f5ffd5b50610417600480360381019061041291906124d4565b6114d4565b604051610426939291906126d3565b60405180910390f35b34801561043a575f5ffd5b5061045560048036038101906104509190612268565b611509565b005b348015610462575f5ffd5b5061047d60048036038101906104789190612708565b611617565b005b34801561048a575f5ffd5b506104936119f0565b6040516104a09190612799565b60405180910390f35b3480156104b4575f5ffd5b506104cf60048036038101906104ca91906127dc565b611a14565b005b3480156104dc575f5ffd5b506104e5611b03565b6040516104f2919061253a565b60405180910390f35b348015610506575f5ffd5b50610521600480360381019061051c9190612268565b611b1c565b005b34801561052e575f5ffd5b5061054960048036038101906105449190612476565b611c28565b005b610553611d1e565b73ffffffffffffffffffffffffffffffffffffffff166105716112ac565b73ffffffffffffffffffffffffffffffffffffffff16146105c7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105be90612861565b60405180910390fd5b5f5f90505b600a805490508110156106445781600a82815481106105ee576105ed61287f565b5b905f5260205f20015403610637576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161062e906128f6565b60405180910390fd5b80806001019150506105cc565b50600a81908060018154018082558091505060019003905f5260205f20015f90919091909150557f9a7a6469c25cf017890607695e4a149cc771f294fd871e2080d24cd109033ab68160405161069a91906124ff565b60405180910390a150565b600b602052815f5260405f2081815481106106be575f80fd5b905f5260205f20015f915091509054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6001805f0154908060010154908060020154908060030154908060040154908060050154908060060154905087565b7f000000000000000000000000000000000000000000000000000000000000000081565b600c602052805f5260405f205f915054906101000a900460ff1681565b600a818154811061076c575f80fd5b905f5260205f20015f915090505481565b600d60089054906101000a900467ffffffffffffffff1681565b61079f611d1e565b73ffffffffffffffffffffffffffffffffffffffff166107bd6112ac565b73ffffffffffffffffffffffffffffffffffffffff1614610813576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161080a90612861565b60405180910390fd5b5f6008805490501461085a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161085190612984565b60405180910390fd5b5f5f90505b600b5f8381526020019081526020015f2080549050811015610926575f600c5f600b5f8681526020019081526020015f2084815481106108a2576108a161287f565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550808060010191505061085f565b50600b5f8281526020019081526020015f205f610943919061216f565b7f2621c61d3315f2a3d26b22d746ba21a96d249f51ada323f7226cce5fe5fc3d648160405161097291906124ff565b60405180910390a150565b60095481565b600160088054905011156109cc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109c390612a12565b60405180910390fd5b600d5f9054906101000a900467ffffffffffffffff1667ffffffffffffffff165f73ffffffffffffffffffffffffffffffffffffffff167f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1614610ad1577f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663b80777ea6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610aa8573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610acc9190612a44565b610ad3565b425b67ffffffffffffffff1611610b1d576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b1490612adf565b60405180910390fd5b5f6008805490501115610c5f5760085f81548110610b3e57610b3d61287f565b5b905f5260205f2090600302015f0154600180018190555060085f81548110610b6957610b6861287f565b5b905f5260205f209060030201600201546001600301819055506001600601546001600501819055507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663daeab41260085f81548110610be157610be061287f565b5b905f5260205f2090600302015f015460085f81548110610c0457610c0361287f565b5b905f5260205f209060030201600101546040518363ffffffff1660e01b8152600401610c31929190612afd565b5f604051808303815f87803b158015610c48575f5ffd5b505af1158015610c5a573d5f5f3e3d5ffd5b505050505b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663d5719dc260017f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663eca067ad6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610d06573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d2a9190612b38565b610d349190612b90565b6040518263ffffffff1660e01b8152600401610d509190612562565b602060405180830381865afa158015610d6b573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d8f9190612bd7565b6001600401819055505f73ffffffffffffffffffffffffffffffffffffffff167f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1614610e7d577f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166309bd5a606040518163ffffffff1660e01b8152600401602060405180830381865afa158015610e54573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610e789190612bd7565b610e8c565b600143610e8a9190612b90565b405b600160060181905550600d60089054906101000a900467ffffffffffffffff1642610eb79190612c02565b600d5f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550565b610ee8611d1e565b73ffffffffffffffffffffffffffffffffffffffff16610f066112ac565b73ffffffffffffffffffffffffffffffffffffffff1614610f5c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610f5390612861565b60405180910390fd5b5f5f90505b600a80549050811015610fa057610f93600a8281548110610f8557610f8461287f565b5b905f5260205f200154610797565b8080600101915050610f61565b50600a5f610fae919061218d565b7feca62e0074a13a90d600f003b7cb8d5bd50100008d3f3915f2554f3f8552c5cc60405160405180910390a1565b60018282905014611022576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161101990612c87565b60405180910390fd5b600c5f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff16156110ac576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016110a390612cef565b60405180910390fd5b5f600b5f8581526020019081526020015f208054905003611136575f5f90505f600a8054905090505b5f8111156111285784600a6001836110ed9190612b90565b815481106110fe576110fd61287f565b5b905f5260205f200154036111155760019150611128565b808061112090612d0d565b9150506110d5565b508061113457506111fb565b505b6001600c5f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550600b5f8481526020019081526020015f2084908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b50505050565b611209611d1e565b73ffffffffffffffffffffffffffffffffffffffff166112276112ac565b73ffffffffffffffffffffffffffffffffffffffff161461127d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161127490612861565b60405180910390fd5b6112865f611d25565b565b7f000000000000000000000000000000000000000000000000000000000000000081565b5f5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b6112db611d1e565b73ffffffffffffffffffffffffffffffffffffffff166112f96112ac565b73ffffffffffffffffffffffffffffffffffffffff161461134f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161134690612861565b60405180910390fd5b600160088054905011611397576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161138e90612d7e565b60405180910390fd5b5f5f90505b600880549050811015611495576113d282600883815481106113c1576113c061287f565b5b905f5260205f209060030201611de6565b156114885760085f6113e491906121ab565b600882908060018154018082558091505060019003905f5260205f2090600302015f9091909190915081816114199190612eb2565b50505f600d5f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff16021790555061144b610983565b7fe42eaf0737e2478a5f5aed3a0610ae7b09a27cbac9ad6a5cc4d68f78afd1425b8260405161147a9190612f3d565b60405180910390a1506114d1565b808060010191505061139c565b506040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016114c890612fa0565b60405180910390fd5b50565b600881815481106114e3575f80fd5b905f5260205f2090600302015f91509050805f0154908060010154908060020154905083565b611511611d1e565b73ffffffffffffffffffffffffffffffffffffffff1661152f6112ac565b73ffffffffffffffffffffffffffffffffffffffff1614611585576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161157c90612861565b60405180910390fd5b5f600880549050146115cc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016115c39061302e565b60405180910390fd5b806001600201819055507fb9eb20b32fac965884cb58326102257cae604504f0a36cd1008a32845ad5c29b8160016003015460405161160c929190612afd565b60405180910390a150565b6041838390501461165d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161165490613096565b60405180910390fd5b5f6116686001611e1e565b855f01358660200135604051602001611683939291906130d4565b604051602081830303815290604052805190602001209050600c5f6116fc86868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f81840152601f19601f820116905080830192505050505050506116ee85611e74565b611ea790919063ffffffff16565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff16611781576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016117789061315a565b60405180910390fd5b6001800154855f0135036117ca576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016117c1906131c2565b60405180910390fd5b5f5f90505b6008805490508110156118525761180586600883815481106117f4576117f361287f565b5b905f5260205f209060030201611de6565b15611845576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161183c9061322a565b60405180910390fd5b80806001019150506117cf565b505f600880549050036118a957600d60089054906101000a900467ffffffffffffffff16426118819190612c02565b600d5f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055505b600885908060018154018082558091505060019003905f5260205f2090600302015f9091909190915081816118de9190612eb2565b50506002600880549050036119e957600160095f8282546118ff9190613248565b925050819055507f37e8add694c5926d564e971160f5974103cbbbc7c90747c4c6f802031d3567a76009546040516119379190612562565b60405180910390a15f8273ffffffffffffffffffffffffffffffffffffffff1647604051611964906132a8565b5f6040518083038185875af1925050503d805f811461199e576040519150601f19603f3d011682016040523d82523d5f602084013e6119a3565b606091505b50509050806119e7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016119de90613306565b60405180910390fd5b505b5050505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b611a1c611d1e565b73ffffffffffffffffffffffffffffffffffffffff16611a3a6112ac565b73ffffffffffffffffffffffffffffffffffffffff1614611a90576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611a8790612861565b60405180910390fd5b5f60088054905014611ad7576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611ace90613394565b60405180910390fd5b80600d60086101000a81548167ffffffffffffffff021916908367ffffffffffffffff16021790555050565b600d5f9054906101000a900467ffffffffffffffff1681565b611b24611d1e565b73ffffffffffffffffffffffffffffffffffffffff16611b426112ac565b73ffffffffffffffffffffffffffffffffffffffff1614611b98576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611b8f90612861565b60405180910390fd5b5f60088054905014611bdf576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611bd69061302e565b60405180910390fd5b8060015f01819055507fc985bccbd0c90e197f4a7373020a33ba6ff864d0399fd7d65c5c7c32ffb015ec816001800154604051611c1d929190612afd565b60405180910390a150565b611c30611d1e565b73ffffffffffffffffffffffffffffffffffffffff16611c4e6112ac565b73ffffffffffffffffffffffffffffffffffffffff1614611ca4576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611c9b90612861565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603611d12576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611d0990613422565b60405180910390fd5b611d1b81611d25565b50565b5f33905090565b5f5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050815f5f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b5f815f0154835f0135148015611e03575081600101548360200135145b8015611e16575081600201548360400135145b905092915050565b5f815f0154826001015483600201548460030154856004015486600501548760060154604051602001611e579796959493929190613440565b604051602081830303815290604052805190602001209050919050565b5f7f19457468657265756d205369676e6564204d6573736167653a0a3332000000005f5281601c52603c5f209050919050565b5f5f5f5f611eb58686611ed1565b925092509250611ec58282611f26565b82935050505092915050565b5f5f5f6041845103611f11575f5f5f602087015192506040870151915060608701515f1a9050611f0388828585612088565b955095509550505050611f1f565b5f600285515f1b9250925092505b9250925092565b5f6003811115611f3957611f386134c0565b5b826003811115611f4c57611f4b6134c0565b5b03156120845760016003811115611f6657611f656134c0565b5b826003811115611f7957611f786134c0565b5b03611fb0576040517ff645eedf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60026003811115611fc457611fc36134c0565b5b826003811115611fd757611fd66134c0565b5b0361201b57805f1c6040517ffce698f70000000000000000000000000000000000000000000000000000000081526004016120129190612562565b60405180910390fd5b60038081111561202e5761202d6134c0565b5b826003811115612041576120406134c0565b5b0361208357806040517fd78bce0c00000000000000000000000000000000000000000000000000000000815260040161207a91906124ff565b60405180910390fd5b5b5050565b5f5f5f7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0845f1c11156120c4575f600385925092509250612165565b5f6001888888886040515f81526020016040526040516120e79493929190613508565b6020604051602081039080840390855afa158015612107573d5f5f3e3d5ffd5b5050506020604051035190505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603612158575f60015f5f1b93509350935050612165565b805f5f5f1b935093509350505b9450945094915050565b5080545f8255905f5260205f209081019061218a91906121cc565b50565b5080545f8255905f5260205f20908101906121a891906121e7565b50565b5080545f8255600302905f5260205f20908101906121c99190612202565b50565b5b808211156121e3575f815f9055506001016121cd565b5090565b5b808211156121fe575f815f9055506001016121e8565b5090565b5b80821115612229575f5f82015f9055600182015f9055600282015f905550600301612203565b5090565b5f5ffd5b5f5ffd5b5f819050919050565b61224781612235565b8114612251575f5ffd5b50565b5f813590506122628161223e565b92915050565b5f6020828403121561227d5761227c61222d565b5b5f61228a84828501612254565b91505092915050565b5f819050919050565b6122a581612293565b81146122af575f5ffd5b50565b5f813590506122c08161229c565b92915050565b5f5f604083850312156122dc576122db61222d565b5b5f6122e985828601612254565b92505060206122fa858286016122b2565b9150509250929050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f61232d82612304565b9050919050565b61233d81612323565b82525050565b5f6020820190506123565f830184612334565b92915050565b61236581612235565b82525050565b5f60e08201905061237e5f83018a61235c565b61238b602083018961235c565b612398604083018861235c565b6123a5606083018761235c565b6123b2608083018661235c565b6123bf60a083018561235c565b6123cc60c083018461235c565b98975050505050505050565b5f819050919050565b5f6123fb6123f66123f184612304565b6123d8565b612304565b9050919050565b5f61240c826123e1565b9050919050565b5f61241d82612402565b9050919050565b61242d81612413565b82525050565b5f6020820190506124465f830184612424565b92915050565b61245581612323565b811461245f575f5ffd5b50565b5f813590506124708161244c565b92915050565b5f6020828403121561248b5761248a61222d565b5b5f61249884828501612462565b91505092915050565b5f8115159050919050565b6124b5816124a1565b82525050565b5f6020820190506124ce5f8301846124ac565b92915050565b5f602082840312156124e9576124e861222d565b5b5f6124f6848285016122b2565b91505092915050565b5f6020820190506125125f83018461235c565b92915050565b5f67ffffffffffffffff82169050919050565b61253481612518565b82525050565b5f60208201905061254d5f83018461252b565b92915050565b61255c81612293565b82525050565b5f6020820190506125755f830184612553565b92915050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83601f84011261259c5761259b61257b565b5b8235905067ffffffffffffffff8111156125b9576125b861257f565b5b6020830191508360018202830111156125d5576125d4612583565b5b9250929050565b5f5f5f5f606085870312156125f4576125f361222d565b5b5f61260187828801612462565b945050602061261287828801612254565b935050604085013567ffffffffffffffff81111561263357612632612231565b5b61263f87828801612587565b925092505092959194509250565b5f61265782612402565b9050919050565b6126678161264d565b82525050565b5f6020820190506126805f83018461265e565b92915050565b5f5ffd5b5f6060828403121561269f5761269e612686565b5b81905092915050565b5f606082840312156126bd576126bc61222d565b5b5f6126ca8482850161268a565b91505092915050565b5f6060820190506126e65f83018661235c565b6126f3602083018561235c565b612700604083018461235c565b949350505050565b5f5f5f5f60a085870312156127205761271f61222d565b5b5f61272d8782880161268a565b945050606085013567ffffffffffffffff81111561274e5761274d612231565b5b61275a87828801612587565b9350935050608061276d87828801612462565b91505092959194509250565b5f61278382612402565b9050919050565b61279381612779565b82525050565b5f6020820190506127ac5f83018461278a565b92915050565b6127bb81612518565b81146127c5575f5ffd5b50565b5f813590506127d6816127b2565b92915050565b5f602082840312156127f1576127f061222d565b5b5f6127fe848285016127c8565b91505092915050565b5f82825260208201905092915050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65725f82015250565b5f61284b602083612807565b915061285682612817565b602082019050919050565b5f6020820190508181035f8301526128788161283f565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f7465652070726f6772616d20616c7265616479206578697374730000000000005f82015250565b5f6128e0601a83612807565b91506128eb826128ac565b602082019050919050565b5f6020820190508181035f83015261290d816128d4565b9050919050565b7f63616e6e6f742072656d6f7665207465652070726f6772616d207768696c65205f8201527f617373657274696f6e2069732070656e64696e67000000000000000000000000602082015250565b5f61296e603483612807565b915061297982612914565b604082019050919050565b5f6020820190508181035f83015261299b81612962565b9050919050565b7f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201527f746f6f206d616e7920617373657274696f6e7300000000000000000000000000602082015250565b5f6129fc603383612807565b9150612a07826129a2565b604082019050919050565b5f6020820190508181035f830152612a29816129f0565b9050919050565b5f81519050612a3e816127b2565b92915050565b5f60208284031215612a5957612a5861222d565b5b5f612a6684828501612a30565b91505092915050565b7f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201527f696e73756666696369656e742074696d65206861732070617373656400000000602082015250565b5f612ac9603c83612807565b9150612ad482612a6f565b604082019050919050565b5f6020820190508181035f830152612af681612abd565b9050919050565b5f604082019050612b105f83018561235c565b612b1d602083018461235c565b9392505050565b5f81519050612b328161229c565b92915050565b5f60208284031215612b4d57612b4c61222d565b5b5f612b5a84828501612b24565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f612b9a82612293565b9150612ba583612293565b9250828203905081811115612bbd57612bbc612b63565b5b92915050565b5f81519050612bd18161223e565b92915050565b5f60208284031215612bec57612beb61222d565b5b5f612bf984828501612bc3565b91505092915050565b5f612c0c82612518565b9150612c1783612518565b9250828201905067ffffffffffffffff811115612c3757612c36612b63565b5b92915050565b7f746f646f3a2076616c6964617465207a6b207a6b50726f6f66000000000000005f82015250565b5f612c71601983612807565b9150612c7c82612c3d565b602082019050919050565b5f6020820190508181035f830152612c9e81612c65565b9050919050565b7f6b657920616c72656164792061646465640000000000000000000000000000005f82015250565b5f612cd9601183612807565b9150612ce482612ca5565b602082019050919050565b5f6020820190508181035f830152612d0681612ccd565b9050919050565b5f612d1782612293565b91505f8203612d2957612d28612b63565b5b600182039050919050565b7f6368616c6c656e676520646f6573206e6f7420657869737400000000000000005f82015250565b5f612d68601883612807565b9150612d7382612d34565b602082019050919050565b5f6020820190508181035f830152612d9581612d5c565b9050919050565b5f8135612da88161223e565b80915050919050565b5f815f1b9050919050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff612de784612db1565b9350801983169250808416831791505092915050565b5f612e0782612235565b9050919050565b5f815f1c9050919050565b5f612e2382612e0e565b9050919050565b612e3382612dfd565b612e46612e3f82612e19565b8354612dbc565b8255505050565b5f81015f830180612e5d81612d9c565b9050612e698184612e2a565b505050600181016020830180612e7e81612d9c565b9050612e8a8184612e2a565b505050600281016040830180612e9f81612d9c565b9050612eab8184612e2a565b5050505050565b612ebc8282612e4d565b5050565b5f612ece6020840184612254565b905092915050565b612edf81612235565b82525050565b60608201612ef55f830183612ec0565b612f015f850182612ed6565b50612f0f6020830183612ec0565b612f1c6020850182612ed6565b50612f2a6040830183612ec0565b612f376040850182612ed6565b50505050565b5f606082019050612f505f830184612ee5565b92915050565b7f617373657274696f6e206e6f7420666f756e64000000000000000000000000005f82015250565b5f612f8a601383612807565b9150612f9582612f56565b602082019050919050565b5f6020820190508181035f830152612fb781612f7e565b9050919050565b7f63616e6e6f742075706461746520636f6e6669672068617368207768696c65205f8201527f617373657274696f6e73206172652070656e64696e6700000000000000000000602082015250565b5f613018603683612807565b915061302382612fbe565b604082019050919050565b5f6020820190508181035f8301526130458161300c565b9050919050565b7f696e76616c6964207369676e6174757265206c656e67746800000000000000005f82015250565b5f613080601883612807565b915061308b8261304c565b602082019050919050565b5f6020820190508181035f8301526130ad81613074565b9050919050565b5f819050919050565b6130ce6130c982612235565b6130b4565b82525050565b5f6130df82866130bd565b6020820191506130ef82856130bd565b6020820191506130ff82846130bd565b602082019150819050949350505050565b7f696e76616c696420746565207369676e617475726500000000000000000000005f82015250565b5f613144601583612807565b915061314f82613110565b602082019050919050565b5f6020820190508181035f83015261317181613138565b9050919050565b7f617070636861696e20626c6f636b206861736820756e6368616e6765640000005f82015250565b5f6131ac601d83612807565b91506131b782613178565b602082019050919050565b5f6020820190508181035f8301526131d9816131a0565b9050919050565b7f617373657274696f6e20616c72656164792065786973747300000000000000005f82015250565b5f613214601883612807565b915061321f826131e0565b602082019050919050565b5f6020820190508181035f83015261324181613208565b9050919050565b5f61325282612293565b915061325d83612293565b925082820190508082111561327557613274612b63565b5b92915050565b5f81905092915050565b50565b5f6132935f8361327b565b915061329e82613285565b5f82019050919050565b5f6132b282613288565b9150819050919050565b7f7061796d656e74206661696c65640000000000000000000000000000000000005f82015250565b5f6132f0600e83612807565b91506132fb826132bc565b602082019050919050565b5f6020820190508181035f83015261331d816132e4565b9050919050565b7f63616e6e6f7420757064617465206368616c6c656e67652077696e646f7720775f8201527f68696c6520617373657274696f6e2069732070656e64696e6700000000000000602082015250565b5f61337e603983612807565b915061338982613324565b604082019050919050565b5f6020820190508181035f8301526133ab81613372565b9050919050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f20615f8201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b5f61340c602683612807565b9150613417826133b2565b604082019050919050565b5f6020820190508181035f83015261343981613400565b9050919050565b5f61344b828a6130bd565b60208201915061345b82896130bd565b60208201915061346b82886130bd565b60208201915061347b82876130bd565b60208201915061348b82866130bd565b60208201915061349b82856130bd565b6020820191506134ab82846130bd565b60208201915081905098975050505050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b5f60ff82169050919050565b613502816134ed565b82525050565b5f60808201905061351b5f83018761235c565b61352860208301866134f9565b613535604083018561235c565b613542606083018461235c565b9594505050505056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\x01NW_5`\xE0\x1C\x80cqP\x18\xA6\x11a\0\xB5W\x80c\xE5\x0CaV\x11a\0nW\x80c\xE5\x0CaV\x14a\x04WW\x80c\xE7\x8C\xEA\x92\x14a\x04\x7FW\x80c\xEB`U:\x14a\x04\xA9W\x80c\xEE\x1C(\xB8\x14a\x04\xD1W\x80c\xF2#\x05\\\x14a\x04\xFBW\x80c\xF2\xFD\xE3\x8B\x14a\x05#Wa\x01UV[\x80cqP\x18\xA6\x14a\x03_W\x80c\x80\x95\x97!\x14a\x03uW\x80c\x8D\xA5\xCB[\x14a\x03\x9FW\x80c\x8F\xEDU\xA3\x14a\x03\xC9W\x80c\xA5n\xC6\xCD\x14a\x03\xF1W\x80c\xC3\xF2\xDB\xD3\x14a\x04/Wa\x01UV[\x80cK\xD1g\xC9\x11a\x01\x07W\x80cK\xD1g\xC9\x14a\x02\x8FW\x80c_p\xC4A\x14a\x02\xB9W\x80ci{^b\x14a\x02\xE1W\x80clL `\x14a\x03\x0BW\x80cn\xF0\x12\x01\x14a\x03!W\x80cpdn\xA2\x14a\x037Wa\x01UV[\x80c\x1C\x12B\x7F\x14a\x01YW\x80c33\x90\x06\x14a\x01\x81W\x80c<\xEA\xAE}\x14a\x01\xBDW\x80cB\x0C\xAF:\x14a\x01\xEDW\x80cGt&@\x14a\x02\x17W\x80cJ\xFF\xFC\xC9\x14a\x02SWa\x01UV[6a\x01UW\0[__\xFD[4\x80\x15a\x01dW__\xFD[Pa\x01\x7F`\x04\x806\x03\x81\x01\x90a\x01z\x91\x90a\"hV[a\x05KV[\0[4\x80\x15a\x01\x8CW__\xFD[Pa\x01\xA7`\x04\x806\x03\x81\x01\x90a\x01\xA2\x91\x90a\"\xC6V[a\x06\xA5V[`@Qa\x01\xB4\x91\x90a#CV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x01\xC8W__\xFD[Pa\x01\xD1a\x06\xEDV[`@Qa\x01\xE4\x97\x96\x95\x94\x93\x92\x91\x90a#kV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x01\xF8W__\xFD[Pa\x02\x01a\x07\x1CV[`@Qa\x02\x0E\x91\x90a$3V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\"W__\xFD[Pa\x02=`\x04\x806\x03\x81\x01\x90a\x028\x91\x90a$vV[a\x07@V[`@Qa\x02J\x91\x90a$\xBBV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02^W__\xFD[Pa\x02y`\x04\x806\x03\x81\x01\x90a\x02t\x91\x90a$\xD4V[a\x07]V[`@Qa\x02\x86\x91\x90a$\xFFV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\x9AW__\xFD[Pa\x02\xA3a\x07}V[`@Qa\x02\xB0\x91\x90a%:V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xC4W__\xFD[Pa\x02\xDF`\x04\x806\x03\x81\x01\x90a\x02\xDA\x91\x90a\"hV[a\x07\x97V[\0[4\x80\x15a\x02\xECW__\xFD[Pa\x02\xF5a\t}V[`@Qa\x03\x02\x91\x90a%bV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x16W__\xFD[Pa\x03\x1Fa\t\x83V[\0[4\x80\x15a\x03,W__\xFD[Pa\x035a\x0E\xE0V[\0[4\x80\x15a\x03BW__\xFD[Pa\x03]`\x04\x806\x03\x81\x01\x90a\x03X\x91\x90a%\xDCV[a\x0F\xDCV[\0[4\x80\x15a\x03jW__\xFD[Pa\x03sa\x12\x01V[\0[4\x80\x15a\x03\x80W__\xFD[Pa\x03\x89a\x12\x88V[`@Qa\x03\x96\x91\x90a&mV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xAAW__\xFD[Pa\x03\xB3a\x12\xACV[`@Qa\x03\xC0\x91\x90a#CV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xD4W__\xFD[Pa\x03\xEF`\x04\x806\x03\x81\x01\x90a\x03\xEA\x91\x90a&\xA8V[a\x12\xD3V[\0[4\x80\x15a\x03\xFCW__\xFD[Pa\x04\x17`\x04\x806\x03\x81\x01\x90a\x04\x12\x91\x90a$\xD4V[a\x14\xD4V[`@Qa\x04&\x93\x92\x91\x90a&\xD3V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04:W__\xFD[Pa\x04U`\x04\x806\x03\x81\x01\x90a\x04P\x91\x90a\"hV[a\x15\tV[\0[4\x80\x15a\x04bW__\xFD[Pa\x04}`\x04\x806\x03\x81\x01\x90a\x04x\x91\x90a'\x08V[a\x16\x17V[\0[4\x80\x15a\x04\x8AW__\xFD[Pa\x04\x93a\x19\xF0V[`@Qa\x04\xA0\x91\x90a'\x99V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xB4W__\xFD[Pa\x04\xCF`\x04\x806\x03\x81\x01\x90a\x04\xCA\x91\x90a'\xDCV[a\x1A\x14V[\0[4\x80\x15a\x04\xDCW__\xFD[Pa\x04\xE5a\x1B\x03V[`@Qa\x04\xF2\x91\x90a%:V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\x06W__\xFD[Pa\x05!`\x04\x806\x03\x81\x01\x90a\x05\x1C\x91\x90a\"hV[a\x1B\x1CV[\0[4\x80\x15a\x05.W__\xFD[Pa\x05I`\x04\x806\x03\x81\x01\x90a\x05D\x91\x90a$vV[a\x1C(V[\0[a\x05Sa\x1D\x1EV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x05qa\x12\xACV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x05\xC7W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05\xBE\x90a(aV[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\n\x80T\x90P\x81\x10\x15a\x06DW\x81`\n\x82\x81T\x81\x10a\x05\xEEWa\x05\xEDa(\x7FV[[\x90_R` _ \x01T\x03a\x067W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06.\x90a(\xF6V[`@Q\x80\x91\x03\x90\xFD[\x80\x80`\x01\x01\x91PPa\x05\xCCV[P`\n\x81\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91PU\x7F\x9Azdi\xC2\\\xF0\x17\x89\x06\x07i^J\x14\x9C\xC7q\xF2\x94\xFD\x87\x1E \x80\xD2L\xD1\t\x03:\xB6\x81`@Qa\x06\x9A\x91\x90a$\xFFV[`@Q\x80\x91\x03\x90\xA1PV[`\x0B` R\x81_R`@_ \x81\x81T\x81\x10a\x06\xBEW_\x80\xFD[\x90_R` _ \x01_\x91P\x91P\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[`\x01\x80_\x01T\x90\x80`\x01\x01T\x90\x80`\x02\x01T\x90\x80`\x03\x01T\x90\x80`\x04\x01T\x90\x80`\x05\x01T\x90\x80`\x06\x01T\x90P\x87V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`\x0C` R\x80_R`@_ _\x91PT\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[`\n\x81\x81T\x81\x10a\x07lW_\x80\xFD[\x90_R` _ \x01_\x91P\x90PT\x81V[`\r`\x08\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[a\x07\x9Fa\x1D\x1EV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x07\xBDa\x12\xACV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x08\x13W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08\n\x90a(aV[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x14a\x08ZW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08Q\x90a)\x84V[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x0B_\x83\x81R` \x01\x90\x81R` \x01_ \x80T\x90P\x81\x10\x15a\t&W_`\x0C_`\x0B_\x86\x81R` \x01\x90\x81R` \x01_ \x84\x81T\x81\x10a\x08\xA2Wa\x08\xA1a(\x7FV[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa\x08_V[P`\x0B_\x82\x81R` \x01\x90\x81R` \x01_ _a\tC\x91\x90a!oV[\x7F&!\xC6\x1D3\x15\xF2\xA3\xD2k\"\xD7F\xBA!\xA9m$\x9FQ\xAD\xA3#\xF7\"l\xCE_\xE5\xFC=d\x81`@Qa\tr\x91\x90a$\xFFV[`@Q\x80\x91\x03\x90\xA1PV[`\tT\x81V[`\x01`\x08\x80T\x90P\x11\x15a\t\xCCW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\t\xC3\x90a*\x12V[`@Q\x80\x91\x03\x90\xFD[`\r_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\n\xD1W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xB8\x07w\xEA`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n\xA8W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\xCC\x91\x90a*DV[a\n\xD3V[B[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11a\x0B\x1DW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0B\x14\x90a*\xDFV[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x11\x15a\x0C_W`\x08_\x81T\x81\x10a\x0B>Wa\x0B=a(\x7FV[[\x90_R` _ \x90`\x03\x02\x01_\x01T`\x01\x80\x01\x81\x90UP`\x08_\x81T\x81\x10a\x0BiWa\x0Bha(\x7FV[[\x90_R` _ \x90`\x03\x02\x01`\x02\x01T`\x01`\x03\x01\x81\x90UP`\x01`\x06\x01T`\x01`\x05\x01\x81\x90UP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xDA\xEA\xB4\x12`\x08_\x81T\x81\x10a\x0B\xE1Wa\x0B\xE0a(\x7FV[[\x90_R` _ \x90`\x03\x02\x01_\x01T`\x08_\x81T\x81\x10a\x0C\x04Wa\x0C\x03a(\x7FV[[\x90_R` _ \x90`\x03\x02\x01`\x01\x01T`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0C1\x92\x91\x90a*\xFDV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0CHW__\xFD[PZ\xF1\x15\x80\x15a\x0CZW=__>=_\xFD[PPPP[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xD5q\x9D\xC2`\x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xEC\xA0g\xAD`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\r\x06W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r*\x91\x90a+8V[a\r4\x91\x90a+\x90V[`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\rP\x91\x90a%bV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\rkW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r\x8F\x91\x90a+\xD7V[`\x01`\x04\x01\x81\x90UP_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x0E}W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\t\xBDZ``@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0ETW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0Ex\x91\x90a+\xD7V[a\x0E\x8CV[`\x01Ca\x0E\x8A\x91\x90a+\x90V[@[`\x01`\x06\x01\x81\x90UP`\r`\x08\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16Ba\x0E\xB7\x91\x90a,\x02V[`\r_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPV[a\x0E\xE8a\x1D\x1EV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x0F\x06a\x12\xACV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x0F\\W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0FS\x90a(aV[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\n\x80T\x90P\x81\x10\x15a\x0F\xA0Wa\x0F\x93`\n\x82\x81T\x81\x10a\x0F\x85Wa\x0F\x84a(\x7FV[[\x90_R` _ \x01Ta\x07\x97V[\x80\x80`\x01\x01\x91PPa\x0FaV[P`\n_a\x0F\xAE\x91\x90a!\x8DV[\x7F\xEC\xA6.\0t\xA1:\x90\xD6\0\xF0\x03\xB7\xCB\x8D[\xD5\x01\0\0\x8D?9\x15\xF2UO?\x85R\xC5\xCC`@Q`@Q\x80\x91\x03\x90\xA1V[`\x01\x82\x82\x90P\x14a\x10\"W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x10\x19\x90a,\x87V[`@Q\x80\x91\x03\x90\xFD[`\x0C_\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a\x10\xACW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x10\xA3\x90a,\xEFV[`@Q\x80\x91\x03\x90\xFD[_`\x0B_\x85\x81R` \x01\x90\x81R` \x01_ \x80T\x90P\x03a\x116W__\x90P_`\n\x80T\x90P\x90P[_\x81\x11\x15a\x11(W\x84`\n`\x01\x83a\x10\xED\x91\x90a+\x90V[\x81T\x81\x10a\x10\xFEWa\x10\xFDa(\x7FV[[\x90_R` _ \x01T\x03a\x11\x15W`\x01\x91Pa\x11(V[\x80\x80a\x11 \x90a-\rV[\x91PPa\x10\xD5V[P\x80a\x114WPa\x11\xFBV[P[`\x01`\x0C_\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP`\x0B_\x84\x81R` \x01\x90\x81R` \x01_ \x84\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP[PPPPV[a\x12\ta\x1D\x1EV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x12'a\x12\xACV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x12}W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x12t\x90a(aV[`@Q\x80\x91\x03\x90\xFD[a\x12\x86_a\x1D%V[V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[___\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[a\x12\xDBa\x1D\x1EV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x12\xF9a\x12\xACV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x13OW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13F\x90a(aV[`@Q\x80\x91\x03\x90\xFD[`\x01`\x08\x80T\x90P\x11a\x13\x97W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\x8E\x90a-~V[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x08\x80T\x90P\x81\x10\x15a\x14\x95Wa\x13\xD2\x82`\x08\x83\x81T\x81\x10a\x13\xC1Wa\x13\xC0a(\x7FV[[\x90_R` _ \x90`\x03\x02\x01a\x1D\xE6V[\x15a\x14\x88W`\x08_a\x13\xE4\x91\x90a!\xABV[`\x08\x82\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x03\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a\x14\x19\x91\x90a.\xB2V[PP_`\r_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPa\x14Ka\t\x83V[\x7F\xE4.\xAF\x077\xE2G\x8A_Z\xED:\x06\x10\xAE{\t\xA2|\xBA\xC9\xADj\\\xC4\xD6\x8Fx\xAF\xD1B[\x82`@Qa\x14z\x91\x90a/=V[`@Q\x80\x91\x03\x90\xA1Pa\x14\xD1V[\x80\x80`\x01\x01\x91PPa\x13\x9CV[P`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14\xC8\x90a/\xA0V[`@Q\x80\x91\x03\x90\xFD[PV[`\x08\x81\x81T\x81\x10a\x14\xE3W_\x80\xFD[\x90_R` _ \x90`\x03\x02\x01_\x91P\x90P\x80_\x01T\x90\x80`\x01\x01T\x90\x80`\x02\x01T\x90P\x83V[a\x15\x11a\x1D\x1EV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x15/a\x12\xACV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x15\x85W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x15|\x90a(aV[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x14a\x15\xCCW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x15\xC3\x90a0.V[`@Q\x80\x91\x03\x90\xFD[\x80`\x01`\x02\x01\x81\x90UP\x7F\xB9\xEB \xB3/\xAC\x96X\x84\xCBX2a\x02%|\xAE`E\x04\xF0\xA3l\xD1\0\x8A2\x84Z\xD5\xC2\x9B\x81`\x01`\x03\x01T`@Qa\x16\x0C\x92\x91\x90a*\xFDV[`@Q\x80\x91\x03\x90\xA1PV[`A\x83\x83\x90P\x14a\x16]W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x16T\x90a0\x96V[`@Q\x80\x91\x03\x90\xFD[_a\x16h`\x01a\x1E\x1EV[\x85_\x015\x86` \x015`@Q` \x01a\x16\x83\x93\x92\x91\x90a0\xD4V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P`\x0C_a\x16\xFC\x86\x86\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x81\x84\x01R`\x1F\x19`\x1F\x82\x01\x16\x90P\x80\x83\x01\x92PPPPPPPa\x16\xEE\x85a\x1EtV[a\x1E\xA7\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x17\x81W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x17x\x90a1ZV[`@Q\x80\x91\x03\x90\xFD[`\x01\x80\x01T\x85_\x015\x03a\x17\xCAW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x17\xC1\x90a1\xC2V[`@Q\x80\x91\x03\x90\xFD[__\x90P[`\x08\x80T\x90P\x81\x10\x15a\x18RWa\x18\x05\x86`\x08\x83\x81T\x81\x10a\x17\xF4Wa\x17\xF3a(\x7FV[[\x90_R` _ \x90`\x03\x02\x01a\x1D\xE6V[\x15a\x18EW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x18<\x90a2*V[`@Q\x80\x91\x03\x90\xFD[\x80\x80`\x01\x01\x91PPa\x17\xCFV[P_`\x08\x80T\x90P\x03a\x18\xA9W`\r`\x08\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16Ba\x18\x81\x91\x90a,\x02V[`\r_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP[`\x08\x85\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x03\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a\x18\xDE\x91\x90a.\xB2V[PP`\x02`\x08\x80T\x90P\x03a\x19\xE9W`\x01`\t_\x82\x82Ta\x18\xFF\x91\x90a2HV[\x92PP\x81\x90UP\x7F7\xE8\xAD\xD6\x94\xC5\x92mVN\x97\x11`\xF5\x97A\x03\xCB\xBB\xC7\xC9\x07G\xC4\xC6\xF8\x02\x03\x1D5g\xA7`\tT`@Qa\x197\x91\x90a%bV[`@Q\x80\x91\x03\x90\xA1_\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16G`@Qa\x19d\x90a2\xA8V[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a\x19\x9EW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x19\xA3V[``\x91P[PP\x90P\x80a\x19\xE7W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x19\xDE\x90a3\x06V[`@Q\x80\x91\x03\x90\xFD[P[PPPPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x1A\x1Ca\x1D\x1EV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1A:a\x12\xACV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1A\x90W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1A\x87\x90a(aV[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x14a\x1A\xD7W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1A\xCE\x90a3\x94V[`@Q\x80\x91\x03\x90\xFD[\x80`\r`\x08a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[`\r_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[a\x1B$a\x1D\x1EV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1BBa\x12\xACV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1B\x98W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1B\x8F\x90a(aV[`@Q\x80\x91\x03\x90\xFD[_`\x08\x80T\x90P\x14a\x1B\xDFW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1B\xD6\x90a0.V[`@Q\x80\x91\x03\x90\xFD[\x80`\x01_\x01\x81\x90UP\x7F\xC9\x85\xBC\xCB\xD0\xC9\x0E\x19\x7FJss\x02\n3\xBAo\xF8d\xD09\x9F\xD7\xD6\\\\|2\xFF\xB0\x15\xEC\x81`\x01\x80\x01T`@Qa\x1C\x1D\x92\x91\x90a*\xFDV[`@Q\x80\x91\x03\x90\xA1PV[a\x1C0a\x1D\x1EV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1CNa\x12\xACV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1C\xA4W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1C\x9B\x90a(aV[`@Q\x80\x91\x03\x90\xFD[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x1D\x12W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1D\t\x90a4\"V[`@Q\x80\x91\x03\x90\xFD[a\x1D\x1B\x81a\x1D%V[PV[_3\x90P\x90V[___\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x81__a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPV[_\x81_\x01T\x83_\x015\x14\x80\x15a\x1E\x03WP\x81`\x01\x01T\x83` \x015\x14[\x80\x15a\x1E\x16WP\x81`\x02\x01T\x83`@\x015\x14[\x90P\x92\x91PPV[_\x81_\x01T\x82`\x01\x01T\x83`\x02\x01T\x84`\x03\x01T\x85`\x04\x01T\x86`\x05\x01T\x87`\x06\x01T`@Q` \x01a\x1EW\x97\x96\x95\x94\x93\x92\x91\x90a4@V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x91\x90PV[_\x7F\x19Ethereum Signed Message:\n32\0\0\0\0_R\x81`\x1CR`<_ \x90P\x91\x90PV[____a\x1E\xB5\x86\x86a\x1E\xD1V[\x92P\x92P\x92Pa\x1E\xC5\x82\x82a\x1F&V[\x82\x93PPPP\x92\x91PPV[___`A\x84Q\x03a\x1F\x11W___` \x87\x01Q\x92P`@\x87\x01Q\x91P``\x87\x01Q_\x1A\x90Pa\x1F\x03\x88\x82\x85\x85a \x88V[\x95P\x95P\x95PPPPa\x1F\x1FV[_`\x02\x85Q_\x1B\x92P\x92P\x92P[\x92P\x92P\x92V[_`\x03\x81\x11\x15a\x1F9Wa\x1F8a4\xC0V[[\x82`\x03\x81\x11\x15a\x1FLWa\x1FKa4\xC0V[[\x03\x15a \x84W`\x01`\x03\x81\x11\x15a\x1FfWa\x1Fea4\xC0V[[\x82`\x03\x81\x11\x15a\x1FyWa\x1Fxa4\xC0V[[\x03a\x1F\xB0W`@Q\x7F\xF6E\xEE\xDF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`\x03\x81\x11\x15a\x1F\xC4Wa\x1F\xC3a4\xC0V[[\x82`\x03\x81\x11\x15a\x1F\xD7Wa\x1F\xD6a4\xC0V[[\x03a \x1BW\x80_\x1C`@Q\x7F\xFC\xE6\x98\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a \x12\x91\x90a%bV[`@Q\x80\x91\x03\x90\xFD[`\x03\x80\x81\x11\x15a .Wa -a4\xC0V[[\x82`\x03\x81\x11\x15a AWa @a4\xC0V[[\x03a \x83W\x80`@Q\x7F\xD7\x8B\xCE\x0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a z\x91\x90a$\xFFV[`@Q\x80\x91\x03\x90\xFD[[PPV[___\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0\x84_\x1C\x11\x15a \xC4W_`\x03\x85\x92P\x92P\x92Pa!eV[_`\x01\x88\x88\x88\x88`@Q_\x81R` \x01`@R`@Qa \xE7\x94\x93\x92\x91\x90a5\x08V[` `@Q` \x81\x03\x90\x80\x84\x03\x90\x85Z\xFA\x15\x80\x15a!\x07W=__>=_\xFD[PPP` `@Q\x03Q\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a!XW_`\x01__\x1B\x93P\x93P\x93PPa!eV[\x80___\x1B\x93P\x93P\x93PP[\x94P\x94P\x94\x91PPV[P\x80T_\x82U\x90_R` _ \x90\x81\x01\x90a!\x8A\x91\x90a!\xCCV[PV[P\x80T_\x82U\x90_R` _ \x90\x81\x01\x90a!\xA8\x91\x90a!\xE7V[PV[P\x80T_\x82U`\x03\x02\x90_R` _ \x90\x81\x01\x90a!\xC9\x91\x90a\"\x02V[PV[[\x80\x82\x11\x15a!\xE3W_\x81_\x90UP`\x01\x01a!\xCDV[P\x90V[[\x80\x82\x11\x15a!\xFEW_\x81_\x90UP`\x01\x01a!\xE8V[P\x90V[[\x80\x82\x11\x15a\")W__\x82\x01_\x90U`\x01\x82\x01_\x90U`\x02\x82\x01_\x90UP`\x03\x01a\"\x03V[P\x90V[__\xFD[__\xFD[_\x81\x90P\x91\x90PV[a\"G\x81a\"5V[\x81\x14a\"QW__\xFD[PV[_\x815\x90Pa\"b\x81a\">V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\"}Wa\"|a\"-V[[_a\"\x8A\x84\x82\x85\x01a\"TV[\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[a\"\xA5\x81a\"\x93V[\x81\x14a\"\xAFW__\xFD[PV[_\x815\x90Pa\"\xC0\x81a\"\x9CV[\x92\x91PPV[__`@\x83\x85\x03\x12\x15a\"\xDCWa\"\xDBa\"-V[[_a\"\xE9\x85\x82\x86\x01a\"TV[\x92PP` a\"\xFA\x85\x82\x86\x01a\"\xB2V[\x91PP\x92P\x92\x90PV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a#-\x82a#\x04V[\x90P\x91\x90PV[a#=\x81a##V[\x82RPPV[_` \x82\x01\x90Pa#V_\x83\x01\x84a#4V[\x92\x91PPV[a#e\x81a\"5V[\x82RPPV[_`\xE0\x82\x01\x90Pa#~_\x83\x01\x8Aa#\\V[a#\x8B` \x83\x01\x89a#\\V[a#\x98`@\x83\x01\x88a#\\V[a#\xA5``\x83\x01\x87a#\\V[a#\xB2`\x80\x83\x01\x86a#\\V[a#\xBF`\xA0\x83\x01\x85a#\\V[a#\xCC`\xC0\x83\x01\x84a#\\V[\x98\x97PPPPPPPPV[_\x81\x90P\x91\x90PV[_a#\xFBa#\xF6a#\xF1\x84a#\x04V[a#\xD8V[a#\x04V[\x90P\x91\x90PV[_a$\x0C\x82a#\xE1V[\x90P\x91\x90PV[_a$\x1D\x82a$\x02V[\x90P\x91\x90PV[a$-\x81a$\x13V[\x82RPPV[_` \x82\x01\x90Pa$F_\x83\x01\x84a$$V[\x92\x91PPV[a$U\x81a##V[\x81\x14a$_W__\xFD[PV[_\x815\x90Pa$p\x81a$LV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a$\x8BWa$\x8Aa\"-V[[_a$\x98\x84\x82\x85\x01a$bV[\x91PP\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[a$\xB5\x81a$\xA1V[\x82RPPV[_` \x82\x01\x90Pa$\xCE_\x83\x01\x84a$\xACV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a$\xE9Wa$\xE8a\"-V[[_a$\xF6\x84\x82\x85\x01a\"\xB2V[\x91PP\x92\x91PPV[_` \x82\x01\x90Pa%\x12_\x83\x01\x84a#\\V[\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a%4\x81a%\x18V[\x82RPPV[_` \x82\x01\x90Pa%M_\x83\x01\x84a%+V[\x92\x91PPV[a%\\\x81a\"\x93V[\x82RPPV[_` \x82\x01\x90Pa%u_\x83\x01\x84a%SV[\x92\x91PPV[__\xFD[__\xFD[__\xFD[__\x83`\x1F\x84\x01\x12a%\x9CWa%\x9Ba%{V[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a%\xB9Wa%\xB8a%\x7FV[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15a%\xD5Wa%\xD4a%\x83V[[\x92P\x92\x90PV[____``\x85\x87\x03\x12\x15a%\xF4Wa%\xF3a\"-V[[_a&\x01\x87\x82\x88\x01a$bV[\x94PP` a&\x12\x87\x82\x88\x01a\"TV[\x93PP`@\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a&3Wa&2a\"1V[[a&?\x87\x82\x88\x01a%\x87V[\x92P\x92PP\x92\x95\x91\x94P\x92PV[_a&W\x82a$\x02V[\x90P\x91\x90PV[a&g\x81a&MV[\x82RPPV[_` \x82\x01\x90Pa&\x80_\x83\x01\x84a&^V[\x92\x91PPV[__\xFD[_``\x82\x84\x03\x12\x15a&\x9FWa&\x9Ea&\x86V[[\x81\x90P\x92\x91PPV[_``\x82\x84\x03\x12\x15a&\xBDWa&\xBCa\"-V[[_a&\xCA\x84\x82\x85\x01a&\x8AV[\x91PP\x92\x91PPV[_``\x82\x01\x90Pa&\xE6_\x83\x01\x86a#\\V[a&\xF3` \x83\x01\x85a#\\V[a'\0`@\x83\x01\x84a#\\V[\x94\x93PPPPV[____`\xA0\x85\x87\x03\x12\x15a' Wa'\x1Fa\"-V[[_a'-\x87\x82\x88\x01a&\x8AV[\x94PP``\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a'NWa'Ma\"1V[[a'Z\x87\x82\x88\x01a%\x87V[\x93P\x93PP`\x80a'm\x87\x82\x88\x01a$bV[\x91PP\x92\x95\x91\x94P\x92PV[_a'\x83\x82a$\x02V[\x90P\x91\x90PV[a'\x93\x81a'yV[\x82RPPV[_` \x82\x01\x90Pa'\xAC_\x83\x01\x84a'\x8AV[\x92\x91PPV[a'\xBB\x81a%\x18V[\x81\x14a'\xC5W__\xFD[PV[_\x815\x90Pa'\xD6\x81a'\xB2V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a'\xF1Wa'\xF0a\"-V[[_a'\xFE\x84\x82\x85\x01a'\xC8V[\x91PP\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7FOwnable: caller is not the owner_\x82\x01RPV[_a(K` \x83a(\x07V[\x91Pa(V\x82a(\x17V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra(x\x81a(?V[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x7Ftee program already exists\0\0\0\0\0\0_\x82\x01RPV[_a(\xE0`\x1A\x83a(\x07V[\x91Pa(\xEB\x82a(\xACV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra)\r\x81a(\xD4V[\x90P\x91\x90PV[\x7Fcannot remove tee program while _\x82\x01R\x7Fassertion is pending\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a)n`4\x83a(\x07V[\x91Pa)y\x82a)\x14V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra)\x9B\x81a)bV[\x90P\x91\x90PV[\x7Fcannot close challenge window - _\x82\x01R\x7Ftoo many assertions\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a)\xFC`3\x83a(\x07V[\x91Pa*\x07\x82a)\xA2V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra*)\x81a)\xF0V[\x90P\x91\x90PV[_\x81Q\x90Pa*>\x81a'\xB2V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a*YWa*Xa\"-V[[_a*f\x84\x82\x85\x01a*0V[\x91PP\x92\x91PPV[\x7Fcannot close challenge window - _\x82\x01R\x7Finsufficient time has passed\0\0\0\0` \x82\x01RPV[_a*\xC9`<\x83a(\x07V[\x91Pa*\xD4\x82a*oV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra*\xF6\x81a*\xBDV[\x90P\x91\x90PV[_`@\x82\x01\x90Pa+\x10_\x83\x01\x85a#\\V[a+\x1D` \x83\x01\x84a#\\V[\x93\x92PPPV[_\x81Q\x90Pa+2\x81a\"\x9CV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a+MWa+La\"-V[[_a+Z\x84\x82\x85\x01a+$V[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a+\x9A\x82a\"\x93V[\x91Pa+\xA5\x83a\"\x93V[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15a+\xBDWa+\xBCa+cV[[\x92\x91PPV[_\x81Q\x90Pa+\xD1\x81a\">V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a+\xECWa+\xEBa\"-V[[_a+\xF9\x84\x82\x85\x01a+\xC3V[\x91PP\x92\x91PPV[_a,\x0C\x82a%\x18V[\x91Pa,\x17\x83a%\x18V[\x92P\x82\x82\x01\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a,7Wa,6a+cV[[\x92\x91PPV[\x7Ftodo: validate zk zkProof\0\0\0\0\0\0\0_\x82\x01RPV[_a,q`\x19\x83a(\x07V[\x91Pa,|\x82a,=V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra,\x9E\x81a,eV[\x90P\x91\x90PV[\x7Fkey already added\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a,\xD9`\x11\x83a(\x07V[\x91Pa,\xE4\x82a,\xA5V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra-\x06\x81a,\xCDV[\x90P\x91\x90PV[_a-\x17\x82a\"\x93V[\x91P_\x82\x03a-)Wa-(a+cV[[`\x01\x82\x03\x90P\x91\x90PV[\x7Fchallenge does not exist\0\0\0\0\0\0\0\0_\x82\x01RPV[_a-h`\x18\x83a(\x07V[\x91Pa-s\x82a-4V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra-\x95\x81a-\\V[\x90P\x91\x90PV[_\x815a-\xA8\x81a\">V[\x80\x91PP\x91\x90PV[_\x81_\x1B\x90P\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa-\xE7\x84a-\xB1V[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_a.\x07\x82a\"5V[\x90P\x91\x90PV[_\x81_\x1C\x90P\x91\x90PV[_a.#\x82a.\x0EV[\x90P\x91\x90PV[a.3\x82a-\xFDV[a.Fa.?\x82a.\x19V[\x83Ta-\xBCV[\x82UPPPV[_\x81\x01_\x83\x01\x80a.]\x81a-\x9CV[\x90Pa.i\x81\x84a.*V[PPP`\x01\x81\x01` \x83\x01\x80a.~\x81a-\x9CV[\x90Pa.\x8A\x81\x84a.*V[PPP`\x02\x81\x01`@\x83\x01\x80a.\x9F\x81a-\x9CV[\x90Pa.\xAB\x81\x84a.*V[PPPPPV[a.\xBC\x82\x82a.MV[PPV[_a.\xCE` \x84\x01\x84a\"TV[\x90P\x92\x91PPV[a.\xDF\x81a\"5V[\x82RPPV[``\x82\x01a.\xF5_\x83\x01\x83a.\xC0V[a/\x01_\x85\x01\x82a.\xD6V[Pa/\x0F` \x83\x01\x83a.\xC0V[a/\x1C` \x85\x01\x82a.\xD6V[Pa/*`@\x83\x01\x83a.\xC0V[a/7`@\x85\x01\x82a.\xD6V[PPPPV[_``\x82\x01\x90Pa/P_\x83\x01\x84a.\xE5V[\x92\x91PPV[\x7Fassertion not found\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a/\x8A`\x13\x83a(\x07V[\x91Pa/\x95\x82a/VV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra/\xB7\x81a/~V[\x90P\x91\x90PV[\x7Fcannot update config hash while _\x82\x01R\x7Fassertions are pending\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a0\x18`6\x83a(\x07V[\x91Pa0#\x82a/\xBEV[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra0E\x81a0\x0CV[\x90P\x91\x90PV[\x7Finvalid signature length\0\0\0\0\0\0\0\0_\x82\x01RPV[_a0\x80`\x18\x83a(\x07V[\x91Pa0\x8B\x82a0LV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra0\xAD\x81a0tV[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a0\xCEa0\xC9\x82a\"5V[a0\xB4V[\x82RPPV[_a0\xDF\x82\x86a0\xBDV[` \x82\x01\x91Pa0\xEF\x82\x85a0\xBDV[` \x82\x01\x91Pa0\xFF\x82\x84a0\xBDV[` \x82\x01\x91P\x81\x90P\x94\x93PPPPV[\x7Finvalid tee signature\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a1D`\x15\x83a(\x07V[\x91Pa1O\x82a1\x10V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra1q\x81a18V[\x90P\x91\x90PV[\x7Fappchain block hash unchanged\0\0\0_\x82\x01RPV[_a1\xAC`\x1D\x83a(\x07V[\x91Pa1\xB7\x82a1xV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra1\xD9\x81a1\xA0V[\x90P\x91\x90PV[\x7Fassertion already exists\0\0\0\0\0\0\0\0_\x82\x01RPV[_a2\x14`\x18\x83a(\x07V[\x91Pa2\x1F\x82a1\xE0V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra2A\x81a2\x08V[\x90P\x91\x90PV[_a2R\x82a\"\x93V[\x91Pa2]\x83a\"\x93V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a2uWa2ta+cV[[\x92\x91PPV[_\x81\x90P\x92\x91PPV[PV[_a2\x93_\x83a2{V[\x91Pa2\x9E\x82a2\x85V[_\x82\x01\x90P\x91\x90PV[_a2\xB2\x82a2\x88V[\x91P\x81\x90P\x91\x90PV[\x7Fpayment failed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a2\xF0`\x0E\x83a(\x07V[\x91Pa2\xFB\x82a2\xBCV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra3\x1D\x81a2\xE4V[\x90P\x91\x90PV[\x7Fcannot update challenge window w_\x82\x01R\x7Fhile assertion is pending\0\0\0\0\0\0\0` \x82\x01RPV[_a3~`9\x83a(\x07V[\x91Pa3\x89\x82a3$V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra3\xAB\x81a3rV[\x90P\x91\x90PV[\x7FOwnable: new owner is the zero a_\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01RPV[_a4\x0C`&\x83a(\x07V[\x91Pa4\x17\x82a3\xB2V[`@\x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra49\x81a4\0V[\x90P\x91\x90PV[_a4K\x82\x8Aa0\xBDV[` \x82\x01\x91Pa4[\x82\x89a0\xBDV[` \x82\x01\x91Pa4k\x82\x88a0\xBDV[` \x82\x01\x91Pa4{\x82\x87a0\xBDV[` \x82\x01\x91Pa4\x8B\x82\x86a0\xBDV[` \x82\x01\x91Pa4\x9B\x82\x85a0\xBDV[` \x82\x01\x91Pa4\xAB\x82\x84a0\xBDV[` \x82\x01\x91P\x81\x90P\x98\x97PPPPPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[_`\xFF\x82\x16\x90P\x91\x90PV[a5\x02\x81a4\xEDV[\x82RPPV[_`\x80\x82\x01\x90Pa5\x1B_\x83\x01\x87a#\\V[a5(` \x83\x01\x86a4\xF9V[a55`@\x83\x01\x85a#\\V[a5B``\x83\x01\x84a#\\V[\x95\x94PPPPPV",
    );
    /**```solidity
struct PendingAssertion { bytes32 blockHash; bytes32 sendRoot; bytes32 seqBlockHash; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PendingAssertion {
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sendRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqBlockHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PendingAssertion> for UnderlyingRustTuple<'_> {
            fn from(value: PendingAssertion) -> Self {
                (value.blockHash, value.sendRoot, value.seqBlockHash)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PendingAssertion {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    blockHash: tuple.0,
                    sendRoot: tuple.1,
                    seqBlockHash: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for PendingAssertion {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for PendingAssertion {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.sendRoot),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.seqBlockHash),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for PendingAssertion {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for PendingAssertion {
            const NAME: &'static str = "PendingAssertion";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "PendingAssertion(bytes32 blockHash,bytes32 sendRoot,bytes32 seqBlockHash)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.blockHash)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.sendRoot)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.seqBlockHash)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for PendingAssertion {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.blockHash,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sendRoot,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.seqBlockHash,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.blockHash,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sendRoot,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.seqBlockHash,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignature()` and selector `0xf645eedf`.
```solidity
error ECDSAInvalidSignature();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignature {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignature()";
            const SELECTOR: [u8; 4] = [246u8, 69u8, 238u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureLength(uint256)` and selector `0xfce698f7`.
```solidity
error ECDSAInvalidSignatureLength(uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureLength {
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureLength) -> Self {
                (value.length,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ECDSAInvalidSignatureLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { length: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureLength(uint256)";
            const SELECTOR: [u8; 4] = [252u8, 230u8, 152u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureS(bytes32)` and selector `0xd78bce0c`.
```solidity
error ECDSAInvalidSignatureS(bytes32 s);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureS {
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureS> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureS) -> Self {
                (value.s,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignatureS {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { s: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureS {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureS(bytes32)";
            const SELECTOR: [u8; 4] = [215u8, 139u8, 206u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
        }
    };
    /**Event with signature `ChallengeResolved((bytes32,bytes32,bytes32))` and selector `0xe42eaf0737e2478a5f5aed3a0610ae7b09a27cbac9ad6a5cc4d68f78afd1425b`.
```solidity
event ChallengeResolved(PendingAssertion);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ChallengeResolved {
        #[allow(missing_docs)]
        pub _0: <PendingAssertion as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ChallengeResolved {
            type DataTuple<'a> = (PendingAssertion,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ChallengeResolved((bytes32,bytes32,bytes32))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                228u8,
                46u8,
                175u8,
                7u8,
                55u8,
                226u8,
                71u8,
                138u8,
                95u8,
                90u8,
                237u8,
                58u8,
                6u8,
                16u8,
                174u8,
                123u8,
                9u8,
                162u8,
                124u8,
                186u8,
                201u8,
                173u8,
                106u8,
                92u8,
                196u8,
                214u8,
                143u8,
                120u8,
                175u8,
                209u8,
                66u8,
                91u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { _0: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (<PendingAssertion as alloy_sol_types::SolType>::tokenize(&self._0),)
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ChallengeResolved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ChallengeResolved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ChallengeResolved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeAppchainConfigHash(bytes32,bytes32)` and selector `0xc985bccbd0c90e197f4a7373020a33ba6ff864d0399fd7d65c5c7c32ffb015ec`.
```solidity
event TeeAppchainConfigHash(bytes32 configHash, bytes32 blockHash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeAppchainConfigHash {
        #[allow(missing_docs)]
        pub configHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeAppchainConfigHash {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeAppchainConfigHash(bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                201u8,
                133u8,
                188u8,
                203u8,
                208u8,
                201u8,
                14u8,
                25u8,
                127u8,
                74u8,
                115u8,
                115u8,
                2u8,
                10u8,
                51u8,
                186u8,
                111u8,
                248u8,
                100u8,
                208u8,
                57u8,
                159u8,
                215u8,
                214u8,
                92u8,
                92u8,
                124u8,
                50u8,
                255u8,
                176u8,
                21u8,
                236u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    configHash: data.0,
                    blockHash: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.configHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockHash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeAppchainConfigHash {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeAppchainConfigHash> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeAppchainConfigHash) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeHacked(uint256)` and selector `0x37e8add694c5926d564e971160f5974103cbbbc7c90747c4c6f802031d3567a7`.
```solidity
event TeeHacked(uint256);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeHacked {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeHacked {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeHacked(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                55u8,
                232u8,
                173u8,
                214u8,
                148u8,
                197u8,
                146u8,
                109u8,
                86u8,
                78u8,
                151u8,
                17u8,
                96u8,
                245u8,
                151u8,
                65u8,
                3u8,
                203u8,
                187u8,
                199u8,
                201u8,
                7u8,
                71u8,
                196u8,
                198u8,
                248u8,
                2u8,
                3u8,
                29u8,
                53u8,
                103u8,
                167u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { _0: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeHacked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeHacked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeHacked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeKeysRevoked()` and selector `0xeca62e0074a13a90d600f003b7cb8d5bd50100008d3f3915f2554f3f8552c5cc`.
```solidity
event TeeKeysRevoked();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeKeysRevoked {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeKeysRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeKeysRevoked()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                236u8,
                166u8,
                46u8,
                0u8,
                116u8,
                161u8,
                58u8,
                144u8,
                214u8,
                0u8,
                240u8,
                3u8,
                183u8,
                203u8,
                141u8,
                91u8,
                213u8,
                1u8,
                0u8,
                0u8,
                141u8,
                63u8,
                57u8,
                21u8,
                242u8,
                85u8,
                79u8,
                63u8,
                133u8,
                82u8,
                197u8,
                204u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeKeysRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeKeysRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeKeysRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeProgramAdded(bytes32)` and selector `0x9a7a6469c25cf017890607695e4a149cc771f294fd871e2080d24cd109033ab6`.
```solidity
event TeeProgramAdded(bytes32 hash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeProgramAdded {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeProgramAdded {
            type DataTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeProgramAdded(bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                154u8,
                122u8,
                100u8,
                105u8,
                194u8,
                92u8,
                240u8,
                23u8,
                137u8,
                6u8,
                7u8,
                105u8,
                94u8,
                74u8,
                20u8,
                156u8,
                199u8,
                113u8,
                242u8,
                148u8,
                253u8,
                135u8,
                30u8,
                32u8,
                128u8,
                210u8,
                76u8,
                209u8,
                9u8,
                3u8,
                58u8,
                182u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { hash: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeProgramAdded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeProgramAdded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeProgramAdded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeProgramRemoved(bytes32)` and selector `0x2621c61d3315f2a3d26b22d746ba21a96d249f51ada323f7226cce5fe5fc3d64`.
```solidity
event TeeProgramRemoved(bytes32 hash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeProgramRemoved {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeProgramRemoved {
            type DataTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeProgramRemoved(bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                38u8,
                33u8,
                198u8,
                29u8,
                51u8,
                21u8,
                242u8,
                163u8,
                210u8,
                107u8,
                34u8,
                215u8,
                70u8,
                186u8,
                33u8,
                169u8,
                109u8,
                36u8,
                159u8,
                81u8,
                173u8,
                163u8,
                35u8,
                247u8,
                34u8,
                108u8,
                206u8,
                95u8,
                229u8,
                252u8,
                61u8,
                100u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { hash: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeProgramRemoved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeProgramRemoved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeProgramRemoved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeSeqConfigHash(bytes32,bytes32)` and selector `0xb9eb20b32fac965884cb58326102257cae604504f0a36cd1008a32845ad5c29b`.
```solidity
event TeeSeqConfigHash(bytes32 configHash, bytes32 blockHash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeSeqConfigHash {
        #[allow(missing_docs)]
        pub configHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeSeqConfigHash {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeSeqConfigHash(bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                185u8,
                235u8,
                32u8,
                179u8,
                47u8,
                172u8,
                150u8,
                88u8,
                132u8,
                203u8,
                88u8,
                50u8,
                97u8,
                2u8,
                37u8,
                124u8,
                174u8,
                96u8,
                69u8,
                4u8,
                240u8,
                163u8,
                108u8,
                209u8,
                0u8,
                138u8,
                50u8,
                132u8,
                90u8,
                213u8,
                194u8,
                155u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    configHash: data.0,
                    blockHash: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.configHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockHash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeSeqConfigHash {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeSeqConfigHash> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeSeqConfigHash) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address poster_, address bridge_, bytes32 appchainConfigHash_, bytes32 appchainStartBlockHash_, bytes32 seqConfigHash_, bytes32 seqStartBlockHash_, bytes32 l1StartBlockHash_, address l1block_, uint64 challengeWindowDuration_, bytes32 teeProgram);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub poster_: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub bridge_: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub appchainStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1StartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1block_: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub challengeWindowDuration_: u64,
        #[allow(missing_docs)]
        pub teeProgram: alloy::sol_types::private::FixedBytes<32>,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
                u64,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value.poster_,
                        value.bridge_,
                        value.appchainConfigHash_,
                        value.appchainStartBlockHash_,
                        value.seqConfigHash_,
                        value.seqStartBlockHash_,
                        value.l1StartBlockHash_,
                        value.l1block_,
                        value.challengeWindowDuration_,
                        value.teeProgram,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        poster_: tuple.0,
                        bridge_: tuple.1,
                        appchainConfigHash_: tuple.2,
                        appchainStartBlockHash_: tuple.3,
                        seqConfigHash_: tuple.4,
                        seqStartBlockHash_: tuple.5,
                        l1StartBlockHash_: tuple.6,
                        l1block_: tuple.7,
                        challengeWindowDuration_: tuple.8,
                        teeProgram: tuple.9,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.poster_,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge_,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainConfigHash_),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.appchainStartBlockHash_,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.seqConfigHash_),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.seqStartBlockHash_),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.l1StartBlockHash_),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.l1block_,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.challengeWindowDuration_,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.teeProgram),
                )
            }
        }
    };
    /**Function with signature `addTeeKey(address,bytes32,bytes)` and selector `0x70646ea2`.
```solidity
function addTeeKey(address publicKey, bytes32 programHash, bytes memory zkProof) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addTeeKeyCall {
        #[allow(missing_docs)]
        pub publicKey: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub programHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub zkProof: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`addTeeKey(address,bytes32,bytes)`](addTeeKeyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addTeeKeyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addTeeKeyCall> for UnderlyingRustTuple<'_> {
                fn from(value: addTeeKeyCall) -> Self {
                    (value.publicKey, value.programHash, value.zkProof)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addTeeKeyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        publicKey: tuple.0,
                        programHash: tuple.1,
                        zkProof: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addTeeKeyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addTeeKeyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addTeeKeyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addTeeKeyCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addTeeKeyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addTeeKey(address,bytes32,bytes)";
            const SELECTOR: [u8; 4] = [112u8, 100u8, 110u8, 162u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.publicKey,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.programHash),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.zkProof,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `addTeeProgram(bytes32)` and selector `0x1c12427f`.
```solidity
function addTeeProgram(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addTeeProgramCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`addTeeProgram(bytes32)`](addTeeProgramCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addTeeProgramReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addTeeProgramCall> for UnderlyingRustTuple<'_> {
                fn from(value: addTeeProgramCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addTeeProgramCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addTeeProgramReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addTeeProgramReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addTeeProgramReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addTeeProgramCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addTeeProgramReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addTeeProgram(bytes32)";
            const SELECTOR: [u8; 4] = [28u8, 18u8, 66u8, 127u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridge()` and selector `0xe78cea92`.
```solidity
function bridge() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeCall {}
    ///Container type for the return parameters of the [`bridge()`](bridgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridge()";
            const SELECTOR: [u8; 4] = [231u8, 140u8, 234u8, 146u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `challengeWindowDuration()` and selector `0x4bd167c9`.
```solidity
function challengeWindowDuration() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowDurationCall {}
    ///Container type for the return parameters of the [`challengeWindowDuration()`](challengeWindowDurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowDurationReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowDurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowDurationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowDurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowDurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowDurationReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowDurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for challengeWindowDurationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = challengeWindowDurationReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "challengeWindowDuration()";
            const SELECTOR: [u8; 4] = [75u8, 209u8, 103u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `challengeWindowEnd()` and selector `0xee1c28b8`.
```solidity
function challengeWindowEnd() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowEndCall {}
    ///Container type for the return parameters of the [`challengeWindowEnd()`](challengeWindowEndCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowEndReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowEndCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowEndCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowEndCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowEndReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowEndReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowEndReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for challengeWindowEndCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = challengeWindowEndReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "challengeWindowEnd()";
            const SELECTOR: [u8; 4] = [238u8, 28u8, 40u8, 184u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `closeChallengeWindow()` and selector `0x6c4c2060`.
```solidity
function closeChallengeWindow() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct closeChallengeWindowCall {}
    ///Container type for the return parameters of the [`closeChallengeWindow()`](closeChallengeWindowCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct closeChallengeWindowReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<closeChallengeWindowCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: closeChallengeWindowCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for closeChallengeWindowCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<closeChallengeWindowReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: closeChallengeWindowReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for closeChallengeWindowReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for closeChallengeWindowCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = closeChallengeWindowReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "closeChallengeWindow()";
            const SELECTOR: [u8; 4] = [108u8, 76u8, 32u8, 96u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isTeeKey(address)` and selector `0x47742640`.
```solidity
function isTeeKey(address) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isTeeKeyCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isTeeKey(address)`](isTeeKeyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isTeeKeyReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isTeeKeyCall> for UnderlyingRustTuple<'_> {
                fn from(value: isTeeKeyCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isTeeKeyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isTeeKeyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isTeeKeyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isTeeKeyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isTeeKeyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isTeeKeyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isTeeKey(address)";
            const SELECTOR: [u8; 4] = [71u8, 116u8, 38u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `l1block()` and selector `0x420caf3a`.
```solidity
function l1block() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct l1blockCall {}
    ///Container type for the return parameters of the [`l1block()`](l1blockCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct l1blockReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<l1blockCall> for UnderlyingRustTuple<'_> {
                fn from(value: l1blockCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for l1blockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<l1blockReturn> for UnderlyingRustTuple<'_> {
                fn from(value: l1blockReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for l1blockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for l1blockCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = l1blockReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "l1block()";
            const SELECTOR: [u8; 4] = [66u8, 12u8, 175u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall {}
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pendingAssertions(uint256)` and selector `0xa56ec6cd`.
```solidity
function pendingAssertions(uint256) external view returns (bytes32 blockHash, bytes32 sendRoot, bytes32 seqBlockHash);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingAssertionsCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`pendingAssertions(uint256)`](pendingAssertionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingAssertionsReturn {
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sendRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqBlockHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingAssertionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: pendingAssertionsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pendingAssertionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingAssertionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: pendingAssertionsReturn) -> Self {
                    (value.blockHash, value.sendRoot, value.seqBlockHash)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pendingAssertionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blockHash: tuple.0,
                        sendRoot: tuple.1,
                        seqBlockHash: tuple.2,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pendingAssertionsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pendingAssertionsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pendingAssertions(uint256)";
            const SELECTOR: [u8; 4] = [165u8, 110u8, 198u8, 205u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `poster()` and selector `0x80959721`.
```solidity
function poster() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct posterCall {}
    ///Container type for the return parameters of the [`poster()`](posterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct posterReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<posterCall> for UnderlyingRustTuple<'_> {
                fn from(value: posterCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for posterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<posterReturn> for UnderlyingRustTuple<'_> {
                fn from(value: posterReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for posterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for posterCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = posterReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "poster()";
            const SELECTOR: [u8; 4] = [128u8, 149u8, 151u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeTeeProgram(bytes32)` and selector `0x5f70c441`.
```solidity
function removeTeeProgram(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeTeeProgramCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`removeTeeProgram(bytes32)`](removeTeeProgramCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeTeeProgramReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeTeeProgramCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeTeeProgramCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeTeeProgramCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeTeeProgramReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeTeeProgramReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeTeeProgramReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeTeeProgramCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeTeeProgramReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeTeeProgram(bytes32)";
            const SELECTOR: [u8; 4] = [95u8, 112u8, 196u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall {}
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `resolveChallenge((bytes32,bytes32,bytes32))` and selector `0x8fed55a3`.
```solidity
function resolveChallenge(PendingAssertion memory assertion) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolveChallengeCall {
        #[allow(missing_docs)]
        pub assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`resolveChallenge((bytes32,bytes32,bytes32))`](resolveChallengeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolveChallengeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (PendingAssertion,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PendingAssertion as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolveChallengeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: resolveChallengeCall) -> Self {
                    (value.assertion,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resolveChallengeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { assertion: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolveChallengeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: resolveChallengeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resolveChallengeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for resolveChallengeCall {
            type Parameters<'a> = (PendingAssertion,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = resolveChallengeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "resolveChallenge((bytes32,bytes32,bytes32))";
            const SELECTOR: [u8; 4] = [143u8, 237u8, 85u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PendingAssertion as alloy_sol_types::SolType>::tokenize(
                        &self.assertion,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeAllTeeKeys()` and selector `0x6ef01201`.
```solidity
function revokeAllTeeKeys() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeAllTeeKeysCall {}
    ///Container type for the return parameters of the [`revokeAllTeeKeys()`](revokeAllTeeKeysCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeAllTeeKeysReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeAllTeeKeysCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: revokeAllTeeKeysCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for revokeAllTeeKeysCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeAllTeeKeysReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: revokeAllTeeKeysReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for revokeAllTeeKeysReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeAllTeeKeysCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeAllTeeKeysReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeAllTeeKeys()";
            const SELECTOR: [u8; 4] = [110u8, 240u8, 18u8, 1u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setAppchainConfigHash(bytes32)` and selector `0xf223055c`.
```solidity
function setAppchainConfigHash(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAppchainConfigHashCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`setAppchainConfigHash(bytes32)`](setAppchainConfigHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAppchainConfigHashReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAppchainConfigHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAppchainConfigHashCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAppchainConfigHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAppchainConfigHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAppchainConfigHashReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAppchainConfigHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setAppchainConfigHashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setAppchainConfigHashReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setAppchainConfigHash(bytes32)";
            const SELECTOR: [u8; 4] = [242u8, 35u8, 5u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setChallengeWindowDuration(uint64)` and selector `0xeb60553a`.
```solidity
function setChallengeWindowDuration(uint64 duration) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setChallengeWindowDurationCall {
        #[allow(missing_docs)]
        pub duration: u64,
    }
    ///Container type for the return parameters of the [`setChallengeWindowDuration(uint64)`](setChallengeWindowDurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setChallengeWindowDurationReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setChallengeWindowDurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setChallengeWindowDurationCall) -> Self {
                    (value.duration,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setChallengeWindowDurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { duration: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setChallengeWindowDurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setChallengeWindowDurationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setChallengeWindowDurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setChallengeWindowDurationCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setChallengeWindowDurationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setChallengeWindowDuration(uint64)";
            const SELECTOR: [u8; 4] = [235u8, 96u8, 85u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.duration),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setSeqConfigHash(bytes32)` and selector `0xc3f2dbd3`.
```solidity
function setSeqConfigHash(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSeqConfigHashCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`setSeqConfigHash(bytes32)`](setSeqConfigHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSeqConfigHashReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSeqConfigHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setSeqConfigHashCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setSeqConfigHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSeqConfigHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setSeqConfigHashReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setSeqConfigHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setSeqConfigHashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setSeqConfigHashReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setSeqConfigHash(bytes32)";
            const SELECTOR: [u8; 4] = [195u8, 242u8, 219u8, 211u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `submitAssertion((bytes32,bytes32,bytes32),bytes,address)` and selector `0xe50c6156`.
```solidity
function submitAssertion(PendingAssertion memory assertion, bytes memory signature, address rewardAddr) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitAssertionCall {
        #[allow(missing_docs)]
        pub assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub signature: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub rewardAddr: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`submitAssertion((bytes32,bytes32,bytes32),bytes,address)`](submitAssertionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitAssertionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                PendingAssertion,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PendingAssertion as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitAssertionCall> for UnderlyingRustTuple<'_> {
                fn from(value: submitAssertionCall) -> Self {
                    (value.assertion, value.signature, value.rewardAddr)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for submitAssertionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        assertion: tuple.0,
                        signature: tuple.1,
                        rewardAddr: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitAssertionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: submitAssertionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for submitAssertionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for submitAssertionCall {
            type Parameters<'a> = (
                PendingAssertion,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = submitAssertionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "submitAssertion((bytes32,bytes32,bytes32),bytes,address)";
            const SELECTOR: [u8; 4] = [229u8, 12u8, 97u8, 86u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PendingAssertion as alloy_sol_types::SolType>::tokenize(
                        &self.assertion,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.signature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rewardAddr,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teeHackCount()` and selector `0x697b5e62`.
```solidity
function teeHackCount() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeHackCountCall {}
    ///Container type for the return parameters of the [`teeHackCount()`](teeHackCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeHackCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeHackCountCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeHackCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeHackCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeHackCountReturn> for UnderlyingRustTuple<'_> {
                fn from(value: teeHackCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeHackCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeHackCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeHackCountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teeHackCount()";
            const SELECTOR: [u8; 4] = [105u8, 123u8, 94u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teeProgramKeys(bytes32,uint256)` and selector `0x33339006`.
```solidity
function teeProgramKeys(bytes32, uint256) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeProgramKeysCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`teeProgramKeys(bytes32,uint256)`](teeProgramKeysCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeProgramKeysReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeProgramKeysCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeProgramKeysCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeProgramKeysCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeProgramKeysReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: teeProgramKeysReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for teeProgramKeysReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeProgramKeysCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeProgramKeysReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teeProgramKeys(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [51u8, 51u8, 144u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teePrograms(uint256)` and selector `0x4afffcc9`.
```solidity
function teePrograms(uint256) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeProgramsCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`teePrograms(uint256)`](teeProgramsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeProgramsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeProgramsCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeProgramsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeProgramsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeProgramsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: teeProgramsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeProgramsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeProgramsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeProgramsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teePrograms(uint256)";
            const SELECTOR: [u8; 4] = [74u8, 255u8, 252u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teeTrustedInput()` and selector `0x3ceaae7d`.
```solidity
function teeTrustedInput() external view returns (bytes32 appchainConfigHash, bytes32 appchainStartBlockHash, bytes32 seqConfigHash, bytes32 seqStartBlockHash, bytes32 setDelayedMessageAcc, bytes32 l1StartBlockHash, bytes32 l1EndBlockHash);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeTrustedInputCall {}
    ///Container type for the return parameters of the [`teeTrustedInput()`](teeTrustedInputCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeTrustedInputReturn {
        #[allow(missing_docs)]
        pub appchainConfigHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub appchainStartBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqConfigHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqStartBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub setDelayedMessageAcc: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1StartBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1EndBlockHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeTrustedInputCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeTrustedInputCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeTrustedInputCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeTrustedInputReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: teeTrustedInputReturn) -> Self {
                    (
                        value.appchainConfigHash,
                        value.appchainStartBlockHash,
                        value.seqConfigHash,
                        value.seqStartBlockHash,
                        value.setDelayedMessageAcc,
                        value.l1StartBlockHash,
                        value.l1EndBlockHash,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for teeTrustedInputReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        appchainConfigHash: tuple.0,
                        appchainStartBlockHash: tuple.1,
                        seqConfigHash: tuple.2,
                        seqStartBlockHash: tuple.3,
                        setDelayedMessageAcc: tuple.4,
                        l1StartBlockHash: tuple.5,
                        l1EndBlockHash: tuple.6,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeTrustedInputCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeTrustedInputReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teeTrustedInput()";
            const SELECTOR: [u8; 4] = [60u8, 234u8, 174u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`TeeModule`](self) function calls.
    pub enum TeeModuleCalls {
        #[allow(missing_docs)]
        addTeeKey(addTeeKeyCall),
        #[allow(missing_docs)]
        addTeeProgram(addTeeProgramCall),
        #[allow(missing_docs)]
        bridge(bridgeCall),
        #[allow(missing_docs)]
        challengeWindowDuration(challengeWindowDurationCall),
        #[allow(missing_docs)]
        challengeWindowEnd(challengeWindowEndCall),
        #[allow(missing_docs)]
        closeChallengeWindow(closeChallengeWindowCall),
        #[allow(missing_docs)]
        isTeeKey(isTeeKeyCall),
        #[allow(missing_docs)]
        l1block(l1blockCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        pendingAssertions(pendingAssertionsCall),
        #[allow(missing_docs)]
        poster(posterCall),
        #[allow(missing_docs)]
        removeTeeProgram(removeTeeProgramCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        resolveChallenge(resolveChallengeCall),
        #[allow(missing_docs)]
        revokeAllTeeKeys(revokeAllTeeKeysCall),
        #[allow(missing_docs)]
        setAppchainConfigHash(setAppchainConfigHashCall),
        #[allow(missing_docs)]
        setChallengeWindowDuration(setChallengeWindowDurationCall),
        #[allow(missing_docs)]
        setSeqConfigHash(setSeqConfigHashCall),
        #[allow(missing_docs)]
        submitAssertion(submitAssertionCall),
        #[allow(missing_docs)]
        teeHackCount(teeHackCountCall),
        #[allow(missing_docs)]
        teeProgramKeys(teeProgramKeysCall),
        #[allow(missing_docs)]
        teePrograms(teeProgramsCall),
        #[allow(missing_docs)]
        teeTrustedInput(teeTrustedInputCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
    }
    #[automatically_derived]
    impl TeeModuleCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [28u8, 18u8, 66u8, 127u8],
            [51u8, 51u8, 144u8, 6u8],
            [60u8, 234u8, 174u8, 125u8],
            [66u8, 12u8, 175u8, 58u8],
            [71u8, 116u8, 38u8, 64u8],
            [74u8, 255u8, 252u8, 201u8],
            [75u8, 209u8, 103u8, 201u8],
            [95u8, 112u8, 196u8, 65u8],
            [105u8, 123u8, 94u8, 98u8],
            [108u8, 76u8, 32u8, 96u8],
            [110u8, 240u8, 18u8, 1u8],
            [112u8, 100u8, 110u8, 162u8],
            [113u8, 80u8, 24u8, 166u8],
            [128u8, 149u8, 151u8, 33u8],
            [141u8, 165u8, 203u8, 91u8],
            [143u8, 237u8, 85u8, 163u8],
            [165u8, 110u8, 198u8, 205u8],
            [195u8, 242u8, 219u8, 211u8],
            [229u8, 12u8, 97u8, 86u8],
            [231u8, 140u8, 234u8, 146u8],
            [235u8, 96u8, 85u8, 58u8],
            [238u8, 28u8, 40u8, 184u8],
            [242u8, 35u8, 5u8, 92u8],
            [242u8, 253u8, 227u8, 139u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for TeeModuleCalls {
        const NAME: &'static str = "TeeModuleCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 24usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::addTeeKey(_) => {
                    <addTeeKeyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addTeeProgram(_) => {
                    <addTeeProgramCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridge(_) => <bridgeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::challengeWindowDuration(_) => {
                    <challengeWindowDurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::challengeWindowEnd(_) => {
                    <challengeWindowEndCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::closeChallengeWindow(_) => {
                    <closeChallengeWindowCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isTeeKey(_) => <isTeeKeyCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::l1block(_) => <l1blockCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pendingAssertions(_) => {
                    <pendingAssertionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::poster(_) => <posterCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::removeTeeProgram(_) => {
                    <removeTeeProgramCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::resolveChallenge(_) => {
                    <resolveChallengeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeAllTeeKeys(_) => {
                    <revokeAllTeeKeysCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setAppchainConfigHash(_) => {
                    <setAppchainConfigHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setChallengeWindowDuration(_) => {
                    <setChallengeWindowDurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setSeqConfigHash(_) => {
                    <setSeqConfigHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::submitAssertion(_) => {
                    <submitAssertionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::teeHackCount(_) => {
                    <teeHackCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::teeProgramKeys(_) => {
                    <teeProgramKeysCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::teePrograms(_) => {
                    <teeProgramsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::teeTrustedInput(_) => {
                    <teeTrustedInputCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<TeeModuleCalls>] = &[
                {
                    fn addTeeProgram(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <addTeeProgramCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::addTeeProgram)
                    }
                    addTeeProgram
                },
                {
                    fn teeProgramKeys(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeProgramKeysCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teeProgramKeys)
                    }
                    teeProgramKeys
                },
                {
                    fn teeTrustedInput(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeTrustedInputCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teeTrustedInput)
                    }
                    teeTrustedInput
                },
                {
                    fn l1block(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <l1blockCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::l1block)
                    }
                    l1block
                },
                {
                    fn isTeeKey(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <isTeeKeyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::isTeeKey)
                    }
                    isTeeKey
                },
                {
                    fn teePrograms(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeProgramsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teePrograms)
                    }
                    teePrograms
                },
                {
                    fn challengeWindowDuration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <challengeWindowDurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::challengeWindowDuration)
                    }
                    challengeWindowDuration
                },
                {
                    fn removeTeeProgram(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <removeTeeProgramCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::removeTeeProgram)
                    }
                    removeTeeProgram
                },
                {
                    fn teeHackCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeHackCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teeHackCount)
                    }
                    teeHackCount
                },
                {
                    fn closeChallengeWindow(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <closeChallengeWindowCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::closeChallengeWindow)
                    }
                    closeChallengeWindow
                },
                {
                    fn revokeAllTeeKeys(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <revokeAllTeeKeysCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::revokeAllTeeKeys)
                    }
                    revokeAllTeeKeys
                },
                {
                    fn addTeeKey(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <addTeeKeyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::addTeeKey)
                    }
                    addTeeKey
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn poster(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <posterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::poster)
                    }
                    poster
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::owner)
                    }
                    owner
                },
                {
                    fn resolveChallenge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <resolveChallengeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::resolveChallenge)
                    }
                    resolveChallenge
                },
                {
                    fn pendingAssertions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <pendingAssertionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::pendingAssertions)
                    }
                    pendingAssertions
                },
                {
                    fn setSeqConfigHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <setSeqConfigHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::setSeqConfigHash)
                    }
                    setSeqConfigHash
                },
                {
                    fn submitAssertion(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <submitAssertionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::submitAssertion)
                    }
                    submitAssertion
                },
                {
                    fn bridge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <bridgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::bridge)
                    }
                    bridge
                },
                {
                    fn setChallengeWindowDuration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <setChallengeWindowDurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::setChallengeWindowDuration)
                    }
                    setChallengeWindowDuration
                },
                {
                    fn challengeWindowEnd(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <challengeWindowEndCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::challengeWindowEnd)
                    }
                    challengeWindowEnd
                },
                {
                    fn setAppchainConfigHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <setAppchainConfigHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::setAppchainConfigHash)
                    }
                    setAppchainConfigHash
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::transferOwnership)
                    }
                    transferOwnership
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::addTeeKey(inner) => {
                    <addTeeKeyCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::addTeeProgram(inner) => {
                    <addTeeProgramCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridge(inner) => {
                    <bridgeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::challengeWindowDuration(inner) => {
                    <challengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::challengeWindowEnd(inner) => {
                    <challengeWindowEndCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::closeChallengeWindow(inner) => {
                    <closeChallengeWindowCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isTeeKey(inner) => {
                    <isTeeKeyCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::l1block(inner) => {
                    <l1blockCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pendingAssertions(inner) => {
                    <pendingAssertionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::poster(inner) => {
                    <posterCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::removeTeeProgram(inner) => {
                    <removeTeeProgramCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::resolveChallenge(inner) => {
                    <resolveChallengeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeAllTeeKeys(inner) => {
                    <revokeAllTeeKeysCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setAppchainConfigHash(inner) => {
                    <setAppchainConfigHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setChallengeWindowDuration(inner) => {
                    <setChallengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setSeqConfigHash(inner) => {
                    <setSeqConfigHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::submitAssertion(inner) => {
                    <submitAssertionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::teeHackCount(inner) => {
                    <teeHackCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::teeProgramKeys(inner) => {
                    <teeProgramKeysCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::teePrograms(inner) => {
                    <teeProgramsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::teeTrustedInput(inner) => {
                    <teeTrustedInputCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::addTeeKey(inner) => {
                    <addTeeKeyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addTeeProgram(inner) => {
                    <addTeeProgramCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridge(inner) => {
                    <bridgeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::challengeWindowDuration(inner) => {
                    <challengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::challengeWindowEnd(inner) => {
                    <challengeWindowEndCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::closeChallengeWindow(inner) => {
                    <closeChallengeWindowCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isTeeKey(inner) => {
                    <isTeeKeyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::l1block(inner) => {
                    <l1blockCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pendingAssertions(inner) => {
                    <pendingAssertionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::poster(inner) => {
                    <posterCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::removeTeeProgram(inner) => {
                    <removeTeeProgramCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::resolveChallenge(inner) => {
                    <resolveChallengeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeAllTeeKeys(inner) => {
                    <revokeAllTeeKeysCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setAppchainConfigHash(inner) => {
                    <setAppchainConfigHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setChallengeWindowDuration(inner) => {
                    <setChallengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setSeqConfigHash(inner) => {
                    <setSeqConfigHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::submitAssertion(inner) => {
                    <submitAssertionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::teeHackCount(inner) => {
                    <teeHackCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::teeProgramKeys(inner) => {
                    <teeProgramKeysCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::teePrograms(inner) => {
                    <teeProgramsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::teeTrustedInput(inner) => {
                    <teeTrustedInputCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`TeeModule`](self) custom errors.
    pub enum TeeModuleErrors {
        #[allow(missing_docs)]
        ECDSAInvalidSignature(ECDSAInvalidSignature),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureLength(ECDSAInvalidSignatureLength),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureS(ECDSAInvalidSignatureS),
    }
    #[automatically_derived]
    impl TeeModuleErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [215u8, 139u8, 206u8, 12u8],
            [246u8, 69u8, 238u8, 223u8],
            [252u8, 230u8, 152u8, 247u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for TeeModuleErrors {
        const NAME: &'static str = "TeeModuleErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 3usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ECDSAInvalidSignature(_) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureLength(_) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureS(_) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<TeeModuleErrors>] = &[
                {
                    fn ECDSAInvalidSignatureS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::ECDSAInvalidSignatureS)
                    }
                    ECDSAInvalidSignatureS
                },
                {
                    fn ECDSAInvalidSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::ECDSAInvalidSignature)
                    }
                    ECDSAInvalidSignature
                },
                {
                    fn ECDSAInvalidSignatureLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::ECDSAInvalidSignatureLength)
                    }
                    ECDSAInvalidSignatureLength
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`TeeModule`](self) events.
    pub enum TeeModuleEvents {
        #[allow(missing_docs)]
        ChallengeResolved(ChallengeResolved),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
        #[allow(missing_docs)]
        TeeAppchainConfigHash(TeeAppchainConfigHash),
        #[allow(missing_docs)]
        TeeHacked(TeeHacked),
        #[allow(missing_docs)]
        TeeKeysRevoked(TeeKeysRevoked),
        #[allow(missing_docs)]
        TeeProgramAdded(TeeProgramAdded),
        #[allow(missing_docs)]
        TeeProgramRemoved(TeeProgramRemoved),
        #[allow(missing_docs)]
        TeeSeqConfigHash(TeeSeqConfigHash),
    }
    #[automatically_derived]
    impl TeeModuleEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                38u8,
                33u8,
                198u8,
                29u8,
                51u8,
                21u8,
                242u8,
                163u8,
                210u8,
                107u8,
                34u8,
                215u8,
                70u8,
                186u8,
                33u8,
                169u8,
                109u8,
                36u8,
                159u8,
                81u8,
                173u8,
                163u8,
                35u8,
                247u8,
                34u8,
                108u8,
                206u8,
                95u8,
                229u8,
                252u8,
                61u8,
                100u8,
            ],
            [
                55u8,
                232u8,
                173u8,
                214u8,
                148u8,
                197u8,
                146u8,
                109u8,
                86u8,
                78u8,
                151u8,
                17u8,
                96u8,
                245u8,
                151u8,
                65u8,
                3u8,
                203u8,
                187u8,
                199u8,
                201u8,
                7u8,
                71u8,
                196u8,
                198u8,
                248u8,
                2u8,
                3u8,
                29u8,
                53u8,
                103u8,
                167u8,
            ],
            [
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ],
            [
                154u8,
                122u8,
                100u8,
                105u8,
                194u8,
                92u8,
                240u8,
                23u8,
                137u8,
                6u8,
                7u8,
                105u8,
                94u8,
                74u8,
                20u8,
                156u8,
                199u8,
                113u8,
                242u8,
                148u8,
                253u8,
                135u8,
                30u8,
                32u8,
                128u8,
                210u8,
                76u8,
                209u8,
                9u8,
                3u8,
                58u8,
                182u8,
            ],
            [
                185u8,
                235u8,
                32u8,
                179u8,
                47u8,
                172u8,
                150u8,
                88u8,
                132u8,
                203u8,
                88u8,
                50u8,
                97u8,
                2u8,
                37u8,
                124u8,
                174u8,
                96u8,
                69u8,
                4u8,
                240u8,
                163u8,
                108u8,
                209u8,
                0u8,
                138u8,
                50u8,
                132u8,
                90u8,
                213u8,
                194u8,
                155u8,
            ],
            [
                201u8,
                133u8,
                188u8,
                203u8,
                208u8,
                201u8,
                14u8,
                25u8,
                127u8,
                74u8,
                115u8,
                115u8,
                2u8,
                10u8,
                51u8,
                186u8,
                111u8,
                248u8,
                100u8,
                208u8,
                57u8,
                159u8,
                215u8,
                214u8,
                92u8,
                92u8,
                124u8,
                50u8,
                255u8,
                176u8,
                21u8,
                236u8,
            ],
            [
                228u8,
                46u8,
                175u8,
                7u8,
                55u8,
                226u8,
                71u8,
                138u8,
                95u8,
                90u8,
                237u8,
                58u8,
                6u8,
                16u8,
                174u8,
                123u8,
                9u8,
                162u8,
                124u8,
                186u8,
                201u8,
                173u8,
                106u8,
                92u8,
                196u8,
                214u8,
                143u8,
                120u8,
                175u8,
                209u8,
                66u8,
                91u8,
            ],
            [
                236u8,
                166u8,
                46u8,
                0u8,
                116u8,
                161u8,
                58u8,
                144u8,
                214u8,
                0u8,
                240u8,
                3u8,
                183u8,
                203u8,
                141u8,
                91u8,
                213u8,
                1u8,
                0u8,
                0u8,
                141u8,
                63u8,
                57u8,
                21u8,
                242u8,
                85u8,
                79u8,
                63u8,
                133u8,
                82u8,
                197u8,
                204u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for TeeModuleEvents {
        const NAME: &'static str = "TeeModuleEvents";
        const COUNT: usize = 8usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <ChallengeResolved as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ChallengeResolved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ChallengeResolved)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(
                    <TeeAppchainConfigHash as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <TeeAppchainConfigHash as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeAppchainConfigHash)
                }
                Some(<TeeHacked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TeeHacked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeHacked)
                }
                Some(<TeeKeysRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TeeKeysRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeKeysRevoked)
                }
                Some(<TeeProgramAdded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TeeProgramAdded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeProgramAdded)
                }
                Some(
                    <TeeProgramRemoved as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <TeeProgramRemoved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeProgramRemoved)
                }
                Some(<TeeSeqConfigHash as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TeeSeqConfigHash as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeSeqConfigHash)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for TeeModuleEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChallengeResolved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeAppchainConfigHash(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeHacked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeKeysRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeProgramAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeProgramRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeSeqConfigHash(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChallengeResolved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeAppchainConfigHash(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeHacked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeKeysRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeProgramAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeProgramRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeSeqConfigHash(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`TeeModule`](self) contract instance.

See the [wrapper's documentation](`TeeModuleInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> TeeModuleInstance<T, P, N> {
        TeeModuleInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        poster_: alloy::sol_types::private::Address,
        bridge_: alloy::sol_types::private::Address,
        appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        appchainStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        seqConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        seqStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        l1StartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        l1block_: alloy::sol_types::private::Address,
        challengeWindowDuration_: u64,
        teeProgram: alloy::sol_types::private::FixedBytes<32>,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<TeeModuleInstance<T, P, N>>,
    > {
        TeeModuleInstance::<
            T,
            P,
            N,
        >::deploy(
            provider,
            poster_,
            bridge_,
            appchainConfigHash_,
            appchainStartBlockHash_,
            seqConfigHash_,
            seqStartBlockHash_,
            l1StartBlockHash_,
            l1block_,
            challengeWindowDuration_,
            teeProgram,
        )
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        poster_: alloy::sol_types::private::Address,
        bridge_: alloy::sol_types::private::Address,
        appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        appchainStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        seqConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        seqStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        l1StartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        l1block_: alloy::sol_types::private::Address,
        challengeWindowDuration_: u64,
        teeProgram: alloy::sol_types::private::FixedBytes<32>,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        TeeModuleInstance::<
            T,
            P,
            N,
        >::deploy_builder(
            provider,
            poster_,
            bridge_,
            appchainConfigHash_,
            appchainStartBlockHash_,
            seqConfigHash_,
            seqStartBlockHash_,
            l1StartBlockHash_,
            l1block_,
            challengeWindowDuration_,
            teeProgram,
        )
    }
    /**A [`TeeModule`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`TeeModule`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct TeeModuleInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for TeeModuleInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("TeeModuleInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TeeModuleInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`TeeModule`](self) contract instance.

See the [wrapper's documentation](`TeeModuleInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            poster_: alloy::sol_types::private::Address,
            bridge_: alloy::sol_types::private::Address,
            appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
            appchainStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            seqConfigHash_: alloy::sol_types::private::FixedBytes<32>,
            seqStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            l1StartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            l1block_: alloy::sol_types::private::Address,
            challengeWindowDuration_: u64,
            teeProgram: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::Result<TeeModuleInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                poster_,
                bridge_,
                appchainConfigHash_,
                appchainStartBlockHash_,
                seqConfigHash_,
                seqStartBlockHash_,
                l1StartBlockHash_,
                l1block_,
                challengeWindowDuration_,
                teeProgram,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            poster_: alloy::sol_types::private::Address,
            bridge_: alloy::sol_types::private::Address,
            appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
            appchainStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            seqConfigHash_: alloy::sol_types::private::FixedBytes<32>,
            seqStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            l1StartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            l1block_: alloy::sol_types::private::Address,
            challengeWindowDuration_: u64,
            teeProgram: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            poster_,
                            bridge_,
                            appchainConfigHash_,
                            appchainStartBlockHash_,
                            seqConfigHash_,
                            seqStartBlockHash_,
                            l1StartBlockHash_,
                            l1block_,
                            challengeWindowDuration_,
                            teeProgram,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> TeeModuleInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> TeeModuleInstance<T, P, N> {
            TeeModuleInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TeeModuleInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`addTeeKey`] function.
        pub fn addTeeKey(
            &self,
            publicKey: alloy::sol_types::private::Address,
            programHash: alloy::sol_types::private::FixedBytes<32>,
            zkProof: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, addTeeKeyCall, N> {
            self.call_builder(
                &addTeeKeyCall {
                    publicKey,
                    programHash,
                    zkProof,
                },
            )
        }
        ///Creates a new call builder for the [`addTeeProgram`] function.
        pub fn addTeeProgram(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, addTeeProgramCall, N> {
            self.call_builder(&addTeeProgramCall { hash })
        }
        ///Creates a new call builder for the [`bridge`] function.
        pub fn bridge(&self) -> alloy_contract::SolCallBuilder<T, &P, bridgeCall, N> {
            self.call_builder(&bridgeCall {})
        }
        ///Creates a new call builder for the [`challengeWindowDuration`] function.
        pub fn challengeWindowDuration(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, challengeWindowDurationCall, N> {
            self.call_builder(&challengeWindowDurationCall {})
        }
        ///Creates a new call builder for the [`challengeWindowEnd`] function.
        pub fn challengeWindowEnd(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, challengeWindowEndCall, N> {
            self.call_builder(&challengeWindowEndCall {})
        }
        ///Creates a new call builder for the [`closeChallengeWindow`] function.
        pub fn closeChallengeWindow(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, closeChallengeWindowCall, N> {
            self.call_builder(&closeChallengeWindowCall {})
        }
        ///Creates a new call builder for the [`isTeeKey`] function.
        pub fn isTeeKey(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isTeeKeyCall, N> {
            self.call_builder(&isTeeKeyCall { _0 })
        }
        ///Creates a new call builder for the [`l1block`] function.
        pub fn l1block(&self) -> alloy_contract::SolCallBuilder<T, &P, l1blockCall, N> {
            self.call_builder(&l1blockCall {})
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        ///Creates a new call builder for the [`pendingAssertions`] function.
        pub fn pendingAssertions(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, pendingAssertionsCall, N> {
            self.call_builder(&pendingAssertionsCall { _0 })
        }
        ///Creates a new call builder for the [`poster`] function.
        pub fn poster(&self) -> alloy_contract::SolCallBuilder<T, &P, posterCall, N> {
            self.call_builder(&posterCall {})
        }
        ///Creates a new call builder for the [`removeTeeProgram`] function.
        pub fn removeTeeProgram(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeTeeProgramCall, N> {
            self.call_builder(&removeTeeProgramCall { hash })
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall {})
        }
        ///Creates a new call builder for the [`resolveChallenge`] function.
        pub fn resolveChallenge(
            &self,
            assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, resolveChallengeCall, N> {
            self.call_builder(&resolveChallengeCall { assertion })
        }
        ///Creates a new call builder for the [`revokeAllTeeKeys`] function.
        pub fn revokeAllTeeKeys(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, revokeAllTeeKeysCall, N> {
            self.call_builder(&revokeAllTeeKeysCall {})
        }
        ///Creates a new call builder for the [`setAppchainConfigHash`] function.
        pub fn setAppchainConfigHash(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setAppchainConfigHashCall, N> {
            self.call_builder(&setAppchainConfigHashCall { hash })
        }
        ///Creates a new call builder for the [`setChallengeWindowDuration`] function.
        pub fn setChallengeWindowDuration(
            &self,
            duration: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, setChallengeWindowDurationCall, N> {
            self.call_builder(
                &setChallengeWindowDurationCall {
                    duration,
                },
            )
        }
        ///Creates a new call builder for the [`setSeqConfigHash`] function.
        pub fn setSeqConfigHash(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setSeqConfigHashCall, N> {
            self.call_builder(&setSeqConfigHashCall { hash })
        }
        ///Creates a new call builder for the [`submitAssertion`] function.
        pub fn submitAssertion(
            &self,
            assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
            signature: alloy::sol_types::private::Bytes,
            rewardAddr: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, submitAssertionCall, N> {
            self.call_builder(
                &submitAssertionCall {
                    assertion,
                    signature,
                    rewardAddr,
                },
            )
        }
        ///Creates a new call builder for the [`teeHackCount`] function.
        pub fn teeHackCount(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeHackCountCall, N> {
            self.call_builder(&teeHackCountCall {})
        }
        ///Creates a new call builder for the [`teeProgramKeys`] function.
        pub fn teeProgramKeys(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
            _1: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeProgramKeysCall, N> {
            self.call_builder(&teeProgramKeysCall { _0, _1 })
        }
        ///Creates a new call builder for the [`teePrograms`] function.
        pub fn teePrograms(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeProgramsCall, N> {
            self.call_builder(&teeProgramsCall { _0 })
        }
        ///Creates a new call builder for the [`teeTrustedInput`] function.
        pub fn teeTrustedInput(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeTrustedInputCall, N> {
            self.call_builder(&teeTrustedInputCall {})
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TeeModuleInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`ChallengeResolved`] event.
        pub fn ChallengeResolved_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ChallengeResolved, N> {
            self.event_filter::<ChallengeResolved>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`TeeAppchainConfigHash`] event.
        pub fn TeeAppchainConfigHash_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeAppchainConfigHash, N> {
            self.event_filter::<TeeAppchainConfigHash>()
        }
        ///Creates a new event filter for the [`TeeHacked`] event.
        pub fn TeeHacked_filter(&self) -> alloy_contract::Event<T, &P, TeeHacked, N> {
            self.event_filter::<TeeHacked>()
        }
        ///Creates a new event filter for the [`TeeKeysRevoked`] event.
        pub fn TeeKeysRevoked_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeKeysRevoked, N> {
            self.event_filter::<TeeKeysRevoked>()
        }
        ///Creates a new event filter for the [`TeeProgramAdded`] event.
        pub fn TeeProgramAdded_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeProgramAdded, N> {
            self.event_filter::<TeeProgramAdded>()
        }
        ///Creates a new event filter for the [`TeeProgramRemoved`] event.
        pub fn TeeProgramRemoved_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeProgramRemoved, N> {
            self.event_filter::<TeeProgramRemoved>()
        }
        ///Creates a new event filter for the [`TeeSeqConfigHash`] event.
        pub fn TeeSeqConfigHash_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeSeqConfigHash, N> {
            self.event_filter::<TeeSeqConfigHash>()
        }
    }
}
