/**

Generated by the following Solidity interface...
```solidity
interface ArbChainConfig {
    error InvalidInitialization();
    error NotInitializing();
    error OwnableInvalidOwner(address owner);
    error OwnableUnauthorizedAccount(address account);

    event AllowedSettlementAddressesUpdated(address[] newAllowedSettlementAddresses);
    event DefaultSequencingChainRpcUrlUpdated(string newRpcUrl);
    event Initialized(uint64 version);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event RollupOwnerUpdated(address indexed newRollupOwner);

    constructor();

    function ALLOWED_SETTLEMENT_ADDRESSES(uint256) external view returns (address);
    function APPCHAIN_BLOCK_EXPLORER_URL() external view returns (string memory);
    function ARBITRUM_BRIDGE_ADDRESS() external view returns (address);
    function ARBITRUM_IGNORE_DELAYED_MESSAGES() external view returns (bool);
    function ARBITRUM_INBOX_ADDRESS() external view returns (address);
    function CHAIN_ID() external view returns (uint256);
    function DEFAULT_SEQUENCING_CHAIN_RPC_URL() external view returns (string memory);
    function ROLLUP_OWNER() external view returns (address);
    function SEQUENCING_CHAIN_ID() external view returns (uint256);
    function SEQUENCING_CONTRACT_ADDRESS() external view returns (address);
    function SEQUENCING_START_BLOCK() external view returns (uint256);
    function SETTLEMENT_DELAY() external view returns (uint256);
    function SETTLEMENT_START_BLOCK() external view returns (uint256);
    function initialize(address owner, uint256 chainId, uint256 sequencingChainId, address arbitrumBridgeAddress, address arbitrumInboxAddress, bool arbitrumIgnoreDelayedMessages, uint256 settlementDelay, uint256 settlementStartBlock, address sequencingContractAddress, uint256 sequencingStartBlock, address rollupOwner, string memory sequencingChainRpcUrl, string memory appchainBlockExplorerUrl, address[] memory allowedSettlementAddresses) external;
    function owner() external view returns (address);
    function renounceOwnership() external;
    function transferOwnership(address newOwner) external;
    function updateAllowedSettlementAddresses(address[] memory newAllowedSettlementAddresses) external;
    function updateDefaultSequencingChainRpcUrl(string memory newRpcUrl) external;
    function updateRollupOwner(address newRollupOwner) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "ALLOWED_SETTLEMENT_ADDRESSES",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "APPCHAIN_BLOCK_EXPLORER_URL",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ARBITRUM_BRIDGE_ADDRESS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ARBITRUM_IGNORE_DELAYED_MESSAGES",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ARBITRUM_INBOX_ADDRESS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "CHAIN_ID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEFAULT_SEQUENCING_CHAIN_RPC_URL",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ROLLUP_OWNER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SEQUENCING_CHAIN_ID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SEQUENCING_CONTRACT_ADDRESS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SEQUENCING_START_BLOCK",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SETTLEMENT_DELAY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SETTLEMENT_START_BLOCK",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "sequencingChainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "arbitrumBridgeAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "arbitrumInboxAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "arbitrumIgnoreDelayedMessages",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "settlementDelay",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "settlementStartBlock",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "sequencingContractAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "sequencingStartBlock",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "rollupOwner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "sequencingChainRpcUrl",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "appchainBlockExplorerUrl",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "allowedSettlementAddresses",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateAllowedSettlementAddresses",
    "inputs": [
      {
        "name": "newAllowedSettlementAddresses",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateDefaultSequencingChainRpcUrl",
    "inputs": [
      {
        "name": "newRpcUrl",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateRollupOwner",
    "inputs": [
      {
        "name": "newRollupOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "AllowedSettlementAddressesUpdated",
    "inputs": [
      {
        "name": "newAllowedSettlementAddresses",
        "type": "address[]",
        "indexed": false,
        "internalType": "address[]"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DefaultSequencingChainRpcUrlUpdated",
    "inputs": [
      {
        "name": "newRpcUrl",
        "type": "string",
        "indexed": false,
        "internalType": "string"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RollupOwnerUpdated",
    "inputs": [
      {
        "name": "newRollupOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "InvalidInitialization",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotInitializing",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OwnableInvalidOwner",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OwnableUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod ArbChainConfig {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60806040523461002757610011610036565b61001961002c565b61218861020e823961218890f35b610032565b60405190565b5f80fd5b61003f336100a8565b565b90565b60018060a01b031690565b90565b61006661006161006b92610041565b61004f565b610044565b90565b61007790610052565b90565b61008390610044565b90565b61008f9061007a565b9052565b91906100a6905f60208501940190610086565b565b806100c36100bd6100b85f61006e565b61007a565b9161007a565b146100d3576100d1906101ae565b565b6100fd6100df5f61006e565b6100e761002c565b918291631e4fbdf760e01b835260048301610093565b0390fd5b5f1c90565b60018060a01b031690565b61011d61012291610101565b610106565b90565b61012f9054610111565b90565b5f1b90565b9061014860018060a01b0391610132565b9181191691161790565b61016661016161016b92610044565b61004f565b610044565b90565b61017790610152565b90565b6101839061016e565b90565b90565b9061019e6101996101a59261017a565b610186565b8254610137565b9055565b5f0190565b6101b75f610125565b6101c1825f610189565b906101f56101ef7f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09361017a565b9161017a565b916101fe61002c565b80610208816101a9565b0390a356fe60c06040526004361015610013575b610dc2565b61001d5f3561015c565b80630743bf6e146101575780632a84b0f01461015257806341fc712d1461014d57806357d1ba25146101485780635a2d9c181461014357806362c73caa1461013e57806366a1d108146101395780636edd6c0914610134578063715018a61461012f57806385e1f4d01461012a5780638da5cb5b14610125578063a3c6e1e714610120578063aa6a43d81461011b578063bf6db6f814610116578063cb60840814610111578063d1f4737c1461010c578063e79388e614610107578063f2fde38b14610102578063f881afaf146100fd5763f8a144be0361000e57610d8d565b610d49565b610c83565b610c4e565b610bbb565b610b78565b610ace565b610a8a565b610a46565b610a02565b6109cd565b61098b565b610956565b610912565b6108cf565b610810565b61052d565b61049b565b610402565b61036c565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f91031261017a57565b61016c565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b90600160028304921680156101c6575b60208310146101c157565b610192565b91607f16916101b6565b60209181520190565b5f5260205f2090565b905f92918054906101fc6101f5836101a6565b80946101d0565b916001811690815f146102535750600114610217575b505050565b61022491929394506101d9565b915f925b81841061023b57505001905f8080610212565b60018160209295939554848601520191019290610228565b92949550505060ff19168252151560200201905f8080610212565b90610278916101e2565b90565b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906102a39061027b565b810190811067ffffffffffffffff8211176102bd57604052565b610285565b906102e26102db926102d2610162565b9384809261026e565b0383610299565b565b905f106102f7576102f4906102c2565b90565b61017f565b610308600b5f906102e4565b90565b5190565b60209181520190565b90825f9392825e0152565b61034261034b602093610350936103398161030b565b9384809361030f565b95869101610318565b61027b565b0190565b6103699160208201915f818403910152610323565b90565b3461039c5761037c366004610170565b6103986103876102fc565b61038f610162565b91829182610354565b0390f35b610168565b5f80fd5b60018060a01b031690565b6103b9906103a5565b90565b6103c5816103b0565b036103cc57565b5f80fd5b905035906103dd826103bc565b565b906020828203126103f8576103f5915f016103d0565b90565b61016c565b5f0190565b346104305761041a6104153660046103df565b610f98565b610422610162565b8061042c816103fd565b0390f35b610168565b1c90565b60018060a01b031690565b6104549060086104599302610435565b610439565b90565b906104679154610444565b90565b61047660095f9061045c565b90565b610482906103b0565b9052565b9190610499905f60208501940190610479565b565b346104cb576104ab366004610170565b6104c76104b661046a565b6104be610162565b91829182610486565b0390f35b610168565b90565b6104e39060086104e89302610435565b6104d0565b90565b906104f691546104d3565b90565b61050560065f906104eb565b90565b90565b61051490610508565b9052565b919061052b905f6020850194019061050b565b565b3461055d5761053d366004610170565b6105596105486104f9565b610550610162565b91829182610518565b0390f35b610168565b61056b81610508565b0361057257565b5f80fd5b9050359061058382610562565b565b151590565b61059381610585565b0361059a57565b5f80fd5b905035906105ab8261058a565b565b5f80fd5b5f80fd5b906105c86105c1610162565b9283610299565b565b67ffffffffffffffff81116105e8576105e460209161027b565b0190565b610285565b90825f939282370152565b9092919261060d610608826105ca565b6105b5565b9381855260208501908284011161062957610627926105ed565b565b6105b1565b9080601f8301121561064c57816020610649933591016105f8565b90565b6105ad565b67ffffffffffffffff81116106695760208091020190565b610285565b5f80fd5b9092919261068761068282610651565b6105b5565b93818552602080860192028301928184116106c457915b8383106106ab5750505050565b602080916106b984866103d0565b81520192019161069e565b61066e565b9080601f830112156106e7578160206106e493359101610672565b90565b6105ad565b9190916101c08184031261080b57610706835f83016103d0565b926107148160208401610576565b926107228260408501610576565b9261073083606083016103d0565b9261073e81608084016103d0565b9261074c8260a0850161059e565b9261075a8360c08301610576565b926107688160e08401610576565b926107778261010085016103d0565b92610786836101208301610576565b926107958161014084016103d0565b9261016083013567ffffffffffffffff811161080657826107b791850161062e565b9261018081013567ffffffffffffffff811161080157836107d991830161062e565b926101a082013567ffffffffffffffff81116107fc576107f992016106c9565b90565b6103a1565b6103a1565b6103a1565b61016c565b346108515761083b6108233660046106ec565b9c9b909b9a919a999299989398979497969596611c44565b610843610162565b8061084d816103fd565b0390f35b610168565b5f80fd5b909182601f830112156108945781359167ffffffffffffffff831161088f57602001926001830284011161088a57565b61066e565b610856565b6105ad565b906020828203126108ca575f82013567ffffffffffffffff81116108c5576108c1920161085a565b9091565b6103a1565b61016c565b346108fe576108e86108e2366004610899565b90611dd6565b6108f0610162565b806108fa816103fd565b0390f35b610168565b61090f600a5f906102e4565b90565b3461094257610922366004610170565b61093e61092d610903565b610935610162565b91829182610354565b0390f35b610168565b61095360015f9061045c565b90565b3461098657610966366004610170565b610982610971610947565b610979610162565b91829182610486565b0390f35b610168565b346109b95761099b366004610170565b6109a3611e07565b6109ab610162565b806109b5816103fd565b0390f35b610168565b6109ca60045f906104eb565b90565b346109fd576109dd366004610170565b6109f96109e86109be565b6109f0610162565b91829182610518565b0390f35b610168565b34610a3257610a12366004610170565b610a2e610a1d611e36565b610a25610162565b91829182610486565b0390f35b610168565b610a4360085f906104eb565b90565b34610a7657610a56366004610170565b610a72610a61610a37565b610a69610162565b91829182610518565b0390f35b610168565b610a8760025f9061045c565b90565b34610aba57610a9a366004610170565b610ab6610aa5610a7b565b610aad610162565b91829182610486565b0390f35b610168565b610acb60035f9061045c565b90565b34610afe57610ade366004610170565b610afa610ae9610abf565b610af1610162565b91829182610486565b0390f35b610168565b909182601f83011215610b3d5781359167ffffffffffffffff8311610b38576020019260208302840111610b3357565b61066e565b610856565b6105ad565b90602082820312610b73575f82013567ffffffffffffffff8111610b6e57610b6a9201610b03565b9091565b6103a1565b61016c565b34610ba757610b91610b8b366004610b42565b90611fea565b610b99610162565b80610ba3816103fd565b0390f35b610168565b610bb860075f906104eb565b90565b34610beb57610bcb366004610170565b610be7610bd6610bac565b610bde610162565b91829182610518565b0390f35b610168565b60ff1690565b610c06906008610c0b9302610435565b610bf0565b90565b90610c199154610bf6565b90565b610c296003601490610c0e565b90565b610c3590610585565b9052565b9190610c4c905f60208501940190610c2c565b565b34610c7e57610c5e366004610170565b610c7a610c69610c1c565b610c71610162565b91829182610c39565b0390f35b610168565b34610cb157610c9b610c963660046103df565b612062565b610ca3610162565b80610cad816103fd565b0390f35b610168565b90602082820312610ccf57610ccc915f01610576565b90565b61016c565b634e487b7160e01b5f52603260045260245ffd5b5490565b5f5260205f2090565b610cfe81610ce8565b821015610d1857610d10600191610cec565b910201905f90565b610cd4565b600c610d2881610ce8565b821015610d4557610d4291610d3c91610cf5565b9061045c565b90565b5f80fd5b34610d7957610d75610d64610d5f366004610cb6565b610d1d565b610d6c610162565b91829182610486565b0390f35b610168565b610d8a60055f906104eb565b90565b34610dbd57610d9d366004610170565b610db9610da8610d7e565b610db0610162565b91829182610518565b0390f35b610168565b5f80fd5b610dd790610dd261206d565b610f26565b565b90565b90565b610df3610dee610df892610dd9565b610ddc565b6103a5565b90565b610e0490610ddf565b90565b60207f6164647265737300000000000000000000000000000000000000000000000000917f4e657720726f6c6c7570206f776e65722063616e6e6f74206265207a65726f205f8201520152565b610e61602760409261030f565b610e6a81610e07565b0190565b610e839060208101905f818303910152610e54565b90565b15610e8d57565b610e95610162565b62461bcd60e51b815280610eab60048201610e6e565b0390fd5b5f1b90565b90610ec560018060a01b0391610eaf565b9181191691161790565b610ee3610ede610ee8926103a5565b610ddc565b6103a5565b90565b610ef490610ecf565b90565b610f0090610eeb565b90565b90565b90610f1b610f16610f2292610ef7565b610f03565b8254610eb4565b9055565b610f4b81610f44610f3e610f395f610dfb565b6103b0565b916103b0565b1415610e86565b610f56816009610f06565b610f807f8829bee46683608d5fd80e243c0fae04d129ce172f70db1021c1128074a6f4d991610ef7565b90610f89610162565b80610f93816103fd565b0390a2565b610fa190610dc6565b565b60401c90565b610fb5610fba91610fa3565b610bf0565b90565b610fc79054610fa9565b90565b5f1c90565b67ffffffffffffffff1690565b610fe8610fed91610fca565b610fcf565b90565b610ffa9054610fdc565b90565b67ffffffffffffffff1690565b61101e61101961102392610dd9565b610ddc565b610ffd565b90565b90565b61103d61103861104292611026565b610ddc565b610ffd565b90565b61104e90610eeb565b90565b61106561106061106a92610dd9565b610ddc565b610508565b90565b9061108067ffffffffffffffff91610eaf565b9181191691161790565b61109e6110996110a392610ffd565b610ddc565b610ffd565b90565b90565b906110be6110b96110c59261108a565b6110a6565b825461106d565b9055565b60401b90565b906110e368ff0000000000000000916110c9565b9181191691161790565b6110f690610585565b90565b90565b9061111161110c611118926110ed565b6110f9565b82546110cf565b9055565b61112590611029565b9052565b919061113c905f6020850194019061111c565b565b9c9b9a999897969594939291906111536120c2565b60805261116c6111665f60805101610fbd565b15610585565b60a05261117c5f60805101610ff0565b8061118f6111895f61100a565b91610ffd565b14806112b8575b906111aa6111a46001611029565b91610ffd565b1480611290575b6111bc909115610585565b908161127f575b5061125c576111f09d6111e36111d96001611029565b5f608051016110a9565b60a051611248575b611ab2565b60a0516111fa575b565b6112085f80608051016110fc565b60016112407fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d291611237610162565b91829182611129565b0390a16111f8565b61125760015f608051016110fc565b6111eb565b611264610162565b63f92ee8a960e01b81528061127b600482016103fd565b0390fd5b61128a915015610585565b5f6111c3565b506111bc61129d30611045565b3b6112b06112aa5f611051565b91610508565b1490506111b1565b5060a051611196565b5f7f4f776e65722063616e6e6f74206265207a65726f206164647265737300000000910152565b6112f5601c60209261030f565b6112fe816112c1565b0190565b6113179060208101905f8183039101526112e8565b90565b1561132157565b611329610162565b62461bcd60e51b81528061133f60048201611302565b0390fd5b5f7f436861696e2049442063616e6e6f74206265207a65726f000000000000000000910152565b611377601760209261030f565b61138081611343565b0190565b6113999060208101905f81830391015261136a565b90565b156113a357565b6113ab610162565b62461bcd60e51b8152806113c160048201611384565b0390fd5b60207f726f000000000000000000000000000000000000000000000000000000000000917f53657175656e63696e6720636861696e2049442063616e6e6f74206265207a655f8201520152565b61141f602260409261030f565b611428816113c5565b0190565b6114419060208101905f818303910152611412565b90565b1561144b57565b611453610162565b62461bcd60e51b8152806114696004820161142c565b0390fd5b60207f65207a65726f0000000000000000000000000000000000000000000000000000917f417262697472756d2062726964676520616464726573732063616e6e6f7420625f8201520152565b6114c7602660409261030f565b6114d08161146d565b0190565b6114e99060208101905f8183039101526114ba565b90565b156114f357565b6114fb610162565b62461bcd60e51b815280611511600482016114d4565b0390fd5b60207f207a65726f000000000000000000000000000000000000000000000000000000917f417262697472756d20696e626f7820616464726573732063616e6e6f742062655f8201520152565b61156f602560409261030f565b61157881611515565b0190565b6115919060208101905f818303910152611562565b90565b1561159b57565b6115a3610162565b62461bcd60e51b8152806115b96004820161157c565b0390fd5b60207f6f74206265207a65726f00000000000000000000000000000000000000000000917f53657175656e63696e6720636f6e747261637420616464726573732063616e6e5f8201520152565b611617602a60409261030f565b611620816115bd565b0190565b6116399060208101905f81830391015261160a565b90565b1561164357565b61164b610162565b62461bcd60e51b81528061166160048201611624565b0390fd5b60207f6573730000000000000000000000000000000000000000000000000000000000917f526f6c6c7570206f776e65722063616e6e6f74206265207a65726f20616464725f8201520152565b6116bf602360409261030f565b6116c881611665565b0190565b6116e19060208101905f8183039101526116b2565b90565b156116eb57565b6116f3610162565b62461bcd60e51b815280611709600482016116cc565b0390fd5b906117195f1991610eaf565b9181191691161790565b61173761173261173c92610508565b610ddc565b610508565b90565b90565b9061175761175261175e92611723565b61173f565b825461170d565b9055565b60a01b90565b9061177760ff60a01b91611762565b9181191691161790565b9061179661179161179d926110ed565b6110f9565b8254611768565b9055565b601f602091010490565b1b90565b919060086117ca9102916117c45f19846117ab565b926117ab565b9181191691161790565b91906117ea6117e56117f293611723565b61173f565b9083546117af565b9055565b5f90565b61180c916118066117f6565b916117d4565b565b5b81811061181a575050565b806118275f6001936117fa565b0161180f565b9190601f811161183d575b505050565b61184961186e936101d9565b906020611855846117a1565b83019310611876575b611867906117a1565b019061180e565b5f8080611838565b91506118678192905061185e565b90611894905f1990600802610435565b191690565b816118a391611884565b906002021790565b906118b58161030b565b9067ffffffffffffffff8211611975576118d9826118d385546101a6565b8561182d565b602090601f831160011461190d579180916118fc935f92611901575b5050611899565b90555b565b90915001515f806118f5565b601f1983169161191c856101d9565b925f5b81811061195d57509160029391856001969410611943575b505050020190556118ff565b611953910151601f841690611884565b90555f8080611937565b9193602060018192878701518155019501920161191f565b610285565b90611984916118ab565b565b600190818003010490565b5b81811061199d575050565b806119aa5f6001936117fa565b01611992565b90918281106119bf575b505050565b6119dd6119d76119d16119e895611986565b92611986565b92610cec565b918201910190611991565b5f80806119ba565b90680100000000000000008111611a195781611a0e611a1793610ce8565b908281556119b0565b565b610285565b5190565b611a2c90516103b0565b90565b60200190565b611a3e82611a1e565b9167ffffffffffffffff8311611aa157611a6c611a66600192611a6186866119f0565b611a2f565b92610cec565b9204915f5b838110611a7e5750505050565b6001906020611a94611a8f86611a22565b610f03565b9401938184015501611a71565b610285565b90611ab091611a35565b565b9b97611c13611c2f98611c429f9c968f99611c3d9f9a611c289a611c369f98611c0c94611bf7611c219c611bf08f94611be9611c1a9e611be28f98611bc1611bfe9a611b1c611c059e611b15611b0f611b0a5f610dfb565b6103b0565b916103b0565b141561131a565b611b3985611b32611b2c5f611051565b91610508565b141561139c565b611b5687611b4f611b495f611051565b91610508565b1415611444565b611b7b89611b74611b6e611b695f610dfb565b6103b0565b916103b0565b14156114ec565b611ba08b611b99611b93611b8e5f610dfb565b6103b0565b916103b0565b1415611594565b611bba611bb4611baf5f610dfb565b6103b0565b916103b0565b141561163c565b611bdb611bd5611bd05f610dfb565b6103b0565b916103b0565b14156116e4565b6004611742565b6005611742565b6001610f06565b6002610f06565b6003611781565b6006611742565b6007611742565b6003610f06565b6008611742565b6009610f06565b600a61197a565b600b61197a565b600c611aa6565b6120e6565b565b90611c5a9d9c9b9a99989796959493929161113e565b565b90611c6e91611c6961206d565b611d8d565b565b5090565b91611c7f9082611c70565b9067ffffffffffffffff8211611d3e57611ca382611c9d85546101a6565b8561182d565b5f90601f8311600114611cd657918091611cc5935f92611cca575b5050611899565b90555b565b90915001355f80611cbe565b601f19831691611ce5856101d9565b925f5b818110611d2657509160029391856001969410611d0c575b50505002019055611cc8565b611d1c910135601f841690611884565b90555f8080611d00565b91936020600181928787013581550195019201611ce8565b610285565b90611d4e9291611c74565b565b9190611d6a81611d6381611d6f9561030f565b80956105ed565b61027b565b0190565b9091611d8a9260208301925f818503910152611d50565b90565b611d9a818390600a611d43565b907f0234a4e910f2b1e618f2c93be316ec0c7f40e1af23fe33f9fba2c5bb388a95f291611dd1611dc8610162565b92839283611d73565b0390a1565b90611de091611c5c565b565b611dea61206d565b611df2611df4565b565b611e05611e005f610dfb565b6120e6565b565b611e0f611de2565b565b5f90565b611e21611e2691610fca565b610439565b90565b611e339054611e15565b90565b611e3e611e11565b50611e485f611e29565b90565b90611e5d91611e5861206d565b611fa1565b565b5090565b35611e6d816103bc565b90565b90565b9091611e7f9083611e5f565b9167ffffffffffffffff8311611ee257611ead611ea7600192611ea286866119f0565b611e70565b92610cec565b9204915f5b838110611ebf5750505050565b6001906020611ed5611ed086611e63565b610f03565b9401938184015501611eb2565b610285565b90611ef29291611e73565b565b60209181520190565b611f06906103b0565b9052565b90611f1781602093611efd565b0190565b50611f2a9060208101906103d0565b90565b60200190565b91611f4182611f4792611ef4565b92611e70565b90815f905b828210611f5a575050505090565b90919293611f7c611f76600192611f718886611f1b565b611f0a565b95611f2d565b920190929192611f4c565b9091611f9e9260208301925f818503910152611f33565b90565b611fae818390600c611ee7565b907fb4a2866a583699c6ed7b77a1521fad424f8edcca30601f442c2a5b76a0105be291611fe5611fdc610162565b92839283611f87565b0390a1565b90611ff491611e4b565b565b6120079061200261206d565b612009565b565b8061202461201e6120195f610dfb565b6103b0565b916103b0565b1461203457612032906120e6565b565b61205e6120405f610dfb565b612048610162565b918291631e4fbdf760e01b835260048301610486565b0390fd5b61206b90611ff6565b565b612075611e36565b61208e612088612083612145565b6103b0565b916103b0565b0361209557565b6120be6120a0612145565b6120a8610162565b91829163118cdaa760e01b835260048301610486565b0390fd5b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0090565b6120ef5f611e29565b6120f9825f610f06565b9061212d6121277f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e093610ef7565b91610ef7565b91612136610162565b80612140816103fd565b0390a3565b61214d611e11565b50339056fea2646970667358221220c39260c8d5d3b774ec3b9808705a87efaad42fe39de4cbda199bded744c8deac64736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4a\0'Wa\0\x11a\x006V[a\0\x19a\0,V[a!\x88a\x02\x0E\x829a!\x88\x90\xF3[a\x002V[`@Q\x90V[_\x80\xFD[a\0?3a\0\xA8V[V[\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[\x90V[a\0fa\0aa\0k\x92a\0AV[a\0OV[a\0DV[\x90V[a\0w\x90a\0RV[\x90V[a\0\x83\x90a\0DV[\x90V[a\0\x8F\x90a\0zV[\x90RV[\x91\x90a\0\xA6\x90_` \x85\x01\x94\x01\x90a\0\x86V[V[\x80a\0\xC3a\0\xBDa\0\xB8_a\0nV[a\0zV[\x91a\0zV[\x14a\0\xD3Wa\0\xD1\x90a\x01\xAEV[V[a\0\xFDa\0\xDF_a\0nV[a\0\xE7a\0,V[\x91\x82\x91c\x1EO\xBD\xF7`\xE0\x1B\x83R`\x04\x83\x01a\0\x93V[\x03\x90\xFD[_\x1C\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x01\x1Da\x01\"\x91a\x01\x01V[a\x01\x06V[\x90V[a\x01/\x90Ta\x01\x11V[\x90V[_\x1B\x90V[\x90a\x01H`\x01\x80`\xA0\x1B\x03\x91a\x012V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x01fa\x01aa\x01k\x92a\0DV[a\0OV[a\0DV[\x90V[a\x01w\x90a\x01RV[\x90V[a\x01\x83\x90a\x01nV[\x90V[\x90V[\x90a\x01\x9Ea\x01\x99a\x01\xA5\x92a\x01zV[a\x01\x86V[\x82Ta\x017V[\x90UV[_\x01\x90V[a\x01\xB7_a\x01%V[a\x01\xC1\x82_a\x01\x89V[\x90a\x01\xF5a\x01\xEF\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x93a\x01zV[\x91a\x01zV[\x91a\x01\xFEa\0,V[\x80a\x02\x08\x81a\x01\xA9V[\x03\x90\xA3V\xFE`\xC0`@R`\x046\x10\x15a\0\x13W[a\r\xC2V[a\0\x1D_5a\x01\\V[\x80c\x07C\xBFn\x14a\x01WW\x80c*\x84\xB0\xF0\x14a\x01RW\x80cA\xFCq-\x14a\x01MW\x80cW\xD1\xBA%\x14a\x01HW\x80cZ-\x9C\x18\x14a\x01CW\x80cb\xC7<\xAA\x14a\x01>W\x80cf\xA1\xD1\x08\x14a\x019W\x80cn\xDDl\t\x14a\x014W\x80cqP\x18\xA6\x14a\x01/W\x80c\x85\xE1\xF4\xD0\x14a\x01*W\x80c\x8D\xA5\xCB[\x14a\x01%W\x80c\xA3\xC6\xE1\xE7\x14a\x01 W\x80c\xAAjC\xD8\x14a\x01\x1BW\x80c\xBFm\xB6\xF8\x14a\x01\x16W\x80c\xCB`\x84\x08\x14a\x01\x11W\x80c\xD1\xF4s|\x14a\x01\x0CW\x80c\xE7\x93\x88\xE6\x14a\x01\x07W\x80c\xF2\xFD\xE3\x8B\x14a\x01\x02W\x80c\xF8\x81\xAF\xAF\x14a\0\xFDWc\xF8\xA1D\xBE\x03a\0\x0EWa\r\x8DV[a\rIV[a\x0C\x83V[a\x0CNV[a\x0B\xBBV[a\x0BxV[a\n\xCEV[a\n\x8AV[a\nFV[a\n\x02V[a\t\xCDV[a\t\x8BV[a\tVV[a\t\x12V[a\x08\xCFV[a\x08\x10V[a\x05-V[a\x04\x9BV[a\x04\x02V[a\x03lV[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x91\x03\x12a\x01zWV[a\x01lV[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x01\xC6W[` \x83\x10\x14a\x01\xC1WV[a\x01\x92V[\x91`\x7F\x16\x91a\x01\xB6V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x01\xFCa\x01\xF5\x83a\x01\xA6V[\x80\x94a\x01\xD0V[\x91`\x01\x81\x16\x90\x81_\x14a\x02SWP`\x01\x14a\x02\x17W[PPPV[a\x02$\x91\x92\x93\x94Pa\x01\xD9V[\x91_\x92[\x81\x84\x10a\x02;WPP\x01\x90_\x80\x80a\x02\x12V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x02(V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x02\x12V[\x90a\x02x\x91a\x01\xE2V[\x90V[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x02\xA3\x90a\x02{V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x02\xBDW`@RV[a\x02\x85V[\x90a\x02\xE2a\x02\xDB\x92a\x02\xD2a\x01bV[\x93\x84\x80\x92a\x02nV[\x03\x83a\x02\x99V[V[\x90_\x10a\x02\xF7Wa\x02\xF4\x90a\x02\xC2V[\x90V[a\x01\x7FV[a\x03\x08`\x0B_\x90a\x02\xE4V[\x90V[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[a\x03Ba\x03K` \x93a\x03P\x93a\x039\x81a\x03\x0BV[\x93\x84\x80\x93a\x03\x0FV[\x95\x86\x91\x01a\x03\x18V[a\x02{V[\x01\x90V[a\x03i\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x03#V[\x90V[4a\x03\x9CWa\x03|6`\x04a\x01pV[a\x03\x98a\x03\x87a\x02\xFCV[a\x03\x8Fa\x01bV[\x91\x82\x91\x82a\x03TV[\x03\x90\xF3[a\x01hV[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x03\xB9\x90a\x03\xA5V[\x90V[a\x03\xC5\x81a\x03\xB0V[\x03a\x03\xCCWV[_\x80\xFD[\x90P5\x90a\x03\xDD\x82a\x03\xBCV[V[\x90` \x82\x82\x03\x12a\x03\xF8Wa\x03\xF5\x91_\x01a\x03\xD0V[\x90V[a\x01lV[_\x01\x90V[4a\x040Wa\x04\x1Aa\x04\x156`\x04a\x03\xDFV[a\x0F\x98V[a\x04\"a\x01bV[\x80a\x04,\x81a\x03\xFDV[\x03\x90\xF3[a\x01hV[\x1C\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x04T\x90`\x08a\x04Y\x93\x02a\x045V[a\x049V[\x90V[\x90a\x04g\x91Ta\x04DV[\x90V[a\x04v`\t_\x90a\x04\\V[\x90V[a\x04\x82\x90a\x03\xB0V[\x90RV[\x91\x90a\x04\x99\x90_` \x85\x01\x94\x01\x90a\x04yV[V[4a\x04\xCBWa\x04\xAB6`\x04a\x01pV[a\x04\xC7a\x04\xB6a\x04jV[a\x04\xBEa\x01bV[\x91\x82\x91\x82a\x04\x86V[\x03\x90\xF3[a\x01hV[\x90V[a\x04\xE3\x90`\x08a\x04\xE8\x93\x02a\x045V[a\x04\xD0V[\x90V[\x90a\x04\xF6\x91Ta\x04\xD3V[\x90V[a\x05\x05`\x06_\x90a\x04\xEBV[\x90V[\x90V[a\x05\x14\x90a\x05\x08V[\x90RV[\x91\x90a\x05+\x90_` \x85\x01\x94\x01\x90a\x05\x0BV[V[4a\x05]Wa\x05=6`\x04a\x01pV[a\x05Ya\x05Ha\x04\xF9V[a\x05Pa\x01bV[\x91\x82\x91\x82a\x05\x18V[\x03\x90\xF3[a\x01hV[a\x05k\x81a\x05\x08V[\x03a\x05rWV[_\x80\xFD[\x90P5\x90a\x05\x83\x82a\x05bV[V[\x15\x15\x90V[a\x05\x93\x81a\x05\x85V[\x03a\x05\x9AWV[_\x80\xFD[\x90P5\x90a\x05\xAB\x82a\x05\x8AV[V[_\x80\xFD[_\x80\xFD[\x90a\x05\xC8a\x05\xC1a\x01bV[\x92\x83a\x02\x99V[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x05\xE8Wa\x05\xE4` \x91a\x02{V[\x01\x90V[a\x02\x85V[\x90\x82_\x93\x92\x827\x01RV[\x90\x92\x91\x92a\x06\ra\x06\x08\x82a\x05\xCAV[a\x05\xB5V[\x93\x81\x85R` \x85\x01\x90\x82\x84\x01\x11a\x06)Wa\x06'\x92a\x05\xEDV[V[a\x05\xB1V[\x90\x80`\x1F\x83\x01\x12\x15a\x06LW\x81` a\x06I\x935\x91\x01a\x05\xF8V[\x90V[a\x05\xADV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x06iW` \x80\x91\x02\x01\x90V[a\x02\x85V[_\x80\xFD[\x90\x92\x91\x92a\x06\x87a\x06\x82\x82a\x06QV[a\x05\xB5V[\x93\x81\x85R` \x80\x86\x01\x92\x02\x83\x01\x92\x81\x84\x11a\x06\xC4W\x91[\x83\x83\x10a\x06\xABWPPPPV[` \x80\x91a\x06\xB9\x84\x86a\x03\xD0V[\x81R\x01\x92\x01\x91a\x06\x9EV[a\x06nV[\x90\x80`\x1F\x83\x01\x12\x15a\x06\xE7W\x81` a\x06\xE4\x935\x91\x01a\x06rV[\x90V[a\x05\xADV[\x91\x90\x91a\x01\xC0\x81\x84\x03\x12a\x08\x0BWa\x07\x06\x83_\x83\x01a\x03\xD0V[\x92a\x07\x14\x81` \x84\x01a\x05vV[\x92a\x07\"\x82`@\x85\x01a\x05vV[\x92a\x070\x83``\x83\x01a\x03\xD0V[\x92a\x07>\x81`\x80\x84\x01a\x03\xD0V[\x92a\x07L\x82`\xA0\x85\x01a\x05\x9EV[\x92a\x07Z\x83`\xC0\x83\x01a\x05vV[\x92a\x07h\x81`\xE0\x84\x01a\x05vV[\x92a\x07w\x82a\x01\0\x85\x01a\x03\xD0V[\x92a\x07\x86\x83a\x01 \x83\x01a\x05vV[\x92a\x07\x95\x81a\x01@\x84\x01a\x03\xD0V[\x92a\x01`\x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x08\x06W\x82a\x07\xB7\x91\x85\x01a\x06.V[\x92a\x01\x80\x81\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x08\x01W\x83a\x07\xD9\x91\x83\x01a\x06.V[\x92a\x01\xA0\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x07\xFCWa\x07\xF9\x92\x01a\x06\xC9V[\x90V[a\x03\xA1V[a\x03\xA1V[a\x03\xA1V[a\x01lV[4a\x08QWa\x08;a\x08#6`\x04a\x06\xECV[\x9C\x9B\x90\x9B\x9A\x91\x9A\x99\x92\x99\x98\x93\x98\x97\x94\x97\x96\x95\x96a\x1CDV[a\x08Ca\x01bV[\x80a\x08M\x81a\x03\xFDV[\x03\x90\xF3[a\x01hV[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x08\x94W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x08\x8FW` \x01\x92`\x01\x83\x02\x84\x01\x11a\x08\x8AWV[a\x06nV[a\x08VV[a\x05\xADV[\x90` \x82\x82\x03\x12a\x08\xCAW_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x08\xC5Wa\x08\xC1\x92\x01a\x08ZV[\x90\x91V[a\x03\xA1V[a\x01lV[4a\x08\xFEWa\x08\xE8a\x08\xE26`\x04a\x08\x99V[\x90a\x1D\xD6V[a\x08\xF0a\x01bV[\x80a\x08\xFA\x81a\x03\xFDV[\x03\x90\xF3[a\x01hV[a\t\x0F`\n_\x90a\x02\xE4V[\x90V[4a\tBWa\t\"6`\x04a\x01pV[a\t>a\t-a\t\x03V[a\t5a\x01bV[\x91\x82\x91\x82a\x03TV[\x03\x90\xF3[a\x01hV[a\tS`\x01_\x90a\x04\\V[\x90V[4a\t\x86Wa\tf6`\x04a\x01pV[a\t\x82a\tqa\tGV[a\tya\x01bV[\x91\x82\x91\x82a\x04\x86V[\x03\x90\xF3[a\x01hV[4a\t\xB9Wa\t\x9B6`\x04a\x01pV[a\t\xA3a\x1E\x07V[a\t\xABa\x01bV[\x80a\t\xB5\x81a\x03\xFDV[\x03\x90\xF3[a\x01hV[a\t\xCA`\x04_\x90a\x04\xEBV[\x90V[4a\t\xFDWa\t\xDD6`\x04a\x01pV[a\t\xF9a\t\xE8a\t\xBEV[a\t\xF0a\x01bV[\x91\x82\x91\x82a\x05\x18V[\x03\x90\xF3[a\x01hV[4a\n2Wa\n\x126`\x04a\x01pV[a\n.a\n\x1Da\x1E6V[a\n%a\x01bV[\x91\x82\x91\x82a\x04\x86V[\x03\x90\xF3[a\x01hV[a\nC`\x08_\x90a\x04\xEBV[\x90V[4a\nvWa\nV6`\x04a\x01pV[a\nra\naa\n7V[a\nia\x01bV[\x91\x82\x91\x82a\x05\x18V[\x03\x90\xF3[a\x01hV[a\n\x87`\x02_\x90a\x04\\V[\x90V[4a\n\xBAWa\n\x9A6`\x04a\x01pV[a\n\xB6a\n\xA5a\n{V[a\n\xADa\x01bV[\x91\x82\x91\x82a\x04\x86V[\x03\x90\xF3[a\x01hV[a\n\xCB`\x03_\x90a\x04\\V[\x90V[4a\n\xFEWa\n\xDE6`\x04a\x01pV[a\n\xFAa\n\xE9a\n\xBFV[a\n\xF1a\x01bV[\x91\x82\x91\x82a\x04\x86V[\x03\x90\xF3[a\x01hV[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x0B=W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x0B8W` \x01\x92` \x83\x02\x84\x01\x11a\x0B3WV[a\x06nV[a\x08VV[a\x05\xADV[\x90` \x82\x82\x03\x12a\x0BsW_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x0BnWa\x0Bj\x92\x01a\x0B\x03V[\x90\x91V[a\x03\xA1V[a\x01lV[4a\x0B\xA7Wa\x0B\x91a\x0B\x8B6`\x04a\x0BBV[\x90a\x1F\xEAV[a\x0B\x99a\x01bV[\x80a\x0B\xA3\x81a\x03\xFDV[\x03\x90\xF3[a\x01hV[a\x0B\xB8`\x07_\x90a\x04\xEBV[\x90V[4a\x0B\xEBWa\x0B\xCB6`\x04a\x01pV[a\x0B\xE7a\x0B\xD6a\x0B\xACV[a\x0B\xDEa\x01bV[\x91\x82\x91\x82a\x05\x18V[\x03\x90\xF3[a\x01hV[`\xFF\x16\x90V[a\x0C\x06\x90`\x08a\x0C\x0B\x93\x02a\x045V[a\x0B\xF0V[\x90V[\x90a\x0C\x19\x91Ta\x0B\xF6V[\x90V[a\x0C)`\x03`\x14\x90a\x0C\x0EV[\x90V[a\x0C5\x90a\x05\x85V[\x90RV[\x91\x90a\x0CL\x90_` \x85\x01\x94\x01\x90a\x0C,V[V[4a\x0C~Wa\x0C^6`\x04a\x01pV[a\x0Cza\x0Cia\x0C\x1CV[a\x0Cqa\x01bV[\x91\x82\x91\x82a\x0C9V[\x03\x90\xF3[a\x01hV[4a\x0C\xB1Wa\x0C\x9Ba\x0C\x966`\x04a\x03\xDFV[a bV[a\x0C\xA3a\x01bV[\x80a\x0C\xAD\x81a\x03\xFDV[\x03\x90\xF3[a\x01hV[\x90` \x82\x82\x03\x12a\x0C\xCFWa\x0C\xCC\x91_\x01a\x05vV[\x90V[a\x01lV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[T\x90V[_R` _ \x90V[a\x0C\xFE\x81a\x0C\xE8V[\x82\x10\x15a\r\x18Wa\r\x10`\x01\x91a\x0C\xECV[\x91\x02\x01\x90_\x90V[a\x0C\xD4V[`\x0Ca\r(\x81a\x0C\xE8V[\x82\x10\x15a\rEWa\rB\x91a\r<\x91a\x0C\xF5V[\x90a\x04\\V[\x90V[_\x80\xFD[4a\ryWa\rua\rda\r_6`\x04a\x0C\xB6V[a\r\x1DV[a\rla\x01bV[\x91\x82\x91\x82a\x04\x86V[\x03\x90\xF3[a\x01hV[a\r\x8A`\x05_\x90a\x04\xEBV[\x90V[4a\r\xBDWa\r\x9D6`\x04a\x01pV[a\r\xB9a\r\xA8a\r~V[a\r\xB0a\x01bV[\x91\x82\x91\x82a\x05\x18V[\x03\x90\xF3[a\x01hV[_\x80\xFD[a\r\xD7\x90a\r\xD2a mV[a\x0F&V[V[\x90V[\x90V[a\r\xF3a\r\xEEa\r\xF8\x92a\r\xD9V[a\r\xDCV[a\x03\xA5V[\x90V[a\x0E\x04\x90a\r\xDFV[\x90V[` \x7Faddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FNew rollup owner cannot be zero _\x82\x01R\x01RV[a\x0Ea`'`@\x92a\x03\x0FV[a\x0Ej\x81a\x0E\x07V[\x01\x90V[a\x0E\x83\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x0ETV[\x90V[\x15a\x0E\x8DWV[a\x0E\x95a\x01bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x0E\xAB`\x04\x82\x01a\x0EnV[\x03\x90\xFD[_\x1B\x90V[\x90a\x0E\xC5`\x01\x80`\xA0\x1B\x03\x91a\x0E\xAFV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x0E\xE3a\x0E\xDEa\x0E\xE8\x92a\x03\xA5V[a\r\xDCV[a\x03\xA5V[\x90V[a\x0E\xF4\x90a\x0E\xCFV[\x90V[a\x0F\0\x90a\x0E\xEBV[\x90V[\x90V[\x90a\x0F\x1Ba\x0F\x16a\x0F\"\x92a\x0E\xF7V[a\x0F\x03V[\x82Ta\x0E\xB4V[\x90UV[a\x0FK\x81a\x0FDa\x0F>a\x0F9_a\r\xFBV[a\x03\xB0V[\x91a\x03\xB0V[\x14\x15a\x0E\x86V[a\x0FV\x81`\ta\x0F\x06V[a\x0F\x80\x7F\x88)\xBE\xE4f\x83`\x8D_\xD8\x0E$<\x0F\xAE\x04\xD1)\xCE\x17/p\xDB\x10!\xC1\x12\x80t\xA6\xF4\xD9\x91a\x0E\xF7V[\x90a\x0F\x89a\x01bV[\x80a\x0F\x93\x81a\x03\xFDV[\x03\x90\xA2V[a\x0F\xA1\x90a\r\xC6V[V[`@\x1C\x90V[a\x0F\xB5a\x0F\xBA\x91a\x0F\xA3V[a\x0B\xF0V[\x90V[a\x0F\xC7\x90Ta\x0F\xA9V[\x90V[_\x1C\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x0F\xE8a\x0F\xED\x91a\x0F\xCAV[a\x0F\xCFV[\x90V[a\x0F\xFA\x90Ta\x0F\xDCV[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x10\x1Ea\x10\x19a\x10#\x92a\r\xD9V[a\r\xDCV[a\x0F\xFDV[\x90V[\x90V[a\x10=a\x108a\x10B\x92a\x10&V[a\r\xDCV[a\x0F\xFDV[\x90V[a\x10N\x90a\x0E\xEBV[\x90V[a\x10ea\x10`a\x10j\x92a\r\xD9V[a\r\xDCV[a\x05\x08V[\x90V[\x90a\x10\x80g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x0E\xAFV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x10\x9Ea\x10\x99a\x10\xA3\x92a\x0F\xFDV[a\r\xDCV[a\x0F\xFDV[\x90V[\x90V[\x90a\x10\xBEa\x10\xB9a\x10\xC5\x92a\x10\x8AV[a\x10\xA6V[\x82Ta\x10mV[\x90UV[`@\x1B\x90V[\x90a\x10\xE3h\xFF\0\0\0\0\0\0\0\0\x91a\x10\xC9V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x10\xF6\x90a\x05\x85V[\x90V[\x90V[\x90a\x11\x11a\x11\x0Ca\x11\x18\x92a\x10\xEDV[a\x10\xF9V[\x82Ta\x10\xCFV[\x90UV[a\x11%\x90a\x10)V[\x90RV[\x91\x90a\x11<\x90_` \x85\x01\x94\x01\x90a\x11\x1CV[V[\x9C\x9B\x9A\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90a\x11Sa \xC2V[`\x80Ra\x11la\x11f_`\x80Q\x01a\x0F\xBDV[\x15a\x05\x85V[`\xA0Ra\x11|_`\x80Q\x01a\x0F\xF0V[\x80a\x11\x8Fa\x11\x89_a\x10\nV[\x91a\x0F\xFDV[\x14\x80a\x12\xB8W[\x90a\x11\xAAa\x11\xA4`\x01a\x10)V[\x91a\x0F\xFDV[\x14\x80a\x12\x90W[a\x11\xBC\x90\x91\x15a\x05\x85V[\x90\x81a\x12\x7FW[Pa\x12\\Wa\x11\xF0\x9Da\x11\xE3a\x11\xD9`\x01a\x10)V[_`\x80Q\x01a\x10\xA9V[`\xA0Qa\x12HW[a\x1A\xB2V[`\xA0Qa\x11\xFAW[V[a\x12\x08_\x80`\x80Q\x01a\x10\xFCV[`\x01a\x12@\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x91a\x127a\x01bV[\x91\x82\x91\x82a\x11)V[\x03\x90\xA1a\x11\xF8V[a\x12W`\x01_`\x80Q\x01a\x10\xFCV[a\x11\xEBV[a\x12da\x01bV[c\xF9.\xE8\xA9`\xE0\x1B\x81R\x80a\x12{`\x04\x82\x01a\x03\xFDV[\x03\x90\xFD[a\x12\x8A\x91P\x15a\x05\x85V[_a\x11\xC3V[Pa\x11\xBCa\x12\x9D0a\x10EV[;a\x12\xB0a\x12\xAA_a\x10QV[\x91a\x05\x08V[\x14\x90Pa\x11\xB1V[P`\xA0Qa\x11\x96V[_\x7FOwner cannot be zero address\0\0\0\0\x91\x01RV[a\x12\xF5`\x1C` \x92a\x03\x0FV[a\x12\xFE\x81a\x12\xC1V[\x01\x90V[a\x13\x17\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x12\xE8V[\x90V[\x15a\x13!WV[a\x13)a\x01bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x13?`\x04\x82\x01a\x13\x02V[\x03\x90\xFD[_\x7FChain ID cannot be zero\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x13w`\x17` \x92a\x03\x0FV[a\x13\x80\x81a\x13CV[\x01\x90V[a\x13\x99\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x13jV[\x90V[\x15a\x13\xA3WV[a\x13\xABa\x01bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x13\xC1`\x04\x82\x01a\x13\x84V[\x03\x90\xFD[` \x7Fro\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FSequencing chain ID cannot be ze_\x82\x01R\x01RV[a\x14\x1F`\"`@\x92a\x03\x0FV[a\x14(\x81a\x13\xC5V[\x01\x90V[a\x14A\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x14\x12V[\x90V[\x15a\x14KWV[a\x14Sa\x01bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x14i`\x04\x82\x01a\x14,V[\x03\x90\xFD[` \x7Fe zero\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FArbitrum bridge address cannot b_\x82\x01R\x01RV[a\x14\xC7`&`@\x92a\x03\x0FV[a\x14\xD0\x81a\x14mV[\x01\x90V[a\x14\xE9\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x14\xBAV[\x90V[\x15a\x14\xF3WV[a\x14\xFBa\x01bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x15\x11`\x04\x82\x01a\x14\xD4V[\x03\x90\xFD[` \x7F zero\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FArbitrum inbox address cannot be_\x82\x01R\x01RV[a\x15o`%`@\x92a\x03\x0FV[a\x15x\x81a\x15\x15V[\x01\x90V[a\x15\x91\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x15bV[\x90V[\x15a\x15\x9BWV[a\x15\xA3a\x01bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x15\xB9`\x04\x82\x01a\x15|V[\x03\x90\xFD[` \x7Fot be zero\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FSequencing contract address cann_\x82\x01R\x01RV[a\x16\x17`*`@\x92a\x03\x0FV[a\x16 \x81a\x15\xBDV[\x01\x90V[a\x169\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x16\nV[\x90V[\x15a\x16CWV[a\x16Ka\x01bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x16a`\x04\x82\x01a\x16$V[\x03\x90\xFD[` \x7Fess\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FRollup owner cannot be zero addr_\x82\x01R\x01RV[a\x16\xBF`#`@\x92a\x03\x0FV[a\x16\xC8\x81a\x16eV[\x01\x90V[a\x16\xE1\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x16\xB2V[\x90V[\x15a\x16\xEBWV[a\x16\xF3a\x01bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x17\t`\x04\x82\x01a\x16\xCCV[\x03\x90\xFD[\x90a\x17\x19_\x19\x91a\x0E\xAFV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x177a\x172a\x17<\x92a\x05\x08V[a\r\xDCV[a\x05\x08V[\x90V[\x90V[\x90a\x17Wa\x17Ra\x17^\x92a\x17#V[a\x17?V[\x82Ta\x17\rV[\x90UV[`\xA0\x1B\x90V[\x90a\x17w`\xFF`\xA0\x1B\x91a\x17bV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x17\x96a\x17\x91a\x17\x9D\x92a\x10\xEDV[a\x10\xF9V[\x82Ta\x17hV[\x90UV[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a\x17\xCA\x91\x02\x91a\x17\xC4_\x19\x84a\x17\xABV[\x92a\x17\xABV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\x17\xEAa\x17\xE5a\x17\xF2\x93a\x17#V[a\x17?V[\x90\x83Ta\x17\xAFV[\x90UV[_\x90V[a\x18\x0C\x91a\x18\x06a\x17\xF6V[\x91a\x17\xD4V[V[[\x81\x81\x10a\x18\x1AWPPV[\x80a\x18'_`\x01\x93a\x17\xFAV[\x01a\x18\x0FV[\x91\x90`\x1F\x81\x11a\x18=W[PPPV[a\x18Ia\x18n\x93a\x01\xD9V[\x90` a\x18U\x84a\x17\xA1V[\x83\x01\x93\x10a\x18vW[a\x18g\x90a\x17\xA1V[\x01\x90a\x18\x0EV[_\x80\x80a\x188V[\x91Pa\x18g\x81\x92\x90Pa\x18^V[\x90a\x18\x94\x90_\x19\x90`\x08\x02a\x045V[\x19\x16\x90V[\x81a\x18\xA3\x91a\x18\x84V[\x90`\x02\x02\x17\x90V[\x90a\x18\xB5\x81a\x03\x0BV[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x19uWa\x18\xD9\x82a\x18\xD3\x85Ta\x01\xA6V[\x85a\x18-V[` \x90`\x1F\x83\x11`\x01\x14a\x19\rW\x91\x80\x91a\x18\xFC\x93_\x92a\x19\x01W[PPa\x18\x99V[\x90U[V[\x90\x91P\x01Q_\x80a\x18\xF5V[`\x1F\x19\x83\x16\x91a\x19\x1C\x85a\x01\xD9V[\x92_[\x81\x81\x10a\x19]WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x19CW[PPP\x02\x01\x90Ua\x18\xFFV[a\x19S\x91\x01Q`\x1F\x84\x16\x90a\x18\x84V[\x90U_\x80\x80a\x197V[\x91\x93` `\x01\x81\x92\x87\x87\x01Q\x81U\x01\x95\x01\x92\x01a\x19\x1FV[a\x02\x85V[\x90a\x19\x84\x91a\x18\xABV[V[`\x01\x90\x81\x80\x03\x01\x04\x90V[[\x81\x81\x10a\x19\x9DWPPV[\x80a\x19\xAA_`\x01\x93a\x17\xFAV[\x01a\x19\x92V[\x90\x91\x82\x81\x10a\x19\xBFW[PPPV[a\x19\xDDa\x19\xD7a\x19\xD1a\x19\xE8\x95a\x19\x86V[\x92a\x19\x86V[\x92a\x0C\xECV[\x91\x82\x01\x91\x01\x90a\x19\x91V[_\x80\x80a\x19\xBAV[\x90h\x01\0\0\0\0\0\0\0\0\x81\x11a\x1A\x19W\x81a\x1A\x0Ea\x1A\x17\x93a\x0C\xE8V[\x90\x82\x81Ua\x19\xB0V[V[a\x02\x85V[Q\x90V[a\x1A,\x90Qa\x03\xB0V[\x90V[` \x01\x90V[a\x1A>\x82a\x1A\x1EV[\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x1A\xA1Wa\x1Ala\x1Af`\x01\x92a\x1Aa\x86\x86a\x19\xF0V[a\x1A/V[\x92a\x0C\xECV[\x92\x04\x91_[\x83\x81\x10a\x1A~WPPPPV[`\x01\x90` a\x1A\x94a\x1A\x8F\x86a\x1A\"V[a\x0F\x03V[\x94\x01\x93\x81\x84\x01U\x01a\x1AqV[a\x02\x85V[\x90a\x1A\xB0\x91a\x1A5V[V[\x9B\x97a\x1C\x13a\x1C/\x98a\x1CB\x9F\x9C\x96\x8F\x99a\x1C=\x9F\x9Aa\x1C(\x9Aa\x1C6\x9F\x98a\x1C\x0C\x94a\x1B\xF7a\x1C!\x9Ca\x1B\xF0\x8F\x94a\x1B\xE9a\x1C\x1A\x9Ea\x1B\xE2\x8F\x98a\x1B\xC1a\x1B\xFE\x9Aa\x1B\x1Ca\x1C\x05\x9Ea\x1B\x15a\x1B\x0Fa\x1B\n_a\r\xFBV[a\x03\xB0V[\x91a\x03\xB0V[\x14\x15a\x13\x1AV[a\x1B9\x85a\x1B2a\x1B,_a\x10QV[\x91a\x05\x08V[\x14\x15a\x13\x9CV[a\x1BV\x87a\x1BOa\x1BI_a\x10QV[\x91a\x05\x08V[\x14\x15a\x14DV[a\x1B{\x89a\x1Bta\x1Bna\x1Bi_a\r\xFBV[a\x03\xB0V[\x91a\x03\xB0V[\x14\x15a\x14\xECV[a\x1B\xA0\x8Ba\x1B\x99a\x1B\x93a\x1B\x8E_a\r\xFBV[a\x03\xB0V[\x91a\x03\xB0V[\x14\x15a\x15\x94V[a\x1B\xBAa\x1B\xB4a\x1B\xAF_a\r\xFBV[a\x03\xB0V[\x91a\x03\xB0V[\x14\x15a\x16<V[a\x1B\xDBa\x1B\xD5a\x1B\xD0_a\r\xFBV[a\x03\xB0V[\x91a\x03\xB0V[\x14\x15a\x16\xE4V[`\x04a\x17BV[`\x05a\x17BV[`\x01a\x0F\x06V[`\x02a\x0F\x06V[`\x03a\x17\x81V[`\x06a\x17BV[`\x07a\x17BV[`\x03a\x0F\x06V[`\x08a\x17BV[`\ta\x0F\x06V[`\na\x19zV[`\x0Ba\x19zV[`\x0Ca\x1A\xA6V[a \xE6V[V[\x90a\x1CZ\x9D\x9C\x9B\x9A\x99\x98\x97\x96\x95\x94\x93\x92\x91a\x11>V[V[\x90a\x1Cn\x91a\x1Cia mV[a\x1D\x8DV[V[P\x90V[\x91a\x1C\x7F\x90\x82a\x1CpV[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x1D>Wa\x1C\xA3\x82a\x1C\x9D\x85Ta\x01\xA6V[\x85a\x18-V[_\x90`\x1F\x83\x11`\x01\x14a\x1C\xD6W\x91\x80\x91a\x1C\xC5\x93_\x92a\x1C\xCAW[PPa\x18\x99V[\x90U[V[\x90\x91P\x015_\x80a\x1C\xBEV[`\x1F\x19\x83\x16\x91a\x1C\xE5\x85a\x01\xD9V[\x92_[\x81\x81\x10a\x1D&WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x1D\x0CW[PPP\x02\x01\x90Ua\x1C\xC8V[a\x1D\x1C\x91\x015`\x1F\x84\x16\x90a\x18\x84V[\x90U_\x80\x80a\x1D\0V[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a\x1C\xE8V[a\x02\x85V[\x90a\x1DN\x92\x91a\x1CtV[V[\x91\x90a\x1Dj\x81a\x1Dc\x81a\x1Do\x95a\x03\x0FV[\x80\x95a\x05\xEDV[a\x02{V[\x01\x90V[\x90\x91a\x1D\x8A\x92` \x83\x01\x92_\x81\x85\x03\x91\x01Ra\x1DPV[\x90V[a\x1D\x9A\x81\x83\x90`\na\x1DCV[\x90\x7F\x024\xA4\xE9\x10\xF2\xB1\xE6\x18\xF2\xC9;\xE3\x16\xEC\x0C\x7F@\xE1\xAF#\xFE3\xF9\xFB\xA2\xC5\xBB8\x8A\x95\xF2\x91a\x1D\xD1a\x1D\xC8a\x01bV[\x92\x83\x92\x83a\x1DsV[\x03\x90\xA1V[\x90a\x1D\xE0\x91a\x1C\\V[V[a\x1D\xEAa mV[a\x1D\xF2a\x1D\xF4V[V[a\x1E\x05a\x1E\0_a\r\xFBV[a \xE6V[V[a\x1E\x0Fa\x1D\xE2V[V[_\x90V[a\x1E!a\x1E&\x91a\x0F\xCAV[a\x049V[\x90V[a\x1E3\x90Ta\x1E\x15V[\x90V[a\x1E>a\x1E\x11V[Pa\x1EH_a\x1E)V[\x90V[\x90a\x1E]\x91a\x1EXa mV[a\x1F\xA1V[V[P\x90V[5a\x1Em\x81a\x03\xBCV[\x90V[\x90V[\x90\x91a\x1E\x7F\x90\x83a\x1E_V[\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x1E\xE2Wa\x1E\xADa\x1E\xA7`\x01\x92a\x1E\xA2\x86\x86a\x19\xF0V[a\x1EpV[\x92a\x0C\xECV[\x92\x04\x91_[\x83\x81\x10a\x1E\xBFWPPPPV[`\x01\x90` a\x1E\xD5a\x1E\xD0\x86a\x1EcV[a\x0F\x03V[\x94\x01\x93\x81\x84\x01U\x01a\x1E\xB2V[a\x02\x85V[\x90a\x1E\xF2\x92\x91a\x1EsV[V[` \x91\x81R\x01\x90V[a\x1F\x06\x90a\x03\xB0V[\x90RV[\x90a\x1F\x17\x81` \x93a\x1E\xFDV[\x01\x90V[Pa\x1F*\x90` \x81\x01\x90a\x03\xD0V[\x90V[` \x01\x90V[\x91a\x1FA\x82a\x1FG\x92a\x1E\xF4V[\x92a\x1EpV[\x90\x81_\x90[\x82\x82\x10a\x1FZWPPPP\x90V[\x90\x91\x92\x93a\x1F|a\x1Fv`\x01\x92a\x1Fq\x88\x86a\x1F\x1BV[a\x1F\nV[\x95a\x1F-V[\x92\x01\x90\x92\x91\x92a\x1FLV[\x90\x91a\x1F\x9E\x92` \x83\x01\x92_\x81\x85\x03\x91\x01Ra\x1F3V[\x90V[a\x1F\xAE\x81\x83\x90`\x0Ca\x1E\xE7V[\x90\x7F\xB4\xA2\x86jX6\x99\xC6\xED{w\xA1R\x1F\xADBO\x8E\xDC\xCA0`\x1FD,*[v\xA0\x10[\xE2\x91a\x1F\xE5a\x1F\xDCa\x01bV[\x92\x83\x92\x83a\x1F\x87V[\x03\x90\xA1V[\x90a\x1F\xF4\x91a\x1EKV[V[a \x07\x90a \x02a mV[a \tV[V[\x80a $a \x1Ea \x19_a\r\xFBV[a\x03\xB0V[\x91a\x03\xB0V[\x14a 4Wa 2\x90a \xE6V[V[a ^a @_a\r\xFBV[a Ha\x01bV[\x91\x82\x91c\x1EO\xBD\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x04\x86V[\x03\x90\xFD[a k\x90a\x1F\xF6V[V[a ua\x1E6V[a \x8Ea \x88a \x83a!EV[a\x03\xB0V[\x91a\x03\xB0V[\x03a \x95WV[a \xBEa \xA0a!EV[a \xA8a\x01bV[\x91\x82\x91c\x11\x8C\xDA\xA7`\xE0\x1B\x83R`\x04\x83\x01a\x04\x86V[\x03\x90\xFD[\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90V[a \xEF_a\x1E)V[a \xF9\x82_a\x0F\x06V[\x90a!-a!'\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x93a\x0E\xF7V[\x91a\x0E\xF7V[\x91a!6a\x01bV[\x80a!@\x81a\x03\xFDV[\x03\x90\xA3V[a!Ma\x1E\x11V[P3\x90V\xFE\xA2dipfsX\"\x12 \xC3\x92`\xC8\xD5\xD3\xB7t\xEC;\x98\x08pZ\x87\xEF\xAA\xD4/\xE3\x9D\xE4\xCB\xDA\x19\x9B\xDE\xD7D\xC8\xDE\xACdsolcC\0\x08\x19\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60c06040526004361015610013575b610dc2565b61001d5f3561015c565b80630743bf6e146101575780632a84b0f01461015257806341fc712d1461014d57806357d1ba25146101485780635a2d9c181461014357806362c73caa1461013e57806366a1d108146101395780636edd6c0914610134578063715018a61461012f57806385e1f4d01461012a5780638da5cb5b14610125578063a3c6e1e714610120578063aa6a43d81461011b578063bf6db6f814610116578063cb60840814610111578063d1f4737c1461010c578063e79388e614610107578063f2fde38b14610102578063f881afaf146100fd5763f8a144be0361000e57610d8d565b610d49565b610c83565b610c4e565b610bbb565b610b78565b610ace565b610a8a565b610a46565b610a02565b6109cd565b61098b565b610956565b610912565b6108cf565b610810565b61052d565b61049b565b610402565b61036c565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f91031261017a57565b61016c565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b90600160028304921680156101c6575b60208310146101c157565b610192565b91607f16916101b6565b60209181520190565b5f5260205f2090565b905f92918054906101fc6101f5836101a6565b80946101d0565b916001811690815f146102535750600114610217575b505050565b61022491929394506101d9565b915f925b81841061023b57505001905f8080610212565b60018160209295939554848601520191019290610228565b92949550505060ff19168252151560200201905f8080610212565b90610278916101e2565b90565b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906102a39061027b565b810190811067ffffffffffffffff8211176102bd57604052565b610285565b906102e26102db926102d2610162565b9384809261026e565b0383610299565b565b905f106102f7576102f4906102c2565b90565b61017f565b610308600b5f906102e4565b90565b5190565b60209181520190565b90825f9392825e0152565b61034261034b602093610350936103398161030b565b9384809361030f565b95869101610318565b61027b565b0190565b6103699160208201915f818403910152610323565b90565b3461039c5761037c366004610170565b6103986103876102fc565b61038f610162565b91829182610354565b0390f35b610168565b5f80fd5b60018060a01b031690565b6103b9906103a5565b90565b6103c5816103b0565b036103cc57565b5f80fd5b905035906103dd826103bc565b565b906020828203126103f8576103f5915f016103d0565b90565b61016c565b5f0190565b346104305761041a6104153660046103df565b610f98565b610422610162565b8061042c816103fd565b0390f35b610168565b1c90565b60018060a01b031690565b6104549060086104599302610435565b610439565b90565b906104679154610444565b90565b61047660095f9061045c565b90565b610482906103b0565b9052565b9190610499905f60208501940190610479565b565b346104cb576104ab366004610170565b6104c76104b661046a565b6104be610162565b91829182610486565b0390f35b610168565b90565b6104e39060086104e89302610435565b6104d0565b90565b906104f691546104d3565b90565b61050560065f906104eb565b90565b90565b61051490610508565b9052565b919061052b905f6020850194019061050b565b565b3461055d5761053d366004610170565b6105596105486104f9565b610550610162565b91829182610518565b0390f35b610168565b61056b81610508565b0361057257565b5f80fd5b9050359061058382610562565b565b151590565b61059381610585565b0361059a57565b5f80fd5b905035906105ab8261058a565b565b5f80fd5b5f80fd5b906105c86105c1610162565b9283610299565b565b67ffffffffffffffff81116105e8576105e460209161027b565b0190565b610285565b90825f939282370152565b9092919261060d610608826105ca565b6105b5565b9381855260208501908284011161062957610627926105ed565b565b6105b1565b9080601f8301121561064c57816020610649933591016105f8565b90565b6105ad565b67ffffffffffffffff81116106695760208091020190565b610285565b5f80fd5b9092919261068761068282610651565b6105b5565b93818552602080860192028301928184116106c457915b8383106106ab5750505050565b602080916106b984866103d0565b81520192019161069e565b61066e565b9080601f830112156106e7578160206106e493359101610672565b90565b6105ad565b9190916101c08184031261080b57610706835f83016103d0565b926107148160208401610576565b926107228260408501610576565b9261073083606083016103d0565b9261073e81608084016103d0565b9261074c8260a0850161059e565b9261075a8360c08301610576565b926107688160e08401610576565b926107778261010085016103d0565b92610786836101208301610576565b926107958161014084016103d0565b9261016083013567ffffffffffffffff811161080657826107b791850161062e565b9261018081013567ffffffffffffffff811161080157836107d991830161062e565b926101a082013567ffffffffffffffff81116107fc576107f992016106c9565b90565b6103a1565b6103a1565b6103a1565b61016c565b346108515761083b6108233660046106ec565b9c9b909b9a919a999299989398979497969596611c44565b610843610162565b8061084d816103fd565b0390f35b610168565b5f80fd5b909182601f830112156108945781359167ffffffffffffffff831161088f57602001926001830284011161088a57565b61066e565b610856565b6105ad565b906020828203126108ca575f82013567ffffffffffffffff81116108c5576108c1920161085a565b9091565b6103a1565b61016c565b346108fe576108e86108e2366004610899565b90611dd6565b6108f0610162565b806108fa816103fd565b0390f35b610168565b61090f600a5f906102e4565b90565b3461094257610922366004610170565b61093e61092d610903565b610935610162565b91829182610354565b0390f35b610168565b61095360015f9061045c565b90565b3461098657610966366004610170565b610982610971610947565b610979610162565b91829182610486565b0390f35b610168565b346109b95761099b366004610170565b6109a3611e07565b6109ab610162565b806109b5816103fd565b0390f35b610168565b6109ca60045f906104eb565b90565b346109fd576109dd366004610170565b6109f96109e86109be565b6109f0610162565b91829182610518565b0390f35b610168565b34610a3257610a12366004610170565b610a2e610a1d611e36565b610a25610162565b91829182610486565b0390f35b610168565b610a4360085f906104eb565b90565b34610a7657610a56366004610170565b610a72610a61610a37565b610a69610162565b91829182610518565b0390f35b610168565b610a8760025f9061045c565b90565b34610aba57610a9a366004610170565b610ab6610aa5610a7b565b610aad610162565b91829182610486565b0390f35b610168565b610acb60035f9061045c565b90565b34610afe57610ade366004610170565b610afa610ae9610abf565b610af1610162565b91829182610486565b0390f35b610168565b909182601f83011215610b3d5781359167ffffffffffffffff8311610b38576020019260208302840111610b3357565b61066e565b610856565b6105ad565b90602082820312610b73575f82013567ffffffffffffffff8111610b6e57610b6a9201610b03565b9091565b6103a1565b61016c565b34610ba757610b91610b8b366004610b42565b90611fea565b610b99610162565b80610ba3816103fd565b0390f35b610168565b610bb860075f906104eb565b90565b34610beb57610bcb366004610170565b610be7610bd6610bac565b610bde610162565b91829182610518565b0390f35b610168565b60ff1690565b610c06906008610c0b9302610435565b610bf0565b90565b90610c199154610bf6565b90565b610c296003601490610c0e565b90565b610c3590610585565b9052565b9190610c4c905f60208501940190610c2c565b565b34610c7e57610c5e366004610170565b610c7a610c69610c1c565b610c71610162565b91829182610c39565b0390f35b610168565b34610cb157610c9b610c963660046103df565b612062565b610ca3610162565b80610cad816103fd565b0390f35b610168565b90602082820312610ccf57610ccc915f01610576565b90565b61016c565b634e487b7160e01b5f52603260045260245ffd5b5490565b5f5260205f2090565b610cfe81610ce8565b821015610d1857610d10600191610cec565b910201905f90565b610cd4565b600c610d2881610ce8565b821015610d4557610d4291610d3c91610cf5565b9061045c565b90565b5f80fd5b34610d7957610d75610d64610d5f366004610cb6565b610d1d565b610d6c610162565b91829182610486565b0390f35b610168565b610d8a60055f906104eb565b90565b34610dbd57610d9d366004610170565b610db9610da8610d7e565b610db0610162565b91829182610518565b0390f35b610168565b5f80fd5b610dd790610dd261206d565b610f26565b565b90565b90565b610df3610dee610df892610dd9565b610ddc565b6103a5565b90565b610e0490610ddf565b90565b60207f6164647265737300000000000000000000000000000000000000000000000000917f4e657720726f6c6c7570206f776e65722063616e6e6f74206265207a65726f205f8201520152565b610e61602760409261030f565b610e6a81610e07565b0190565b610e839060208101905f818303910152610e54565b90565b15610e8d57565b610e95610162565b62461bcd60e51b815280610eab60048201610e6e565b0390fd5b5f1b90565b90610ec560018060a01b0391610eaf565b9181191691161790565b610ee3610ede610ee8926103a5565b610ddc565b6103a5565b90565b610ef490610ecf565b90565b610f0090610eeb565b90565b90565b90610f1b610f16610f2292610ef7565b610f03565b8254610eb4565b9055565b610f4b81610f44610f3e610f395f610dfb565b6103b0565b916103b0565b1415610e86565b610f56816009610f06565b610f807f8829bee46683608d5fd80e243c0fae04d129ce172f70db1021c1128074a6f4d991610ef7565b90610f89610162565b80610f93816103fd565b0390a2565b610fa190610dc6565b565b60401c90565b610fb5610fba91610fa3565b610bf0565b90565b610fc79054610fa9565b90565b5f1c90565b67ffffffffffffffff1690565b610fe8610fed91610fca565b610fcf565b90565b610ffa9054610fdc565b90565b67ffffffffffffffff1690565b61101e61101961102392610dd9565b610ddc565b610ffd565b90565b90565b61103d61103861104292611026565b610ddc565b610ffd565b90565b61104e90610eeb565b90565b61106561106061106a92610dd9565b610ddc565b610508565b90565b9061108067ffffffffffffffff91610eaf565b9181191691161790565b61109e6110996110a392610ffd565b610ddc565b610ffd565b90565b90565b906110be6110b96110c59261108a565b6110a6565b825461106d565b9055565b60401b90565b906110e368ff0000000000000000916110c9565b9181191691161790565b6110f690610585565b90565b90565b9061111161110c611118926110ed565b6110f9565b82546110cf565b9055565b61112590611029565b9052565b919061113c905f6020850194019061111c565b565b9c9b9a999897969594939291906111536120c2565b60805261116c6111665f60805101610fbd565b15610585565b60a05261117c5f60805101610ff0565b8061118f6111895f61100a565b91610ffd565b14806112b8575b906111aa6111a46001611029565b91610ffd565b1480611290575b6111bc909115610585565b908161127f575b5061125c576111f09d6111e36111d96001611029565b5f608051016110a9565b60a051611248575b611ab2565b60a0516111fa575b565b6112085f80608051016110fc565b60016112407fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d291611237610162565b91829182611129565b0390a16111f8565b61125760015f608051016110fc565b6111eb565b611264610162565b63f92ee8a960e01b81528061127b600482016103fd565b0390fd5b61128a915015610585565b5f6111c3565b506111bc61129d30611045565b3b6112b06112aa5f611051565b91610508565b1490506111b1565b5060a051611196565b5f7f4f776e65722063616e6e6f74206265207a65726f206164647265737300000000910152565b6112f5601c60209261030f565b6112fe816112c1565b0190565b6113179060208101905f8183039101526112e8565b90565b1561132157565b611329610162565b62461bcd60e51b81528061133f60048201611302565b0390fd5b5f7f436861696e2049442063616e6e6f74206265207a65726f000000000000000000910152565b611377601760209261030f565b61138081611343565b0190565b6113999060208101905f81830391015261136a565b90565b156113a357565b6113ab610162565b62461bcd60e51b8152806113c160048201611384565b0390fd5b60207f726f000000000000000000000000000000000000000000000000000000000000917f53657175656e63696e6720636861696e2049442063616e6e6f74206265207a655f8201520152565b61141f602260409261030f565b611428816113c5565b0190565b6114419060208101905f818303910152611412565b90565b1561144b57565b611453610162565b62461bcd60e51b8152806114696004820161142c565b0390fd5b60207f65207a65726f0000000000000000000000000000000000000000000000000000917f417262697472756d2062726964676520616464726573732063616e6e6f7420625f8201520152565b6114c7602660409261030f565b6114d08161146d565b0190565b6114e99060208101905f8183039101526114ba565b90565b156114f357565b6114fb610162565b62461bcd60e51b815280611511600482016114d4565b0390fd5b60207f207a65726f000000000000000000000000000000000000000000000000000000917f417262697472756d20696e626f7820616464726573732063616e6e6f742062655f8201520152565b61156f602560409261030f565b61157881611515565b0190565b6115919060208101905f818303910152611562565b90565b1561159b57565b6115a3610162565b62461bcd60e51b8152806115b96004820161157c565b0390fd5b60207f6f74206265207a65726f00000000000000000000000000000000000000000000917f53657175656e63696e6720636f6e747261637420616464726573732063616e6e5f8201520152565b611617602a60409261030f565b611620816115bd565b0190565b6116399060208101905f81830391015261160a565b90565b1561164357565b61164b610162565b62461bcd60e51b81528061166160048201611624565b0390fd5b60207f6573730000000000000000000000000000000000000000000000000000000000917f526f6c6c7570206f776e65722063616e6e6f74206265207a65726f20616464725f8201520152565b6116bf602360409261030f565b6116c881611665565b0190565b6116e19060208101905f8183039101526116b2565b90565b156116eb57565b6116f3610162565b62461bcd60e51b815280611709600482016116cc565b0390fd5b906117195f1991610eaf565b9181191691161790565b61173761173261173c92610508565b610ddc565b610508565b90565b90565b9061175761175261175e92611723565b61173f565b825461170d565b9055565b60a01b90565b9061177760ff60a01b91611762565b9181191691161790565b9061179661179161179d926110ed565b6110f9565b8254611768565b9055565b601f602091010490565b1b90565b919060086117ca9102916117c45f19846117ab565b926117ab565b9181191691161790565b91906117ea6117e56117f293611723565b61173f565b9083546117af565b9055565b5f90565b61180c916118066117f6565b916117d4565b565b5b81811061181a575050565b806118275f6001936117fa565b0161180f565b9190601f811161183d575b505050565b61184961186e936101d9565b906020611855846117a1565b83019310611876575b611867906117a1565b019061180e565b5f8080611838565b91506118678192905061185e565b90611894905f1990600802610435565b191690565b816118a391611884565b906002021790565b906118b58161030b565b9067ffffffffffffffff8211611975576118d9826118d385546101a6565b8561182d565b602090601f831160011461190d579180916118fc935f92611901575b5050611899565b90555b565b90915001515f806118f5565b601f1983169161191c856101d9565b925f5b81811061195d57509160029391856001969410611943575b505050020190556118ff565b611953910151601f841690611884565b90555f8080611937565b9193602060018192878701518155019501920161191f565b610285565b90611984916118ab565b565b600190818003010490565b5b81811061199d575050565b806119aa5f6001936117fa565b01611992565b90918281106119bf575b505050565b6119dd6119d76119d16119e895611986565b92611986565b92610cec565b918201910190611991565b5f80806119ba565b90680100000000000000008111611a195781611a0e611a1793610ce8565b908281556119b0565b565b610285565b5190565b611a2c90516103b0565b90565b60200190565b611a3e82611a1e565b9167ffffffffffffffff8311611aa157611a6c611a66600192611a6186866119f0565b611a2f565b92610cec565b9204915f5b838110611a7e5750505050565b6001906020611a94611a8f86611a22565b610f03565b9401938184015501611a71565b610285565b90611ab091611a35565b565b9b97611c13611c2f98611c429f9c968f99611c3d9f9a611c289a611c369f98611c0c94611bf7611c219c611bf08f94611be9611c1a9e611be28f98611bc1611bfe9a611b1c611c059e611b15611b0f611b0a5f610dfb565b6103b0565b916103b0565b141561131a565b611b3985611b32611b2c5f611051565b91610508565b141561139c565b611b5687611b4f611b495f611051565b91610508565b1415611444565b611b7b89611b74611b6e611b695f610dfb565b6103b0565b916103b0565b14156114ec565b611ba08b611b99611b93611b8e5f610dfb565b6103b0565b916103b0565b1415611594565b611bba611bb4611baf5f610dfb565b6103b0565b916103b0565b141561163c565b611bdb611bd5611bd05f610dfb565b6103b0565b916103b0565b14156116e4565b6004611742565b6005611742565b6001610f06565b6002610f06565b6003611781565b6006611742565b6007611742565b6003610f06565b6008611742565b6009610f06565b600a61197a565b600b61197a565b600c611aa6565b6120e6565b565b90611c5a9d9c9b9a99989796959493929161113e565b565b90611c6e91611c6961206d565b611d8d565b565b5090565b91611c7f9082611c70565b9067ffffffffffffffff8211611d3e57611ca382611c9d85546101a6565b8561182d565b5f90601f8311600114611cd657918091611cc5935f92611cca575b5050611899565b90555b565b90915001355f80611cbe565b601f19831691611ce5856101d9565b925f5b818110611d2657509160029391856001969410611d0c575b50505002019055611cc8565b611d1c910135601f841690611884565b90555f8080611d00565b91936020600181928787013581550195019201611ce8565b610285565b90611d4e9291611c74565b565b9190611d6a81611d6381611d6f9561030f565b80956105ed565b61027b565b0190565b9091611d8a9260208301925f818503910152611d50565b90565b611d9a818390600a611d43565b907f0234a4e910f2b1e618f2c93be316ec0c7f40e1af23fe33f9fba2c5bb388a95f291611dd1611dc8610162565b92839283611d73565b0390a1565b90611de091611c5c565b565b611dea61206d565b611df2611df4565b565b611e05611e005f610dfb565b6120e6565b565b611e0f611de2565b565b5f90565b611e21611e2691610fca565b610439565b90565b611e339054611e15565b90565b611e3e611e11565b50611e485f611e29565b90565b90611e5d91611e5861206d565b611fa1565b565b5090565b35611e6d816103bc565b90565b90565b9091611e7f9083611e5f565b9167ffffffffffffffff8311611ee257611ead611ea7600192611ea286866119f0565b611e70565b92610cec565b9204915f5b838110611ebf5750505050565b6001906020611ed5611ed086611e63565b610f03565b9401938184015501611eb2565b610285565b90611ef29291611e73565b565b60209181520190565b611f06906103b0565b9052565b90611f1781602093611efd565b0190565b50611f2a9060208101906103d0565b90565b60200190565b91611f4182611f4792611ef4565b92611e70565b90815f905b828210611f5a575050505090565b90919293611f7c611f76600192611f718886611f1b565b611f0a565b95611f2d565b920190929192611f4c565b9091611f9e9260208301925f818503910152611f33565b90565b611fae818390600c611ee7565b907fb4a2866a583699c6ed7b77a1521fad424f8edcca30601f442c2a5b76a0105be291611fe5611fdc610162565b92839283611f87565b0390a1565b90611ff491611e4b565b565b6120079061200261206d565b612009565b565b8061202461201e6120195f610dfb565b6103b0565b916103b0565b1461203457612032906120e6565b565b61205e6120405f610dfb565b612048610162565b918291631e4fbdf760e01b835260048301610486565b0390fd5b61206b90611ff6565b565b612075611e36565b61208e612088612083612145565b6103b0565b916103b0565b0361209557565b6120be6120a0612145565b6120a8610162565b91829163118cdaa760e01b835260048301610486565b0390fd5b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0090565b6120ef5f611e29565b6120f9825f610f06565b9061212d6121277f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e093610ef7565b91610ef7565b91612136610162565b80612140816103fd565b0390a3565b61214d611e11565b50339056fea2646970667358221220c39260c8d5d3b774ec3b9808705a87efaad42fe39de4cbda199bded744c8deac64736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xC0`@R`\x046\x10\x15a\0\x13W[a\r\xC2V[a\0\x1D_5a\x01\\V[\x80c\x07C\xBFn\x14a\x01WW\x80c*\x84\xB0\xF0\x14a\x01RW\x80cA\xFCq-\x14a\x01MW\x80cW\xD1\xBA%\x14a\x01HW\x80cZ-\x9C\x18\x14a\x01CW\x80cb\xC7<\xAA\x14a\x01>W\x80cf\xA1\xD1\x08\x14a\x019W\x80cn\xDDl\t\x14a\x014W\x80cqP\x18\xA6\x14a\x01/W\x80c\x85\xE1\xF4\xD0\x14a\x01*W\x80c\x8D\xA5\xCB[\x14a\x01%W\x80c\xA3\xC6\xE1\xE7\x14a\x01 W\x80c\xAAjC\xD8\x14a\x01\x1BW\x80c\xBFm\xB6\xF8\x14a\x01\x16W\x80c\xCB`\x84\x08\x14a\x01\x11W\x80c\xD1\xF4s|\x14a\x01\x0CW\x80c\xE7\x93\x88\xE6\x14a\x01\x07W\x80c\xF2\xFD\xE3\x8B\x14a\x01\x02W\x80c\xF8\x81\xAF\xAF\x14a\0\xFDWc\xF8\xA1D\xBE\x03a\0\x0EWa\r\x8DV[a\rIV[a\x0C\x83V[a\x0CNV[a\x0B\xBBV[a\x0BxV[a\n\xCEV[a\n\x8AV[a\nFV[a\n\x02V[a\t\xCDV[a\t\x8BV[a\tVV[a\t\x12V[a\x08\xCFV[a\x08\x10V[a\x05-V[a\x04\x9BV[a\x04\x02V[a\x03lV[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x91\x03\x12a\x01zWV[a\x01lV[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x01\xC6W[` \x83\x10\x14a\x01\xC1WV[a\x01\x92V[\x91`\x7F\x16\x91a\x01\xB6V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x01\xFCa\x01\xF5\x83a\x01\xA6V[\x80\x94a\x01\xD0V[\x91`\x01\x81\x16\x90\x81_\x14a\x02SWP`\x01\x14a\x02\x17W[PPPV[a\x02$\x91\x92\x93\x94Pa\x01\xD9V[\x91_\x92[\x81\x84\x10a\x02;WPP\x01\x90_\x80\x80a\x02\x12V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x02(V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x02\x12V[\x90a\x02x\x91a\x01\xE2V[\x90V[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x02\xA3\x90a\x02{V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x02\xBDW`@RV[a\x02\x85V[\x90a\x02\xE2a\x02\xDB\x92a\x02\xD2a\x01bV[\x93\x84\x80\x92a\x02nV[\x03\x83a\x02\x99V[V[\x90_\x10a\x02\xF7Wa\x02\xF4\x90a\x02\xC2V[\x90V[a\x01\x7FV[a\x03\x08`\x0B_\x90a\x02\xE4V[\x90V[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[a\x03Ba\x03K` \x93a\x03P\x93a\x039\x81a\x03\x0BV[\x93\x84\x80\x93a\x03\x0FV[\x95\x86\x91\x01a\x03\x18V[a\x02{V[\x01\x90V[a\x03i\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x03#V[\x90V[4a\x03\x9CWa\x03|6`\x04a\x01pV[a\x03\x98a\x03\x87a\x02\xFCV[a\x03\x8Fa\x01bV[\x91\x82\x91\x82a\x03TV[\x03\x90\xF3[a\x01hV[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x03\xB9\x90a\x03\xA5V[\x90V[a\x03\xC5\x81a\x03\xB0V[\x03a\x03\xCCWV[_\x80\xFD[\x90P5\x90a\x03\xDD\x82a\x03\xBCV[V[\x90` \x82\x82\x03\x12a\x03\xF8Wa\x03\xF5\x91_\x01a\x03\xD0V[\x90V[a\x01lV[_\x01\x90V[4a\x040Wa\x04\x1Aa\x04\x156`\x04a\x03\xDFV[a\x0F\x98V[a\x04\"a\x01bV[\x80a\x04,\x81a\x03\xFDV[\x03\x90\xF3[a\x01hV[\x1C\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x04T\x90`\x08a\x04Y\x93\x02a\x045V[a\x049V[\x90V[\x90a\x04g\x91Ta\x04DV[\x90V[a\x04v`\t_\x90a\x04\\V[\x90V[a\x04\x82\x90a\x03\xB0V[\x90RV[\x91\x90a\x04\x99\x90_` \x85\x01\x94\x01\x90a\x04yV[V[4a\x04\xCBWa\x04\xAB6`\x04a\x01pV[a\x04\xC7a\x04\xB6a\x04jV[a\x04\xBEa\x01bV[\x91\x82\x91\x82a\x04\x86V[\x03\x90\xF3[a\x01hV[\x90V[a\x04\xE3\x90`\x08a\x04\xE8\x93\x02a\x045V[a\x04\xD0V[\x90V[\x90a\x04\xF6\x91Ta\x04\xD3V[\x90V[a\x05\x05`\x06_\x90a\x04\xEBV[\x90V[\x90V[a\x05\x14\x90a\x05\x08V[\x90RV[\x91\x90a\x05+\x90_` \x85\x01\x94\x01\x90a\x05\x0BV[V[4a\x05]Wa\x05=6`\x04a\x01pV[a\x05Ya\x05Ha\x04\xF9V[a\x05Pa\x01bV[\x91\x82\x91\x82a\x05\x18V[\x03\x90\xF3[a\x01hV[a\x05k\x81a\x05\x08V[\x03a\x05rWV[_\x80\xFD[\x90P5\x90a\x05\x83\x82a\x05bV[V[\x15\x15\x90V[a\x05\x93\x81a\x05\x85V[\x03a\x05\x9AWV[_\x80\xFD[\x90P5\x90a\x05\xAB\x82a\x05\x8AV[V[_\x80\xFD[_\x80\xFD[\x90a\x05\xC8a\x05\xC1a\x01bV[\x92\x83a\x02\x99V[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x05\xE8Wa\x05\xE4` \x91a\x02{V[\x01\x90V[a\x02\x85V[\x90\x82_\x93\x92\x827\x01RV[\x90\x92\x91\x92a\x06\ra\x06\x08\x82a\x05\xCAV[a\x05\xB5V[\x93\x81\x85R` \x85\x01\x90\x82\x84\x01\x11a\x06)Wa\x06'\x92a\x05\xEDV[V[a\x05\xB1V[\x90\x80`\x1F\x83\x01\x12\x15a\x06LW\x81` a\x06I\x935\x91\x01a\x05\xF8V[\x90V[a\x05\xADV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x06iW` \x80\x91\x02\x01\x90V[a\x02\x85V[_\x80\xFD[\x90\x92\x91\x92a\x06\x87a\x06\x82\x82a\x06QV[a\x05\xB5V[\x93\x81\x85R` \x80\x86\x01\x92\x02\x83\x01\x92\x81\x84\x11a\x06\xC4W\x91[\x83\x83\x10a\x06\xABWPPPPV[` \x80\x91a\x06\xB9\x84\x86a\x03\xD0V[\x81R\x01\x92\x01\x91a\x06\x9EV[a\x06nV[\x90\x80`\x1F\x83\x01\x12\x15a\x06\xE7W\x81` a\x06\xE4\x935\x91\x01a\x06rV[\x90V[a\x05\xADV[\x91\x90\x91a\x01\xC0\x81\x84\x03\x12a\x08\x0BWa\x07\x06\x83_\x83\x01a\x03\xD0V[\x92a\x07\x14\x81` \x84\x01a\x05vV[\x92a\x07\"\x82`@\x85\x01a\x05vV[\x92a\x070\x83``\x83\x01a\x03\xD0V[\x92a\x07>\x81`\x80\x84\x01a\x03\xD0V[\x92a\x07L\x82`\xA0\x85\x01a\x05\x9EV[\x92a\x07Z\x83`\xC0\x83\x01a\x05vV[\x92a\x07h\x81`\xE0\x84\x01a\x05vV[\x92a\x07w\x82a\x01\0\x85\x01a\x03\xD0V[\x92a\x07\x86\x83a\x01 \x83\x01a\x05vV[\x92a\x07\x95\x81a\x01@\x84\x01a\x03\xD0V[\x92a\x01`\x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x08\x06W\x82a\x07\xB7\x91\x85\x01a\x06.V[\x92a\x01\x80\x81\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x08\x01W\x83a\x07\xD9\x91\x83\x01a\x06.V[\x92a\x01\xA0\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x07\xFCWa\x07\xF9\x92\x01a\x06\xC9V[\x90V[a\x03\xA1V[a\x03\xA1V[a\x03\xA1V[a\x01lV[4a\x08QWa\x08;a\x08#6`\x04a\x06\xECV[\x9C\x9B\x90\x9B\x9A\x91\x9A\x99\x92\x99\x98\x93\x98\x97\x94\x97\x96\x95\x96a\x1CDV[a\x08Ca\x01bV[\x80a\x08M\x81a\x03\xFDV[\x03\x90\xF3[a\x01hV[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x08\x94W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x08\x8FW` \x01\x92`\x01\x83\x02\x84\x01\x11a\x08\x8AWV[a\x06nV[a\x08VV[a\x05\xADV[\x90` \x82\x82\x03\x12a\x08\xCAW_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x08\xC5Wa\x08\xC1\x92\x01a\x08ZV[\x90\x91V[a\x03\xA1V[a\x01lV[4a\x08\xFEWa\x08\xE8a\x08\xE26`\x04a\x08\x99V[\x90a\x1D\xD6V[a\x08\xF0a\x01bV[\x80a\x08\xFA\x81a\x03\xFDV[\x03\x90\xF3[a\x01hV[a\t\x0F`\n_\x90a\x02\xE4V[\x90V[4a\tBWa\t\"6`\x04a\x01pV[a\t>a\t-a\t\x03V[a\t5a\x01bV[\x91\x82\x91\x82a\x03TV[\x03\x90\xF3[a\x01hV[a\tS`\x01_\x90a\x04\\V[\x90V[4a\t\x86Wa\tf6`\x04a\x01pV[a\t\x82a\tqa\tGV[a\tya\x01bV[\x91\x82\x91\x82a\x04\x86V[\x03\x90\xF3[a\x01hV[4a\t\xB9Wa\t\x9B6`\x04a\x01pV[a\t\xA3a\x1E\x07V[a\t\xABa\x01bV[\x80a\t\xB5\x81a\x03\xFDV[\x03\x90\xF3[a\x01hV[a\t\xCA`\x04_\x90a\x04\xEBV[\x90V[4a\t\xFDWa\t\xDD6`\x04a\x01pV[a\t\xF9a\t\xE8a\t\xBEV[a\t\xF0a\x01bV[\x91\x82\x91\x82a\x05\x18V[\x03\x90\xF3[a\x01hV[4a\n2Wa\n\x126`\x04a\x01pV[a\n.a\n\x1Da\x1E6V[a\n%a\x01bV[\x91\x82\x91\x82a\x04\x86V[\x03\x90\xF3[a\x01hV[a\nC`\x08_\x90a\x04\xEBV[\x90V[4a\nvWa\nV6`\x04a\x01pV[a\nra\naa\n7V[a\nia\x01bV[\x91\x82\x91\x82a\x05\x18V[\x03\x90\xF3[a\x01hV[a\n\x87`\x02_\x90a\x04\\V[\x90V[4a\n\xBAWa\n\x9A6`\x04a\x01pV[a\n\xB6a\n\xA5a\n{V[a\n\xADa\x01bV[\x91\x82\x91\x82a\x04\x86V[\x03\x90\xF3[a\x01hV[a\n\xCB`\x03_\x90a\x04\\V[\x90V[4a\n\xFEWa\n\xDE6`\x04a\x01pV[a\n\xFAa\n\xE9a\n\xBFV[a\n\xF1a\x01bV[\x91\x82\x91\x82a\x04\x86V[\x03\x90\xF3[a\x01hV[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x0B=W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x0B8W` \x01\x92` \x83\x02\x84\x01\x11a\x0B3WV[a\x06nV[a\x08VV[a\x05\xADV[\x90` \x82\x82\x03\x12a\x0BsW_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x0BnWa\x0Bj\x92\x01a\x0B\x03V[\x90\x91V[a\x03\xA1V[a\x01lV[4a\x0B\xA7Wa\x0B\x91a\x0B\x8B6`\x04a\x0BBV[\x90a\x1F\xEAV[a\x0B\x99a\x01bV[\x80a\x0B\xA3\x81a\x03\xFDV[\x03\x90\xF3[a\x01hV[a\x0B\xB8`\x07_\x90a\x04\xEBV[\x90V[4a\x0B\xEBWa\x0B\xCB6`\x04a\x01pV[a\x0B\xE7a\x0B\xD6a\x0B\xACV[a\x0B\xDEa\x01bV[\x91\x82\x91\x82a\x05\x18V[\x03\x90\xF3[a\x01hV[`\xFF\x16\x90V[a\x0C\x06\x90`\x08a\x0C\x0B\x93\x02a\x045V[a\x0B\xF0V[\x90V[\x90a\x0C\x19\x91Ta\x0B\xF6V[\x90V[a\x0C)`\x03`\x14\x90a\x0C\x0EV[\x90V[a\x0C5\x90a\x05\x85V[\x90RV[\x91\x90a\x0CL\x90_` \x85\x01\x94\x01\x90a\x0C,V[V[4a\x0C~Wa\x0C^6`\x04a\x01pV[a\x0Cza\x0Cia\x0C\x1CV[a\x0Cqa\x01bV[\x91\x82\x91\x82a\x0C9V[\x03\x90\xF3[a\x01hV[4a\x0C\xB1Wa\x0C\x9Ba\x0C\x966`\x04a\x03\xDFV[a bV[a\x0C\xA3a\x01bV[\x80a\x0C\xAD\x81a\x03\xFDV[\x03\x90\xF3[a\x01hV[\x90` \x82\x82\x03\x12a\x0C\xCFWa\x0C\xCC\x91_\x01a\x05vV[\x90V[a\x01lV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[T\x90V[_R` _ \x90V[a\x0C\xFE\x81a\x0C\xE8V[\x82\x10\x15a\r\x18Wa\r\x10`\x01\x91a\x0C\xECV[\x91\x02\x01\x90_\x90V[a\x0C\xD4V[`\x0Ca\r(\x81a\x0C\xE8V[\x82\x10\x15a\rEWa\rB\x91a\r<\x91a\x0C\xF5V[\x90a\x04\\V[\x90V[_\x80\xFD[4a\ryWa\rua\rda\r_6`\x04a\x0C\xB6V[a\r\x1DV[a\rla\x01bV[\x91\x82\x91\x82a\x04\x86V[\x03\x90\xF3[a\x01hV[a\r\x8A`\x05_\x90a\x04\xEBV[\x90V[4a\r\xBDWa\r\x9D6`\x04a\x01pV[a\r\xB9a\r\xA8a\r~V[a\r\xB0a\x01bV[\x91\x82\x91\x82a\x05\x18V[\x03\x90\xF3[a\x01hV[_\x80\xFD[a\r\xD7\x90a\r\xD2a mV[a\x0F&V[V[\x90V[\x90V[a\r\xF3a\r\xEEa\r\xF8\x92a\r\xD9V[a\r\xDCV[a\x03\xA5V[\x90V[a\x0E\x04\x90a\r\xDFV[\x90V[` \x7Faddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FNew rollup owner cannot be zero _\x82\x01R\x01RV[a\x0Ea`'`@\x92a\x03\x0FV[a\x0Ej\x81a\x0E\x07V[\x01\x90V[a\x0E\x83\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x0ETV[\x90V[\x15a\x0E\x8DWV[a\x0E\x95a\x01bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x0E\xAB`\x04\x82\x01a\x0EnV[\x03\x90\xFD[_\x1B\x90V[\x90a\x0E\xC5`\x01\x80`\xA0\x1B\x03\x91a\x0E\xAFV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x0E\xE3a\x0E\xDEa\x0E\xE8\x92a\x03\xA5V[a\r\xDCV[a\x03\xA5V[\x90V[a\x0E\xF4\x90a\x0E\xCFV[\x90V[a\x0F\0\x90a\x0E\xEBV[\x90V[\x90V[\x90a\x0F\x1Ba\x0F\x16a\x0F\"\x92a\x0E\xF7V[a\x0F\x03V[\x82Ta\x0E\xB4V[\x90UV[a\x0FK\x81a\x0FDa\x0F>a\x0F9_a\r\xFBV[a\x03\xB0V[\x91a\x03\xB0V[\x14\x15a\x0E\x86V[a\x0FV\x81`\ta\x0F\x06V[a\x0F\x80\x7F\x88)\xBE\xE4f\x83`\x8D_\xD8\x0E$<\x0F\xAE\x04\xD1)\xCE\x17/p\xDB\x10!\xC1\x12\x80t\xA6\xF4\xD9\x91a\x0E\xF7V[\x90a\x0F\x89a\x01bV[\x80a\x0F\x93\x81a\x03\xFDV[\x03\x90\xA2V[a\x0F\xA1\x90a\r\xC6V[V[`@\x1C\x90V[a\x0F\xB5a\x0F\xBA\x91a\x0F\xA3V[a\x0B\xF0V[\x90V[a\x0F\xC7\x90Ta\x0F\xA9V[\x90V[_\x1C\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x0F\xE8a\x0F\xED\x91a\x0F\xCAV[a\x0F\xCFV[\x90V[a\x0F\xFA\x90Ta\x0F\xDCV[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x10\x1Ea\x10\x19a\x10#\x92a\r\xD9V[a\r\xDCV[a\x0F\xFDV[\x90V[\x90V[a\x10=a\x108a\x10B\x92a\x10&V[a\r\xDCV[a\x0F\xFDV[\x90V[a\x10N\x90a\x0E\xEBV[\x90V[a\x10ea\x10`a\x10j\x92a\r\xD9V[a\r\xDCV[a\x05\x08V[\x90V[\x90a\x10\x80g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x0E\xAFV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x10\x9Ea\x10\x99a\x10\xA3\x92a\x0F\xFDV[a\r\xDCV[a\x0F\xFDV[\x90V[\x90V[\x90a\x10\xBEa\x10\xB9a\x10\xC5\x92a\x10\x8AV[a\x10\xA6V[\x82Ta\x10mV[\x90UV[`@\x1B\x90V[\x90a\x10\xE3h\xFF\0\0\0\0\0\0\0\0\x91a\x10\xC9V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x10\xF6\x90a\x05\x85V[\x90V[\x90V[\x90a\x11\x11a\x11\x0Ca\x11\x18\x92a\x10\xEDV[a\x10\xF9V[\x82Ta\x10\xCFV[\x90UV[a\x11%\x90a\x10)V[\x90RV[\x91\x90a\x11<\x90_` \x85\x01\x94\x01\x90a\x11\x1CV[V[\x9C\x9B\x9A\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90a\x11Sa \xC2V[`\x80Ra\x11la\x11f_`\x80Q\x01a\x0F\xBDV[\x15a\x05\x85V[`\xA0Ra\x11|_`\x80Q\x01a\x0F\xF0V[\x80a\x11\x8Fa\x11\x89_a\x10\nV[\x91a\x0F\xFDV[\x14\x80a\x12\xB8W[\x90a\x11\xAAa\x11\xA4`\x01a\x10)V[\x91a\x0F\xFDV[\x14\x80a\x12\x90W[a\x11\xBC\x90\x91\x15a\x05\x85V[\x90\x81a\x12\x7FW[Pa\x12\\Wa\x11\xF0\x9Da\x11\xE3a\x11\xD9`\x01a\x10)V[_`\x80Q\x01a\x10\xA9V[`\xA0Qa\x12HW[a\x1A\xB2V[`\xA0Qa\x11\xFAW[V[a\x12\x08_\x80`\x80Q\x01a\x10\xFCV[`\x01a\x12@\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x91a\x127a\x01bV[\x91\x82\x91\x82a\x11)V[\x03\x90\xA1a\x11\xF8V[a\x12W`\x01_`\x80Q\x01a\x10\xFCV[a\x11\xEBV[a\x12da\x01bV[c\xF9.\xE8\xA9`\xE0\x1B\x81R\x80a\x12{`\x04\x82\x01a\x03\xFDV[\x03\x90\xFD[a\x12\x8A\x91P\x15a\x05\x85V[_a\x11\xC3V[Pa\x11\xBCa\x12\x9D0a\x10EV[;a\x12\xB0a\x12\xAA_a\x10QV[\x91a\x05\x08V[\x14\x90Pa\x11\xB1V[P`\xA0Qa\x11\x96V[_\x7FOwner cannot be zero address\0\0\0\0\x91\x01RV[a\x12\xF5`\x1C` \x92a\x03\x0FV[a\x12\xFE\x81a\x12\xC1V[\x01\x90V[a\x13\x17\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x12\xE8V[\x90V[\x15a\x13!WV[a\x13)a\x01bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x13?`\x04\x82\x01a\x13\x02V[\x03\x90\xFD[_\x7FChain ID cannot be zero\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x13w`\x17` \x92a\x03\x0FV[a\x13\x80\x81a\x13CV[\x01\x90V[a\x13\x99\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x13jV[\x90V[\x15a\x13\xA3WV[a\x13\xABa\x01bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x13\xC1`\x04\x82\x01a\x13\x84V[\x03\x90\xFD[` \x7Fro\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FSequencing chain ID cannot be ze_\x82\x01R\x01RV[a\x14\x1F`\"`@\x92a\x03\x0FV[a\x14(\x81a\x13\xC5V[\x01\x90V[a\x14A\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x14\x12V[\x90V[\x15a\x14KWV[a\x14Sa\x01bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x14i`\x04\x82\x01a\x14,V[\x03\x90\xFD[` \x7Fe zero\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FArbitrum bridge address cannot b_\x82\x01R\x01RV[a\x14\xC7`&`@\x92a\x03\x0FV[a\x14\xD0\x81a\x14mV[\x01\x90V[a\x14\xE9\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x14\xBAV[\x90V[\x15a\x14\xF3WV[a\x14\xFBa\x01bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x15\x11`\x04\x82\x01a\x14\xD4V[\x03\x90\xFD[` \x7F zero\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FArbitrum inbox address cannot be_\x82\x01R\x01RV[a\x15o`%`@\x92a\x03\x0FV[a\x15x\x81a\x15\x15V[\x01\x90V[a\x15\x91\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x15bV[\x90V[\x15a\x15\x9BWV[a\x15\xA3a\x01bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x15\xB9`\x04\x82\x01a\x15|V[\x03\x90\xFD[` \x7Fot be zero\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FSequencing contract address cann_\x82\x01R\x01RV[a\x16\x17`*`@\x92a\x03\x0FV[a\x16 \x81a\x15\xBDV[\x01\x90V[a\x169\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x16\nV[\x90V[\x15a\x16CWV[a\x16Ka\x01bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x16a`\x04\x82\x01a\x16$V[\x03\x90\xFD[` \x7Fess\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FRollup owner cannot be zero addr_\x82\x01R\x01RV[a\x16\xBF`#`@\x92a\x03\x0FV[a\x16\xC8\x81a\x16eV[\x01\x90V[a\x16\xE1\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x16\xB2V[\x90V[\x15a\x16\xEBWV[a\x16\xF3a\x01bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x17\t`\x04\x82\x01a\x16\xCCV[\x03\x90\xFD[\x90a\x17\x19_\x19\x91a\x0E\xAFV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x177a\x172a\x17<\x92a\x05\x08V[a\r\xDCV[a\x05\x08V[\x90V[\x90V[\x90a\x17Wa\x17Ra\x17^\x92a\x17#V[a\x17?V[\x82Ta\x17\rV[\x90UV[`\xA0\x1B\x90V[\x90a\x17w`\xFF`\xA0\x1B\x91a\x17bV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x17\x96a\x17\x91a\x17\x9D\x92a\x10\xEDV[a\x10\xF9V[\x82Ta\x17hV[\x90UV[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a\x17\xCA\x91\x02\x91a\x17\xC4_\x19\x84a\x17\xABV[\x92a\x17\xABV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\x17\xEAa\x17\xE5a\x17\xF2\x93a\x17#V[a\x17?V[\x90\x83Ta\x17\xAFV[\x90UV[_\x90V[a\x18\x0C\x91a\x18\x06a\x17\xF6V[\x91a\x17\xD4V[V[[\x81\x81\x10a\x18\x1AWPPV[\x80a\x18'_`\x01\x93a\x17\xFAV[\x01a\x18\x0FV[\x91\x90`\x1F\x81\x11a\x18=W[PPPV[a\x18Ia\x18n\x93a\x01\xD9V[\x90` a\x18U\x84a\x17\xA1V[\x83\x01\x93\x10a\x18vW[a\x18g\x90a\x17\xA1V[\x01\x90a\x18\x0EV[_\x80\x80a\x188V[\x91Pa\x18g\x81\x92\x90Pa\x18^V[\x90a\x18\x94\x90_\x19\x90`\x08\x02a\x045V[\x19\x16\x90V[\x81a\x18\xA3\x91a\x18\x84V[\x90`\x02\x02\x17\x90V[\x90a\x18\xB5\x81a\x03\x0BV[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x19uWa\x18\xD9\x82a\x18\xD3\x85Ta\x01\xA6V[\x85a\x18-V[` \x90`\x1F\x83\x11`\x01\x14a\x19\rW\x91\x80\x91a\x18\xFC\x93_\x92a\x19\x01W[PPa\x18\x99V[\x90U[V[\x90\x91P\x01Q_\x80a\x18\xF5V[`\x1F\x19\x83\x16\x91a\x19\x1C\x85a\x01\xD9V[\x92_[\x81\x81\x10a\x19]WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x19CW[PPP\x02\x01\x90Ua\x18\xFFV[a\x19S\x91\x01Q`\x1F\x84\x16\x90a\x18\x84V[\x90U_\x80\x80a\x197V[\x91\x93` `\x01\x81\x92\x87\x87\x01Q\x81U\x01\x95\x01\x92\x01a\x19\x1FV[a\x02\x85V[\x90a\x19\x84\x91a\x18\xABV[V[`\x01\x90\x81\x80\x03\x01\x04\x90V[[\x81\x81\x10a\x19\x9DWPPV[\x80a\x19\xAA_`\x01\x93a\x17\xFAV[\x01a\x19\x92V[\x90\x91\x82\x81\x10a\x19\xBFW[PPPV[a\x19\xDDa\x19\xD7a\x19\xD1a\x19\xE8\x95a\x19\x86V[\x92a\x19\x86V[\x92a\x0C\xECV[\x91\x82\x01\x91\x01\x90a\x19\x91V[_\x80\x80a\x19\xBAV[\x90h\x01\0\0\0\0\0\0\0\0\x81\x11a\x1A\x19W\x81a\x1A\x0Ea\x1A\x17\x93a\x0C\xE8V[\x90\x82\x81Ua\x19\xB0V[V[a\x02\x85V[Q\x90V[a\x1A,\x90Qa\x03\xB0V[\x90V[` \x01\x90V[a\x1A>\x82a\x1A\x1EV[\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x1A\xA1Wa\x1Ala\x1Af`\x01\x92a\x1Aa\x86\x86a\x19\xF0V[a\x1A/V[\x92a\x0C\xECV[\x92\x04\x91_[\x83\x81\x10a\x1A~WPPPPV[`\x01\x90` a\x1A\x94a\x1A\x8F\x86a\x1A\"V[a\x0F\x03V[\x94\x01\x93\x81\x84\x01U\x01a\x1AqV[a\x02\x85V[\x90a\x1A\xB0\x91a\x1A5V[V[\x9B\x97a\x1C\x13a\x1C/\x98a\x1CB\x9F\x9C\x96\x8F\x99a\x1C=\x9F\x9Aa\x1C(\x9Aa\x1C6\x9F\x98a\x1C\x0C\x94a\x1B\xF7a\x1C!\x9Ca\x1B\xF0\x8F\x94a\x1B\xE9a\x1C\x1A\x9Ea\x1B\xE2\x8F\x98a\x1B\xC1a\x1B\xFE\x9Aa\x1B\x1Ca\x1C\x05\x9Ea\x1B\x15a\x1B\x0Fa\x1B\n_a\r\xFBV[a\x03\xB0V[\x91a\x03\xB0V[\x14\x15a\x13\x1AV[a\x1B9\x85a\x1B2a\x1B,_a\x10QV[\x91a\x05\x08V[\x14\x15a\x13\x9CV[a\x1BV\x87a\x1BOa\x1BI_a\x10QV[\x91a\x05\x08V[\x14\x15a\x14DV[a\x1B{\x89a\x1Bta\x1Bna\x1Bi_a\r\xFBV[a\x03\xB0V[\x91a\x03\xB0V[\x14\x15a\x14\xECV[a\x1B\xA0\x8Ba\x1B\x99a\x1B\x93a\x1B\x8E_a\r\xFBV[a\x03\xB0V[\x91a\x03\xB0V[\x14\x15a\x15\x94V[a\x1B\xBAa\x1B\xB4a\x1B\xAF_a\r\xFBV[a\x03\xB0V[\x91a\x03\xB0V[\x14\x15a\x16<V[a\x1B\xDBa\x1B\xD5a\x1B\xD0_a\r\xFBV[a\x03\xB0V[\x91a\x03\xB0V[\x14\x15a\x16\xE4V[`\x04a\x17BV[`\x05a\x17BV[`\x01a\x0F\x06V[`\x02a\x0F\x06V[`\x03a\x17\x81V[`\x06a\x17BV[`\x07a\x17BV[`\x03a\x0F\x06V[`\x08a\x17BV[`\ta\x0F\x06V[`\na\x19zV[`\x0Ba\x19zV[`\x0Ca\x1A\xA6V[a \xE6V[V[\x90a\x1CZ\x9D\x9C\x9B\x9A\x99\x98\x97\x96\x95\x94\x93\x92\x91a\x11>V[V[\x90a\x1Cn\x91a\x1Cia mV[a\x1D\x8DV[V[P\x90V[\x91a\x1C\x7F\x90\x82a\x1CpV[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x1D>Wa\x1C\xA3\x82a\x1C\x9D\x85Ta\x01\xA6V[\x85a\x18-V[_\x90`\x1F\x83\x11`\x01\x14a\x1C\xD6W\x91\x80\x91a\x1C\xC5\x93_\x92a\x1C\xCAW[PPa\x18\x99V[\x90U[V[\x90\x91P\x015_\x80a\x1C\xBEV[`\x1F\x19\x83\x16\x91a\x1C\xE5\x85a\x01\xD9V[\x92_[\x81\x81\x10a\x1D&WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x1D\x0CW[PPP\x02\x01\x90Ua\x1C\xC8V[a\x1D\x1C\x91\x015`\x1F\x84\x16\x90a\x18\x84V[\x90U_\x80\x80a\x1D\0V[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a\x1C\xE8V[a\x02\x85V[\x90a\x1DN\x92\x91a\x1CtV[V[\x91\x90a\x1Dj\x81a\x1Dc\x81a\x1Do\x95a\x03\x0FV[\x80\x95a\x05\xEDV[a\x02{V[\x01\x90V[\x90\x91a\x1D\x8A\x92` \x83\x01\x92_\x81\x85\x03\x91\x01Ra\x1DPV[\x90V[a\x1D\x9A\x81\x83\x90`\na\x1DCV[\x90\x7F\x024\xA4\xE9\x10\xF2\xB1\xE6\x18\xF2\xC9;\xE3\x16\xEC\x0C\x7F@\xE1\xAF#\xFE3\xF9\xFB\xA2\xC5\xBB8\x8A\x95\xF2\x91a\x1D\xD1a\x1D\xC8a\x01bV[\x92\x83\x92\x83a\x1DsV[\x03\x90\xA1V[\x90a\x1D\xE0\x91a\x1C\\V[V[a\x1D\xEAa mV[a\x1D\xF2a\x1D\xF4V[V[a\x1E\x05a\x1E\0_a\r\xFBV[a \xE6V[V[a\x1E\x0Fa\x1D\xE2V[V[_\x90V[a\x1E!a\x1E&\x91a\x0F\xCAV[a\x049V[\x90V[a\x1E3\x90Ta\x1E\x15V[\x90V[a\x1E>a\x1E\x11V[Pa\x1EH_a\x1E)V[\x90V[\x90a\x1E]\x91a\x1EXa mV[a\x1F\xA1V[V[P\x90V[5a\x1Em\x81a\x03\xBCV[\x90V[\x90V[\x90\x91a\x1E\x7F\x90\x83a\x1E_V[\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x1E\xE2Wa\x1E\xADa\x1E\xA7`\x01\x92a\x1E\xA2\x86\x86a\x19\xF0V[a\x1EpV[\x92a\x0C\xECV[\x92\x04\x91_[\x83\x81\x10a\x1E\xBFWPPPPV[`\x01\x90` a\x1E\xD5a\x1E\xD0\x86a\x1EcV[a\x0F\x03V[\x94\x01\x93\x81\x84\x01U\x01a\x1E\xB2V[a\x02\x85V[\x90a\x1E\xF2\x92\x91a\x1EsV[V[` \x91\x81R\x01\x90V[a\x1F\x06\x90a\x03\xB0V[\x90RV[\x90a\x1F\x17\x81` \x93a\x1E\xFDV[\x01\x90V[Pa\x1F*\x90` \x81\x01\x90a\x03\xD0V[\x90V[` \x01\x90V[\x91a\x1FA\x82a\x1FG\x92a\x1E\xF4V[\x92a\x1EpV[\x90\x81_\x90[\x82\x82\x10a\x1FZWPPPP\x90V[\x90\x91\x92\x93a\x1F|a\x1Fv`\x01\x92a\x1Fq\x88\x86a\x1F\x1BV[a\x1F\nV[\x95a\x1F-V[\x92\x01\x90\x92\x91\x92a\x1FLV[\x90\x91a\x1F\x9E\x92` \x83\x01\x92_\x81\x85\x03\x91\x01Ra\x1F3V[\x90V[a\x1F\xAE\x81\x83\x90`\x0Ca\x1E\xE7V[\x90\x7F\xB4\xA2\x86jX6\x99\xC6\xED{w\xA1R\x1F\xADBO\x8E\xDC\xCA0`\x1FD,*[v\xA0\x10[\xE2\x91a\x1F\xE5a\x1F\xDCa\x01bV[\x92\x83\x92\x83a\x1F\x87V[\x03\x90\xA1V[\x90a\x1F\xF4\x91a\x1EKV[V[a \x07\x90a \x02a mV[a \tV[V[\x80a $a \x1Ea \x19_a\r\xFBV[a\x03\xB0V[\x91a\x03\xB0V[\x14a 4Wa 2\x90a \xE6V[V[a ^a @_a\r\xFBV[a Ha\x01bV[\x91\x82\x91c\x1EO\xBD\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x04\x86V[\x03\x90\xFD[a k\x90a\x1F\xF6V[V[a ua\x1E6V[a \x8Ea \x88a \x83a!EV[a\x03\xB0V[\x91a\x03\xB0V[\x03a \x95WV[a \xBEa \xA0a!EV[a \xA8a\x01bV[\x91\x82\x91c\x11\x8C\xDA\xA7`\xE0\x1B\x83R`\x04\x83\x01a\x04\x86V[\x03\x90\xFD[\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90V[a \xEF_a\x1E)V[a \xF9\x82_a\x0F\x06V[\x90a!-a!'\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x93a\x0E\xF7V[\x91a\x0E\xF7V[\x91a!6a\x01bV[\x80a!@\x81a\x03\xFDV[\x03\x90\xA3V[a!Ma\x1E\x11V[P3\x90V\xFE\xA2dipfsX\"\x12 \xC3\x92`\xC8\xD5\xD3\xB7t\xEC;\x98\x08pZ\x87\xEF\xAA\xD4/\xE3\x9D\xE4\xCB\xDA\x19\x9B\xDE\xD7D\xC8\xDE\xACdsolcC\0\x08\x19\x003",
    );
    /**Custom error with signature `InvalidInitialization()` and selector `0xf92ee8a9`.
```solidity
error InvalidInitialization();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidInitialization {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidInitialization> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidInitialization) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidInitialization {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidInitialization {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidInitialization()";
            const SELECTOR: [u8; 4] = [249u8, 46u8, 232u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `NotInitializing()` and selector `0xd7e6bcf8`.
```solidity
error NotInitializing();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializing {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializing> for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializing) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotInitializing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializing()";
            const SELECTOR: [u8; 4] = [215u8, 230u8, 188u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `OwnableInvalidOwner(address)` and selector `0x1e4fbdf7`.
```solidity
error OwnableInvalidOwner(address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableInvalidOwner {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableInvalidOwner> for UnderlyingRustTuple<'_> {
            fn from(value: OwnableInvalidOwner) -> Self {
                (value.owner,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OwnableInvalidOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { owner: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableInvalidOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableInvalidOwner(address)";
            const SELECTOR: [u8; 4] = [30u8, 79u8, 189u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `OwnableUnauthorizedAccount(address)` and selector `0x118cdaa7`.
```solidity
error OwnableUnauthorizedAccount(address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: OwnableUnauthorizedAccount) -> Self {
                (value.account,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OwnableUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { account: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableUnauthorizedAccount(address)";
            const SELECTOR: [u8; 4] = [17u8, 140u8, 218u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
        }
    };
    /**Event with signature `AllowedSettlementAddressesUpdated(address[])` and selector `0xb4a2866a583699c6ed7b77a1521fad424f8edcca30601f442c2a5b76a0105be2`.
```solidity
event AllowedSettlementAddressesUpdated(address[] newAllowedSettlementAddresses);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct AllowedSettlementAddressesUpdated {
        #[allow(missing_docs)]
        pub newAllowedSettlementAddresses: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for AllowedSettlementAddressesUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "AllowedSettlementAddressesUpdated(address[])";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                180u8,
                162u8,
                134u8,
                106u8,
                88u8,
                54u8,
                153u8,
                198u8,
                237u8,
                123u8,
                119u8,
                161u8,
                82u8,
                31u8,
                173u8,
                66u8,
                79u8,
                142u8,
                220u8,
                202u8,
                48u8,
                96u8,
                31u8,
                68u8,
                44u8,
                42u8,
                91u8,
                118u8,
                160u8,
                16u8,
                91u8,
                226u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    newAllowedSettlementAddresses: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newAllowedSettlementAddresses,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData
        for AllowedSettlementAddressesUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&AllowedSettlementAddressesUpdated>
        for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &AllowedSettlementAddressesUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `DefaultSequencingChainRpcUrlUpdated(string)` and selector `0x0234a4e910f2b1e618f2c93be316ec0c7f40e1af23fe33f9fba2c5bb388a95f2`.
```solidity
event DefaultSequencingChainRpcUrlUpdated(string newRpcUrl);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DefaultSequencingChainRpcUrlUpdated {
        #[allow(missing_docs)]
        pub newRpcUrl: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DefaultSequencingChainRpcUrlUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::String,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "DefaultSequencingChainRpcUrlUpdated(string)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                2u8,
                52u8,
                164u8,
                233u8,
                16u8,
                242u8,
                177u8,
                230u8,
                24u8,
                242u8,
                201u8,
                59u8,
                227u8,
                22u8,
                236u8,
                12u8,
                127u8,
                64u8,
                225u8,
                175u8,
                35u8,
                254u8,
                51u8,
                249u8,
                251u8,
                162u8,
                197u8,
                187u8,
                56u8,
                138u8,
                149u8,
                242u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { newRpcUrl: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.newRpcUrl,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData
        for DefaultSequencingChainRpcUrlUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DefaultSequencingChainRpcUrlUpdated>
        for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &DefaultSequencingChainRpcUrlUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Initialized(uint64)` and selector `0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2`.
```solidity
event Initialized(uint64 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                199u8,
                245u8,
                5u8,
                178u8,
                243u8,
                113u8,
                174u8,
                33u8,
                117u8,
                238u8,
                73u8,
                19u8,
                244u8,
                73u8,
                158u8,
                31u8,
                38u8,
                51u8,
                167u8,
                181u8,
                147u8,
                99u8,
                33u8,
                238u8,
                209u8,
                205u8,
                174u8,
                182u8,
                17u8,
                81u8,
                129u8,
                210u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RollupOwnerUpdated(address)` and selector `0x8829bee46683608d5fd80e243c0fae04d129ce172f70db1021c1128074a6f4d9`.
```solidity
event RollupOwnerUpdated(address indexed newRollupOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RollupOwnerUpdated {
        #[allow(missing_docs)]
        pub newRollupOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RollupOwnerUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RollupOwnerUpdated(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                136u8,
                41u8,
                190u8,
                228u8,
                102u8,
                131u8,
                96u8,
                141u8,
                95u8,
                216u8,
                14u8,
                36u8,
                60u8,
                15u8,
                174u8,
                4u8,
                209u8,
                41u8,
                206u8,
                23u8,
                47u8,
                112u8,
                219u8,
                16u8,
                33u8,
                193u8,
                18u8,
                128u8,
                116u8,
                166u8,
                244u8,
                217u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { newRollupOwner: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.newRollupOwner.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newRollupOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RollupOwnerUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RollupOwnerUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RollupOwnerUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Function with signature `ALLOWED_SETTLEMENT_ADDRESSES(uint256)` and selector `0xf881afaf`.
```solidity
function ALLOWED_SETTLEMENT_ADDRESSES(uint256) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ALLOWED_SETTLEMENT_ADDRESSESCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`ALLOWED_SETTLEMENT_ADDRESSES(uint256)`](ALLOWED_SETTLEMENT_ADDRESSESCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ALLOWED_SETTLEMENT_ADDRESSESReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ALLOWED_SETTLEMENT_ADDRESSESCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: ALLOWED_SETTLEMENT_ADDRESSESCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ALLOWED_SETTLEMENT_ADDRESSESCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ALLOWED_SETTLEMENT_ADDRESSESReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: ALLOWED_SETTLEMENT_ADDRESSESReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ALLOWED_SETTLEMENT_ADDRESSESReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ALLOWED_SETTLEMENT_ADDRESSESCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ALLOWED_SETTLEMENT_ADDRESSESReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ALLOWED_SETTLEMENT_ADDRESSES(uint256)";
            const SELECTOR: [u8; 4] = [248u8, 129u8, 175u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `APPCHAIN_BLOCK_EXPLORER_URL()` and selector `0x0743bf6e`.
```solidity
function APPCHAIN_BLOCK_EXPLORER_URL() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct APPCHAIN_BLOCK_EXPLORER_URLCall {}
    ///Container type for the return parameters of the [`APPCHAIN_BLOCK_EXPLORER_URL()`](APPCHAIN_BLOCK_EXPLORER_URLCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct APPCHAIN_BLOCK_EXPLORER_URLReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<APPCHAIN_BLOCK_EXPLORER_URLCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: APPCHAIN_BLOCK_EXPLORER_URLCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for APPCHAIN_BLOCK_EXPLORER_URLCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<APPCHAIN_BLOCK_EXPLORER_URLReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: APPCHAIN_BLOCK_EXPLORER_URLReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for APPCHAIN_BLOCK_EXPLORER_URLReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for APPCHAIN_BLOCK_EXPLORER_URLCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = APPCHAIN_BLOCK_EXPLORER_URLReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "APPCHAIN_BLOCK_EXPLORER_URL()";
            const SELECTOR: [u8; 4] = [7u8, 67u8, 191u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `ARBITRUM_BRIDGE_ADDRESS()` and selector `0x6edd6c09`.
```solidity
function ARBITRUM_BRIDGE_ADDRESS() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ARBITRUM_BRIDGE_ADDRESSCall {}
    ///Container type for the return parameters of the [`ARBITRUM_BRIDGE_ADDRESS()`](ARBITRUM_BRIDGE_ADDRESSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ARBITRUM_BRIDGE_ADDRESSReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ARBITRUM_BRIDGE_ADDRESSCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: ARBITRUM_BRIDGE_ADDRESSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ARBITRUM_BRIDGE_ADDRESSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ARBITRUM_BRIDGE_ADDRESSReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: ARBITRUM_BRIDGE_ADDRESSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ARBITRUM_BRIDGE_ADDRESSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ARBITRUM_BRIDGE_ADDRESSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ARBITRUM_BRIDGE_ADDRESSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ARBITRUM_BRIDGE_ADDRESS()";
            const SELECTOR: [u8; 4] = [110u8, 221u8, 108u8, 9u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `ARBITRUM_IGNORE_DELAYED_MESSAGES()` and selector `0xe79388e6`.
```solidity
function ARBITRUM_IGNORE_DELAYED_MESSAGES() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ARBITRUM_IGNORE_DELAYED_MESSAGESCall {}
    ///Container type for the return parameters of the [`ARBITRUM_IGNORE_DELAYED_MESSAGES()`](ARBITRUM_IGNORE_DELAYED_MESSAGESCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ARBITRUM_IGNORE_DELAYED_MESSAGESReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ARBITRUM_IGNORE_DELAYED_MESSAGESCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: ARBITRUM_IGNORE_DELAYED_MESSAGESCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ARBITRUM_IGNORE_DELAYED_MESSAGESCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ARBITRUM_IGNORE_DELAYED_MESSAGESReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: ARBITRUM_IGNORE_DELAYED_MESSAGESReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ARBITRUM_IGNORE_DELAYED_MESSAGESReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ARBITRUM_IGNORE_DELAYED_MESSAGESCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ARBITRUM_IGNORE_DELAYED_MESSAGESReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ARBITRUM_IGNORE_DELAYED_MESSAGES()";
            const SELECTOR: [u8; 4] = [231u8, 147u8, 136u8, 230u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `ARBITRUM_INBOX_ADDRESS()` and selector `0xaa6a43d8`.
```solidity
function ARBITRUM_INBOX_ADDRESS() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ARBITRUM_INBOX_ADDRESSCall {}
    ///Container type for the return parameters of the [`ARBITRUM_INBOX_ADDRESS()`](ARBITRUM_INBOX_ADDRESSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ARBITRUM_INBOX_ADDRESSReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ARBITRUM_INBOX_ADDRESSCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: ARBITRUM_INBOX_ADDRESSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ARBITRUM_INBOX_ADDRESSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ARBITRUM_INBOX_ADDRESSReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: ARBITRUM_INBOX_ADDRESSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ARBITRUM_INBOX_ADDRESSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ARBITRUM_INBOX_ADDRESSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ARBITRUM_INBOX_ADDRESSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ARBITRUM_INBOX_ADDRESS()";
            const SELECTOR: [u8; 4] = [170u8, 106u8, 67u8, 216u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `CHAIN_ID()` and selector `0x85e1f4d0`.
```solidity
function CHAIN_ID() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CHAIN_IDCall {}
    ///Container type for the return parameters of the [`CHAIN_ID()`](CHAIN_IDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CHAIN_IDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CHAIN_IDCall> for UnderlyingRustTuple<'_> {
                fn from(value: CHAIN_IDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for CHAIN_IDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CHAIN_IDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: CHAIN_IDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for CHAIN_IDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for CHAIN_IDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = CHAIN_IDReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CHAIN_ID()";
            const SELECTOR: [u8; 4] = [133u8, 225u8, 244u8, 208u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DEFAULT_SEQUENCING_CHAIN_RPC_URL()` and selector `0x66a1d108`.
```solidity
function DEFAULT_SEQUENCING_CHAIN_RPC_URL() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_SEQUENCING_CHAIN_RPC_URLCall {}
    ///Container type for the return parameters of the [`DEFAULT_SEQUENCING_CHAIN_RPC_URL()`](DEFAULT_SEQUENCING_CHAIN_RPC_URLCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_SEQUENCING_CHAIN_RPC_URLReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_SEQUENCING_CHAIN_RPC_URLCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_SEQUENCING_CHAIN_RPC_URLCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_SEQUENCING_CHAIN_RPC_URLCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_SEQUENCING_CHAIN_RPC_URLReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_SEQUENCING_CHAIN_RPC_URLReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_SEQUENCING_CHAIN_RPC_URLReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_SEQUENCING_CHAIN_RPC_URLCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DEFAULT_SEQUENCING_CHAIN_RPC_URLReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_SEQUENCING_CHAIN_RPC_URL()";
            const SELECTOR: [u8; 4] = [102u8, 161u8, 209u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `ROLLUP_OWNER()` and selector `0x41fc712d`.
```solidity
function ROLLUP_OWNER() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ROLLUP_OWNERCall {}
    ///Container type for the return parameters of the [`ROLLUP_OWNER()`](ROLLUP_OWNERCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ROLLUP_OWNERReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ROLLUP_OWNERCall> for UnderlyingRustTuple<'_> {
                fn from(value: ROLLUP_OWNERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ROLLUP_OWNERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ROLLUP_OWNERReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ROLLUP_OWNERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ROLLUP_OWNERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ROLLUP_OWNERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ROLLUP_OWNERReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ROLLUP_OWNER()";
            const SELECTOR: [u8; 4] = [65u8, 252u8, 113u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `SEQUENCING_CHAIN_ID()` and selector `0xf8a144be`.
```solidity
function SEQUENCING_CHAIN_ID() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SEQUENCING_CHAIN_IDCall {}
    ///Container type for the return parameters of the [`SEQUENCING_CHAIN_ID()`](SEQUENCING_CHAIN_IDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SEQUENCING_CHAIN_IDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SEQUENCING_CHAIN_IDCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: SEQUENCING_CHAIN_IDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SEQUENCING_CHAIN_IDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SEQUENCING_CHAIN_IDReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: SEQUENCING_CHAIN_IDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SEQUENCING_CHAIN_IDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SEQUENCING_CHAIN_IDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = SEQUENCING_CHAIN_IDReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SEQUENCING_CHAIN_ID()";
            const SELECTOR: [u8; 4] = [248u8, 161u8, 68u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `SEQUENCING_CONTRACT_ADDRESS()` and selector `0xbf6db6f8`.
```solidity
function SEQUENCING_CONTRACT_ADDRESS() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SEQUENCING_CONTRACT_ADDRESSCall {}
    ///Container type for the return parameters of the [`SEQUENCING_CONTRACT_ADDRESS()`](SEQUENCING_CONTRACT_ADDRESSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SEQUENCING_CONTRACT_ADDRESSReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SEQUENCING_CONTRACT_ADDRESSCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: SEQUENCING_CONTRACT_ADDRESSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SEQUENCING_CONTRACT_ADDRESSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SEQUENCING_CONTRACT_ADDRESSReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: SEQUENCING_CONTRACT_ADDRESSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SEQUENCING_CONTRACT_ADDRESSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SEQUENCING_CONTRACT_ADDRESSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = SEQUENCING_CONTRACT_ADDRESSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SEQUENCING_CONTRACT_ADDRESS()";
            const SELECTOR: [u8; 4] = [191u8, 109u8, 182u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `SEQUENCING_START_BLOCK()` and selector `0xa3c6e1e7`.
```solidity
function SEQUENCING_START_BLOCK() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SEQUENCING_START_BLOCKCall {}
    ///Container type for the return parameters of the [`SEQUENCING_START_BLOCK()`](SEQUENCING_START_BLOCKCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SEQUENCING_START_BLOCKReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SEQUENCING_START_BLOCKCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: SEQUENCING_START_BLOCKCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SEQUENCING_START_BLOCKCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SEQUENCING_START_BLOCKReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: SEQUENCING_START_BLOCKReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SEQUENCING_START_BLOCKReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SEQUENCING_START_BLOCKCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = SEQUENCING_START_BLOCKReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SEQUENCING_START_BLOCK()";
            const SELECTOR: [u8; 4] = [163u8, 198u8, 225u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `SETTLEMENT_DELAY()` and selector `0x57d1ba25`.
```solidity
function SETTLEMENT_DELAY() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SETTLEMENT_DELAYCall {}
    ///Container type for the return parameters of the [`SETTLEMENT_DELAY()`](SETTLEMENT_DELAYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SETTLEMENT_DELAYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SETTLEMENT_DELAYCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: SETTLEMENT_DELAYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SETTLEMENT_DELAYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SETTLEMENT_DELAYReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: SETTLEMENT_DELAYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SETTLEMENT_DELAYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SETTLEMENT_DELAYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = SETTLEMENT_DELAYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SETTLEMENT_DELAY()";
            const SELECTOR: [u8; 4] = [87u8, 209u8, 186u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `SETTLEMENT_START_BLOCK()` and selector `0xd1f4737c`.
```solidity
function SETTLEMENT_START_BLOCK() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SETTLEMENT_START_BLOCKCall {}
    ///Container type for the return parameters of the [`SETTLEMENT_START_BLOCK()`](SETTLEMENT_START_BLOCKCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SETTLEMENT_START_BLOCKReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SETTLEMENT_START_BLOCKCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: SETTLEMENT_START_BLOCKCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SETTLEMENT_START_BLOCKCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SETTLEMENT_START_BLOCKReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: SETTLEMENT_START_BLOCKReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SETTLEMENT_START_BLOCKReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SETTLEMENT_START_BLOCKCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = SETTLEMENT_START_BLOCKReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SETTLEMENT_START_BLOCK()";
            const SELECTOR: [u8; 4] = [209u8, 244u8, 115u8, 124u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `initialize(address,uint256,uint256,address,address,bool,uint256,uint256,address,uint256,address,string,string,address[])` and selector `0x5a2d9c18`.
```solidity
function initialize(address owner, uint256 chainId, uint256 sequencingChainId, address arbitrumBridgeAddress, address arbitrumInboxAddress, bool arbitrumIgnoreDelayedMessages, uint256 settlementDelay, uint256 settlementStartBlock, address sequencingContractAddress, uint256 sequencingStartBlock, address rollupOwner, string memory sequencingChainRpcUrl, string memory appchainBlockExplorerUrl, address[] memory allowedSettlementAddresses) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub sequencingChainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub arbitrumBridgeAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub arbitrumInboxAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub arbitrumIgnoreDelayedMessages: bool,
        #[allow(missing_docs)]
        pub settlementDelay: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub settlementStartBlock: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub sequencingContractAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sequencingStartBlock: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub rollupOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sequencingChainRpcUrl: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub appchainBlockExplorerUrl: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub allowedSettlementAddresses: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    ///Container type for the return parameters of the [`initialize(address,uint256,uint256,address,address,bool,uint256,uint256,address,uint256,address,string,string,address[])`](initializeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                bool,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (
                        value.owner,
                        value.chainId,
                        value.sequencingChainId,
                        value.arbitrumBridgeAddress,
                        value.arbitrumInboxAddress,
                        value.arbitrumIgnoreDelayedMessages,
                        value.settlementDelay,
                        value.settlementStartBlock,
                        value.sequencingContractAddress,
                        value.sequencingStartBlock,
                        value.rollupOwner,
                        value.sequencingChainRpcUrl,
                        value.appchainBlockExplorerUrl,
                        value.allowedSettlementAddresses,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        chainId: tuple.1,
                        sequencingChainId: tuple.2,
                        arbitrumBridgeAddress: tuple.3,
                        arbitrumInboxAddress: tuple.4,
                        arbitrumIgnoreDelayedMessages: tuple.5,
                        settlementDelay: tuple.6,
                        settlementStartBlock: tuple.7,
                        sequencingContractAddress: tuple.8,
                        sequencingStartBlock: tuple.9,
                        rollupOwner: tuple.10,
                        sequencingChainRpcUrl: tuple.11,
                        appchainBlockExplorerUrl: tuple.12,
                        allowedSettlementAddresses: tuple.13,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize(address,uint256,uint256,address,address,bool,uint256,uint256,address,uint256,address,string,string,address[])";
            const SELECTOR: [u8; 4] = [90u8, 45u8, 156u8, 24u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.sequencingChainId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.arbitrumBridgeAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.arbitrumInboxAddress,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.arbitrumIgnoreDelayedMessages,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.settlementDelay),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.settlementStartBlock),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sequencingContractAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.sequencingStartBlock),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rollupOwner,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.sequencingChainRpcUrl,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.appchainBlockExplorerUrl,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.allowedSettlementAddresses,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall {}
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall {}
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `updateAllowedSettlementAddresses(address[])` and selector `0xcb608408`.
```solidity
function updateAllowedSettlementAddresses(address[] memory newAllowedSettlementAddresses) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateAllowedSettlementAddressesCall {
        #[allow(missing_docs)]
        pub newAllowedSettlementAddresses: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    ///Container type for the return parameters of the [`updateAllowedSettlementAddresses(address[])`](updateAllowedSettlementAddressesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateAllowedSettlementAddressesReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateAllowedSettlementAddressesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateAllowedSettlementAddressesCall) -> Self {
                    (value.newAllowedSettlementAddresses,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateAllowedSettlementAddressesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newAllowedSettlementAddresses: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateAllowedSettlementAddressesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateAllowedSettlementAddressesReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateAllowedSettlementAddressesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateAllowedSettlementAddressesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateAllowedSettlementAddressesReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateAllowedSettlementAddresses(address[])";
            const SELECTOR: [u8; 4] = [203u8, 96u8, 132u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newAllowedSettlementAddresses,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `updateDefaultSequencingChainRpcUrl(string)` and selector `0x62c73caa`.
```solidity
function updateDefaultSequencingChainRpcUrl(string memory newRpcUrl) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateDefaultSequencingChainRpcUrlCall {
        #[allow(missing_docs)]
        pub newRpcUrl: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`updateDefaultSequencingChainRpcUrl(string)`](updateDefaultSequencingChainRpcUrlCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateDefaultSequencingChainRpcUrlReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateDefaultSequencingChainRpcUrlCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateDefaultSequencingChainRpcUrlCall) -> Self {
                    (value.newRpcUrl,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateDefaultSequencingChainRpcUrlCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newRpcUrl: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateDefaultSequencingChainRpcUrlReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateDefaultSequencingChainRpcUrlReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateDefaultSequencingChainRpcUrlReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateDefaultSequencingChainRpcUrlCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateDefaultSequencingChainRpcUrlReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateDefaultSequencingChainRpcUrl(string)";
            const SELECTOR: [u8; 4] = [98u8, 199u8, 60u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.newRpcUrl,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `updateRollupOwner(address)` and selector `0x2a84b0f0`.
```solidity
function updateRollupOwner(address newRollupOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateRollupOwnerCall {
        #[allow(missing_docs)]
        pub newRollupOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`updateRollupOwner(address)`](updateRollupOwnerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateRollupOwnerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateRollupOwnerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateRollupOwnerCall) -> Self {
                    (value.newRollupOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateRollupOwnerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newRollupOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateRollupOwnerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateRollupOwnerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateRollupOwnerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateRollupOwnerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateRollupOwnerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateRollupOwner(address)";
            const SELECTOR: [u8; 4] = [42u8, 132u8, 176u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newRollupOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`ArbChainConfig`](self) function calls.
    pub enum ArbChainConfigCalls {
        #[allow(missing_docs)]
        ALLOWED_SETTLEMENT_ADDRESSES(ALLOWED_SETTLEMENT_ADDRESSESCall),
        #[allow(missing_docs)]
        APPCHAIN_BLOCK_EXPLORER_URL(APPCHAIN_BLOCK_EXPLORER_URLCall),
        #[allow(missing_docs)]
        ARBITRUM_BRIDGE_ADDRESS(ARBITRUM_BRIDGE_ADDRESSCall),
        #[allow(missing_docs)]
        ARBITRUM_IGNORE_DELAYED_MESSAGES(ARBITRUM_IGNORE_DELAYED_MESSAGESCall),
        #[allow(missing_docs)]
        ARBITRUM_INBOX_ADDRESS(ARBITRUM_INBOX_ADDRESSCall),
        #[allow(missing_docs)]
        CHAIN_ID(CHAIN_IDCall),
        #[allow(missing_docs)]
        DEFAULT_SEQUENCING_CHAIN_RPC_URL(DEFAULT_SEQUENCING_CHAIN_RPC_URLCall),
        #[allow(missing_docs)]
        ROLLUP_OWNER(ROLLUP_OWNERCall),
        #[allow(missing_docs)]
        SEQUENCING_CHAIN_ID(SEQUENCING_CHAIN_IDCall),
        #[allow(missing_docs)]
        SEQUENCING_CONTRACT_ADDRESS(SEQUENCING_CONTRACT_ADDRESSCall),
        #[allow(missing_docs)]
        SEQUENCING_START_BLOCK(SEQUENCING_START_BLOCKCall),
        #[allow(missing_docs)]
        SETTLEMENT_DELAY(SETTLEMENT_DELAYCall),
        #[allow(missing_docs)]
        SETTLEMENT_START_BLOCK(SETTLEMENT_START_BLOCKCall),
        #[allow(missing_docs)]
        initialize(initializeCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
        #[allow(missing_docs)]
        updateAllowedSettlementAddresses(updateAllowedSettlementAddressesCall),
        #[allow(missing_docs)]
        updateDefaultSequencingChainRpcUrl(updateDefaultSequencingChainRpcUrlCall),
        #[allow(missing_docs)]
        updateRollupOwner(updateRollupOwnerCall),
    }
    #[automatically_derived]
    impl ArbChainConfigCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [7u8, 67u8, 191u8, 110u8],
            [42u8, 132u8, 176u8, 240u8],
            [65u8, 252u8, 113u8, 45u8],
            [87u8, 209u8, 186u8, 37u8],
            [90u8, 45u8, 156u8, 24u8],
            [98u8, 199u8, 60u8, 170u8],
            [102u8, 161u8, 209u8, 8u8],
            [110u8, 221u8, 108u8, 9u8],
            [113u8, 80u8, 24u8, 166u8],
            [133u8, 225u8, 244u8, 208u8],
            [141u8, 165u8, 203u8, 91u8],
            [163u8, 198u8, 225u8, 231u8],
            [170u8, 106u8, 67u8, 216u8],
            [191u8, 109u8, 182u8, 248u8],
            [203u8, 96u8, 132u8, 8u8],
            [209u8, 244u8, 115u8, 124u8],
            [231u8, 147u8, 136u8, 230u8],
            [242u8, 253u8, 227u8, 139u8],
            [248u8, 129u8, 175u8, 175u8],
            [248u8, 161u8, 68u8, 190u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for ArbChainConfigCalls {
        const NAME: &'static str = "ArbChainConfigCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 20usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ALLOWED_SETTLEMENT_ADDRESSES(_) => {
                    <ALLOWED_SETTLEMENT_ADDRESSESCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::APPCHAIN_BLOCK_EXPLORER_URL(_) => {
                    <APPCHAIN_BLOCK_EXPLORER_URLCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::ARBITRUM_BRIDGE_ADDRESS(_) => {
                    <ARBITRUM_BRIDGE_ADDRESSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::ARBITRUM_IGNORE_DELAYED_MESSAGES(_) => {
                    <ARBITRUM_IGNORE_DELAYED_MESSAGESCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::ARBITRUM_INBOX_ADDRESS(_) => {
                    <ARBITRUM_INBOX_ADDRESSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::CHAIN_ID(_) => <CHAIN_IDCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::DEFAULT_SEQUENCING_CHAIN_RPC_URL(_) => {
                    <DEFAULT_SEQUENCING_CHAIN_RPC_URLCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::ROLLUP_OWNER(_) => {
                    <ROLLUP_OWNERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SEQUENCING_CHAIN_ID(_) => {
                    <SEQUENCING_CHAIN_IDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SEQUENCING_CONTRACT_ADDRESS(_) => {
                    <SEQUENCING_CONTRACT_ADDRESSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SEQUENCING_START_BLOCK(_) => {
                    <SEQUENCING_START_BLOCKCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SETTLEMENT_DELAY(_) => {
                    <SETTLEMENT_DELAYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SETTLEMENT_START_BLOCK(_) => {
                    <SETTLEMENT_START_BLOCKCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initialize(_) => {
                    <initializeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateAllowedSettlementAddresses(_) => {
                    <updateAllowedSettlementAddressesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateDefaultSequencingChainRpcUrl(_) => {
                    <updateDefaultSequencingChainRpcUrlCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateRollupOwner(_) => {
                    <updateRollupOwnerCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<ArbChainConfigCalls>] = &[
                {
                    fn APPCHAIN_BLOCK_EXPLORER_URL(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigCalls> {
                        <APPCHAIN_BLOCK_EXPLORER_URLCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigCalls::APPCHAIN_BLOCK_EXPLORER_URL)
                    }
                    APPCHAIN_BLOCK_EXPLORER_URL
                },
                {
                    fn updateRollupOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigCalls> {
                        <updateRollupOwnerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigCalls::updateRollupOwner)
                    }
                    updateRollupOwner
                },
                {
                    fn ROLLUP_OWNER(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigCalls> {
                        <ROLLUP_OWNERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigCalls::ROLLUP_OWNER)
                    }
                    ROLLUP_OWNER
                },
                {
                    fn SETTLEMENT_DELAY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigCalls> {
                        <SETTLEMENT_DELAYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigCalls::SETTLEMENT_DELAY)
                    }
                    SETTLEMENT_DELAY
                },
                {
                    fn initialize(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigCalls::initialize)
                    }
                    initialize
                },
                {
                    fn updateDefaultSequencingChainRpcUrl(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigCalls> {
                        <updateDefaultSequencingChainRpcUrlCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigCalls::updateDefaultSequencingChainRpcUrl)
                    }
                    updateDefaultSequencingChainRpcUrl
                },
                {
                    fn DEFAULT_SEQUENCING_CHAIN_RPC_URL(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigCalls> {
                        <DEFAULT_SEQUENCING_CHAIN_RPC_URLCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigCalls::DEFAULT_SEQUENCING_CHAIN_RPC_URL)
                    }
                    DEFAULT_SEQUENCING_CHAIN_RPC_URL
                },
                {
                    fn ARBITRUM_BRIDGE_ADDRESS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigCalls> {
                        <ARBITRUM_BRIDGE_ADDRESSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigCalls::ARBITRUM_BRIDGE_ADDRESS)
                    }
                    ARBITRUM_BRIDGE_ADDRESS
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn CHAIN_ID(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigCalls> {
                        <CHAIN_IDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigCalls::CHAIN_ID)
                    }
                    CHAIN_ID
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigCalls::owner)
                    }
                    owner
                },
                {
                    fn SEQUENCING_START_BLOCK(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigCalls> {
                        <SEQUENCING_START_BLOCKCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigCalls::SEQUENCING_START_BLOCK)
                    }
                    SEQUENCING_START_BLOCK
                },
                {
                    fn ARBITRUM_INBOX_ADDRESS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigCalls> {
                        <ARBITRUM_INBOX_ADDRESSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigCalls::ARBITRUM_INBOX_ADDRESS)
                    }
                    ARBITRUM_INBOX_ADDRESS
                },
                {
                    fn SEQUENCING_CONTRACT_ADDRESS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigCalls> {
                        <SEQUENCING_CONTRACT_ADDRESSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigCalls::SEQUENCING_CONTRACT_ADDRESS)
                    }
                    SEQUENCING_CONTRACT_ADDRESS
                },
                {
                    fn updateAllowedSettlementAddresses(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigCalls> {
                        <updateAllowedSettlementAddressesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigCalls::updateAllowedSettlementAddresses)
                    }
                    updateAllowedSettlementAddresses
                },
                {
                    fn SETTLEMENT_START_BLOCK(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigCalls> {
                        <SETTLEMENT_START_BLOCKCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigCalls::SETTLEMENT_START_BLOCK)
                    }
                    SETTLEMENT_START_BLOCK
                },
                {
                    fn ARBITRUM_IGNORE_DELAYED_MESSAGES(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigCalls> {
                        <ARBITRUM_IGNORE_DELAYED_MESSAGESCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigCalls::ARBITRUM_IGNORE_DELAYED_MESSAGES)
                    }
                    ARBITRUM_IGNORE_DELAYED_MESSAGES
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigCalls::transferOwnership)
                    }
                    transferOwnership
                },
                {
                    fn ALLOWED_SETTLEMENT_ADDRESSES(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigCalls> {
                        <ALLOWED_SETTLEMENT_ADDRESSESCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigCalls::ALLOWED_SETTLEMENT_ADDRESSES)
                    }
                    ALLOWED_SETTLEMENT_ADDRESSES
                },
                {
                    fn SEQUENCING_CHAIN_ID(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigCalls> {
                        <SEQUENCING_CHAIN_IDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigCalls::SEQUENCING_CHAIN_ID)
                    }
                    SEQUENCING_CHAIN_ID
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ALLOWED_SETTLEMENT_ADDRESSES(inner) => {
                    <ALLOWED_SETTLEMENT_ADDRESSESCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::APPCHAIN_BLOCK_EXPLORER_URL(inner) => {
                    <APPCHAIN_BLOCK_EXPLORER_URLCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ARBITRUM_BRIDGE_ADDRESS(inner) => {
                    <ARBITRUM_BRIDGE_ADDRESSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ARBITRUM_IGNORE_DELAYED_MESSAGES(inner) => {
                    <ARBITRUM_IGNORE_DELAYED_MESSAGESCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ARBITRUM_INBOX_ADDRESS(inner) => {
                    <ARBITRUM_INBOX_ADDRESSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CHAIN_ID(inner) => {
                    <CHAIN_IDCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::DEFAULT_SEQUENCING_CHAIN_RPC_URL(inner) => {
                    <DEFAULT_SEQUENCING_CHAIN_RPC_URLCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ROLLUP_OWNER(inner) => {
                    <ROLLUP_OWNERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SEQUENCING_CHAIN_ID(inner) => {
                    <SEQUENCING_CHAIN_IDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SEQUENCING_CONTRACT_ADDRESS(inner) => {
                    <SEQUENCING_CONTRACT_ADDRESSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SEQUENCING_START_BLOCK(inner) => {
                    <SEQUENCING_START_BLOCKCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SETTLEMENT_DELAY(inner) => {
                    <SETTLEMENT_DELAYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SETTLEMENT_START_BLOCK(inner) => {
                    <SETTLEMENT_START_BLOCKCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateAllowedSettlementAddresses(inner) => {
                    <updateAllowedSettlementAddressesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateDefaultSequencingChainRpcUrl(inner) => {
                    <updateDefaultSequencingChainRpcUrlCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateRollupOwner(inner) => {
                    <updateRollupOwnerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ALLOWED_SETTLEMENT_ADDRESSES(inner) => {
                    <ALLOWED_SETTLEMENT_ADDRESSESCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::APPCHAIN_BLOCK_EXPLORER_URL(inner) => {
                    <APPCHAIN_BLOCK_EXPLORER_URLCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ARBITRUM_BRIDGE_ADDRESS(inner) => {
                    <ARBITRUM_BRIDGE_ADDRESSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ARBITRUM_IGNORE_DELAYED_MESSAGES(inner) => {
                    <ARBITRUM_IGNORE_DELAYED_MESSAGESCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ARBITRUM_INBOX_ADDRESS(inner) => {
                    <ARBITRUM_INBOX_ADDRESSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CHAIN_ID(inner) => {
                    <CHAIN_IDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEFAULT_SEQUENCING_CHAIN_RPC_URL(inner) => {
                    <DEFAULT_SEQUENCING_CHAIN_RPC_URLCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ROLLUP_OWNER(inner) => {
                    <ROLLUP_OWNERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SEQUENCING_CHAIN_ID(inner) => {
                    <SEQUENCING_CHAIN_IDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SEQUENCING_CONTRACT_ADDRESS(inner) => {
                    <SEQUENCING_CONTRACT_ADDRESSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SEQUENCING_START_BLOCK(inner) => {
                    <SEQUENCING_START_BLOCKCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SETTLEMENT_DELAY(inner) => {
                    <SETTLEMENT_DELAYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SETTLEMENT_START_BLOCK(inner) => {
                    <SETTLEMENT_START_BLOCKCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateAllowedSettlementAddresses(inner) => {
                    <updateAllowedSettlementAddressesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateDefaultSequencingChainRpcUrl(inner) => {
                    <updateDefaultSequencingChainRpcUrlCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateRollupOwner(inner) => {
                    <updateRollupOwnerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`ArbChainConfig`](self) custom errors.
    pub enum ArbChainConfigErrors {
        #[allow(missing_docs)]
        InvalidInitialization(InvalidInitialization),
        #[allow(missing_docs)]
        NotInitializing(NotInitializing),
        #[allow(missing_docs)]
        OwnableInvalidOwner(OwnableInvalidOwner),
        #[allow(missing_docs)]
        OwnableUnauthorizedAccount(OwnableUnauthorizedAccount),
    }
    #[automatically_derived]
    impl ArbChainConfigErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [17u8, 140u8, 218u8, 167u8],
            [30u8, 79u8, 189u8, 247u8],
            [215u8, 230u8, 188u8, 248u8],
            [249u8, 46u8, 232u8, 169u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for ArbChainConfigErrors {
        const NAME: &'static str = "ArbChainConfigErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 4usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::InvalidInitialization(_) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializing(_) => {
                    <NotInitializing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableInvalidOwner(_) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableUnauthorizedAccount(_) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<ArbChainConfigErrors>] = &[
                {
                    fn OwnableUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigErrors> {
                        <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigErrors::OwnableUnauthorizedAccount)
                    }
                    OwnableUnauthorizedAccount
                },
                {
                    fn OwnableInvalidOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigErrors> {
                        <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigErrors::OwnableInvalidOwner)
                    }
                    OwnableInvalidOwner
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ArbChainConfigErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ArbChainConfigErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`ArbChainConfig`](self) events.
    pub enum ArbChainConfigEvents {
        #[allow(missing_docs)]
        AllowedSettlementAddressesUpdated(AllowedSettlementAddressesUpdated),
        #[allow(missing_docs)]
        DefaultSequencingChainRpcUrlUpdated(DefaultSequencingChainRpcUrlUpdated),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
        #[allow(missing_docs)]
        RollupOwnerUpdated(RollupOwnerUpdated),
    }
    #[automatically_derived]
    impl ArbChainConfigEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                2u8,
                52u8,
                164u8,
                233u8,
                16u8,
                242u8,
                177u8,
                230u8,
                24u8,
                242u8,
                201u8,
                59u8,
                227u8,
                22u8,
                236u8,
                12u8,
                127u8,
                64u8,
                225u8,
                175u8,
                35u8,
                254u8,
                51u8,
                249u8,
                251u8,
                162u8,
                197u8,
                187u8,
                56u8,
                138u8,
                149u8,
                242u8,
            ],
            [
                136u8,
                41u8,
                190u8,
                228u8,
                102u8,
                131u8,
                96u8,
                141u8,
                95u8,
                216u8,
                14u8,
                36u8,
                60u8,
                15u8,
                174u8,
                4u8,
                209u8,
                41u8,
                206u8,
                23u8,
                47u8,
                112u8,
                219u8,
                16u8,
                33u8,
                193u8,
                18u8,
                128u8,
                116u8,
                166u8,
                244u8,
                217u8,
            ],
            [
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ],
            [
                180u8,
                162u8,
                134u8,
                106u8,
                88u8,
                54u8,
                153u8,
                198u8,
                237u8,
                123u8,
                119u8,
                161u8,
                82u8,
                31u8,
                173u8,
                66u8,
                79u8,
                142u8,
                220u8,
                202u8,
                48u8,
                96u8,
                31u8,
                68u8,
                44u8,
                42u8,
                91u8,
                118u8,
                160u8,
                16u8,
                91u8,
                226u8,
            ],
            [
                199u8,
                245u8,
                5u8,
                178u8,
                243u8,
                113u8,
                174u8,
                33u8,
                117u8,
                238u8,
                73u8,
                19u8,
                244u8,
                73u8,
                158u8,
                31u8,
                38u8,
                51u8,
                167u8,
                181u8,
                147u8,
                99u8,
                33u8,
                238u8,
                209u8,
                205u8,
                174u8,
                182u8,
                17u8,
                81u8,
                129u8,
                210u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for ArbChainConfigEvents {
        const NAME: &'static str = "ArbChainConfigEvents";
        const COUNT: usize = 5usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <AllowedSettlementAddressesUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <AllowedSettlementAddressesUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::AllowedSettlementAddressesUpdated)
                }
                Some(
                    <DefaultSequencingChainRpcUrlUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DefaultSequencingChainRpcUrlUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DefaultSequencingChainRpcUrlUpdated)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Initialized)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(
                    <RollupOwnerUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <RollupOwnerUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RollupOwnerUpdated)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for ArbChainConfigEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AllowedSettlementAddressesUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DefaultSequencingChainRpcUrlUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RollupOwnerUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AllowedSettlementAddressesUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DefaultSequencingChainRpcUrlUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RollupOwnerUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`ArbChainConfig`](self) contract instance.

See the [wrapper's documentation](`ArbChainConfigInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> ArbChainConfigInstance<T, P, N> {
        ArbChainConfigInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<ArbChainConfigInstance<T, P, N>>,
    > {
        ArbChainConfigInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        ArbChainConfigInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`ArbChainConfig`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`ArbChainConfig`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct ArbChainConfigInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for ArbChainConfigInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("ArbChainConfigInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ArbChainConfigInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`ArbChainConfig`](self) contract instance.

See the [wrapper's documentation](`ArbChainConfigInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<ArbChainConfigInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> ArbChainConfigInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> ArbChainConfigInstance<T, P, N> {
            ArbChainConfigInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ArbChainConfigInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`ALLOWED_SETTLEMENT_ADDRESSES`] function.
        pub fn ALLOWED_SETTLEMENT_ADDRESSES(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, ALLOWED_SETTLEMENT_ADDRESSESCall, N> {
            self.call_builder(
                &ALLOWED_SETTLEMENT_ADDRESSESCall {
                    _0,
                },
            )
        }
        ///Creates a new call builder for the [`APPCHAIN_BLOCK_EXPLORER_URL`] function.
        pub fn APPCHAIN_BLOCK_EXPLORER_URL(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, APPCHAIN_BLOCK_EXPLORER_URLCall, N> {
            self.call_builder(&APPCHAIN_BLOCK_EXPLORER_URLCall {})
        }
        ///Creates a new call builder for the [`ARBITRUM_BRIDGE_ADDRESS`] function.
        pub fn ARBITRUM_BRIDGE_ADDRESS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, ARBITRUM_BRIDGE_ADDRESSCall, N> {
            self.call_builder(&ARBITRUM_BRIDGE_ADDRESSCall {})
        }
        ///Creates a new call builder for the [`ARBITRUM_IGNORE_DELAYED_MESSAGES`] function.
        pub fn ARBITRUM_IGNORE_DELAYED_MESSAGES(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            ARBITRUM_IGNORE_DELAYED_MESSAGESCall,
            N,
        > {
            self.call_builder(
                &ARBITRUM_IGNORE_DELAYED_MESSAGESCall {
                },
            )
        }
        ///Creates a new call builder for the [`ARBITRUM_INBOX_ADDRESS`] function.
        pub fn ARBITRUM_INBOX_ADDRESS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, ARBITRUM_INBOX_ADDRESSCall, N> {
            self.call_builder(&ARBITRUM_INBOX_ADDRESSCall {})
        }
        ///Creates a new call builder for the [`CHAIN_ID`] function.
        pub fn CHAIN_ID(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, CHAIN_IDCall, N> {
            self.call_builder(&CHAIN_IDCall {})
        }
        ///Creates a new call builder for the [`DEFAULT_SEQUENCING_CHAIN_RPC_URL`] function.
        pub fn DEFAULT_SEQUENCING_CHAIN_RPC_URL(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            DEFAULT_SEQUENCING_CHAIN_RPC_URLCall,
            N,
        > {
            self.call_builder(
                &DEFAULT_SEQUENCING_CHAIN_RPC_URLCall {
                },
            )
        }
        ///Creates a new call builder for the [`ROLLUP_OWNER`] function.
        pub fn ROLLUP_OWNER(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, ROLLUP_OWNERCall, N> {
            self.call_builder(&ROLLUP_OWNERCall {})
        }
        ///Creates a new call builder for the [`SEQUENCING_CHAIN_ID`] function.
        pub fn SEQUENCING_CHAIN_ID(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, SEQUENCING_CHAIN_IDCall, N> {
            self.call_builder(&SEQUENCING_CHAIN_IDCall {})
        }
        ///Creates a new call builder for the [`SEQUENCING_CONTRACT_ADDRESS`] function.
        pub fn SEQUENCING_CONTRACT_ADDRESS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, SEQUENCING_CONTRACT_ADDRESSCall, N> {
            self.call_builder(&SEQUENCING_CONTRACT_ADDRESSCall {})
        }
        ///Creates a new call builder for the [`SEQUENCING_START_BLOCK`] function.
        pub fn SEQUENCING_START_BLOCK(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, SEQUENCING_START_BLOCKCall, N> {
            self.call_builder(&SEQUENCING_START_BLOCKCall {})
        }
        ///Creates a new call builder for the [`SETTLEMENT_DELAY`] function.
        pub fn SETTLEMENT_DELAY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, SETTLEMENT_DELAYCall, N> {
            self.call_builder(&SETTLEMENT_DELAYCall {})
        }
        ///Creates a new call builder for the [`SETTLEMENT_START_BLOCK`] function.
        pub fn SETTLEMENT_START_BLOCK(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, SETTLEMENT_START_BLOCKCall, N> {
            self.call_builder(&SETTLEMENT_START_BLOCKCall {})
        }
        ///Creates a new call builder for the [`initialize`] function.
        pub fn initialize(
            &self,
            owner: alloy::sol_types::private::Address,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
            sequencingChainId: alloy::sol_types::private::primitives::aliases::U256,
            arbitrumBridgeAddress: alloy::sol_types::private::Address,
            arbitrumInboxAddress: alloy::sol_types::private::Address,
            arbitrumIgnoreDelayedMessages: bool,
            settlementDelay: alloy::sol_types::private::primitives::aliases::U256,
            settlementStartBlock: alloy::sol_types::private::primitives::aliases::U256,
            sequencingContractAddress: alloy::sol_types::private::Address,
            sequencingStartBlock: alloy::sol_types::private::primitives::aliases::U256,
            rollupOwner: alloy::sol_types::private::Address,
            sequencingChainRpcUrl: alloy::sol_types::private::String,
            appchainBlockExplorerUrl: alloy::sol_types::private::String,
            allowedSettlementAddresses: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, initializeCall, N> {
            self.call_builder(
                &initializeCall {
                    owner,
                    chainId,
                    sequencingChainId,
                    arbitrumBridgeAddress,
                    arbitrumInboxAddress,
                    arbitrumIgnoreDelayedMessages,
                    settlementDelay,
                    settlementStartBlock,
                    sequencingContractAddress,
                    sequencingStartBlock,
                    rollupOwner,
                    sequencingChainRpcUrl,
                    appchainBlockExplorerUrl,
                    allowedSettlementAddresses,
                },
            )
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall {})
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        ///Creates a new call builder for the [`updateAllowedSettlementAddresses`] function.
        pub fn updateAllowedSettlementAddresses(
            &self,
            newAllowedSettlementAddresses: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            updateAllowedSettlementAddressesCall,
            N,
        > {
            self.call_builder(
                &updateAllowedSettlementAddressesCall {
                    newAllowedSettlementAddresses,
                },
            )
        }
        ///Creates a new call builder for the [`updateDefaultSequencingChainRpcUrl`] function.
        pub fn updateDefaultSequencingChainRpcUrl(
            &self,
            newRpcUrl: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            updateDefaultSequencingChainRpcUrlCall,
            N,
        > {
            self.call_builder(
                &updateDefaultSequencingChainRpcUrlCall {
                    newRpcUrl,
                },
            )
        }
        ///Creates a new call builder for the [`updateRollupOwner`] function.
        pub fn updateRollupOwner(
            &self,
            newRollupOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateRollupOwnerCall, N> {
            self.call_builder(
                &updateRollupOwnerCall {
                    newRollupOwner,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ArbChainConfigInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`AllowedSettlementAddressesUpdated`] event.
        pub fn AllowedSettlementAddressesUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, AllowedSettlementAddressesUpdated, N> {
            self.event_filter::<AllowedSettlementAddressesUpdated>()
        }
        ///Creates a new event filter for the [`DefaultSequencingChainRpcUrlUpdated`] event.
        pub fn DefaultSequencingChainRpcUrlUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DefaultSequencingChainRpcUrlUpdated, N> {
            self.event_filter::<DefaultSequencingChainRpcUrlUpdated>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`RollupOwnerUpdated`] event.
        pub fn RollupOwnerUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RollupOwnerUpdated, N> {
            self.event_filter::<RollupOwnerUpdated>()
        }
    }
}
