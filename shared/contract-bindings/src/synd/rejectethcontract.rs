/**

Generated by the following Solidity interface...
```solidity
interface RejectEthContract {
    fallback() external payable;

    receive() external payable;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "fallback",
    "stateMutability": "payable"
  },
  {
    "type": "receive",
    "stateMutability": "payable"
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod RejectEthContract {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x608060405234601957600e601d565b60aa6028823960aa90f35b6023565b60405190565b5f80fdfe608060405236608c57606e565b60405190565b60209181520190565b5f7f43616e6e6f742072656365697665204554480000000000000000000000000000910152565b604d60126020926012565b605481601b565b0190565b606b9060208101905f8183039101526042565b90565b6074600c565b62461bcd60e51b8152806088600482016058565b0390fd5b6092600c565b62461bcd60e51b81528060a6600482016058565b0390fd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4`\x19W`\x0E`\x1DV[`\xAA`(\x829`\xAA\x90\xF3[`#V[`@Q\x90V[_\x80\xFD\xFE`\x80`@R6`\x8CW`nV[`@Q\x90V[` \x91\x81R\x01\x90V[_\x7FCannot receive ETH\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[`M`\x12` \x92`\x12V[`T\x81`\x1BV[\x01\x90V[`k\x90` \x81\x01\x90_\x81\x83\x03\x91\x01R`BV[\x90V[`t`\x0CV[bF\x1B\xCD`\xE5\x1B\x81R\x80`\x88`\x04\x82\x01`XV[\x03\x90\xFD[`\x92`\x0CV[bF\x1B\xCD`\xE5\x1B\x81R\x80`\xA6`\x04\x82\x01`XV[\x03\x90\xFD",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405236608c57606e565b60405190565b60209181520190565b5f7f43616e6e6f742072656365697665204554480000000000000000000000000000910152565b604d60126020926012565b605481601b565b0190565b606b9060208101905f8183039101526042565b90565b6074600c565b62461bcd60e51b8152806088600482016058565b0390fd5b6092600c565b62461bcd60e51b81528060a6600482016058565b0390fd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R6`\x8CW`nV[`@Q\x90V[` \x91\x81R\x01\x90V[_\x7FCannot receive ETH\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[`M`\x12` \x92`\x12V[`T\x81`\x1BV[\x01\x90V[`k\x90` \x81\x01\x90_\x81\x83\x03\x91\x01R`BV[\x90V[`t`\x0CV[bF\x1B\xCD`\xE5\x1B\x81R\x80`\x88`\x04\x82\x01`XV[\x03\x90\xFD[`\x92`\x0CV[bF\x1B\xCD`\xE5\x1B\x81R\x80`\xA6`\x04\x82\x01`XV[\x03\x90\xFD",
    );
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`RejectEthContract`](self) contract instance.

See the [wrapper's documentation](`RejectEthContractInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> RejectEthContractInstance<T, P, N> {
        RejectEthContractInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<RejectEthContractInstance<T, P, N>>,
    > {
        RejectEthContractInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        RejectEthContractInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`RejectEthContract`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`RejectEthContract`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct RejectEthContractInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for RejectEthContractInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("RejectEthContractInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > RejectEthContractInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`RejectEthContract`](self) contract instance.

See the [wrapper's documentation](`RejectEthContractInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<RejectEthContractInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> RejectEthContractInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> RejectEthContractInstance<T, P, N> {
            RejectEthContractInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > RejectEthContractInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > RejectEthContractInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
