/**

Generated by the following Solidity interface...
```solidity
interface BridgeProxy {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error BridgeCallFailed();
    error ZeroAddress();
    error ZeroAmount();

    event BridgeCalldataUpdated(bytes oldCalldata, bytes newCalldata);
    event BridgeExecuted(address indexed token, uint256 amount, address indexed target, bool success);
    event BridgeTargetUpdated(address indexed oldTarget, address indexed newTarget);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    constructor(address admin);

    function BRIDGE_ADMIN_ROLE() external view returns (bytes32);
    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function bridgeCalldata() external view returns (bytes memory);
    function bridgeTarget() external view returns (address);
    function executeBridge(address token, uint256 amount, bytes memory data) external;
    function getBridgeConfiguration() external view returns (address target, bytes memory calldata_);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function recoverTokens(address token, uint256 amount, address to) external;
    function renounceRole(bytes32 role, address callerConfirmation) external;
    function revokeRole(bytes32 role, address account) external;
    function setBridgeCalldata(bytes memory calldata_) external;
    function setBridgeTarget(address target) external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "admin",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "BRIDGE_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeCalldata",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeTarget",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "executeBridge",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getBridgeConfiguration",
    "inputs": [],
    "outputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "calldata_",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "recoverTokens",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "callerConfirmation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeCalldata",
    "inputs": [
      {
        "name": "calldata_",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeTarget",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "BridgeCalldataUpdated",
    "inputs": [
      {
        "name": "oldCalldata",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      },
      {
        "name": "newCalldata",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeExecuted",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "target",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "success",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeTargetUpdated",
    "inputs": [
      {
        "name": "oldTarget",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newTarget",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccessControlBadConfirmation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AccessControlUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "neededRole",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "BridgeCallFailed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAmount",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod BridgeProxy {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60806040523461002f576100196100146100f4565b61019c565b610021610034565b61187c6103cb823961187c90f35b61003a565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906100669061003e565b810190811060018060401b0382111761007e57604052565b610048565b9061009661008f610034565b928361005c565b565b5f80fd5b60018060a01b031690565b6100b09061009c565b90565b6100bc816100a7565b036100c357565b5f80fd5b905051906100d4826100b3565b565b906020828203126100ef576100ec915f016100c7565b90565b610098565b610112611c478038038061010781610083565b9283398101906100d6565b90565b90565b90565b61012f61012a61013492610115565b610118565b61009c565b90565b6101409061011b565b90565b5f0190565b90565b5f1b90565b61016461015f61016992610115565b61014b565b610148565b90565b6101755f610150565b90565b7f751b795d24b92e3d92d1d0d8f2885f4e9c9c269da350af36ae6b49069babf4bf90565b806101b76101b16101ac5f610137565b6100a7565b916100a7565b146101e3576101e0906101d26101cb61016c565b82906102b9565b506101db610178565b6102b9565b50565b5f63d92e233d60e01b8152806101fb60048201610143565b0390fd5b5f90565b151590565b61021190610148565b90565b9061021e90610208565b5f5260205260405f2090565b61023e6102396102439261009c565b610118565b61009c565b90565b61024f9061022a565b90565b61025b90610246565b90565b9061026890610252565b5f5260205260405f2090565b9061028060ff9161014b565b9181191691161790565b61029390610203565b90565b90565b906102ae6102a96102b59261028a565b610296565b8254610274565b9055565b6102c16101ff565b506102d66102d0828490610390565b15610203565b5f1461035e576102fd60016102f85f6102f0818690610214565b01859061025e565b610299565b906103066103bd565b9061034361033d6103377f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d95610208565b92610252565b92610252565b9261034c610034565b8061035681610143565b0390a4600190565b50505f90565b5f1c90565b60ff1690565b61037b61038091610364565b610369565b90565b61038d905461036f565b90565b6103b6915f6103ab6103b1936103a46101ff565b5082610214565b0161025e565b610383565b90565b5f90565b6103c56103b9565b50339056fe60806040526004361015610013575b6109c5565b61001d5f3561010c565b806301ffc9a71461010757806307a1d5fa14610102578063118c38c7146100fd57806318b68b8c146100f8578063248a9ca3146100f35780632f2ff15d146100ee57806336568abe146100e95780635d7eba3b146100e457806361b0a56e146100df5780636bcc8c14146100da578063802a1d37146100d557806391d14854146100d0578063a217fddf146100cb578063c9f5b63e146100c65763d547741f0361000e57610991565b61095c565b6108ce565b61085d565b610829565b6107c0565b61076e565b6106ff565b610531565b6104fd565b61049b565b610423565b610303565b610279565b610198565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61013981610124565b0361014057565b5f80fd5b9050359061015182610130565b565b9060208282031261016c57610169915f01610144565b90565b61011c565b151590565b61017f90610171565b9052565b9190610196905f60208501940190610176565b565b346101c8576101c46101b36101ae366004610153565b6109cd565b6101bb610112565b91829182610183565b0390f35b610118565b5f9103126101d757565b61011c565b60018060a01b031690565b6101f0906101dc565b90565b6101fc906101e7565b9052565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b61024161024a60209361024f9361023881610200565b93848093610204565b9586910161020d565b610218565b0190565b916102769261026960408201935f8301906101f3565b6020818403910152610222565b90565b346102aa576102893660046101cd565b610291610a48565b906102a661029d610112565b92839283610253565b0390f35b610118565b7f751b795d24b92e3d92d1d0d8f2885f4e9c9c269da350af36ae6b49069babf4bf90565b6102db6102af565b90565b90565b6102ea906102de565b9052565b9190610301905f602085019401906102e1565b565b34610333576103133660046101cd565b61032f61031e6102d3565b610326610112565b918291826102ee565b0390f35b610118565b610341816101e7565b0361034857565b5f80fd5b9050359061035982610338565b565b90565b6103678161035b565b0361036e57565b5f80fd5b9050359061037f8261035e565b565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156103c75781359167ffffffffffffffff83116103c25760200192600183028401116103bd57565b610389565b610385565b610381565b91606083830312610419576103e3825f850161034c565b926103f18360208301610372565b92604082013567ffffffffffffffff811161041457610410920161038d565b9091565b610120565b61011c565b5f0190565b346104555761043f6104363660046103cc565b92919091610d6d565b610447610112565b806104518161041e565b0390f35b610118565b610463816102de565b0361046a57565b5f80fd5b9050359061047b8261045a565b565b9060208282031261049657610493915f0161046e565b90565b61011c565b346104cb576104c76104b66104b136600461047d565b611071565b6104be610112565b918291826102ee565b0390f35b610118565b91906040838203126104f857806104ec6104f5925f860161046e565b9360200161034c565b90565b61011c565b3461052c576105166105103660046104d0565b906110bc565b61051e610112565b806105288161041e565b0390f35b610118565b346105605761054a6105443660046104d0565b906110c8565b610552610112565b8061055c8161041e565b0390f35b610118565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b90600160028304921680156105ac575b60208310146105a757565b610578565b91607f169161059c565b60209181520190565b5f5260205f2090565b905f92918054906105e26105db8361058c565b80946105b6565b916001811690815f1461063957506001146105fd575b505050565b61060a91929394506105bf565b915f925b81841061062157505001905f80806105f8565b6001816020929593955484860152019101929061060e565b92949550505060ff19168252151560200201905f80806105f8565b9061065e916105c8565b90565b634e487b7160e01b5f52604160045260245ffd5b9061067f90610218565b810190811067ffffffffffffffff82111761069957604052565b610661565b906106be6106b7926106ae610112565b93848092610654565b0383610675565b565b905f106106d3576106d09061069e565b90565b610565565b6106e460025f906106c0565b90565b6106fc9160208201915f818403910152610222565b90565b3461072f5761070f3660046101cd565b61072b61071a6106d8565b610722610112565b918291826106e7565b0390f35b610118565b90916060828403126107695761076661074f845f850161034c565b9361075d8160208601610372565b9360400161034c565b90565b61011c565b3461079d57610787610781366004610734565b916111ee565b61078f610112565b806107998161041e565b0390f35b610118565b906020828203126107bb576107b8915f0161034c565b90565b61011c565b346107ee576107d86107d33660046107a2565b6112f1565b6107e0610112565b806107ea8161041e565b0390f35b610118565b90602082820312610824575f82013567ffffffffffffffff811161081f5761081b920161038d565b9091565b610120565b61011c565b346108585761084261083c3660046107f3565b9061159e565b61084a610112565b806108548161041e565b0390f35b610118565b3461088e5761088a6108796108733660046104d0565b906115e7565b610881610112565b91829182610183565b0390f35b610118565b90565b5f1b90565b6108af6108aa6108b492610893565b610896565b6102de565b90565b6108c05f61089b565b90565b6108cb6108b7565b90565b346108fe576108de3660046101cd565b6108fa6108e96108c3565b6108f1610112565b918291826102ee565b0390f35b610118565b1c90565b60018060a01b031690565b6109229060086109279302610903565b610907565b90565b906109359154610912565b90565b61094460015f9061092a565b90565b919061095a905f602085019401906101f3565b565b3461098c5761096c3660046101cd565b610988610977610938565b61097f610112565b91829182610947565b0390f35b610118565b346109c0576109aa6109a43660046104d0565b9061163a565b6109b2610112565b806109bc8161041e565b0390f35b610118565b5f80fd5b5f90565b6109d56109c9565b50806109f06109ea637965db0b60e01b610124565b91610124565b149081156109fd575b5090565b610a079150611646565b5f6109f9565b5f90565b606090565b5f1c90565b610a27610a2c91610a16565b610907565b90565b610a399054610a1b565b90565b610a459061069e565b90565b610a50610a0d565b50610a59610a11565b50610a646001610a2f565b90610a6f6002610a3c565b90565b90565b610a89610a84610a8e92610893565b610a72565b6101dc565b90565b610a9a90610a75565b90565b610ab1610aac610ab692610893565b610a72565b61035b565b90565b610acd610ac8610ad2926101dc565b610a72565b6101dc565b90565b610ade90610ab9565b90565b610aea90610ad5565b90565b610af690610ab9565b90565b610b0290610aed565b90565b610b0e90610aed565b90565b60e01b90565b610b2081610171565b03610b2757565b5f80fd5b90505190610b3882610b17565b565b90602082820312610b5357610b50915f01610b2b565b90565b61011c565b610b619061035b565b9052565b604090610b8e610b959496959396610b8460608401985f8501906101f3565b60208301906101f3565b0190610b58565b565b610b9f610112565b3d5f823e3d90fd5b916020610bc8929493610bc160408201965f8301906101f3565b0190610b58565b565b610bd4905461058c565b90565b610be090610b11565b90565b610bef610bf49161010c565b610bd7565b90565b610c019054610be3565b90565b1b90565b610c25610c1482610bca565b9180601f8411610c52575b50610bf7565b9060048110610c33575b5090565b610c4b9063ffffffff60e01b90600403600802610c04565b165f610c2f565b610c5c91506105bf565b5f610c1f565b90825f939282370152565b9190610c8781610c8081610c8c95610204565b8095610c62565b610218565b0190565b610cb6610cc39593949294610cac60608401965f8501906101f3565b6020830190610b58565b6040818503910152610c6d565b90565b90610cd9610cd2610112565b9283610675565b565b67ffffffffffffffff8111610cf957610cf5602091610218565b0190565b610661565b90610d10610d0b83610cdb565b610cc6565b918252565b3d5f14610d3057610d253d610cfe565b903d5f602084013e5b565b610d38610a11565b90610d2e565b610d4790610aed565b90565b916020610d6b929493610d6460408201965f830190610b58565b0190610176565b565b919282610d8a610d84610d7f5f610a91565b6101e7565b916101e7565b1461100b5781610da2610d9c5f610a9d565b9161035b565b14610fef57610db16001610a2f565b610dcb610dc5610dc05f610a91565b6101e7565b916101e7565b14610fd357610de1610ddc84610ae1565b610af9565b60206323b872dd913390610e115f610df830610b05565b95610e1c89610e05610112565b98899788968795610b11565b855260048501610b65565b03925af18015610fce57610fa2575b50610e3d610e3884610ae1565b610af9565b93602063095ea7b395610e506001610a2f565b90610e6e5f8799610e79610e62610112565b9b8c9687958694610b11565b845260048401610ba7565b03925af1908115610f9d57610ed35f93610ec4600493610f4f998796610f71575b50610ea56002610c08565b92899189909192610eb4610112565b9788966020880190815201610c90565b60208201810382520382610675565b610edd6001610a2f565b9082602082019151925af1610ef0610d15565b5091610efc6001610a2f565b9083610f31610f2b7f8e7f1561e09be9c40c53b4c5dd162d6db5b665ddb6f8bcfdf8f9e1a8e75fa67193610d3e565b93610d3e565b93610f46610f3d610112565b92839283610d4a565b0390a315610171565b610f5557565b5f631bb7daad60e11b815280610f6d6004820161041e565b0390fd5b610f919060203d8111610f96575b610f898183610675565b810190610b3a565b610e9a565b503d610f7f565b610b97565b610fc29060203d8111610fc7575b610fba8183610675565b810190610b3a565b610e2b565b503d610fb0565b610b97565b5f63d92e233d60e01b815280610feb6004820161041e565b0390fd5b5f631f2a200560e01b8152806110076004820161041e565b0390fd5b5f63d92e233d60e01b8152806110236004820161041e565b0390fd5b5f90565b611034906102de565b90565b906110419061102b565b5f5260205260405f2090565b90565b61105c61106191610a16565b61104d565b90565b61106e9054611050565b90565b600161108961108f92611082611027565b505f611037565b01611064565b90565b906110ad916110a86110a382611071565b61166c565b6110af565b565b906110b9916116c5565b50565b906110c691611092565b565b90806110e36110dd6110d8611770565b6101e7565b916101e7565b036110f4576110f19161177d565b50565b5f63334bd91960e11b81528061110c6004820161041e565b0390fd5b9061112b92916111266111216108b7565b61166c565b61112d565b565b908261114961114361113e5f610a91565b6101e7565b916101e7565b146111d25761116161115c602093610ae1565b610af9565b6111845f63a9059cbb95939561118f611178610112565b97889687958694610b11565b845260048401610ba7565b03925af180156111cd576111a1575b50565b6111c19060203d81116111c6575b6111b98183610675565b810190610b3a565b61119e565b503d6111af565b610b97565b5f63d92e233d60e01b8152806111ea6004820161041e565b0390fd5b906111f99291611110565b565b6112149061120f61120a6102af565b61166c565b611254565b565b9061122760018060a01b0391610896565b9181191691161790565b90565b9061124961124461125092610d3e565b611231565b8254611216565b9055565b8061126f6112696112645f610a91565b6101e7565b916101e7565b146112d55761127e6001610a2f565b611289826001611234565b906112bd6112b77fb07f8b1b85042d74022c867c836edeb0bcd70e135b0042390d2b1fd10829806993610d3e565b91610d3e565b916112c6610112565b806112d08161041e565b0390a3565b5f63d92e233d60e01b8152806112ed6004820161041e565b0390fd5b6112fa906111fb565b565b906113169161131161130c6102af565b61166c565b611548565b565b5090565b601f602091010490565b9190600861134191029161133b5f1984610c04565b92610c04565b9181191691161790565b61135f61135a6113649261035b565b610a72565b61035b565b90565b90565b919061138061137b6113889361134b565b611367565b908354611326565b9055565b5f90565b6113a29161139c61138c565b9161136a565b565b5b8181106113b0575050565b806113bd5f600193611390565b016113a5565b9190601f81116113d3575b505050565b6113df611404936105bf565b9060206113eb8461131c565b8301931061140c575b6113fd9061131c565b01906113a4565b5f80806113ce565b91506113fd819290506113f4565b9061142a905f1990600802610903565b191690565b816114399161141a565b906002021790565b9161144c9082611318565b9067ffffffffffffffff821161150b576114708261146a855461058c565b856113c3565b5f90601f83116001146114a357918091611492935f92611497575b505061142f565b90555b565b90915001355f8061148b565b601f198316916114b2856105bf565b925f5b8181106114f3575091600293918560019694106114d9575b50505002019055611495565b6114e9910135601f84169061141a565b90555f80806114cd565b919360206001819287870135815501950192016114b5565b610661565b9061151b9291611441565b565b91611537611545949260408501908582035f870152610222565b926020818503910152610c6d565b90565b906115536002610a3c565b6115608383906002611510565b9190916115997ff0dca53f6423fafdd825c9ca79bc76f4356686872f74a062e09d6d7e2f832c5a93611590610112565b9384938461151d565b0390a1565b906115a8916112fc565b565b906115b490610d3e565b5f5260205260405f2090565b60ff1690565b6115d26115d791610a16565b6115c0565b90565b6115e490546115c6565b90565b61160d915f611602611608936115fb6109c9565b5082611037565b016115aa565b6115da565b90565b9061162b9161162661162182611071565b61166c565b61162d565b565b906116379161177d565b50565b9061164491611610565b565b61164e6109c9565b506116686116626301ffc9a760e01b610124565b91610124565b1490565b61167e90611678611770565b90611841565b565b9061168c60ff91610896565b9181191691161790565b61169f90610171565b90565b90565b906116ba6116b56116c192611696565b6116a2565b8254611680565b9055565b6116cd6109c9565b506116e26116dc8284906115e7565b15610171565b5f1461176a5761170960016117045f6116fc818690611037565b0185906115aa565b6116a5565b90611712611770565b9061174f6117496117437f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d9561102b565b92610d3e565b92610d3e565b92611758610112565b806117628161041e565b0390a4600190565b50505f90565b611778610a0d565b503390565b6117856109c9565b506117918183906115e7565b5f14611818576117b75f6117b25f6117aa818690611037565b0185906115aa565b6116a5565b906117c0611770565b906117fd6117f76117f17ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9561102b565b92610d3e565b92610d3e565b92611806610112565b806118108161041e565b0390a4600190565b50505f90565b91602061183f92949361183860408201965f8301906101f3565b01906102e1565b565b906118566118508383906115e7565b15610171565b61185e575050565b6118785f92839263e2517d3f60e01b84526004840161181e565b0390fd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4a\0/Wa\0\x19a\0\x14a\0\xF4V[a\x01\x9CV[a\0!a\x004V[a\x18|a\x03\xCB\x829a\x18|\x90\xF3[a\0:V[`@Q\x90V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\0f\x90a\0>V[\x81\x01\x90\x81\x10`\x01\x80`@\x1B\x03\x82\x11\x17a\0~W`@RV[a\0HV[\x90a\0\x96a\0\x8Fa\x004V[\x92\x83a\0\\V[V[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\0\xB0\x90a\0\x9CV[\x90V[a\0\xBC\x81a\0\xA7V[\x03a\0\xC3WV[_\x80\xFD[\x90PQ\x90a\0\xD4\x82a\0\xB3V[V[\x90` \x82\x82\x03\x12a\0\xEFWa\0\xEC\x91_\x01a\0\xC7V[\x90V[a\0\x98V[a\x01\x12a\x1CG\x808\x03\x80a\x01\x07\x81a\0\x83V[\x92\x839\x81\x01\x90a\0\xD6V[\x90V[\x90V[\x90V[a\x01/a\x01*a\x014\x92a\x01\x15V[a\x01\x18V[a\0\x9CV[\x90V[a\x01@\x90a\x01\x1BV[\x90V[_\x01\x90V[\x90V[_\x1B\x90V[a\x01da\x01_a\x01i\x92a\x01\x15V[a\x01KV[a\x01HV[\x90V[a\x01u_a\x01PV[\x90V[\x7Fu\x1By]$\xB9.=\x92\xD1\xD0\xD8\xF2\x88_N\x9C\x9C&\x9D\xA3P\xAF6\xAEkI\x06\x9B\xAB\xF4\xBF\x90V[\x80a\x01\xB7a\x01\xB1a\x01\xAC_a\x017V[a\0\xA7V[\x91a\0\xA7V[\x14a\x01\xE3Wa\x01\xE0\x90a\x01\xD2a\x01\xCBa\x01lV[\x82\x90a\x02\xB9V[Pa\x01\xDBa\x01xV[a\x02\xB9V[PV[_c\xD9.#=`\xE0\x1B\x81R\x80a\x01\xFB`\x04\x82\x01a\x01CV[\x03\x90\xFD[_\x90V[\x15\x15\x90V[a\x02\x11\x90a\x01HV[\x90V[\x90a\x02\x1E\x90a\x02\x08V[_R` R`@_ \x90V[a\x02>a\x029a\x02C\x92a\0\x9CV[a\x01\x18V[a\0\x9CV[\x90V[a\x02O\x90a\x02*V[\x90V[a\x02[\x90a\x02FV[\x90V[\x90a\x02h\x90a\x02RV[_R` R`@_ \x90V[\x90a\x02\x80`\xFF\x91a\x01KV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x02\x93\x90a\x02\x03V[\x90V[\x90V[\x90a\x02\xAEa\x02\xA9a\x02\xB5\x92a\x02\x8AV[a\x02\x96V[\x82Ta\x02tV[\x90UV[a\x02\xC1a\x01\xFFV[Pa\x02\xD6a\x02\xD0\x82\x84\x90a\x03\x90V[\x15a\x02\x03V[_\x14a\x03^Wa\x02\xFD`\x01a\x02\xF8_a\x02\xF0\x81\x86\x90a\x02\x14V[\x01\x85\x90a\x02^V[a\x02\x99V[\x90a\x03\x06a\x03\xBDV[\x90a\x03Ca\x03=a\x037\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\x02\x08V[\x92a\x02RV[\x92a\x02RV[\x92a\x03La\x004V[\x80a\x03V\x81a\x01CV[\x03\x90\xA4`\x01\x90V[PP_\x90V[_\x1C\x90V[`\xFF\x16\x90V[a\x03{a\x03\x80\x91a\x03dV[a\x03iV[\x90V[a\x03\x8D\x90Ta\x03oV[\x90V[a\x03\xB6\x91_a\x03\xABa\x03\xB1\x93a\x03\xA4a\x01\xFFV[P\x82a\x02\x14V[\x01a\x02^V[a\x03\x83V[\x90V[_\x90V[a\x03\xC5a\x03\xB9V[P3\x90V\xFE`\x80`@R`\x046\x10\x15a\0\x13W[a\t\xC5V[a\0\x1D_5a\x01\x0CV[\x80c\x01\xFF\xC9\xA7\x14a\x01\x07W\x80c\x07\xA1\xD5\xFA\x14a\x01\x02W\x80c\x11\x8C8\xC7\x14a\0\xFDW\x80c\x18\xB6\x8B\x8C\x14a\0\xF8W\x80c$\x8A\x9C\xA3\x14a\0\xF3W\x80c//\xF1]\x14a\0\xEEW\x80c6V\x8A\xBE\x14a\0\xE9W\x80c]~\xBA;\x14a\0\xE4W\x80ca\xB0\xA5n\x14a\0\xDFW\x80ck\xCC\x8C\x14\x14a\0\xDAW\x80c\x80*\x1D7\x14a\0\xD5W\x80c\x91\xD1HT\x14a\0\xD0W\x80c\xA2\x17\xFD\xDF\x14a\0\xCBW\x80c\xC9\xF5\xB6>\x14a\0\xC6Wc\xD5Gt\x1F\x03a\0\x0EWa\t\x91V[a\t\\V[a\x08\xCEV[a\x08]V[a\x08)V[a\x07\xC0V[a\x07nV[a\x06\xFFV[a\x051V[a\x04\xFDV[a\x04\x9BV[a\x04#V[a\x03\x03V[a\x02yV[a\x01\x98V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x019\x81a\x01$V[\x03a\x01@WV[_\x80\xFD[\x90P5\x90a\x01Q\x82a\x010V[V[\x90` \x82\x82\x03\x12a\x01lWa\x01i\x91_\x01a\x01DV[\x90V[a\x01\x1CV[\x15\x15\x90V[a\x01\x7F\x90a\x01qV[\x90RV[\x91\x90a\x01\x96\x90_` \x85\x01\x94\x01\x90a\x01vV[V[4a\x01\xC8Wa\x01\xC4a\x01\xB3a\x01\xAE6`\x04a\x01SV[a\t\xCDV[a\x01\xBBa\x01\x12V[\x91\x82\x91\x82a\x01\x83V[\x03\x90\xF3[a\x01\x18V[_\x91\x03\x12a\x01\xD7WV[a\x01\x1CV[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x01\xF0\x90a\x01\xDCV[\x90V[a\x01\xFC\x90a\x01\xE7V[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x02Aa\x02J` \x93a\x02O\x93a\x028\x81a\x02\0V[\x93\x84\x80\x93a\x02\x04V[\x95\x86\x91\x01a\x02\rV[a\x02\x18V[\x01\x90V[\x91a\x02v\x92a\x02i`@\x82\x01\x93_\x83\x01\x90a\x01\xF3V[` \x81\x84\x03\x91\x01Ra\x02\"V[\x90V[4a\x02\xAAWa\x02\x896`\x04a\x01\xCDV[a\x02\x91a\nHV[\x90a\x02\xA6a\x02\x9Da\x01\x12V[\x92\x83\x92\x83a\x02SV[\x03\x90\xF3[a\x01\x18V[\x7Fu\x1By]$\xB9.=\x92\xD1\xD0\xD8\xF2\x88_N\x9C\x9C&\x9D\xA3P\xAF6\xAEkI\x06\x9B\xAB\xF4\xBF\x90V[a\x02\xDBa\x02\xAFV[\x90V[\x90V[a\x02\xEA\x90a\x02\xDEV[\x90RV[\x91\x90a\x03\x01\x90_` \x85\x01\x94\x01\x90a\x02\xE1V[V[4a\x033Wa\x03\x136`\x04a\x01\xCDV[a\x03/a\x03\x1Ea\x02\xD3V[a\x03&a\x01\x12V[\x91\x82\x91\x82a\x02\xEEV[\x03\x90\xF3[a\x01\x18V[a\x03A\x81a\x01\xE7V[\x03a\x03HWV[_\x80\xFD[\x90P5\x90a\x03Y\x82a\x038V[V[\x90V[a\x03g\x81a\x03[V[\x03a\x03nWV[_\x80\xFD[\x90P5\x90a\x03\x7F\x82a\x03^V[V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x03\xC7W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x03\xC2W` \x01\x92`\x01\x83\x02\x84\x01\x11a\x03\xBDWV[a\x03\x89V[a\x03\x85V[a\x03\x81V[\x91``\x83\x83\x03\x12a\x04\x19Wa\x03\xE3\x82_\x85\x01a\x03LV[\x92a\x03\xF1\x83` \x83\x01a\x03rV[\x92`@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x14Wa\x04\x10\x92\x01a\x03\x8DV[\x90\x91V[a\x01 V[a\x01\x1CV[_\x01\x90V[4a\x04UWa\x04?a\x0466`\x04a\x03\xCCV[\x92\x91\x90\x91a\rmV[a\x04Ga\x01\x12V[\x80a\x04Q\x81a\x04\x1EV[\x03\x90\xF3[a\x01\x18V[a\x04c\x81a\x02\xDEV[\x03a\x04jWV[_\x80\xFD[\x90P5\x90a\x04{\x82a\x04ZV[V[\x90` \x82\x82\x03\x12a\x04\x96Wa\x04\x93\x91_\x01a\x04nV[\x90V[a\x01\x1CV[4a\x04\xCBWa\x04\xC7a\x04\xB6a\x04\xB16`\x04a\x04}V[a\x10qV[a\x04\xBEa\x01\x12V[\x91\x82\x91\x82a\x02\xEEV[\x03\x90\xF3[a\x01\x18V[\x91\x90`@\x83\x82\x03\x12a\x04\xF8W\x80a\x04\xECa\x04\xF5\x92_\x86\x01a\x04nV[\x93` \x01a\x03LV[\x90V[a\x01\x1CV[4a\x05,Wa\x05\x16a\x05\x106`\x04a\x04\xD0V[\x90a\x10\xBCV[a\x05\x1Ea\x01\x12V[\x80a\x05(\x81a\x04\x1EV[\x03\x90\xF3[a\x01\x18V[4a\x05`Wa\x05Ja\x05D6`\x04a\x04\xD0V[\x90a\x10\xC8V[a\x05Ra\x01\x12V[\x80a\x05\\\x81a\x04\x1EV[\x03\x90\xF3[a\x01\x18V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x05\xACW[` \x83\x10\x14a\x05\xA7WV[a\x05xV[\x91`\x7F\x16\x91a\x05\x9CV[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x05\xE2a\x05\xDB\x83a\x05\x8CV[\x80\x94a\x05\xB6V[\x91`\x01\x81\x16\x90\x81_\x14a\x069WP`\x01\x14a\x05\xFDW[PPPV[a\x06\n\x91\x92\x93\x94Pa\x05\xBFV[\x91_\x92[\x81\x84\x10a\x06!WPP\x01\x90_\x80\x80a\x05\xF8V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x06\x0EV[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x05\xF8V[\x90a\x06^\x91a\x05\xC8V[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x06\x7F\x90a\x02\x18V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x06\x99W`@RV[a\x06aV[\x90a\x06\xBEa\x06\xB7\x92a\x06\xAEa\x01\x12V[\x93\x84\x80\x92a\x06TV[\x03\x83a\x06uV[V[\x90_\x10a\x06\xD3Wa\x06\xD0\x90a\x06\x9EV[\x90V[a\x05eV[a\x06\xE4`\x02_\x90a\x06\xC0V[\x90V[a\x06\xFC\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x02\"V[\x90V[4a\x07/Wa\x07\x0F6`\x04a\x01\xCDV[a\x07+a\x07\x1Aa\x06\xD8V[a\x07\"a\x01\x12V[\x91\x82\x91\x82a\x06\xE7V[\x03\x90\xF3[a\x01\x18V[\x90\x91``\x82\x84\x03\x12a\x07iWa\x07fa\x07O\x84_\x85\x01a\x03LV[\x93a\x07]\x81` \x86\x01a\x03rV[\x93`@\x01a\x03LV[\x90V[a\x01\x1CV[4a\x07\x9DWa\x07\x87a\x07\x816`\x04a\x074V[\x91a\x11\xEEV[a\x07\x8Fa\x01\x12V[\x80a\x07\x99\x81a\x04\x1EV[\x03\x90\xF3[a\x01\x18V[\x90` \x82\x82\x03\x12a\x07\xBBWa\x07\xB8\x91_\x01a\x03LV[\x90V[a\x01\x1CV[4a\x07\xEEWa\x07\xD8a\x07\xD36`\x04a\x07\xA2V[a\x12\xF1V[a\x07\xE0a\x01\x12V[\x80a\x07\xEA\x81a\x04\x1EV[\x03\x90\xF3[a\x01\x18V[\x90` \x82\x82\x03\x12a\x08$W_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x08\x1FWa\x08\x1B\x92\x01a\x03\x8DV[\x90\x91V[a\x01 V[a\x01\x1CV[4a\x08XWa\x08Ba\x08<6`\x04a\x07\xF3V[\x90a\x15\x9EV[a\x08Ja\x01\x12V[\x80a\x08T\x81a\x04\x1EV[\x03\x90\xF3[a\x01\x18V[4a\x08\x8EWa\x08\x8Aa\x08ya\x08s6`\x04a\x04\xD0V[\x90a\x15\xE7V[a\x08\x81a\x01\x12V[\x91\x82\x91\x82a\x01\x83V[\x03\x90\xF3[a\x01\x18V[\x90V[_\x1B\x90V[a\x08\xAFa\x08\xAAa\x08\xB4\x92a\x08\x93V[a\x08\x96V[a\x02\xDEV[\x90V[a\x08\xC0_a\x08\x9BV[\x90V[a\x08\xCBa\x08\xB7V[\x90V[4a\x08\xFEWa\x08\xDE6`\x04a\x01\xCDV[a\x08\xFAa\x08\xE9a\x08\xC3V[a\x08\xF1a\x01\x12V[\x91\x82\x91\x82a\x02\xEEV[\x03\x90\xF3[a\x01\x18V[\x1C\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\t\"\x90`\x08a\t'\x93\x02a\t\x03V[a\t\x07V[\x90V[\x90a\t5\x91Ta\t\x12V[\x90V[a\tD`\x01_\x90a\t*V[\x90V[\x91\x90a\tZ\x90_` \x85\x01\x94\x01\x90a\x01\xF3V[V[4a\t\x8CWa\tl6`\x04a\x01\xCDV[a\t\x88a\twa\t8V[a\t\x7Fa\x01\x12V[\x91\x82\x91\x82a\tGV[\x03\x90\xF3[a\x01\x18V[4a\t\xC0Wa\t\xAAa\t\xA46`\x04a\x04\xD0V[\x90a\x16:V[a\t\xB2a\x01\x12V[\x80a\t\xBC\x81a\x04\x1EV[\x03\x90\xF3[a\x01\x18V[_\x80\xFD[_\x90V[a\t\xD5a\t\xC9V[P\x80a\t\xF0a\t\xEAcye\xDB\x0B`\xE0\x1Ba\x01$V[\x91a\x01$V[\x14\x90\x81\x15a\t\xFDW[P\x90V[a\n\x07\x91Pa\x16FV[_a\t\xF9V[_\x90V[``\x90V[_\x1C\x90V[a\n'a\n,\x91a\n\x16V[a\t\x07V[\x90V[a\n9\x90Ta\n\x1BV[\x90V[a\nE\x90a\x06\x9EV[\x90V[a\nPa\n\rV[Pa\nYa\n\x11V[Pa\nd`\x01a\n/V[\x90a\no`\x02a\n<V[\x90V[\x90V[a\n\x89a\n\x84a\n\x8E\x92a\x08\x93V[a\nrV[a\x01\xDCV[\x90V[a\n\x9A\x90a\nuV[\x90V[a\n\xB1a\n\xACa\n\xB6\x92a\x08\x93V[a\nrV[a\x03[V[\x90V[a\n\xCDa\n\xC8a\n\xD2\x92a\x01\xDCV[a\nrV[a\x01\xDCV[\x90V[a\n\xDE\x90a\n\xB9V[\x90V[a\n\xEA\x90a\n\xD5V[\x90V[a\n\xF6\x90a\n\xB9V[\x90V[a\x0B\x02\x90a\n\xEDV[\x90V[a\x0B\x0E\x90a\n\xEDV[\x90V[`\xE0\x1B\x90V[a\x0B \x81a\x01qV[\x03a\x0B'WV[_\x80\xFD[\x90PQ\x90a\x0B8\x82a\x0B\x17V[V[\x90` \x82\x82\x03\x12a\x0BSWa\x0BP\x91_\x01a\x0B+V[\x90V[a\x01\x1CV[a\x0Ba\x90a\x03[V[\x90RV[`@\x90a\x0B\x8Ea\x0B\x95\x94\x96\x95\x93\x96a\x0B\x84``\x84\x01\x98_\x85\x01\x90a\x01\xF3V[` \x83\x01\x90a\x01\xF3V[\x01\x90a\x0BXV[V[a\x0B\x9Fa\x01\x12V[=_\x82>=\x90\xFD[\x91` a\x0B\xC8\x92\x94\x93a\x0B\xC1`@\x82\x01\x96_\x83\x01\x90a\x01\xF3V[\x01\x90a\x0BXV[V[a\x0B\xD4\x90Ta\x05\x8CV[\x90V[a\x0B\xE0\x90a\x0B\x11V[\x90V[a\x0B\xEFa\x0B\xF4\x91a\x01\x0CV[a\x0B\xD7V[\x90V[a\x0C\x01\x90Ta\x0B\xE3V[\x90V[\x1B\x90V[a\x0C%a\x0C\x14\x82a\x0B\xCAV[\x91\x80`\x1F\x84\x11a\x0CRW[Pa\x0B\xF7V[\x90`\x04\x81\x10a\x0C3W[P\x90V[a\x0CK\x90c\xFF\xFF\xFF\xFF`\xE0\x1B\x90`\x04\x03`\x08\x02a\x0C\x04V[\x16_a\x0C/V[a\x0C\\\x91Pa\x05\xBFV[_a\x0C\x1FV[\x90\x82_\x93\x92\x827\x01RV[\x91\x90a\x0C\x87\x81a\x0C\x80\x81a\x0C\x8C\x95a\x02\x04V[\x80\x95a\x0CbV[a\x02\x18V[\x01\x90V[a\x0C\xB6a\x0C\xC3\x95\x93\x94\x92\x94a\x0C\xAC``\x84\x01\x96_\x85\x01\x90a\x01\xF3V[` \x83\x01\x90a\x0BXV[`@\x81\x85\x03\x91\x01Ra\x0CmV[\x90V[\x90a\x0C\xD9a\x0C\xD2a\x01\x12V[\x92\x83a\x06uV[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x0C\xF9Wa\x0C\xF5` \x91a\x02\x18V[\x01\x90V[a\x06aV[\x90a\r\x10a\r\x0B\x83a\x0C\xDBV[a\x0C\xC6V[\x91\x82RV[=_\x14a\r0Wa\r%=a\x0C\xFEV[\x90=_` \x84\x01>[V[a\r8a\n\x11V[\x90a\r.V[a\rG\x90a\n\xEDV[\x90V[\x91` a\rk\x92\x94\x93a\rd`@\x82\x01\x96_\x83\x01\x90a\x0BXV[\x01\x90a\x01vV[V[\x91\x92\x82a\r\x8Aa\r\x84a\r\x7F_a\n\x91V[a\x01\xE7V[\x91a\x01\xE7V[\x14a\x10\x0BW\x81a\r\xA2a\r\x9C_a\n\x9DV[\x91a\x03[V[\x14a\x0F\xEFWa\r\xB1`\x01a\n/V[a\r\xCBa\r\xC5a\r\xC0_a\n\x91V[a\x01\xE7V[\x91a\x01\xE7V[\x14a\x0F\xD3Wa\r\xE1a\r\xDC\x84a\n\xE1V[a\n\xF9V[` c#\xB8r\xDD\x913\x90a\x0E\x11_a\r\xF80a\x0B\x05V[\x95a\x0E\x1C\x89a\x0E\x05a\x01\x12V[\x98\x89\x97\x88\x96\x87\x95a\x0B\x11V[\x85R`\x04\x85\x01a\x0BeV[\x03\x92Z\xF1\x80\x15a\x0F\xCEWa\x0F\xA2W[Pa\x0E=a\x0E8\x84a\n\xE1V[a\n\xF9V[\x93` c\t^\xA7\xB3\x95a\x0EP`\x01a\n/V[\x90a\x0En_\x87\x99a\x0Eya\x0Eba\x01\x12V[\x9B\x8C\x96\x87\x95\x86\x94a\x0B\x11V[\x84R`\x04\x84\x01a\x0B\xA7V[\x03\x92Z\xF1\x90\x81\x15a\x0F\x9DWa\x0E\xD3_\x93a\x0E\xC4`\x04\x93a\x0FO\x99\x87\x96a\x0FqW[Pa\x0E\xA5`\x02a\x0C\x08V[\x92\x89\x91\x89\x90\x91\x92a\x0E\xB4a\x01\x12V[\x97\x88\x96` \x88\x01\x90\x81R\x01a\x0C\x90V[` \x82\x01\x81\x03\x82R\x03\x82a\x06uV[a\x0E\xDD`\x01a\n/V[\x90\x82` \x82\x01\x91Q\x92Z\xF1a\x0E\xF0a\r\x15V[P\x91a\x0E\xFC`\x01a\n/V[\x90\x83a\x0F1a\x0F+\x7F\x8E\x7F\x15a\xE0\x9B\xE9\xC4\x0CS\xB4\xC5\xDD\x16-m\xB5\xB6e\xDD\xB6\xF8\xBC\xFD\xF8\xF9\xE1\xA8\xE7_\xA6q\x93a\r>V[\x93a\r>V[\x93a\x0FFa\x0F=a\x01\x12V[\x92\x83\x92\x83a\rJV[\x03\x90\xA3\x15a\x01qV[a\x0FUWV[_c\x1B\xB7\xDA\xAD`\xE1\x1B\x81R\x80a\x0Fm`\x04\x82\x01a\x04\x1EV[\x03\x90\xFD[a\x0F\x91\x90` =\x81\x11a\x0F\x96W[a\x0F\x89\x81\x83a\x06uV[\x81\x01\x90a\x0B:V[a\x0E\x9AV[P=a\x0F\x7FV[a\x0B\x97V[a\x0F\xC2\x90` =\x81\x11a\x0F\xC7W[a\x0F\xBA\x81\x83a\x06uV[\x81\x01\x90a\x0B:V[a\x0E+V[P=a\x0F\xB0V[a\x0B\x97V[_c\xD9.#=`\xE0\x1B\x81R\x80a\x0F\xEB`\x04\x82\x01a\x04\x1EV[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a\x10\x07`\x04\x82\x01a\x04\x1EV[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x10#`\x04\x82\x01a\x04\x1EV[\x03\x90\xFD[_\x90V[a\x104\x90a\x02\xDEV[\x90V[\x90a\x10A\x90a\x10+V[_R` R`@_ \x90V[\x90V[a\x10\\a\x10a\x91a\n\x16V[a\x10MV[\x90V[a\x10n\x90Ta\x10PV[\x90V[`\x01a\x10\x89a\x10\x8F\x92a\x10\x82a\x10'V[P_a\x107V[\x01a\x10dV[\x90V[\x90a\x10\xAD\x91a\x10\xA8a\x10\xA3\x82a\x10qV[a\x16lV[a\x10\xAFV[V[\x90a\x10\xB9\x91a\x16\xC5V[PV[\x90a\x10\xC6\x91a\x10\x92V[V[\x90\x80a\x10\xE3a\x10\xDDa\x10\xD8a\x17pV[a\x01\xE7V[\x91a\x01\xE7V[\x03a\x10\xF4Wa\x10\xF1\x91a\x17}V[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a\x11\x0C`\x04\x82\x01a\x04\x1EV[\x03\x90\xFD[\x90a\x11+\x92\x91a\x11&a\x11!a\x08\xB7V[a\x16lV[a\x11-V[V[\x90\x82a\x11Ia\x11Ca\x11>_a\n\x91V[a\x01\xE7V[\x91a\x01\xE7V[\x14a\x11\xD2Wa\x11aa\x11\\` \x93a\n\xE1V[a\n\xF9V[a\x11\x84_c\xA9\x05\x9C\xBB\x95\x93\x95a\x11\x8Fa\x11xa\x01\x12V[\x97\x88\x96\x87\x95\x86\x94a\x0B\x11V[\x84R`\x04\x84\x01a\x0B\xA7V[\x03\x92Z\xF1\x80\x15a\x11\xCDWa\x11\xA1W[PV[a\x11\xC1\x90` =\x81\x11a\x11\xC6W[a\x11\xB9\x81\x83a\x06uV[\x81\x01\x90a\x0B:V[a\x11\x9EV[P=a\x11\xAFV[a\x0B\x97V[_c\xD9.#=`\xE0\x1B\x81R\x80a\x11\xEA`\x04\x82\x01a\x04\x1EV[\x03\x90\xFD[\x90a\x11\xF9\x92\x91a\x11\x10V[V[a\x12\x14\x90a\x12\x0Fa\x12\na\x02\xAFV[a\x16lV[a\x12TV[V[\x90a\x12'`\x01\x80`\xA0\x1B\x03\x91a\x08\x96V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x90a\x12Ia\x12Da\x12P\x92a\r>V[a\x121V[\x82Ta\x12\x16V[\x90UV[\x80a\x12oa\x12ia\x12d_a\n\x91V[a\x01\xE7V[\x91a\x01\xE7V[\x14a\x12\xD5Wa\x12~`\x01a\n/V[a\x12\x89\x82`\x01a\x124V[\x90a\x12\xBDa\x12\xB7\x7F\xB0\x7F\x8B\x1B\x85\x04-t\x02,\x86|\x83n\xDE\xB0\xBC\xD7\x0E\x13[\0B9\r+\x1F\xD1\x08)\x80i\x93a\r>V[\x91a\r>V[\x91a\x12\xC6a\x01\x12V[\x80a\x12\xD0\x81a\x04\x1EV[\x03\x90\xA3V[_c\xD9.#=`\xE0\x1B\x81R\x80a\x12\xED`\x04\x82\x01a\x04\x1EV[\x03\x90\xFD[a\x12\xFA\x90a\x11\xFBV[V[\x90a\x13\x16\x91a\x13\x11a\x13\x0Ca\x02\xAFV[a\x16lV[a\x15HV[V[P\x90V[`\x1F` \x91\x01\x04\x90V[\x91\x90`\x08a\x13A\x91\x02\x91a\x13;_\x19\x84a\x0C\x04V[\x92a\x0C\x04V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x13_a\x13Za\x13d\x92a\x03[V[a\nrV[a\x03[V[\x90V[\x90V[\x91\x90a\x13\x80a\x13{a\x13\x88\x93a\x13KV[a\x13gV[\x90\x83Ta\x13&V[\x90UV[_\x90V[a\x13\xA2\x91a\x13\x9Ca\x13\x8CV[\x91a\x13jV[V[[\x81\x81\x10a\x13\xB0WPPV[\x80a\x13\xBD_`\x01\x93a\x13\x90V[\x01a\x13\xA5V[\x91\x90`\x1F\x81\x11a\x13\xD3W[PPPV[a\x13\xDFa\x14\x04\x93a\x05\xBFV[\x90` a\x13\xEB\x84a\x13\x1CV[\x83\x01\x93\x10a\x14\x0CW[a\x13\xFD\x90a\x13\x1CV[\x01\x90a\x13\xA4V[_\x80\x80a\x13\xCEV[\x91Pa\x13\xFD\x81\x92\x90Pa\x13\xF4V[\x90a\x14*\x90_\x19\x90`\x08\x02a\t\x03V[\x19\x16\x90V[\x81a\x149\x91a\x14\x1AV[\x90`\x02\x02\x17\x90V[\x91a\x14L\x90\x82a\x13\x18V[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x15\x0BWa\x14p\x82a\x14j\x85Ta\x05\x8CV[\x85a\x13\xC3V[_\x90`\x1F\x83\x11`\x01\x14a\x14\xA3W\x91\x80\x91a\x14\x92\x93_\x92a\x14\x97W[PPa\x14/V[\x90U[V[\x90\x91P\x015_\x80a\x14\x8BV[`\x1F\x19\x83\x16\x91a\x14\xB2\x85a\x05\xBFV[\x92_[\x81\x81\x10a\x14\xF3WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x14\xD9W[PPP\x02\x01\x90Ua\x14\x95V[a\x14\xE9\x91\x015`\x1F\x84\x16\x90a\x14\x1AV[\x90U_\x80\x80a\x14\xCDV[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a\x14\xB5V[a\x06aV[\x90a\x15\x1B\x92\x91a\x14AV[V[\x91a\x157a\x15E\x94\x92`@\x85\x01\x90\x85\x82\x03_\x87\x01Ra\x02\"V[\x92` \x81\x85\x03\x91\x01Ra\x0CmV[\x90V[\x90a\x15S`\x02a\n<V[a\x15`\x83\x83\x90`\x02a\x15\x10V[\x91\x90\x91a\x15\x99\x7F\xF0\xDC\xA5?d#\xFA\xFD\xD8%\xC9\xCAy\xBCv\xF45f\x86\x87/t\xA0b\xE0\x9Dm~/\x83,Z\x93a\x15\x90a\x01\x12V[\x93\x84\x93\x84a\x15\x1DV[\x03\x90\xA1V[\x90a\x15\xA8\x91a\x12\xFCV[V[\x90a\x15\xB4\x90a\r>V[_R` R`@_ \x90V[`\xFF\x16\x90V[a\x15\xD2a\x15\xD7\x91a\n\x16V[a\x15\xC0V[\x90V[a\x15\xE4\x90Ta\x15\xC6V[\x90V[a\x16\r\x91_a\x16\x02a\x16\x08\x93a\x15\xFBa\t\xC9V[P\x82a\x107V[\x01a\x15\xAAV[a\x15\xDAV[\x90V[\x90a\x16+\x91a\x16&a\x16!\x82a\x10qV[a\x16lV[a\x16-V[V[\x90a\x167\x91a\x17}V[PV[\x90a\x16D\x91a\x16\x10V[V[a\x16Na\t\xC9V[Pa\x16ha\x16bc\x01\xFF\xC9\xA7`\xE0\x1Ba\x01$V[\x91a\x01$V[\x14\x90V[a\x16~\x90a\x16xa\x17pV[\x90a\x18AV[V[\x90a\x16\x8C`\xFF\x91a\x08\x96V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x16\x9F\x90a\x01qV[\x90V[\x90V[\x90a\x16\xBAa\x16\xB5a\x16\xC1\x92a\x16\x96V[a\x16\xA2V[\x82Ta\x16\x80V[\x90UV[a\x16\xCDa\t\xC9V[Pa\x16\xE2a\x16\xDC\x82\x84\x90a\x15\xE7V[\x15a\x01qV[_\x14a\x17jWa\x17\t`\x01a\x17\x04_a\x16\xFC\x81\x86\x90a\x107V[\x01\x85\x90a\x15\xAAV[a\x16\xA5V[\x90a\x17\x12a\x17pV[\x90a\x17Oa\x17Ia\x17C\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\x10+V[\x92a\r>V[\x92a\r>V[\x92a\x17Xa\x01\x12V[\x80a\x17b\x81a\x04\x1EV[\x03\x90\xA4`\x01\x90V[PP_\x90V[a\x17xa\n\rV[P3\x90V[a\x17\x85a\t\xC9V[Pa\x17\x91\x81\x83\x90a\x15\xE7V[_\x14a\x18\x18Wa\x17\xB7_a\x17\xB2_a\x17\xAA\x81\x86\x90a\x107V[\x01\x85\x90a\x15\xAAV[a\x16\xA5V[\x90a\x17\xC0a\x17pV[\x90a\x17\xFDa\x17\xF7a\x17\xF1\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a\x10+V[\x92a\r>V[\x92a\r>V[\x92a\x18\x06a\x01\x12V[\x80a\x18\x10\x81a\x04\x1EV[\x03\x90\xA4`\x01\x90V[PP_\x90V[\x91` a\x18?\x92\x94\x93a\x188`@\x82\x01\x96_\x83\x01\x90a\x01\xF3V[\x01\x90a\x02\xE1V[V[\x90a\x18Va\x18P\x83\x83\x90a\x15\xE7V[\x15a\x01qV[a\x18^WPPV[a\x18x_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01a\x18\x1EV[\x03\x90\xFD",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610013575b6109c5565b61001d5f3561010c565b806301ffc9a71461010757806307a1d5fa14610102578063118c38c7146100fd57806318b68b8c146100f8578063248a9ca3146100f35780632f2ff15d146100ee57806336568abe146100e95780635d7eba3b146100e457806361b0a56e146100df5780636bcc8c14146100da578063802a1d37146100d557806391d14854146100d0578063a217fddf146100cb578063c9f5b63e146100c65763d547741f0361000e57610991565b61095c565b6108ce565b61085d565b610829565b6107c0565b61076e565b6106ff565b610531565b6104fd565b61049b565b610423565b610303565b610279565b610198565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61013981610124565b0361014057565b5f80fd5b9050359061015182610130565b565b9060208282031261016c57610169915f01610144565b90565b61011c565b151590565b61017f90610171565b9052565b9190610196905f60208501940190610176565b565b346101c8576101c46101b36101ae366004610153565b6109cd565b6101bb610112565b91829182610183565b0390f35b610118565b5f9103126101d757565b61011c565b60018060a01b031690565b6101f0906101dc565b90565b6101fc906101e7565b9052565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b61024161024a60209361024f9361023881610200565b93848093610204565b9586910161020d565b610218565b0190565b916102769261026960408201935f8301906101f3565b6020818403910152610222565b90565b346102aa576102893660046101cd565b610291610a48565b906102a661029d610112565b92839283610253565b0390f35b610118565b7f751b795d24b92e3d92d1d0d8f2885f4e9c9c269da350af36ae6b49069babf4bf90565b6102db6102af565b90565b90565b6102ea906102de565b9052565b9190610301905f602085019401906102e1565b565b34610333576103133660046101cd565b61032f61031e6102d3565b610326610112565b918291826102ee565b0390f35b610118565b610341816101e7565b0361034857565b5f80fd5b9050359061035982610338565b565b90565b6103678161035b565b0361036e57565b5f80fd5b9050359061037f8261035e565b565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156103c75781359167ffffffffffffffff83116103c25760200192600183028401116103bd57565b610389565b610385565b610381565b91606083830312610419576103e3825f850161034c565b926103f18360208301610372565b92604082013567ffffffffffffffff811161041457610410920161038d565b9091565b610120565b61011c565b5f0190565b346104555761043f6104363660046103cc565b92919091610d6d565b610447610112565b806104518161041e565b0390f35b610118565b610463816102de565b0361046a57565b5f80fd5b9050359061047b8261045a565b565b9060208282031261049657610493915f0161046e565b90565b61011c565b346104cb576104c76104b66104b136600461047d565b611071565b6104be610112565b918291826102ee565b0390f35b610118565b91906040838203126104f857806104ec6104f5925f860161046e565b9360200161034c565b90565b61011c565b3461052c576105166105103660046104d0565b906110bc565b61051e610112565b806105288161041e565b0390f35b610118565b346105605761054a6105443660046104d0565b906110c8565b610552610112565b8061055c8161041e565b0390f35b610118565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b90600160028304921680156105ac575b60208310146105a757565b610578565b91607f169161059c565b60209181520190565b5f5260205f2090565b905f92918054906105e26105db8361058c565b80946105b6565b916001811690815f1461063957506001146105fd575b505050565b61060a91929394506105bf565b915f925b81841061062157505001905f80806105f8565b6001816020929593955484860152019101929061060e565b92949550505060ff19168252151560200201905f80806105f8565b9061065e916105c8565b90565b634e487b7160e01b5f52604160045260245ffd5b9061067f90610218565b810190811067ffffffffffffffff82111761069957604052565b610661565b906106be6106b7926106ae610112565b93848092610654565b0383610675565b565b905f106106d3576106d09061069e565b90565b610565565b6106e460025f906106c0565b90565b6106fc9160208201915f818403910152610222565b90565b3461072f5761070f3660046101cd565b61072b61071a6106d8565b610722610112565b918291826106e7565b0390f35b610118565b90916060828403126107695761076661074f845f850161034c565b9361075d8160208601610372565b9360400161034c565b90565b61011c565b3461079d57610787610781366004610734565b916111ee565b61078f610112565b806107998161041e565b0390f35b610118565b906020828203126107bb576107b8915f0161034c565b90565b61011c565b346107ee576107d86107d33660046107a2565b6112f1565b6107e0610112565b806107ea8161041e565b0390f35b610118565b90602082820312610824575f82013567ffffffffffffffff811161081f5761081b920161038d565b9091565b610120565b61011c565b346108585761084261083c3660046107f3565b9061159e565b61084a610112565b806108548161041e565b0390f35b610118565b3461088e5761088a6108796108733660046104d0565b906115e7565b610881610112565b91829182610183565b0390f35b610118565b90565b5f1b90565b6108af6108aa6108b492610893565b610896565b6102de565b90565b6108c05f61089b565b90565b6108cb6108b7565b90565b346108fe576108de3660046101cd565b6108fa6108e96108c3565b6108f1610112565b918291826102ee565b0390f35b610118565b1c90565b60018060a01b031690565b6109229060086109279302610903565b610907565b90565b906109359154610912565b90565b61094460015f9061092a565b90565b919061095a905f602085019401906101f3565b565b3461098c5761096c3660046101cd565b610988610977610938565b61097f610112565b91829182610947565b0390f35b610118565b346109c0576109aa6109a43660046104d0565b9061163a565b6109b2610112565b806109bc8161041e565b0390f35b610118565b5f80fd5b5f90565b6109d56109c9565b50806109f06109ea637965db0b60e01b610124565b91610124565b149081156109fd575b5090565b610a079150611646565b5f6109f9565b5f90565b606090565b5f1c90565b610a27610a2c91610a16565b610907565b90565b610a399054610a1b565b90565b610a459061069e565b90565b610a50610a0d565b50610a59610a11565b50610a646001610a2f565b90610a6f6002610a3c565b90565b90565b610a89610a84610a8e92610893565b610a72565b6101dc565b90565b610a9a90610a75565b90565b610ab1610aac610ab692610893565b610a72565b61035b565b90565b610acd610ac8610ad2926101dc565b610a72565b6101dc565b90565b610ade90610ab9565b90565b610aea90610ad5565b90565b610af690610ab9565b90565b610b0290610aed565b90565b610b0e90610aed565b90565b60e01b90565b610b2081610171565b03610b2757565b5f80fd5b90505190610b3882610b17565b565b90602082820312610b5357610b50915f01610b2b565b90565b61011c565b610b619061035b565b9052565b604090610b8e610b959496959396610b8460608401985f8501906101f3565b60208301906101f3565b0190610b58565b565b610b9f610112565b3d5f823e3d90fd5b916020610bc8929493610bc160408201965f8301906101f3565b0190610b58565b565b610bd4905461058c565b90565b610be090610b11565b90565b610bef610bf49161010c565b610bd7565b90565b610c019054610be3565b90565b1b90565b610c25610c1482610bca565b9180601f8411610c52575b50610bf7565b9060048110610c33575b5090565b610c4b9063ffffffff60e01b90600403600802610c04565b165f610c2f565b610c5c91506105bf565b5f610c1f565b90825f939282370152565b9190610c8781610c8081610c8c95610204565b8095610c62565b610218565b0190565b610cb6610cc39593949294610cac60608401965f8501906101f3565b6020830190610b58565b6040818503910152610c6d565b90565b90610cd9610cd2610112565b9283610675565b565b67ffffffffffffffff8111610cf957610cf5602091610218565b0190565b610661565b90610d10610d0b83610cdb565b610cc6565b918252565b3d5f14610d3057610d253d610cfe565b903d5f602084013e5b565b610d38610a11565b90610d2e565b610d4790610aed565b90565b916020610d6b929493610d6460408201965f830190610b58565b0190610176565b565b919282610d8a610d84610d7f5f610a91565b6101e7565b916101e7565b1461100b5781610da2610d9c5f610a9d565b9161035b565b14610fef57610db16001610a2f565b610dcb610dc5610dc05f610a91565b6101e7565b916101e7565b14610fd357610de1610ddc84610ae1565b610af9565b60206323b872dd913390610e115f610df830610b05565b95610e1c89610e05610112565b98899788968795610b11565b855260048501610b65565b03925af18015610fce57610fa2575b50610e3d610e3884610ae1565b610af9565b93602063095ea7b395610e506001610a2f565b90610e6e5f8799610e79610e62610112565b9b8c9687958694610b11565b845260048401610ba7565b03925af1908115610f9d57610ed35f93610ec4600493610f4f998796610f71575b50610ea56002610c08565b92899189909192610eb4610112565b9788966020880190815201610c90565b60208201810382520382610675565b610edd6001610a2f565b9082602082019151925af1610ef0610d15565b5091610efc6001610a2f565b9083610f31610f2b7f8e7f1561e09be9c40c53b4c5dd162d6db5b665ddb6f8bcfdf8f9e1a8e75fa67193610d3e565b93610d3e565b93610f46610f3d610112565b92839283610d4a565b0390a315610171565b610f5557565b5f631bb7daad60e11b815280610f6d6004820161041e565b0390fd5b610f919060203d8111610f96575b610f898183610675565b810190610b3a565b610e9a565b503d610f7f565b610b97565b610fc29060203d8111610fc7575b610fba8183610675565b810190610b3a565b610e2b565b503d610fb0565b610b97565b5f63d92e233d60e01b815280610feb6004820161041e565b0390fd5b5f631f2a200560e01b8152806110076004820161041e565b0390fd5b5f63d92e233d60e01b8152806110236004820161041e565b0390fd5b5f90565b611034906102de565b90565b906110419061102b565b5f5260205260405f2090565b90565b61105c61106191610a16565b61104d565b90565b61106e9054611050565b90565b600161108961108f92611082611027565b505f611037565b01611064565b90565b906110ad916110a86110a382611071565b61166c565b6110af565b565b906110b9916116c5565b50565b906110c691611092565b565b90806110e36110dd6110d8611770565b6101e7565b916101e7565b036110f4576110f19161177d565b50565b5f63334bd91960e11b81528061110c6004820161041e565b0390fd5b9061112b92916111266111216108b7565b61166c565b61112d565b565b908261114961114361113e5f610a91565b6101e7565b916101e7565b146111d25761116161115c602093610ae1565b610af9565b6111845f63a9059cbb95939561118f611178610112565b97889687958694610b11565b845260048401610ba7565b03925af180156111cd576111a1575b50565b6111c19060203d81116111c6575b6111b98183610675565b810190610b3a565b61119e565b503d6111af565b610b97565b5f63d92e233d60e01b8152806111ea6004820161041e565b0390fd5b906111f99291611110565b565b6112149061120f61120a6102af565b61166c565b611254565b565b9061122760018060a01b0391610896565b9181191691161790565b90565b9061124961124461125092610d3e565b611231565b8254611216565b9055565b8061126f6112696112645f610a91565b6101e7565b916101e7565b146112d55761127e6001610a2f565b611289826001611234565b906112bd6112b77fb07f8b1b85042d74022c867c836edeb0bcd70e135b0042390d2b1fd10829806993610d3e565b91610d3e565b916112c6610112565b806112d08161041e565b0390a3565b5f63d92e233d60e01b8152806112ed6004820161041e565b0390fd5b6112fa906111fb565b565b906113169161131161130c6102af565b61166c565b611548565b565b5090565b601f602091010490565b9190600861134191029161133b5f1984610c04565b92610c04565b9181191691161790565b61135f61135a6113649261035b565b610a72565b61035b565b90565b90565b919061138061137b6113889361134b565b611367565b908354611326565b9055565b5f90565b6113a29161139c61138c565b9161136a565b565b5b8181106113b0575050565b806113bd5f600193611390565b016113a5565b9190601f81116113d3575b505050565b6113df611404936105bf565b9060206113eb8461131c565b8301931061140c575b6113fd9061131c565b01906113a4565b5f80806113ce565b91506113fd819290506113f4565b9061142a905f1990600802610903565b191690565b816114399161141a565b906002021790565b9161144c9082611318565b9067ffffffffffffffff821161150b576114708261146a855461058c565b856113c3565b5f90601f83116001146114a357918091611492935f92611497575b505061142f565b90555b565b90915001355f8061148b565b601f198316916114b2856105bf565b925f5b8181106114f3575091600293918560019694106114d9575b50505002019055611495565b6114e9910135601f84169061141a565b90555f80806114cd565b919360206001819287870135815501950192016114b5565b610661565b9061151b9291611441565b565b91611537611545949260408501908582035f870152610222565b926020818503910152610c6d565b90565b906115536002610a3c565b6115608383906002611510565b9190916115997ff0dca53f6423fafdd825c9ca79bc76f4356686872f74a062e09d6d7e2f832c5a93611590610112565b9384938461151d565b0390a1565b906115a8916112fc565b565b906115b490610d3e565b5f5260205260405f2090565b60ff1690565b6115d26115d791610a16565b6115c0565b90565b6115e490546115c6565b90565b61160d915f611602611608936115fb6109c9565b5082611037565b016115aa565b6115da565b90565b9061162b9161162661162182611071565b61166c565b61162d565b565b906116379161177d565b50565b9061164491611610565b565b61164e6109c9565b506116686116626301ffc9a760e01b610124565b91610124565b1490565b61167e90611678611770565b90611841565b565b9061168c60ff91610896565b9181191691161790565b61169f90610171565b90565b90565b906116ba6116b56116c192611696565b6116a2565b8254611680565b9055565b6116cd6109c9565b506116e26116dc8284906115e7565b15610171565b5f1461176a5761170960016117045f6116fc818690611037565b0185906115aa565b6116a5565b90611712611770565b9061174f6117496117437f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d9561102b565b92610d3e565b92610d3e565b92611758610112565b806117628161041e565b0390a4600190565b50505f90565b611778610a0d565b503390565b6117856109c9565b506117918183906115e7565b5f14611818576117b75f6117b25f6117aa818690611037565b0185906115aa565b6116a5565b906117c0611770565b906117fd6117f76117f17ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9561102b565b92610d3e565b92610d3e565b92611806610112565b806118108161041e565b0390a4600190565b50505f90565b91602061183f92949361183860408201965f8301906101f3565b01906102e1565b565b906118566118508383906115e7565b15610171565b61185e575050565b6118785f92839263e2517d3f60e01b84526004840161181e565b0390fd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x13W[a\t\xC5V[a\0\x1D_5a\x01\x0CV[\x80c\x01\xFF\xC9\xA7\x14a\x01\x07W\x80c\x07\xA1\xD5\xFA\x14a\x01\x02W\x80c\x11\x8C8\xC7\x14a\0\xFDW\x80c\x18\xB6\x8B\x8C\x14a\0\xF8W\x80c$\x8A\x9C\xA3\x14a\0\xF3W\x80c//\xF1]\x14a\0\xEEW\x80c6V\x8A\xBE\x14a\0\xE9W\x80c]~\xBA;\x14a\0\xE4W\x80ca\xB0\xA5n\x14a\0\xDFW\x80ck\xCC\x8C\x14\x14a\0\xDAW\x80c\x80*\x1D7\x14a\0\xD5W\x80c\x91\xD1HT\x14a\0\xD0W\x80c\xA2\x17\xFD\xDF\x14a\0\xCBW\x80c\xC9\xF5\xB6>\x14a\0\xC6Wc\xD5Gt\x1F\x03a\0\x0EWa\t\x91V[a\t\\V[a\x08\xCEV[a\x08]V[a\x08)V[a\x07\xC0V[a\x07nV[a\x06\xFFV[a\x051V[a\x04\xFDV[a\x04\x9BV[a\x04#V[a\x03\x03V[a\x02yV[a\x01\x98V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x019\x81a\x01$V[\x03a\x01@WV[_\x80\xFD[\x90P5\x90a\x01Q\x82a\x010V[V[\x90` \x82\x82\x03\x12a\x01lWa\x01i\x91_\x01a\x01DV[\x90V[a\x01\x1CV[\x15\x15\x90V[a\x01\x7F\x90a\x01qV[\x90RV[\x91\x90a\x01\x96\x90_` \x85\x01\x94\x01\x90a\x01vV[V[4a\x01\xC8Wa\x01\xC4a\x01\xB3a\x01\xAE6`\x04a\x01SV[a\t\xCDV[a\x01\xBBa\x01\x12V[\x91\x82\x91\x82a\x01\x83V[\x03\x90\xF3[a\x01\x18V[_\x91\x03\x12a\x01\xD7WV[a\x01\x1CV[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x01\xF0\x90a\x01\xDCV[\x90V[a\x01\xFC\x90a\x01\xE7V[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x02Aa\x02J` \x93a\x02O\x93a\x028\x81a\x02\0V[\x93\x84\x80\x93a\x02\x04V[\x95\x86\x91\x01a\x02\rV[a\x02\x18V[\x01\x90V[\x91a\x02v\x92a\x02i`@\x82\x01\x93_\x83\x01\x90a\x01\xF3V[` \x81\x84\x03\x91\x01Ra\x02\"V[\x90V[4a\x02\xAAWa\x02\x896`\x04a\x01\xCDV[a\x02\x91a\nHV[\x90a\x02\xA6a\x02\x9Da\x01\x12V[\x92\x83\x92\x83a\x02SV[\x03\x90\xF3[a\x01\x18V[\x7Fu\x1By]$\xB9.=\x92\xD1\xD0\xD8\xF2\x88_N\x9C\x9C&\x9D\xA3P\xAF6\xAEkI\x06\x9B\xAB\xF4\xBF\x90V[a\x02\xDBa\x02\xAFV[\x90V[\x90V[a\x02\xEA\x90a\x02\xDEV[\x90RV[\x91\x90a\x03\x01\x90_` \x85\x01\x94\x01\x90a\x02\xE1V[V[4a\x033Wa\x03\x136`\x04a\x01\xCDV[a\x03/a\x03\x1Ea\x02\xD3V[a\x03&a\x01\x12V[\x91\x82\x91\x82a\x02\xEEV[\x03\x90\xF3[a\x01\x18V[a\x03A\x81a\x01\xE7V[\x03a\x03HWV[_\x80\xFD[\x90P5\x90a\x03Y\x82a\x038V[V[\x90V[a\x03g\x81a\x03[V[\x03a\x03nWV[_\x80\xFD[\x90P5\x90a\x03\x7F\x82a\x03^V[V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x03\xC7W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x03\xC2W` \x01\x92`\x01\x83\x02\x84\x01\x11a\x03\xBDWV[a\x03\x89V[a\x03\x85V[a\x03\x81V[\x91``\x83\x83\x03\x12a\x04\x19Wa\x03\xE3\x82_\x85\x01a\x03LV[\x92a\x03\xF1\x83` \x83\x01a\x03rV[\x92`@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x14Wa\x04\x10\x92\x01a\x03\x8DV[\x90\x91V[a\x01 V[a\x01\x1CV[_\x01\x90V[4a\x04UWa\x04?a\x0466`\x04a\x03\xCCV[\x92\x91\x90\x91a\rmV[a\x04Ga\x01\x12V[\x80a\x04Q\x81a\x04\x1EV[\x03\x90\xF3[a\x01\x18V[a\x04c\x81a\x02\xDEV[\x03a\x04jWV[_\x80\xFD[\x90P5\x90a\x04{\x82a\x04ZV[V[\x90` \x82\x82\x03\x12a\x04\x96Wa\x04\x93\x91_\x01a\x04nV[\x90V[a\x01\x1CV[4a\x04\xCBWa\x04\xC7a\x04\xB6a\x04\xB16`\x04a\x04}V[a\x10qV[a\x04\xBEa\x01\x12V[\x91\x82\x91\x82a\x02\xEEV[\x03\x90\xF3[a\x01\x18V[\x91\x90`@\x83\x82\x03\x12a\x04\xF8W\x80a\x04\xECa\x04\xF5\x92_\x86\x01a\x04nV[\x93` \x01a\x03LV[\x90V[a\x01\x1CV[4a\x05,Wa\x05\x16a\x05\x106`\x04a\x04\xD0V[\x90a\x10\xBCV[a\x05\x1Ea\x01\x12V[\x80a\x05(\x81a\x04\x1EV[\x03\x90\xF3[a\x01\x18V[4a\x05`Wa\x05Ja\x05D6`\x04a\x04\xD0V[\x90a\x10\xC8V[a\x05Ra\x01\x12V[\x80a\x05\\\x81a\x04\x1EV[\x03\x90\xF3[a\x01\x18V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x05\xACW[` \x83\x10\x14a\x05\xA7WV[a\x05xV[\x91`\x7F\x16\x91a\x05\x9CV[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x05\xE2a\x05\xDB\x83a\x05\x8CV[\x80\x94a\x05\xB6V[\x91`\x01\x81\x16\x90\x81_\x14a\x069WP`\x01\x14a\x05\xFDW[PPPV[a\x06\n\x91\x92\x93\x94Pa\x05\xBFV[\x91_\x92[\x81\x84\x10a\x06!WPP\x01\x90_\x80\x80a\x05\xF8V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x06\x0EV[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x05\xF8V[\x90a\x06^\x91a\x05\xC8V[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x06\x7F\x90a\x02\x18V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x06\x99W`@RV[a\x06aV[\x90a\x06\xBEa\x06\xB7\x92a\x06\xAEa\x01\x12V[\x93\x84\x80\x92a\x06TV[\x03\x83a\x06uV[V[\x90_\x10a\x06\xD3Wa\x06\xD0\x90a\x06\x9EV[\x90V[a\x05eV[a\x06\xE4`\x02_\x90a\x06\xC0V[\x90V[a\x06\xFC\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x02\"V[\x90V[4a\x07/Wa\x07\x0F6`\x04a\x01\xCDV[a\x07+a\x07\x1Aa\x06\xD8V[a\x07\"a\x01\x12V[\x91\x82\x91\x82a\x06\xE7V[\x03\x90\xF3[a\x01\x18V[\x90\x91``\x82\x84\x03\x12a\x07iWa\x07fa\x07O\x84_\x85\x01a\x03LV[\x93a\x07]\x81` \x86\x01a\x03rV[\x93`@\x01a\x03LV[\x90V[a\x01\x1CV[4a\x07\x9DWa\x07\x87a\x07\x816`\x04a\x074V[\x91a\x11\xEEV[a\x07\x8Fa\x01\x12V[\x80a\x07\x99\x81a\x04\x1EV[\x03\x90\xF3[a\x01\x18V[\x90` \x82\x82\x03\x12a\x07\xBBWa\x07\xB8\x91_\x01a\x03LV[\x90V[a\x01\x1CV[4a\x07\xEEWa\x07\xD8a\x07\xD36`\x04a\x07\xA2V[a\x12\xF1V[a\x07\xE0a\x01\x12V[\x80a\x07\xEA\x81a\x04\x1EV[\x03\x90\xF3[a\x01\x18V[\x90` \x82\x82\x03\x12a\x08$W_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x08\x1FWa\x08\x1B\x92\x01a\x03\x8DV[\x90\x91V[a\x01 V[a\x01\x1CV[4a\x08XWa\x08Ba\x08<6`\x04a\x07\xF3V[\x90a\x15\x9EV[a\x08Ja\x01\x12V[\x80a\x08T\x81a\x04\x1EV[\x03\x90\xF3[a\x01\x18V[4a\x08\x8EWa\x08\x8Aa\x08ya\x08s6`\x04a\x04\xD0V[\x90a\x15\xE7V[a\x08\x81a\x01\x12V[\x91\x82\x91\x82a\x01\x83V[\x03\x90\xF3[a\x01\x18V[\x90V[_\x1B\x90V[a\x08\xAFa\x08\xAAa\x08\xB4\x92a\x08\x93V[a\x08\x96V[a\x02\xDEV[\x90V[a\x08\xC0_a\x08\x9BV[\x90V[a\x08\xCBa\x08\xB7V[\x90V[4a\x08\xFEWa\x08\xDE6`\x04a\x01\xCDV[a\x08\xFAa\x08\xE9a\x08\xC3V[a\x08\xF1a\x01\x12V[\x91\x82\x91\x82a\x02\xEEV[\x03\x90\xF3[a\x01\x18V[\x1C\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\t\"\x90`\x08a\t'\x93\x02a\t\x03V[a\t\x07V[\x90V[\x90a\t5\x91Ta\t\x12V[\x90V[a\tD`\x01_\x90a\t*V[\x90V[\x91\x90a\tZ\x90_` \x85\x01\x94\x01\x90a\x01\xF3V[V[4a\t\x8CWa\tl6`\x04a\x01\xCDV[a\t\x88a\twa\t8V[a\t\x7Fa\x01\x12V[\x91\x82\x91\x82a\tGV[\x03\x90\xF3[a\x01\x18V[4a\t\xC0Wa\t\xAAa\t\xA46`\x04a\x04\xD0V[\x90a\x16:V[a\t\xB2a\x01\x12V[\x80a\t\xBC\x81a\x04\x1EV[\x03\x90\xF3[a\x01\x18V[_\x80\xFD[_\x90V[a\t\xD5a\t\xC9V[P\x80a\t\xF0a\t\xEAcye\xDB\x0B`\xE0\x1Ba\x01$V[\x91a\x01$V[\x14\x90\x81\x15a\t\xFDW[P\x90V[a\n\x07\x91Pa\x16FV[_a\t\xF9V[_\x90V[``\x90V[_\x1C\x90V[a\n'a\n,\x91a\n\x16V[a\t\x07V[\x90V[a\n9\x90Ta\n\x1BV[\x90V[a\nE\x90a\x06\x9EV[\x90V[a\nPa\n\rV[Pa\nYa\n\x11V[Pa\nd`\x01a\n/V[\x90a\no`\x02a\n<V[\x90V[\x90V[a\n\x89a\n\x84a\n\x8E\x92a\x08\x93V[a\nrV[a\x01\xDCV[\x90V[a\n\x9A\x90a\nuV[\x90V[a\n\xB1a\n\xACa\n\xB6\x92a\x08\x93V[a\nrV[a\x03[V[\x90V[a\n\xCDa\n\xC8a\n\xD2\x92a\x01\xDCV[a\nrV[a\x01\xDCV[\x90V[a\n\xDE\x90a\n\xB9V[\x90V[a\n\xEA\x90a\n\xD5V[\x90V[a\n\xF6\x90a\n\xB9V[\x90V[a\x0B\x02\x90a\n\xEDV[\x90V[a\x0B\x0E\x90a\n\xEDV[\x90V[`\xE0\x1B\x90V[a\x0B \x81a\x01qV[\x03a\x0B'WV[_\x80\xFD[\x90PQ\x90a\x0B8\x82a\x0B\x17V[V[\x90` \x82\x82\x03\x12a\x0BSWa\x0BP\x91_\x01a\x0B+V[\x90V[a\x01\x1CV[a\x0Ba\x90a\x03[V[\x90RV[`@\x90a\x0B\x8Ea\x0B\x95\x94\x96\x95\x93\x96a\x0B\x84``\x84\x01\x98_\x85\x01\x90a\x01\xF3V[` \x83\x01\x90a\x01\xF3V[\x01\x90a\x0BXV[V[a\x0B\x9Fa\x01\x12V[=_\x82>=\x90\xFD[\x91` a\x0B\xC8\x92\x94\x93a\x0B\xC1`@\x82\x01\x96_\x83\x01\x90a\x01\xF3V[\x01\x90a\x0BXV[V[a\x0B\xD4\x90Ta\x05\x8CV[\x90V[a\x0B\xE0\x90a\x0B\x11V[\x90V[a\x0B\xEFa\x0B\xF4\x91a\x01\x0CV[a\x0B\xD7V[\x90V[a\x0C\x01\x90Ta\x0B\xE3V[\x90V[\x1B\x90V[a\x0C%a\x0C\x14\x82a\x0B\xCAV[\x91\x80`\x1F\x84\x11a\x0CRW[Pa\x0B\xF7V[\x90`\x04\x81\x10a\x0C3W[P\x90V[a\x0CK\x90c\xFF\xFF\xFF\xFF`\xE0\x1B\x90`\x04\x03`\x08\x02a\x0C\x04V[\x16_a\x0C/V[a\x0C\\\x91Pa\x05\xBFV[_a\x0C\x1FV[\x90\x82_\x93\x92\x827\x01RV[\x91\x90a\x0C\x87\x81a\x0C\x80\x81a\x0C\x8C\x95a\x02\x04V[\x80\x95a\x0CbV[a\x02\x18V[\x01\x90V[a\x0C\xB6a\x0C\xC3\x95\x93\x94\x92\x94a\x0C\xAC``\x84\x01\x96_\x85\x01\x90a\x01\xF3V[` \x83\x01\x90a\x0BXV[`@\x81\x85\x03\x91\x01Ra\x0CmV[\x90V[\x90a\x0C\xD9a\x0C\xD2a\x01\x12V[\x92\x83a\x06uV[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x0C\xF9Wa\x0C\xF5` \x91a\x02\x18V[\x01\x90V[a\x06aV[\x90a\r\x10a\r\x0B\x83a\x0C\xDBV[a\x0C\xC6V[\x91\x82RV[=_\x14a\r0Wa\r%=a\x0C\xFEV[\x90=_` \x84\x01>[V[a\r8a\n\x11V[\x90a\r.V[a\rG\x90a\n\xEDV[\x90V[\x91` a\rk\x92\x94\x93a\rd`@\x82\x01\x96_\x83\x01\x90a\x0BXV[\x01\x90a\x01vV[V[\x91\x92\x82a\r\x8Aa\r\x84a\r\x7F_a\n\x91V[a\x01\xE7V[\x91a\x01\xE7V[\x14a\x10\x0BW\x81a\r\xA2a\r\x9C_a\n\x9DV[\x91a\x03[V[\x14a\x0F\xEFWa\r\xB1`\x01a\n/V[a\r\xCBa\r\xC5a\r\xC0_a\n\x91V[a\x01\xE7V[\x91a\x01\xE7V[\x14a\x0F\xD3Wa\r\xE1a\r\xDC\x84a\n\xE1V[a\n\xF9V[` c#\xB8r\xDD\x913\x90a\x0E\x11_a\r\xF80a\x0B\x05V[\x95a\x0E\x1C\x89a\x0E\x05a\x01\x12V[\x98\x89\x97\x88\x96\x87\x95a\x0B\x11V[\x85R`\x04\x85\x01a\x0BeV[\x03\x92Z\xF1\x80\x15a\x0F\xCEWa\x0F\xA2W[Pa\x0E=a\x0E8\x84a\n\xE1V[a\n\xF9V[\x93` c\t^\xA7\xB3\x95a\x0EP`\x01a\n/V[\x90a\x0En_\x87\x99a\x0Eya\x0Eba\x01\x12V[\x9B\x8C\x96\x87\x95\x86\x94a\x0B\x11V[\x84R`\x04\x84\x01a\x0B\xA7V[\x03\x92Z\xF1\x90\x81\x15a\x0F\x9DWa\x0E\xD3_\x93a\x0E\xC4`\x04\x93a\x0FO\x99\x87\x96a\x0FqW[Pa\x0E\xA5`\x02a\x0C\x08V[\x92\x89\x91\x89\x90\x91\x92a\x0E\xB4a\x01\x12V[\x97\x88\x96` \x88\x01\x90\x81R\x01a\x0C\x90V[` \x82\x01\x81\x03\x82R\x03\x82a\x06uV[a\x0E\xDD`\x01a\n/V[\x90\x82` \x82\x01\x91Q\x92Z\xF1a\x0E\xF0a\r\x15V[P\x91a\x0E\xFC`\x01a\n/V[\x90\x83a\x0F1a\x0F+\x7F\x8E\x7F\x15a\xE0\x9B\xE9\xC4\x0CS\xB4\xC5\xDD\x16-m\xB5\xB6e\xDD\xB6\xF8\xBC\xFD\xF8\xF9\xE1\xA8\xE7_\xA6q\x93a\r>V[\x93a\r>V[\x93a\x0FFa\x0F=a\x01\x12V[\x92\x83\x92\x83a\rJV[\x03\x90\xA3\x15a\x01qV[a\x0FUWV[_c\x1B\xB7\xDA\xAD`\xE1\x1B\x81R\x80a\x0Fm`\x04\x82\x01a\x04\x1EV[\x03\x90\xFD[a\x0F\x91\x90` =\x81\x11a\x0F\x96W[a\x0F\x89\x81\x83a\x06uV[\x81\x01\x90a\x0B:V[a\x0E\x9AV[P=a\x0F\x7FV[a\x0B\x97V[a\x0F\xC2\x90` =\x81\x11a\x0F\xC7W[a\x0F\xBA\x81\x83a\x06uV[\x81\x01\x90a\x0B:V[a\x0E+V[P=a\x0F\xB0V[a\x0B\x97V[_c\xD9.#=`\xE0\x1B\x81R\x80a\x0F\xEB`\x04\x82\x01a\x04\x1EV[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a\x10\x07`\x04\x82\x01a\x04\x1EV[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x10#`\x04\x82\x01a\x04\x1EV[\x03\x90\xFD[_\x90V[a\x104\x90a\x02\xDEV[\x90V[\x90a\x10A\x90a\x10+V[_R` R`@_ \x90V[\x90V[a\x10\\a\x10a\x91a\n\x16V[a\x10MV[\x90V[a\x10n\x90Ta\x10PV[\x90V[`\x01a\x10\x89a\x10\x8F\x92a\x10\x82a\x10'V[P_a\x107V[\x01a\x10dV[\x90V[\x90a\x10\xAD\x91a\x10\xA8a\x10\xA3\x82a\x10qV[a\x16lV[a\x10\xAFV[V[\x90a\x10\xB9\x91a\x16\xC5V[PV[\x90a\x10\xC6\x91a\x10\x92V[V[\x90\x80a\x10\xE3a\x10\xDDa\x10\xD8a\x17pV[a\x01\xE7V[\x91a\x01\xE7V[\x03a\x10\xF4Wa\x10\xF1\x91a\x17}V[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a\x11\x0C`\x04\x82\x01a\x04\x1EV[\x03\x90\xFD[\x90a\x11+\x92\x91a\x11&a\x11!a\x08\xB7V[a\x16lV[a\x11-V[V[\x90\x82a\x11Ia\x11Ca\x11>_a\n\x91V[a\x01\xE7V[\x91a\x01\xE7V[\x14a\x11\xD2Wa\x11aa\x11\\` \x93a\n\xE1V[a\n\xF9V[a\x11\x84_c\xA9\x05\x9C\xBB\x95\x93\x95a\x11\x8Fa\x11xa\x01\x12V[\x97\x88\x96\x87\x95\x86\x94a\x0B\x11V[\x84R`\x04\x84\x01a\x0B\xA7V[\x03\x92Z\xF1\x80\x15a\x11\xCDWa\x11\xA1W[PV[a\x11\xC1\x90` =\x81\x11a\x11\xC6W[a\x11\xB9\x81\x83a\x06uV[\x81\x01\x90a\x0B:V[a\x11\x9EV[P=a\x11\xAFV[a\x0B\x97V[_c\xD9.#=`\xE0\x1B\x81R\x80a\x11\xEA`\x04\x82\x01a\x04\x1EV[\x03\x90\xFD[\x90a\x11\xF9\x92\x91a\x11\x10V[V[a\x12\x14\x90a\x12\x0Fa\x12\na\x02\xAFV[a\x16lV[a\x12TV[V[\x90a\x12'`\x01\x80`\xA0\x1B\x03\x91a\x08\x96V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x90a\x12Ia\x12Da\x12P\x92a\r>V[a\x121V[\x82Ta\x12\x16V[\x90UV[\x80a\x12oa\x12ia\x12d_a\n\x91V[a\x01\xE7V[\x91a\x01\xE7V[\x14a\x12\xD5Wa\x12~`\x01a\n/V[a\x12\x89\x82`\x01a\x124V[\x90a\x12\xBDa\x12\xB7\x7F\xB0\x7F\x8B\x1B\x85\x04-t\x02,\x86|\x83n\xDE\xB0\xBC\xD7\x0E\x13[\0B9\r+\x1F\xD1\x08)\x80i\x93a\r>V[\x91a\r>V[\x91a\x12\xC6a\x01\x12V[\x80a\x12\xD0\x81a\x04\x1EV[\x03\x90\xA3V[_c\xD9.#=`\xE0\x1B\x81R\x80a\x12\xED`\x04\x82\x01a\x04\x1EV[\x03\x90\xFD[a\x12\xFA\x90a\x11\xFBV[V[\x90a\x13\x16\x91a\x13\x11a\x13\x0Ca\x02\xAFV[a\x16lV[a\x15HV[V[P\x90V[`\x1F` \x91\x01\x04\x90V[\x91\x90`\x08a\x13A\x91\x02\x91a\x13;_\x19\x84a\x0C\x04V[\x92a\x0C\x04V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x13_a\x13Za\x13d\x92a\x03[V[a\nrV[a\x03[V[\x90V[\x90V[\x91\x90a\x13\x80a\x13{a\x13\x88\x93a\x13KV[a\x13gV[\x90\x83Ta\x13&V[\x90UV[_\x90V[a\x13\xA2\x91a\x13\x9Ca\x13\x8CV[\x91a\x13jV[V[[\x81\x81\x10a\x13\xB0WPPV[\x80a\x13\xBD_`\x01\x93a\x13\x90V[\x01a\x13\xA5V[\x91\x90`\x1F\x81\x11a\x13\xD3W[PPPV[a\x13\xDFa\x14\x04\x93a\x05\xBFV[\x90` a\x13\xEB\x84a\x13\x1CV[\x83\x01\x93\x10a\x14\x0CW[a\x13\xFD\x90a\x13\x1CV[\x01\x90a\x13\xA4V[_\x80\x80a\x13\xCEV[\x91Pa\x13\xFD\x81\x92\x90Pa\x13\xF4V[\x90a\x14*\x90_\x19\x90`\x08\x02a\t\x03V[\x19\x16\x90V[\x81a\x149\x91a\x14\x1AV[\x90`\x02\x02\x17\x90V[\x91a\x14L\x90\x82a\x13\x18V[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x15\x0BWa\x14p\x82a\x14j\x85Ta\x05\x8CV[\x85a\x13\xC3V[_\x90`\x1F\x83\x11`\x01\x14a\x14\xA3W\x91\x80\x91a\x14\x92\x93_\x92a\x14\x97W[PPa\x14/V[\x90U[V[\x90\x91P\x015_\x80a\x14\x8BV[`\x1F\x19\x83\x16\x91a\x14\xB2\x85a\x05\xBFV[\x92_[\x81\x81\x10a\x14\xF3WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x14\xD9W[PPP\x02\x01\x90Ua\x14\x95V[a\x14\xE9\x91\x015`\x1F\x84\x16\x90a\x14\x1AV[\x90U_\x80\x80a\x14\xCDV[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a\x14\xB5V[a\x06aV[\x90a\x15\x1B\x92\x91a\x14AV[V[\x91a\x157a\x15E\x94\x92`@\x85\x01\x90\x85\x82\x03_\x87\x01Ra\x02\"V[\x92` \x81\x85\x03\x91\x01Ra\x0CmV[\x90V[\x90a\x15S`\x02a\n<V[a\x15`\x83\x83\x90`\x02a\x15\x10V[\x91\x90\x91a\x15\x99\x7F\xF0\xDC\xA5?d#\xFA\xFD\xD8%\xC9\xCAy\xBCv\xF45f\x86\x87/t\xA0b\xE0\x9Dm~/\x83,Z\x93a\x15\x90a\x01\x12V[\x93\x84\x93\x84a\x15\x1DV[\x03\x90\xA1V[\x90a\x15\xA8\x91a\x12\xFCV[V[\x90a\x15\xB4\x90a\r>V[_R` R`@_ \x90V[`\xFF\x16\x90V[a\x15\xD2a\x15\xD7\x91a\n\x16V[a\x15\xC0V[\x90V[a\x15\xE4\x90Ta\x15\xC6V[\x90V[a\x16\r\x91_a\x16\x02a\x16\x08\x93a\x15\xFBa\t\xC9V[P\x82a\x107V[\x01a\x15\xAAV[a\x15\xDAV[\x90V[\x90a\x16+\x91a\x16&a\x16!\x82a\x10qV[a\x16lV[a\x16-V[V[\x90a\x167\x91a\x17}V[PV[\x90a\x16D\x91a\x16\x10V[V[a\x16Na\t\xC9V[Pa\x16ha\x16bc\x01\xFF\xC9\xA7`\xE0\x1Ba\x01$V[\x91a\x01$V[\x14\x90V[a\x16~\x90a\x16xa\x17pV[\x90a\x18AV[V[\x90a\x16\x8C`\xFF\x91a\x08\x96V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x16\x9F\x90a\x01qV[\x90V[\x90V[\x90a\x16\xBAa\x16\xB5a\x16\xC1\x92a\x16\x96V[a\x16\xA2V[\x82Ta\x16\x80V[\x90UV[a\x16\xCDa\t\xC9V[Pa\x16\xE2a\x16\xDC\x82\x84\x90a\x15\xE7V[\x15a\x01qV[_\x14a\x17jWa\x17\t`\x01a\x17\x04_a\x16\xFC\x81\x86\x90a\x107V[\x01\x85\x90a\x15\xAAV[a\x16\xA5V[\x90a\x17\x12a\x17pV[\x90a\x17Oa\x17Ia\x17C\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\x10+V[\x92a\r>V[\x92a\r>V[\x92a\x17Xa\x01\x12V[\x80a\x17b\x81a\x04\x1EV[\x03\x90\xA4`\x01\x90V[PP_\x90V[a\x17xa\n\rV[P3\x90V[a\x17\x85a\t\xC9V[Pa\x17\x91\x81\x83\x90a\x15\xE7V[_\x14a\x18\x18Wa\x17\xB7_a\x17\xB2_a\x17\xAA\x81\x86\x90a\x107V[\x01\x85\x90a\x15\xAAV[a\x16\xA5V[\x90a\x17\xC0a\x17pV[\x90a\x17\xFDa\x17\xF7a\x17\xF1\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a\x10+V[\x92a\r>V[\x92a\r>V[\x92a\x18\x06a\x01\x12V[\x80a\x18\x10\x81a\x04\x1EV[\x03\x90\xA4`\x01\x90V[PP_\x90V[\x91` a\x18?\x92\x94\x93a\x188`@\x82\x01\x96_\x83\x01\x90a\x01\xF3V[\x01\x90a\x02\xE1V[V[\x90a\x18Va\x18P\x83\x83\x90a\x15\xE7V[\x15a\x01qV[a\x18^WPPV[a\x18x_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01a\x18\x1EV[\x03\x90\xFD",
    );
    /**Custom error with signature `AccessControlBadConfirmation()` and selector `0x6697b232`.
```solidity
error AccessControlBadConfirmation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlBadConfirmation {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlBadConfirmation>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlBadConfirmation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlBadConfirmation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlBadConfirmation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlBadConfirmation()";
            const SELECTOR: [u8; 4] = [102u8, 151u8, 178u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `AccessControlUnauthorizedAccount(address,bytes32)` and selector `0xe2517d3f`.
```solidity
error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub neededRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlUnauthorizedAccount) -> Self {
                (value.account, value.neededRole)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    neededRole: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlUnauthorizedAccount(address,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 81u8, 125u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.neededRole),
                )
            }
        }
    };
    /**Custom error with signature `BridgeCallFailed()` and selector `0x376fb55a`.
```solidity
error BridgeCallFailed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BridgeCallFailed {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BridgeCallFailed> for UnderlyingRustTuple<'_> {
            fn from(value: BridgeCallFailed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BridgeCallFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BridgeCallFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BridgeCallFailed()";
            const SELECTOR: [u8; 4] = [55u8, 111u8, 181u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ZeroAddress()` and selector `0xd92e233d`.
```solidity
error ZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAddress {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAddress()";
            const SELECTOR: [u8; 4] = [217u8, 46u8, 35u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ZeroAmount()` and selector `0x1f2a2005`.
```solidity
error ZeroAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAmount {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAmount> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAmount()";
            const SELECTOR: [u8; 4] = [31u8, 42u8, 32u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Event with signature `BridgeCalldataUpdated(bytes,bytes)` and selector `0xf0dca53f6423fafdd825c9ca79bc76f4356686872f74a062e09d6d7e2f832c5a`.
```solidity
event BridgeCalldataUpdated(bytes oldCalldata, bytes newCalldata);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeCalldataUpdated {
        #[allow(missing_docs)]
        pub oldCalldata: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub newCalldata: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeCalldataUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "BridgeCalldataUpdated(bytes,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                240u8,
                220u8,
                165u8,
                63u8,
                100u8,
                35u8,
                250u8,
                253u8,
                216u8,
                37u8,
                201u8,
                202u8,
                121u8,
                188u8,
                118u8,
                244u8,
                53u8,
                102u8,
                134u8,
                135u8,
                47u8,
                116u8,
                160u8,
                98u8,
                224u8,
                157u8,
                109u8,
                126u8,
                47u8,
                131u8,
                44u8,
                90u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldCalldata: data.0,
                    newCalldata: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.oldCalldata,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.newCalldata,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeCalldataUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeCalldataUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeCalldataUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeExecuted(address,uint256,address,bool)` and selector `0x8e7f1561e09be9c40c53b4c5dd162d6db5b665ddb6f8bcfdf8f9e1a8e75fa671`.
```solidity
event BridgeExecuted(address indexed token, uint256 amount, address indexed target, bool success);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeExecuted {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub success: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeExecuted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeExecuted(address,uint256,address,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                142u8,
                127u8,
                21u8,
                97u8,
                224u8,
                155u8,
                233u8,
                196u8,
                12u8,
                83u8,
                180u8,
                197u8,
                221u8,
                22u8,
                45u8,
                109u8,
                181u8,
                182u8,
                101u8,
                221u8,
                182u8,
                248u8,
                188u8,
                253u8,
                248u8,
                249u8,
                225u8,
                168u8,
                231u8,
                95u8,
                166u8,
                113u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    token: topics.1,
                    amount: data.0,
                    target: topics.2,
                    success: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.success,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.token.clone(), self.target.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.token,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.target,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeExecuted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeExecuted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeExecuted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeTargetUpdated(address,address)` and selector `0xb07f8b1b85042d74022c867c836edeb0bcd70e135b0042390d2b1fd108298069`.
```solidity
event BridgeTargetUpdated(address indexed oldTarget, address indexed newTarget);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeTargetUpdated {
        #[allow(missing_docs)]
        pub oldTarget: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newTarget: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeTargetUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeTargetUpdated(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                176u8,
                127u8,
                139u8,
                27u8,
                133u8,
                4u8,
                45u8,
                116u8,
                2u8,
                44u8,
                134u8,
                124u8,
                131u8,
                110u8,
                222u8,
                176u8,
                188u8,
                215u8,
                14u8,
                19u8,
                91u8,
                0u8,
                66u8,
                57u8,
                13u8,
                43u8,
                31u8,
                209u8,
                8u8,
                41u8,
                128u8,
                105u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldTarget: topics.1,
                    newTarget: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.oldTarget.clone(),
                    self.newTarget.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.oldTarget,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newTarget,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeTargetUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeTargetUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeTargetUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address admin);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub admin: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value.admin,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { admin: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.admin,
                    ),
                )
            }
        }
    };
    /**Function with signature `BRIDGE_ADMIN_ROLE()` and selector `0x118c38c7`.
```solidity
function BRIDGE_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_ADMIN_ROLECall {}
    ///Container type for the return parameters of the [`BRIDGE_ADMIN_ROLE()`](BRIDGE_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BRIDGE_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BRIDGE_ADMIN_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BRIDGE_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [17u8, 140u8, 56u8, 199u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall {}
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DEFAULT_ADMIN_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeCalldata()` and selector `0x5d7eba3b`.
```solidity
function bridgeCalldata() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeCalldataCall {}
    ///Container type for the return parameters of the [`bridgeCalldata()`](bridgeCalldataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeCalldataReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeCalldataCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeCalldataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeCalldataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeCalldataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: bridgeCalldataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for bridgeCalldataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeCalldataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeCalldataReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeCalldata()";
            const SELECTOR: [u8; 4] = [93u8, 126u8, 186u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeTarget()` and selector `0xc9f5b63e`.
```solidity
function bridgeTarget() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeTargetCall {}
    ///Container type for the return parameters of the [`bridgeTarget()`](bridgeTargetCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeTargetReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeTargetCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeTargetCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeTargetCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeTargetReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeTargetReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeTargetReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeTargetCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeTargetReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeTarget()";
            const SELECTOR: [u8; 4] = [201u8, 245u8, 182u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `executeBridge(address,uint256,bytes)` and selector `0x18b68b8c`.
```solidity
function executeBridge(address token, uint256 amount, bytes memory data) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct executeBridgeCall {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`executeBridge(address,uint256,bytes)`](executeBridgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct executeBridgeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<executeBridgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: executeBridgeCall) -> Self {
                    (value.token, value.amount, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for executeBridgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        amount: tuple.1,
                        data: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<executeBridgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: executeBridgeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for executeBridgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for executeBridgeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = executeBridgeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "executeBridge(address,uint256,bytes)";
            const SELECTOR: [u8; 4] = [24u8, 182u8, 139u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeConfiguration()` and selector `0x07a1d5fa`.
```solidity
function getBridgeConfiguration() external view returns (address target, bytes memory calldata_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeConfigurationCall {}
    ///Container type for the return parameters of the [`getBridgeConfiguration()`](getBridgeConfigurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeConfigurationReturn {
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub calldata_: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeConfigurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeConfigurationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeConfigurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeConfigurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeConfigurationReturn) -> Self {
                    (value.target, value.calldata_)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeConfigurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        target: tuple.0,
                        calldata_: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeConfigurationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeConfigurationReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeConfiguration()";
            const SELECTOR: [u8; 4] = [7u8, 161u8, 213u8, 250u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRoleAdminReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasRoleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `recoverTokens(address,uint256,address)` and selector `0x61b0a56e`.
```solidity
function recoverTokens(address token, uint256 amount, address to) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct recoverTokensCall {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`recoverTokens(address,uint256,address)`](recoverTokensCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct recoverTokensReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<recoverTokensCall> for UnderlyingRustTuple<'_> {
                fn from(value: recoverTokensCall) -> Self {
                    (value.token, value.amount, value.to)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for recoverTokensCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        amount: tuple.1,
                        to: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<recoverTokensReturn> for UnderlyingRustTuple<'_> {
                fn from(value: recoverTokensReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for recoverTokensReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for recoverTokensCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = recoverTokensReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "recoverTokens(address,uint256,address)";
            const SELECTOR: [u8; 4] = [97u8, 176u8, 165u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address callerConfirmation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub callerConfirmation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.callerConfirmation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        callerConfirmation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callerConfirmation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeCalldata(bytes)` and selector `0x802a1d37`.
```solidity
function setBridgeCalldata(bytes memory calldata_) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeCalldataCall {
        #[allow(missing_docs)]
        pub calldata_: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`setBridgeCalldata(bytes)`](setBridgeCalldataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeCalldataReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeCalldataCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeCalldataCall) -> Self {
                    (value.calldata_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBridgeCalldataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { calldata_: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeCalldataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeCalldataReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBridgeCalldataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeCalldataCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeCalldataReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeCalldata(bytes)";
            const SELECTOR: [u8; 4] = [128u8, 42u8, 29u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.calldata_,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeTarget(address)` and selector `0x6bcc8c14`.
```solidity
function setBridgeTarget(address target) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeTargetCall {
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setBridgeTarget(address)`](setBridgeTargetCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeTargetReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeTargetCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeTargetCall) -> Self {
                    (value.target,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeTargetCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { target: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeTargetReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeTargetReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBridgeTargetReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeTargetCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeTargetReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeTarget(address)";
            const SELECTOR: [u8; 4] = [107u8, 204u8, 140u8, 20u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = supportsInterfaceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`BridgeProxy`](self) function calls.
    pub enum BridgeProxyCalls {
        #[allow(missing_docs)]
        BRIDGE_ADMIN_ROLE(BRIDGE_ADMIN_ROLECall),
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        bridgeCalldata(bridgeCalldataCall),
        #[allow(missing_docs)]
        bridgeTarget(bridgeTargetCall),
        #[allow(missing_docs)]
        executeBridge(executeBridgeCall),
        #[allow(missing_docs)]
        getBridgeConfiguration(getBridgeConfigurationCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        recoverTokens(recoverTokensCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        setBridgeCalldata(setBridgeCalldataCall),
        #[allow(missing_docs)]
        setBridgeTarget(setBridgeTargetCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
    }
    #[automatically_derived]
    impl BridgeProxyCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 255u8, 201u8, 167u8],
            [7u8, 161u8, 213u8, 250u8],
            [17u8, 140u8, 56u8, 199u8],
            [24u8, 182u8, 139u8, 140u8],
            [36u8, 138u8, 156u8, 163u8],
            [47u8, 47u8, 241u8, 93u8],
            [54u8, 86u8, 138u8, 190u8],
            [93u8, 126u8, 186u8, 59u8],
            [97u8, 176u8, 165u8, 110u8],
            [107u8, 204u8, 140u8, 20u8],
            [128u8, 42u8, 29u8, 55u8],
            [145u8, 209u8, 72u8, 84u8],
            [162u8, 23u8, 253u8, 223u8],
            [201u8, 245u8, 182u8, 62u8],
            [213u8, 71u8, 116u8, 31u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for BridgeProxyCalls {
        const NAME: &'static str = "BridgeProxyCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 15usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::BRIDGE_ADMIN_ROLE(_) => {
                    <BRIDGE_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeCalldata(_) => {
                    <bridgeCalldataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeTarget(_) => {
                    <bridgeTargetCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::executeBridge(_) => {
                    <executeBridgeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeConfiguration(_) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::recoverTokens(_) => {
                    <recoverTokensCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeCalldata(_) => {
                    <setBridgeCalldataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeTarget(_) => {
                    <setBridgeTargetCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<BridgeProxyCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BridgeProxyCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BridgeProxyCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn getBridgeConfiguration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BridgeProxyCalls> {
                        <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BridgeProxyCalls::getBridgeConfiguration)
                    }
                    getBridgeConfiguration
                },
                {
                    fn BRIDGE_ADMIN_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BridgeProxyCalls> {
                        <BRIDGE_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BridgeProxyCalls::BRIDGE_ADMIN_ROLE)
                    }
                    BRIDGE_ADMIN_ROLE
                },
                {
                    fn executeBridge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BridgeProxyCalls> {
                        <executeBridgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BridgeProxyCalls::executeBridge)
                    }
                    executeBridge
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BridgeProxyCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BridgeProxyCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn grantRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BridgeProxyCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BridgeProxyCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn renounceRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BridgeProxyCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BridgeProxyCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn bridgeCalldata(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BridgeProxyCalls> {
                        <bridgeCalldataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BridgeProxyCalls::bridgeCalldata)
                    }
                    bridgeCalldata
                },
                {
                    fn recoverTokens(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BridgeProxyCalls> {
                        <recoverTokensCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BridgeProxyCalls::recoverTokens)
                    }
                    recoverTokens
                },
                {
                    fn setBridgeTarget(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BridgeProxyCalls> {
                        <setBridgeTargetCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BridgeProxyCalls::setBridgeTarget)
                    }
                    setBridgeTarget
                },
                {
                    fn setBridgeCalldata(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BridgeProxyCalls> {
                        <setBridgeCalldataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BridgeProxyCalls::setBridgeCalldata)
                    }
                    setBridgeCalldata
                },
                {
                    fn hasRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BridgeProxyCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BridgeProxyCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BridgeProxyCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BridgeProxyCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn bridgeTarget(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BridgeProxyCalls> {
                        <bridgeTargetCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BridgeProxyCalls::bridgeTarget)
                    }
                    bridgeTarget
                },
                {
                    fn revokeRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BridgeProxyCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BridgeProxyCalls::revokeRole)
                    }
                    revokeRole
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::BRIDGE_ADMIN_ROLE(inner) => {
                    <BRIDGE_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridgeCalldata(inner) => {
                    <bridgeCalldataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridgeTarget(inner) => {
                    <bridgeTargetCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::executeBridge(inner) => {
                    <executeBridgeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeConfiguration(inner) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::recoverTokens(inner) => {
                    <recoverTokensCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setBridgeCalldata(inner) => {
                    <setBridgeCalldataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setBridgeTarget(inner) => {
                    <setBridgeTargetCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::BRIDGE_ADMIN_ROLE(inner) => {
                    <BRIDGE_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeCalldata(inner) => {
                    <bridgeCalldataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeTarget(inner) => {
                    <bridgeTargetCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::executeBridge(inner) => {
                    <executeBridgeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeConfiguration(inner) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::recoverTokens(inner) => {
                    <recoverTokensCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeCalldata(inner) => {
                    <setBridgeCalldataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeTarget(inner) => {
                    <setBridgeTargetCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`BridgeProxy`](self) custom errors.
    pub enum BridgeProxyErrors {
        #[allow(missing_docs)]
        AccessControlBadConfirmation(AccessControlBadConfirmation),
        #[allow(missing_docs)]
        AccessControlUnauthorizedAccount(AccessControlUnauthorizedAccount),
        #[allow(missing_docs)]
        BridgeCallFailed(BridgeCallFailed),
        #[allow(missing_docs)]
        ZeroAddress(ZeroAddress),
        #[allow(missing_docs)]
        ZeroAmount(ZeroAmount),
    }
    #[automatically_derived]
    impl BridgeProxyErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [31u8, 42u8, 32u8, 5u8],
            [55u8, 111u8, 181u8, 90u8],
            [102u8, 151u8, 178u8, 50u8],
            [217u8, 46u8, 35u8, 61u8],
            [226u8, 81u8, 125u8, 63u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for BridgeProxyErrors {
        const NAME: &'static str = "BridgeProxyErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 5usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccessControlBadConfirmation(_) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AccessControlUnauthorizedAccount(_) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BridgeCallFailed(_) => {
                    <BridgeCallFailed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAddress(_) => {
                    <ZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAmount(_) => {
                    <ZeroAmount as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<BridgeProxyErrors>] = &[
                {
                    fn ZeroAmount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BridgeProxyErrors> {
                        <ZeroAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BridgeProxyErrors::ZeroAmount)
                    }
                    ZeroAmount
                },
                {
                    fn BridgeCallFailed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BridgeProxyErrors> {
                        <BridgeCallFailed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BridgeProxyErrors::BridgeCallFailed)
                    }
                    BridgeCallFailed
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BridgeProxyErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BridgeProxyErrors::AccessControlBadConfirmation)
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BridgeProxyErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BridgeProxyErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BridgeProxyErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BridgeProxyErrors::AccessControlUnauthorizedAccount)
                    }
                    AccessControlUnauthorizedAccount
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BridgeCallFailed(inner) => {
                    <BridgeCallFailed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BridgeCallFailed(inner) => {
                    <BridgeCallFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`BridgeProxy`](self) events.
    pub enum BridgeProxyEvents {
        #[allow(missing_docs)]
        BridgeCalldataUpdated(BridgeCalldataUpdated),
        #[allow(missing_docs)]
        BridgeExecuted(BridgeExecuted),
        #[allow(missing_docs)]
        BridgeTargetUpdated(BridgeTargetUpdated),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
    }
    #[automatically_derived]
    impl BridgeProxyEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ],
            [
                142u8,
                127u8,
                21u8,
                97u8,
                224u8,
                155u8,
                233u8,
                196u8,
                12u8,
                83u8,
                180u8,
                197u8,
                221u8,
                22u8,
                45u8,
                109u8,
                181u8,
                182u8,
                101u8,
                221u8,
                182u8,
                248u8,
                188u8,
                253u8,
                248u8,
                249u8,
                225u8,
                168u8,
                231u8,
                95u8,
                166u8,
                113u8,
            ],
            [
                176u8,
                127u8,
                139u8,
                27u8,
                133u8,
                4u8,
                45u8,
                116u8,
                2u8,
                44u8,
                134u8,
                124u8,
                131u8,
                110u8,
                222u8,
                176u8,
                188u8,
                215u8,
                14u8,
                19u8,
                91u8,
                0u8,
                66u8,
                57u8,
                13u8,
                43u8,
                31u8,
                209u8,
                8u8,
                41u8,
                128u8,
                105u8,
            ],
            [
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ],
            [
                240u8,
                220u8,
                165u8,
                63u8,
                100u8,
                35u8,
                250u8,
                253u8,
                216u8,
                37u8,
                201u8,
                202u8,
                121u8,
                188u8,
                118u8,
                244u8,
                53u8,
                102u8,
                134u8,
                135u8,
                47u8,
                116u8,
                160u8,
                98u8,
                224u8,
                157u8,
                109u8,
                126u8,
                47u8,
                131u8,
                44u8,
                90u8,
            ],
            [
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for BridgeProxyEvents {
        const NAME: &'static str = "BridgeProxyEvents";
        const COUNT: usize = 6usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <BridgeCalldataUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeCalldataUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeCalldataUpdated)
                }
                Some(<BridgeExecuted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BridgeExecuted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeExecuted)
                }
                Some(
                    <BridgeTargetUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeTargetUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeTargetUpdated)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleRevoked)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for BridgeProxyEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::BridgeCalldataUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeExecuted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeTargetUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::BridgeCalldataUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeExecuted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeTargetUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`BridgeProxy`](self) contract instance.

See the [wrapper's documentation](`BridgeProxyInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> BridgeProxyInstance<T, P, N> {
        BridgeProxyInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        admin: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<BridgeProxyInstance<T, P, N>>,
    > {
        BridgeProxyInstance::<T, P, N>::deploy(provider, admin)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        admin: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        BridgeProxyInstance::<T, P, N>::deploy_builder(provider, admin)
    }
    /**A [`BridgeProxy`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`BridgeProxy`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct BridgeProxyInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for BridgeProxyInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("BridgeProxyInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > BridgeProxyInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`BridgeProxy`](self) contract instance.

See the [wrapper's documentation](`BridgeProxyInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            admin: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<BridgeProxyInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider, admin);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            admin: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall { admin },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> BridgeProxyInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> BridgeProxyInstance<T, P, N> {
            BridgeProxyInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > BridgeProxyInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`BRIDGE_ADMIN_ROLE`] function.
        pub fn BRIDGE_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BRIDGE_ADMIN_ROLECall, N> {
            self.call_builder(&BRIDGE_ADMIN_ROLECall {})
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall {})
        }
        ///Creates a new call builder for the [`bridgeCalldata`] function.
        pub fn bridgeCalldata(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeCalldataCall, N> {
            self.call_builder(&bridgeCalldataCall {})
        }
        ///Creates a new call builder for the [`bridgeTarget`] function.
        pub fn bridgeTarget(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeTargetCall, N> {
            self.call_builder(&bridgeTargetCall {})
        }
        ///Creates a new call builder for the [`executeBridge`] function.
        pub fn executeBridge(
            &self,
            token: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, executeBridgeCall, N> {
            self.call_builder(
                &executeBridgeCall {
                    token,
                    amount,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`getBridgeConfiguration`] function.
        pub fn getBridgeConfiguration(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeConfigurationCall, N> {
            self.call_builder(&getBridgeConfigurationCall {})
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`recoverTokens`] function.
        pub fn recoverTokens(
            &self,
            token: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
            to: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, recoverTokensCall, N> {
            self.call_builder(
                &recoverTokensCall {
                    token,
                    amount,
                    to,
                },
            )
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            callerConfirmation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceRoleCall, N> {
            self.call_builder(
                &renounceRoleCall {
                    role,
                    callerConfirmation,
                },
            )
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`setBridgeCalldata`] function.
        pub fn setBridgeCalldata(
            &self,
            calldata_: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeCalldataCall, N> {
            self.call_builder(&setBridgeCalldataCall { calldata_ })
        }
        ///Creates a new call builder for the [`setBridgeTarget`] function.
        pub fn setBridgeTarget(
            &self,
            target: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeTargetCall, N> {
            self.call_builder(&setBridgeTargetCall { target })
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<T, &P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > BridgeProxyInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`BridgeCalldataUpdated`] event.
        pub fn BridgeCalldataUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeCalldataUpdated, N> {
            self.event_filter::<BridgeCalldataUpdated>()
        }
        ///Creates a new event filter for the [`BridgeExecuted`] event.
        pub fn BridgeExecuted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeExecuted, N> {
            self.event_filter::<BridgeExecuted>()
        }
        ///Creates a new event filter for the [`BridgeTargetUpdated`] event.
        pub fn BridgeTargetUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeTargetUpdated, N> {
            self.event_filter::<BridgeTargetUpdated>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
    }
}
