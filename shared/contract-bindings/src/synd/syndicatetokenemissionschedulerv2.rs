/**

Generated by the following Solidity interface...
```solidity
interface SyndicateTokenEmissionSchedulerV2 {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error AllEmissionsCompleted();
    error BridgeNotConfigured();
    error CalculatorNotInitialized();
    error EmissionTooEarly();
    error EmissionsAlreadyStarted();
    error EmissionsNotStarted();
    error EnforcedPause();
    error ExpectedPause();
    error ReentrancyGuardReentrantCall();
    error SafeERC20FailedOperation(address token);
    error ZeroAddress();

    event BridgeDataUpdated(bytes oldData, bytes newData);
    event BridgeProxyUpdated(address indexed oldProxy, address indexed newProxy);
    event EmissionMinted(uint256 epoch, uint256 amount, address indexed destination);
    event EmissionsStarted(uint256 startTime);
    event Paused(address account);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event Unpaused(address account);

    constructor(address _emissionsCalculator, address defaultAdmin, address emissionsManager, address pauser);

    function BRIDGE_MANAGER_ROLE() external view returns (bytes32);
    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function EMISSIONS_MANAGER_ROLE() external view returns (bytes32);
    function EMISSION_BUFFER_TIME() external view returns (uint256);
    function EPOCH_DURATION() external view returns (uint256);
    function PAUSER_ROLE() external view returns (bytes32);
    function TOTAL_EPOCHS() external view returns (uint256);
    function bridgeData() external view returns (bytes memory);
    function bridgeProxy() external view returns (address);
    function currentEpoch() external view returns (uint256);
    function emissionsCalculator() external view returns (address);
    function emissionsEnded() external view returns (bool);
    function emissionsStartTime() external view returns (uint256);
    function emissionsStarted() external view returns (bool);
    function getCurrentEpoch() external view returns (uint256);
    function getCurrentEpochInfo() external view returns (uint256 epoch, uint256 nextEmissionTime, uint256 nextEmissionAmount, bool canMintEmission);
    function getNextEmissionTime() external view returns (uint256);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function mintEmission() external;
    function pause() external;
    function paused() external view returns (bool);
    function renounceRole(bytes32 role, address callerConfirmation) external;
    function revokeRole(bytes32 role, address account) external;
    function setBridgeData(bytes memory _bridgeData) external;
    function setBridgeProxy(address _bridgeProxy) external;
    function startEmissions() external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function totalEmissionsMinted() external view returns (uint256);
    function unpause() external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_emissionsCalculator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "defaultAdmin",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "emissionsManager",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "pauser",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "BRIDGE_MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSIONS_MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSION_BUFFER_TIME",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EPOCH_DURATION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PAUSER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TOTAL_EPOCHS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeData",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeProxy",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IBridgeProxy"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "currentEpoch",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsCalculator",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract EmissionsCalculator"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsEnded",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsStartTime",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsStarted",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCurrentEpoch",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCurrentEpochInfo",
    "inputs": [],
    "outputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nextEmissionTime",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nextEmissionAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "canMintEmission",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getNextEmissionTime",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "mintEmission",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "pause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "paused",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "callerConfirmation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeData",
    "inputs": [
      {
        "name": "_bridgeData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeProxy",
    "inputs": [
      {
        "name": "_bridgeProxy",
        "type": "address",
        "internalType": "contract IBridgeProxy"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "startEmissions",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "totalEmissionsMinted",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "unpause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "BridgeDataUpdated",
    "inputs": [
      {
        "name": "oldData",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      },
      {
        "name": "newData",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeProxyUpdated",
    "inputs": [
      {
        "name": "oldProxy",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newProxy",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionMinted",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "destination",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionsStarted",
    "inputs": [
      {
        "name": "startTime",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Paused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Unpaused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccessControlBadConfirmation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AccessControlUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "neededRole",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "AllEmissionsCompleted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BridgeNotConfigured",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CalculatorNotInitialized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionTooEarly",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionsAlreadyStarted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionsNotStarted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EnforcedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExpectedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ReentrancyGuardReentrantCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SafeERC20FailedOperation",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod SyndicateTokenEmissionSchedulerV2 {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a0604052346100825761001d61001461016f565b92919091610296565b610025610087565b612cbf61064382396080518181816103cb01528181611456015281816118ab0152818161195d015281816119d201528181611da801528181611ebb0152818161212c015281816122ee0152818161244001526125920152612cbf90f35b61008d565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906100b990610091565b810190811060018060401b038211176100d157604052565b61009b565b906100e96100e2610087565b92836100af565b565b5f80fd5b60018060a01b031690565b610103906100ef565b90565b61010f816100fa565b0361011657565b5f80fd5b9050519061012782610106565b565b60808183031261016a5761013f825f830161011a565b92610167610150846020850161011a565b9361015e816040860161011a565b9360600161011a565b90565b6100eb565b61018d61330280380380610182816100d6565b928339810190610129565b90919293565b90565b90565b6101ad6101a86101b292610193565b610196565b6100ef565b90565b6101be90610199565b90565b5f0190565b6101da6101d56101df926100ef565b610196565b6100ef565b90565b6101eb906101c6565b90565b6101f7906101e2565b90565b90565b5f1b90565b61021661021161021b92610193565b6101fd565b6101fa565b90565b6102275f610202565b90565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b7f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a90565b9291906102a161046a565b836102bc6102b66102b15f6101b5565b6100fa565b916100fa565b146103ca57806102dc6102d66102d15f6101b5565b6100fa565b916100fa565b146103ae57816102fc6102f66102f15f6101b5565b6100fa565b916100fa565b14610392578261031c6103166103115f6101b5565b6100fa565b916100fa565b146103765761035761036592610334610373966101ee565b60805261034961034261021e565b8490610531565b5061035261022a565b610531565b5061036061024e565b610531565b5061036e610272565b610531565b50565b5f63d92e233d60e01b81528061038e600482016101c1565b0390fd5b5f63d92e233d60e01b8152806103aa600482016101c1565b0390fd5b5f63d92e233d60e01b8152806103c6600482016101c1565b0390fd5b5f63d92e233d60e01b8152806103e2600482016101c1565b0390fd5b90565b90565b6104006103fb610405926103e6565b610196565b6103e9565b90565b61041260016103ec565b90565b906104215f19916101fd565b9181191691161790565b61043f61043a610444926103e9565b610196565b6103e9565b90565b90565b9061045f61045a6104669261042b565b610447565b8254610415565b9055565b6104726104d0565b61048461047d610408565b600261044a565b565b9061049260ff916101fd565b9181191691161790565b151590565b6104aa9061049c565b90565b90565b906104c56104c06104cc926104a1565b6104ad565b8254610486565b9055565b6104db5f60016104b0565b565b5f90565b6104ea906101fa565b90565b906104f7906104e1565b5f5260205260405f2090565b61050c906101c6565b90565b61051890610503565b90565b906105259061050f565b5f5260205260405f2090565b6105396104dd565b5061054e610548828490610608565b1561049c565b5f146105d65761057560016105705f6105688186906104ed565b01859061051b565b6104b0565b9061057e610635565b906105bb6105b56105af7f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d956104e1565b9261050f565b9261050f565b926105c4610087565b806105ce816101c1565b0390a4600190565b50505f90565b5f1c90565b60ff1690565b6105f36105f8916105dc565b6105e1565b90565b61060590546105e7565b90565b61062e915f6106236106299361061c6104dd565b50826104ed565b0161051b565b6105fb565b90565b5f90565b61063d610631565b50339056fe60806040526004361015610013575b610f90565b61001d5f3561020c565b806301ffc9a71461020757806313beaa5b146102025780631b02f845146101fd5780632312d7d7146101f8578063243a30cc146101f35780632481bb5c146101ee578063248a9ca3146101e9578063284e1333146101e45780632f2ff15d146101df57806336568abe146101da5780633f4ba83a146101d557806348b0daa6146101d05780635adf0021146101cb5780635c975abb146101c65780635f15c3c9146101c157806376671808146101bc5780638456cb59146101b757806391d14854146101b2578063a217fddf146101ad578063a3d4485b146101a8578063a4d7e31d146101a3578063a571e1841461019e578063a5b326be14610199578063a70b9f0c14610194578063b97dd9e21461018f578063babc394f1461018a578063d547741f14610185578063e3abdfcb14610180578063e63ab1e91461017b578063f508e19d146101765763f75e85120361000e57610f5b565b610ef7565b610ec2565b610e5e565b610dfb565b610dc2565b610d4f565b610d1a565b610cac565b610c79565b610bf7565b610bc2565b610b1f565b610aae565b610a7b565b610a46565b610a11565b6109a5565b610970565b61093b565b6108cc565b610898565b610864565b6107d5565b6107a0565b610705565b6104e3565b610451565b610396565b610353565b610298565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61023981610224565b0361024057565b5f80fd5b9050359061025182610230565b565b9060208282031261026c57610269915f01610244565b90565b61021c565b151590565b61027f90610271565b9052565b9190610296905f60208501940190610276565b565b346102c8576102c46102b36102ae366004610253565b610f98565b6102bb610212565b91829182610283565b0390f35b610218565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156103135781359167ffffffffffffffff831161030e57602001926001830284011161030957565b6102d5565b6102d1565b6102cd565b90602082820312610349575f82013567ffffffffffffffff81116103445761034092016102d9565b9091565b610220565b61021c565b5f0190565b346103825761036c610366366004610318565b906112b8565b610374610212565b8061037e8161034e565b0390f35b610218565b5f91031261039157565b61021c565b346103c4576103a6366004610387565b6103ae61158e565b6103b6610212565b806103c08161034e565b0390f35b610218565b7f000000000000000000000000000000000000000000000000000000000000000090565b60018060a01b031690565b90565b61040f61040a610414926103ed565b6103f8565b6103ed565b90565b610420906103fb565b90565b61042c90610417565b90565b61043890610423565b9052565b919061044f905f6020850194019061042f565b565b3461048157610461366004610387565b61047d61046c6103c9565b610474610212565b9182918261043c565b0390f35b610218565b90565b90565b6104a061049b6104a592610486565b6103f8565b610489565b90565b6104b3610e1061048c565b90565b6104be6104a8565b90565b6104ca90610489565b9052565b91906104e1905f602085019401906104c1565b565b34610513576104f3366004610387565b61050f6104fe6104b6565b610506610212565b918291826104ce565b0390f35b610218565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b906001600283049216801561055f575b602083101461055a57565b61052b565b91607f169161054f565b60209181520190565b5f5260205f2090565b905f929180549061059561058e8361053f565b8094610569565b916001811690815f146105ec57506001146105b0575b505050565b6105bd9192939450610572565b915f925b8184106105d457505001905f80806105ab565b600181602092959395548486015201910192906105c1565b92949550505060ff19168252151560200201905f80806105ab565b906106119161057b565b90565b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b9061063c90610614565b810190811067ffffffffffffffff82111761065657604052565b61061e565b9061067b6106749261066b610212565b93848092610607565b0383610632565b565b905f106106905761068d9061065b565b90565b610518565b6106a160055f9061067d565b90565b5190565b60209181520190565b90825f9392825e0152565b6106db6106e46020936106e9936106d2816106a4565b938480936106a8565b958691016106b1565b610614565b0190565b6107029160208201915f8184039101526106bc565b90565b3461073557610715366004610387565b610731610720610695565b610728610212565b918291826106ed565b0390f35b610218565b90565b6107468161073a565b0361074d57565b5f80fd5b9050359061075e8261073d565b565b9060208282031261077957610776915f01610751565b90565b61021c565b6107879061073a565b9052565b919061079e905f6020850194019061077e565b565b346107d0576107cc6107bb6107b6366004610760565b6115e2565b6107c3610212565b9182918261078b565b0390f35b610218565b34610803576107e5366004610387565b6107ed611c79565b6107f5610212565b806107ff8161034e565b0390f35b610218565b610811906103ed565b90565b61081d81610808565b0361082457565b5f80fd5b9050359061083582610814565b565b919060408382031261085f578061085361085c925f8601610751565b93602001610828565b90565b61021c565b346108935761087d610877366004610837565b90611cad565b610885610212565b8061088f8161034e565b0390f35b610218565b346108c7576108b16108ab366004610837565b90611cb9565b6108b9610212565b806108c38161034e565b0390f35b610218565b346108fa576108dc366004610387565b6108e4611d25565b6108ec610212565b806108f68161034e565b0390f35b610218565b1c90565b90565b61091690600861091b93026108ff565b610903565b90565b906109299154610906565b90565b61093860035f9061091e565b90565b3461096b5761094b366004610387565b61096761095661092c565b61095e610212565b918291826104ce565b0390f35b610218565b346109a057610980366004610387565b61099c61098b611d2f565b610993610212565b91829182610283565b0390f35b610218565b346109d5576109b5366004610387565b6109d16109c0611d7f565b6109c8610212565b91829182610283565b0390f35b610218565b90565b6109f16109ec6109f6926109da565b6103f8565b610489565b90565b610a0360306109dd565b90565b610a0e6109f9565b90565b34610a4157610a21366004610387565b610a3d610a2c610a06565b610a34610212565b918291826104ce565b0390f35b610218565b34610a7657610a56366004610387565b610a72610a61611d95565b610a69610212565b918291826104ce565b0390f35b610218565b34610aa957610a8b366004610387565b610a93611e5f565b610a9b610212565b80610aa58161034e565b0390f35b610218565b34610adf57610adb610aca610ac4366004610837565b90611e7f565b610ad2610212565b91829182610283565b0390f35b610218565b90565b5f1b90565b610b00610afb610b0592610ae4565b610ae7565b61073a565b90565b610b115f610aec565b90565b610b1c610b08565b90565b34610b4f57610b2f366004610387565b610b4b610b3a610b14565b610b42610212565b9182918261078b565b0390f35b610218565b60018060a01b031690565b610b6f906008610b7493026108ff565b610b54565b90565b90610b829154610b5f565b90565b610b9160045f90610b77565b90565b610b9d90610417565b90565b610ba990610b94565b9052565b9190610bc0905f60208501940190610ba0565b565b34610bf257610bd2366004610387565b610bee610bdd610b85565b610be5610212565b91829182610bad565b0390f35b610218565b34610c2757610c07366004610387565b610c23610c12611ea8565b610c1a610212565b91829182610283565b0390f35b610218565b610c3590610808565b90565b610c4181610c2c565b03610c4857565b5f80fd5b90503590610c5982610c38565b565b90602082820312610c7457610c71915f01610c4c565b90565b61021c565b34610ca757610c91610c8c366004610c5b565b612074565b610c99610212565b80610ca38161034e565b0390f35b610218565b34610cdc57610cbc366004610387565b610cd8610cc76120f8565b610ccf610212565b918291826104ce565b0390f35b610218565b90565b610cf8610cf3610cfd92610ce1565b6103f8565b610489565b90565b610d0c62278d00610ce4565b90565b610d17610d00565b90565b34610d4a57610d2a366004610387565b610d46610d35610d0f565b610d3d610212565b918291826104ce565b0390f35b610218565b34610d7f57610d5f366004610387565b610d7b610d6a612239565b610d72610212565b918291826104ce565b0390f35b610218565b610db9610dc094610daf606094989795610da5608086019a5f8701906104c1565b60208501906104c1565b60408301906104c1565b0190610276565b565b34610df657610dd2366004610387565b610df2610ddd612297565b90610de9949294610212565b94859485610d84565b0390f35b610218565b34610e2a57610e14610e0e366004610837565b90612573565b610e1c610212565b80610e268161034e565b0390f35b610218565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b610e5b610e2f565b90565b34610e8e57610e6e366004610387565b610e8a610e79610e53565b610e81610212565b9182918261078b565b0390f35b610218565b7f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a90565b610ebf610e93565b90565b34610ef257610ed2366004610387565b610eee610edd610eb7565b610ee5610212565b9182918261078b565b0390f35b610218565b34610f2757610f07366004610387565b610f23610f1261257f565b610f1a610212565b918291826104ce565b0390f35b610218565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b610f58610f2c565b90565b34610f8b57610f6b366004610387565b610f87610f76610f50565b610f7e610212565b9182918261078b565b0390f35b610218565b5f80fd5b5f90565b610fa0610f94565b5080610fbb610fb5637965db0b60e01b610224565b91610224565b14908115610fc8575b5090565b610fd29150612625565b5f610fc4565b90610ff291610fed610fe8610f2c565b61264b565b611262565b565b610ffd9061065b565b90565b5090565b601f602091010490565b1b90565b9190600861102d9102916110275f198461100e565b9261100e565b9181191691161790565b61104b61104661105092610489565b6103f8565b610489565b90565b90565b919061106c61106761107493611037565b611053565b908354611012565b9055565b5f90565b61108e91611088611078565b91611056565b565b5b81811061109c575050565b806110a95f60019361107c565b01611091565b9190601f81116110bf575b505050565b6110cb6110f093610572565b9060206110d784611004565b830193106110f8575b6110e990611004565b0190611090565b5f80806110ba565b91506110e9819290506110e0565b90611116905f19906008026108ff565b191690565b8161112591611106565b906002021790565b916111389082611000565b9067ffffffffffffffff82116111f75761115c82611156855461053f565b856110af565b5f90601f831160011461118f5791809161117e935f92611183575b505061111b565b90555b565b90915001355f80611177565b601f1983169161119e85610572565b925f5b8181106111df575091600293918560019694106111c5575b50505002019055611181565b6111d5910135601f841690611106565b90555f80806111b9565b919360206001819287870135815501950192016111a1565b61061e565b90611207929161112d565b565b90825f939282370152565b919061122e8161122781611233956106a8565b8095611209565b610614565b0190565b9161125161125f949260408501908582035f8701526106bc565b926020818503910152611214565b90565b9061126d6005610ff4565b61127a83839060056111fc565b9190916112b37fb9a2088426f03b30a81c06428094fbfa9e2692739b3241af6b9ab1da4b5546be936112aa610212565b93849384611237565b0390a1565b906112c291610fd8565b565b6112d46112cf610e2f565b61264b565b6112dc6113fa565b565b5f1c90565b6112ef6112f4916112de565b610903565b90565b61130190546112e3565b90565b61131861131361131d92610ae4565b6103f8565b610489565b90565b61132c611331916112de565b610b54565b90565b61133e9054611320565b90565b61135561135061135a92610ae4565b6103f8565b6103ed565b90565b61136690611341565b90565b5f80fd5b60e01b90565b61137c81610271565b0361138357565b5f80fd5b9050519061139482611373565b565b906020828203126113af576113ac915f01611387565b90565b61021c565b6113bc610212565b3d5f823e3d90fd5b906113d05f1991610ae7565b9181191691161790565b906113ef6113ea6113f692611037565b611053565b82546113c4565b9055565b61140460036112f7565b6114166114105f611304565b91610489565b036115725761142d6114286004611334565b610b94565b61144761144161143c5f61135d565b610808565b91610808565b1461155657611490602061147a7f0000000000000000000000000000000000000000000000000000000000000000610423565b63158ef93e90611488610212565b93849261136d565b825281806114a06004820161034e565b03915afa8015611551576114bc915f91611523575b5015610271565b611507576114cb4260036113da565b426115027f1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a3220341160916114f9610212565b918291826104ce565b0390a1565b5f63a14d1be760e01b81528061151f6004820161034e565b0390fd5b611544915060203d811161154a575b61153c8183610632565b810190611396565b5f6114b5565b503d611532565b6113b4565b5f633b0a48bd60e11b81528061156e6004820161034e565b0390fd5b5f6338e93dbd60e11b81528061158a6004820161034e565b0390fd5b6115966112c4565b565b5f90565b6115a59061073a565b90565b906115b29061159c565b5f5260205260405f2090565b90565b6115cd6115d2916112de565b6115be565b90565b6115df90546115c1565b90565b60016115fa611600926115f3611598565b505f6115a8565b016115d5565b90565b61160b61265f565b611613611615565b565b61161d6126b5565b61162561162f565b61162d61271a565b565b61163f61163a610e2f565b61264b565b61164761186c565b565b61165281610489565b0361165957565b5f80fd5b9050519061166a82611649565b565b9060208282031261168557611682915f0161165d565b90565b61021c565b634e487b7160e01b5f52601160045260245ffd5b6116ad6116b391939293610489565b92610489565b82039182116116be57565b61168a565b6116cc90610417565b90565b6116d890610808565b9052565b91906116ef905f602085019401906116cf565b565b6116fa90610808565b90565b611706816116f1565b0361170d57565b5f80fd5b9050519061171e826116fd565b565b9060208282031261173957611736915f01611711565b90565b61021c565b61174790610417565b90565b611753906103fb565b90565b61175f9061174a565b90565b61176b90610417565b90565b5f91031261177857565b61021c565b905f92918054906117976117908361053f565b80946106a8565b916001811690815f146117ee57506001146117b2575b505050565b6117bf9192939450610572565b915f925b8184106117d657505001905f80806117ad565b600181602092959395548486015201910192906117c3565b92949550505060ff19168252151560200201905f80806117ad565b61182d61183a94929361182360608401955f8501906116cf565b60208301906104c1565b604081840391015261177d565b90565b61184690610417565b90565b91602061186a92949361186360408201965f8301906104c1565b01906104c1565b565b61187660036112f7565b6118886118825f611304565b91610489565b14611c5d57611895611ea8565b611c41576118a1612239565b6118e560206118cf7f0000000000000000000000000000000000000000000000000000000000000000610423565b6376671808906118dd610212565b93849261136d565b825281806118f56004820161034e565b03915afa908115611c3c575f91611c0e575b50904261193461192e61192961191b6120f8565b6119236104a8565b9061169e565b610489565b91610489565b10611bf2578161194c61194683610489565b91610489565b03611bb8575b506119b460206119817f0000000000000000000000000000000000000000000000000000000000000000610423565b63e1f27eb8906119a95f611994306116c3565b9361199d610212565b9687958694859361136d565b8352600483016116dc565b03925af1908115611bb3575f91611b85575b5090611a0c60206119f67f0000000000000000000000000000000000000000000000000000000000000000610423565b635bdf6ca190611a04610212565b93849261136d565b82528180611a1c6004820161034e565b03915afa908115611b8057611a4191611a3c915f91611b52575b5061173e565b611756565b611a5e81611a57611a526004611334565b610b94565b85916127a6565b611a70611a6b6004611334565b610b94565b90611a7f6318b68b8c91611762565b8492600592813b15611b4d575f611aa991611ab48296611a9d610212565b9889978896879561136d565b855260048501611809565b03925af18015611b4857611b1c575b5090611ad7611ad26004611334565b610b94565b90611b027f34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb9261183d565b92611b17611b0e610212565b92839283611849565b0390a2565b611b3b905f3d8111611b41575b611b338183610632565b81019061176e565b5f611ac3565b503d611b29565b6113b4565b611369565b611b73915060203d8111611b79575b611b6b8183610632565b810190611720565b5f611a36565b503d611b61565b6113b4565b611ba6915060203d8111611bac575b611b9e8183610632565b81019061166c565b5f6119c6565b503d611b94565b6113b4565b611bcb611bc58392610489565b91610489565b11611bd6575f611952565b5f631155624b60e21b815280611bee6004820161034e565b0390fd5b5f633d53c75360e01b815280611c0a6004820161034e565b0390fd5b611c2f915060203d8111611c35575b611c278183610632565b81019061166c565b5f611907565b503d611c1d565b6113b4565b5f631155624b60e21b815280611c596004820161034e565b0390fd5b5f638f98404160e01b815280611c756004820161034e565b0390fd5b611c81611603565b565b90611c9e91611c99611c94826115e2565b61264b565b611ca0565b565b90611caa916128a7565b50565b90611cb791611c83565b565b9080611cd4611cce611cc9612956565b610808565b91610808565b03611ce557611ce291612963565b50565b5f63334bd91960e11b815280611cfd6004820161034e565b0390fd5b611d11611d0c610b08565b61264b565b611d19611d1b565b565b611d23612a64565b565b611d2d611d01565b565b611d37610f94565b50611d4260036112f7565b611d54611d4e5f611304565b91610489565b1190565b60ff1690565b611d6a611d6f916112de565b611d58565b90565b611d7c9054611d5e565b90565b611d87610f94565b50611d926001611d72565b90565b611d9d611078565b50611de26020611dcc7f0000000000000000000000000000000000000000000000000000000000000000610423565b637667180890611dda610212565b93849261136d565b82528180611df26004820161034e565b03915afa908115611e36575f91611e08575b5090565b611e29915060203d8111611e2f575b611e218183610632565b81019061166c565b5f611e04565b503d611e17565b6113b4565b611e4b611e46610e93565b61264b565b611e53611e55565b565b611e5d612ace565b565b611e67611e3b565b565b90611e739061183d565b5f5260205260405f2090565b611ea5915f611e9a611ea093611e93610f94565b50826115a8565b01611e69565b611d72565b90565b611eb0610f94565b50611ef56020611edf7f0000000000000000000000000000000000000000000000000000000000000000610423565b63fa391c6490611eed610212565b93849261136d565b82528180611f056004820161034e565b03915afa908115611f49575f91611f1b575b5090565b611f3c915060203d8111611f42575b611f348183610632565b810190611396565b5f611f17565b503d611f2a565b6113b4565b611f6790611f62611f5d610f2c565b61264b565b611fbf565b565b90611f7a60018060a01b0391610ae7565b9181191691161790565b611f8d906103fb565b90565b611f9990611f84565b90565b90565b90611fb4611faf611fbb92611f90565b611f9c565b8254611f69565b9055565b611fc881610b94565b611fe2611fdc611fd75f61135d565b610808565b91610808565b146120585761200d611ffc611ff76004611334565b610b94565b612007836004611f9f565b91610b94565b61204061203a7f07015b6a9f05913148fd5faddf2acc9708f305937f3072ca2b4b46faa5d0898b9361183d565b9161183d565b91612049610212565b806120538161034e565b0390a3565b5f63d92e233d60e01b8152806120706004820161034e565b0390fd5b61207d90611f4e565b565b90565b61209661209161209b9261207f565b6103f8565b610489565b90565b6120ad6120b391939293610489565b92610489565b82018092116120be57565b61168a565b6120d26120d891939293610489565b92610489565b916120e4838202610489565b9281840414901517156120f357565b61168a565b612100611078565b5061210b60036112f7565b61211d6121175f611304565b91610489565b146121f75761216660206121507f0000000000000000000000000000000000000000000000000000000000000000610423565b63766718089061215e610212565b93849261136d565b825281806121766004820161034e565b03915afa80156121f2576121c1915f916121c4575b506121bb6121ad61219c60036112f7565b926121a76001612082565b9061209e565b6121b5610d00565b906120c3565b9061209e565b90565b6121e5915060203d81116121eb575b6121dd8183610632565b81019061166c565b5f61218b565b503d6121d3565b6113b4565b6122005f611304565b90565b634e487b7160e01b5f52601260045260245ffd5b61222361222991610489565b91610489565b908115612234570490565b612203565b612241611078565b5061224c60036112f7565b61225e6122585f611304565b91610489565b1461228b5761228861227a4261227460036112f7565b9061169e565b612282610d00565b90612217565b90565b6122945f611304565b90565b61229f611078565b506122a8611078565b506122b1611078565b506122ba610f94565b506122c560036112f7565b6122d76122d15f611304565b91610489565b14612523576122e4612239565b61232860206123127f0000000000000000000000000000000000000000000000000000000000000000610423565b637667180890612320610212565b93849261136d565b825281806123386004820161034e565b03915afa90811561251e575f916124f0575b50916123546120f8565b9061235e5f611304565b9361237061236a611ea8565b15610271565b806124d6575b612434575b61238560036112f7565b6123976123915f611304565b91610489565b119081612417575b5080612400575b806123d4575b806123bd575b929193929193929190565b506123cf6123c9611d7f565b15610271565b6123b2565b50426123f96123f36123ee856123e86104a8565b9061169e565b610489565b91610489565b10156123ac565b5061241261240c611ea8565b15610271565b6123a6565b905061242c6124268592610489565b91610489565b10155f61239f565b935061247a60206124647f0000000000000000000000000000000000000000000000000000000000000000610423565b6380572f1890612472610212565b93849261136d565b8252818061248a6004820161034e565b03915afa9081156124d1575f916124a3575b509361237b565b6124c4915060203d81116124ca575b6124bc8183610632565b81019061166c565b5f61249c565b503d6124b2565b6113b4565b50806124ea6124e486610489565b91610489565b14612376565b612511915060203d8111612517575b6125098183610632565b81019061166c565b5f61234a565b503d6124ff565b6113b4565b5f905f915f9161254561253f6125395f94611304565b95611304565b93611304565b9190565b906125649161255f61255a826115e2565b61264b565b612566565b565b9061257091612963565b50565b9061257d91612549565b565b612587611078565b506125cc60206125b67f0000000000000000000000000000000000000000000000000000000000000000610423565b63df0244b1906125c4610212565b93849261136d565b825281806125dc6004820161034e565b03915afa908115612620575f916125f2575b5090565b612613915060203d8111612619575b61260b8183610632565b81019061166c565b5f6125ee565b503d612601565b6113b4565b61262d610f94565b506126476126416301ffc9a760e01b610224565b91610224565b1490565b61265d90612657612956565b90612afb565b565b612667611d7f565b61266d57565b5f63d93c066560e01b8152806126856004820161034e565b0390fd5b90565b6126a061269b6126a592612689565b6103f8565b610489565b90565b6126b2600261268c565b90565b6126bf60026112f7565b6126d86126d26126cd6126a8565b610489565b91610489565b146126f1576126ef6126e86126a8565b60026113da565b565b5f633ee5aeb560e01b8152806127096004820161034e565b0390fd5b6127176001612082565b90565b61272c61272561270d565b60026113da565b565b63ffffffff1690565b61274b6127466127509261272e565b61136d565b610224565b90565b91602061277492949361276d60408201965f8301906116cf565b01906104c1565b565b61277f90611304565b9052565b9160206127a492949361279d60408201965f8301906116cf565b0190612776565b565b90916127e96004916127da63095ea7b36127c1879391612737565b926127ca610212565b9586946020860190815201612753565b60208201810382520382610632565b906127fe6127f8828490612b36565b15610271565b612808575b505050565b612855600461285a94612850849161284163095ea7b36128285f91612737565b92612831610212565b9687946020860190815201612783565b60208201810382520383610632565b612bd8565b612bd8565b5f8080612803565b9061286e60ff91610ae7565b9181191691161790565b61288190610271565b90565b90565b9061289c6128976128a392612878565b612884565b8254612862565b9055565b6128af610f94565b506128c46128be828490611e7f565b15610271565b5f1461294c576128eb60016128e65f6128de8186906115a8565b018590611e69565b612887565b906128f4612956565b9061293161292b6129257f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d9561159c565b9261183d565b9261183d565b9261293a610212565b806129448161034e565b0390a4600190565b50505f90565b5f90565b61295e612952565b503390565b61296b610f94565b50612977818390611e7f565b5f146129fe5761299d5f6129985f6129908186906115a8565b018590611e69565b612887565b906129a6612956565b906129e36129dd6129d77ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9561159c565b9261183d565b9261183d565b926129ec610212565b806129f68161034e565b0390a4600190565b50505f90565b612a0c612c8c565b612a14612a16565b565b612a215f6001612887565b612a29612956565b612a5f7f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa91612a56610212565b918291826116dc565b0390a1565b612a6c612a04565b565b612a7661265f565b612a7e612a80565b565b612a8b600180612887565b612a93612956565b612ac97f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25891612ac0610212565b918291826116dc565b0390a1565b612ad6612a6e565b565b916020612af9929493612af260408201965f8301906116cf565b019061077e565b565b90612b10612b0a838390611e7f565b15610271565b612b18575050565b612b325f92839263e2517d3f60e01b845260048401612ad8565b0390fd5b905f602091612b43610f94565b50612b4c610f94565b50612b55611078565b50612b5e611078565b50828151910182855af13d915f51919283612b7a575b50505090565b90919250612b90612b8a5f611304565b91610489565b145f14612bbe57612ba19150611762565b3b612bb4612bae5f611304565b91610489565b115b5f8080612b74565b50612bd2612bcc6001612082565b91610489565b14612bb6565b905f602091612be5611078565b50612bee611078565b50828151910182855af115612c81573d5f5190612c13612c0d5f611304565b91610489565b145f14612c675750612c2481611762565b3b612c37612c315f611304565b91610489565b145b612c405750565b612c4c612c6391611762565b5f918291635274afe760e01b8352600483016116dc565b0390fd5b612c7a612c746001612082565b91610489565b1415612c39565b6040513d5f823e3d90fd5b612c9d612c97611d7f565b15610271565b612ca357565b5f638dfc202b60e01b815280612cbb6004820161034e565b0390fd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R4a\0\x82Wa\0\x1Da\0\x14a\x01oV[\x92\x91\x90\x91a\x02\x96V[a\0%a\0\x87V[a,\xBFa\x06C\x829`\x80Q\x81\x81\x81a\x03\xCB\x01R\x81\x81a\x14V\x01R\x81\x81a\x18\xAB\x01R\x81\x81a\x19]\x01R\x81\x81a\x19\xD2\x01R\x81\x81a\x1D\xA8\x01R\x81\x81a\x1E\xBB\x01R\x81\x81a!,\x01R\x81\x81a\"\xEE\x01R\x81\x81a$@\x01Ra%\x92\x01Ra,\xBF\x90\xF3[a\0\x8DV[`@Q\x90V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\0\xB9\x90a\0\x91V[\x81\x01\x90\x81\x10`\x01\x80`@\x1B\x03\x82\x11\x17a\0\xD1W`@RV[a\0\x9BV[\x90a\0\xE9a\0\xE2a\0\x87V[\x92\x83a\0\xAFV[V[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x01\x03\x90a\0\xEFV[\x90V[a\x01\x0F\x81a\0\xFAV[\x03a\x01\x16WV[_\x80\xFD[\x90PQ\x90a\x01'\x82a\x01\x06V[V[`\x80\x81\x83\x03\x12a\x01jWa\x01?\x82_\x83\x01a\x01\x1AV[\x92a\x01ga\x01P\x84` \x85\x01a\x01\x1AV[\x93a\x01^\x81`@\x86\x01a\x01\x1AV[\x93``\x01a\x01\x1AV[\x90V[a\0\xEBV[a\x01\x8Da3\x02\x808\x03\x80a\x01\x82\x81a\0\xD6V[\x92\x839\x81\x01\x90a\x01)V[\x90\x91\x92\x93V[\x90V[\x90V[a\x01\xADa\x01\xA8a\x01\xB2\x92a\x01\x93V[a\x01\x96V[a\0\xEFV[\x90V[a\x01\xBE\x90a\x01\x99V[\x90V[_\x01\x90V[a\x01\xDAa\x01\xD5a\x01\xDF\x92a\0\xEFV[a\x01\x96V[a\0\xEFV[\x90V[a\x01\xEB\x90a\x01\xC6V[\x90V[a\x01\xF7\x90a\x01\xE2V[\x90V[\x90V[_\x1B\x90V[a\x02\x16a\x02\x11a\x02\x1B\x92a\x01\x93V[a\x01\xFDV[a\x01\xFAV[\x90V[a\x02'_a\x02\x02V[\x90V[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*\x90V[\x92\x91\x90a\x02\xA1a\x04jV[\x83a\x02\xBCa\x02\xB6a\x02\xB1_a\x01\xB5V[a\0\xFAV[\x91a\0\xFAV[\x14a\x03\xCAW\x80a\x02\xDCa\x02\xD6a\x02\xD1_a\x01\xB5V[a\0\xFAV[\x91a\0\xFAV[\x14a\x03\xAEW\x81a\x02\xFCa\x02\xF6a\x02\xF1_a\x01\xB5V[a\0\xFAV[\x91a\0\xFAV[\x14a\x03\x92W\x82a\x03\x1Ca\x03\x16a\x03\x11_a\x01\xB5V[a\0\xFAV[\x91a\0\xFAV[\x14a\x03vWa\x03Wa\x03e\x92a\x034a\x03s\x96a\x01\xEEV[`\x80Ra\x03Ia\x03Ba\x02\x1EV[\x84\x90a\x051V[Pa\x03Ra\x02*V[a\x051V[Pa\x03`a\x02NV[a\x051V[Pa\x03na\x02rV[a\x051V[PV[_c\xD9.#=`\xE0\x1B\x81R\x80a\x03\x8E`\x04\x82\x01a\x01\xC1V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x03\xAA`\x04\x82\x01a\x01\xC1V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x03\xC6`\x04\x82\x01a\x01\xC1V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x03\xE2`\x04\x82\x01a\x01\xC1V[\x03\x90\xFD[\x90V[\x90V[a\x04\0a\x03\xFBa\x04\x05\x92a\x03\xE6V[a\x01\x96V[a\x03\xE9V[\x90V[a\x04\x12`\x01a\x03\xECV[\x90V[\x90a\x04!_\x19\x91a\x01\xFDV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x04?a\x04:a\x04D\x92a\x03\xE9V[a\x01\x96V[a\x03\xE9V[\x90V[\x90V[\x90a\x04_a\x04Za\x04f\x92a\x04+V[a\x04GV[\x82Ta\x04\x15V[\x90UV[a\x04ra\x04\xD0V[a\x04\x84a\x04}a\x04\x08V[`\x02a\x04JV[V[\x90a\x04\x92`\xFF\x91a\x01\xFDV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x15\x15\x90V[a\x04\xAA\x90a\x04\x9CV[\x90V[\x90V[\x90a\x04\xC5a\x04\xC0a\x04\xCC\x92a\x04\xA1V[a\x04\xADV[\x82Ta\x04\x86V[\x90UV[a\x04\xDB_`\x01a\x04\xB0V[V[_\x90V[a\x04\xEA\x90a\x01\xFAV[\x90V[\x90a\x04\xF7\x90a\x04\xE1V[_R` R`@_ \x90V[a\x05\x0C\x90a\x01\xC6V[\x90V[a\x05\x18\x90a\x05\x03V[\x90V[\x90a\x05%\x90a\x05\x0FV[_R` R`@_ \x90V[a\x059a\x04\xDDV[Pa\x05Na\x05H\x82\x84\x90a\x06\x08V[\x15a\x04\x9CV[_\x14a\x05\xD6Wa\x05u`\x01a\x05p_a\x05h\x81\x86\x90a\x04\xEDV[\x01\x85\x90a\x05\x1BV[a\x04\xB0V[\x90a\x05~a\x065V[\x90a\x05\xBBa\x05\xB5a\x05\xAF\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\x04\xE1V[\x92a\x05\x0FV[\x92a\x05\x0FV[\x92a\x05\xC4a\0\x87V[\x80a\x05\xCE\x81a\x01\xC1V[\x03\x90\xA4`\x01\x90V[PP_\x90V[_\x1C\x90V[`\xFF\x16\x90V[a\x05\xF3a\x05\xF8\x91a\x05\xDCV[a\x05\xE1V[\x90V[a\x06\x05\x90Ta\x05\xE7V[\x90V[a\x06.\x91_a\x06#a\x06)\x93a\x06\x1Ca\x04\xDDV[P\x82a\x04\xEDV[\x01a\x05\x1BV[a\x05\xFBV[\x90V[_\x90V[a\x06=a\x061V[P3\x90V\xFE`\x80`@R`\x046\x10\x15a\0\x13W[a\x0F\x90V[a\0\x1D_5a\x02\x0CV[\x80c\x01\xFF\xC9\xA7\x14a\x02\x07W\x80c\x13\xBE\xAA[\x14a\x02\x02W\x80c\x1B\x02\xF8E\x14a\x01\xFDW\x80c#\x12\xD7\xD7\x14a\x01\xF8W\x80c$:0\xCC\x14a\x01\xF3W\x80c$\x81\xBB\\\x14a\x01\xEEW\x80c$\x8A\x9C\xA3\x14a\x01\xE9W\x80c(N\x133\x14a\x01\xE4W\x80c//\xF1]\x14a\x01\xDFW\x80c6V\x8A\xBE\x14a\x01\xDAW\x80c?K\xA8:\x14a\x01\xD5W\x80cH\xB0\xDA\xA6\x14a\x01\xD0W\x80cZ\xDF\0!\x14a\x01\xCBW\x80c\\\x97Z\xBB\x14a\x01\xC6W\x80c_\x15\xC3\xC9\x14a\x01\xC1W\x80cvg\x18\x08\x14a\x01\xBCW\x80c\x84V\xCBY\x14a\x01\xB7W\x80c\x91\xD1HT\x14a\x01\xB2W\x80c\xA2\x17\xFD\xDF\x14a\x01\xADW\x80c\xA3\xD4H[\x14a\x01\xA8W\x80c\xA4\xD7\xE3\x1D\x14a\x01\xA3W\x80c\xA5q\xE1\x84\x14a\x01\x9EW\x80c\xA5\xB3&\xBE\x14a\x01\x99W\x80c\xA7\x0B\x9F\x0C\x14a\x01\x94W\x80c\xB9}\xD9\xE2\x14a\x01\x8FW\x80c\xBA\xBC9O\x14a\x01\x8AW\x80c\xD5Gt\x1F\x14a\x01\x85W\x80c\xE3\xAB\xDF\xCB\x14a\x01\x80W\x80c\xE6:\xB1\xE9\x14a\x01{W\x80c\xF5\x08\xE1\x9D\x14a\x01vWc\xF7^\x85\x12\x03a\0\x0EWa\x0F[V[a\x0E\xF7V[a\x0E\xC2V[a\x0E^V[a\r\xFBV[a\r\xC2V[a\rOV[a\r\x1AV[a\x0C\xACV[a\x0CyV[a\x0B\xF7V[a\x0B\xC2V[a\x0B\x1FV[a\n\xAEV[a\n{V[a\nFV[a\n\x11V[a\t\xA5V[a\tpV[a\t;V[a\x08\xCCV[a\x08\x98V[a\x08dV[a\x07\xD5V[a\x07\xA0V[a\x07\x05V[a\x04\xE3V[a\x04QV[a\x03\x96V[a\x03SV[a\x02\x98V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x029\x81a\x02$V[\x03a\x02@WV[_\x80\xFD[\x90P5\x90a\x02Q\x82a\x020V[V[\x90` \x82\x82\x03\x12a\x02lWa\x02i\x91_\x01a\x02DV[\x90V[a\x02\x1CV[\x15\x15\x90V[a\x02\x7F\x90a\x02qV[\x90RV[\x91\x90a\x02\x96\x90_` \x85\x01\x94\x01\x90a\x02vV[V[4a\x02\xC8Wa\x02\xC4a\x02\xB3a\x02\xAE6`\x04a\x02SV[a\x0F\x98V[a\x02\xBBa\x02\x12V[\x91\x82\x91\x82a\x02\x83V[\x03\x90\xF3[a\x02\x18V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x03\x13W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x03\x0EW` \x01\x92`\x01\x83\x02\x84\x01\x11a\x03\tWV[a\x02\xD5V[a\x02\xD1V[a\x02\xCDV[\x90` \x82\x82\x03\x12a\x03IW_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03DWa\x03@\x92\x01a\x02\xD9V[\x90\x91V[a\x02 V[a\x02\x1CV[_\x01\x90V[4a\x03\x82Wa\x03la\x03f6`\x04a\x03\x18V[\x90a\x12\xB8V[a\x03ta\x02\x12V[\x80a\x03~\x81a\x03NV[\x03\x90\xF3[a\x02\x18V[_\x91\x03\x12a\x03\x91WV[a\x02\x1CV[4a\x03\xC4Wa\x03\xA66`\x04a\x03\x87V[a\x03\xAEa\x15\x8EV[a\x03\xB6a\x02\x12V[\x80a\x03\xC0\x81a\x03NV[\x03\x90\xF3[a\x02\x18V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[\x90V[a\x04\x0Fa\x04\na\x04\x14\x92a\x03\xEDV[a\x03\xF8V[a\x03\xEDV[\x90V[a\x04 \x90a\x03\xFBV[\x90V[a\x04,\x90a\x04\x17V[\x90V[a\x048\x90a\x04#V[\x90RV[\x91\x90a\x04O\x90_` \x85\x01\x94\x01\x90a\x04/V[V[4a\x04\x81Wa\x04a6`\x04a\x03\x87V[a\x04}a\x04la\x03\xC9V[a\x04ta\x02\x12V[\x91\x82\x91\x82a\x04<V[\x03\x90\xF3[a\x02\x18V[\x90V[\x90V[a\x04\xA0a\x04\x9Ba\x04\xA5\x92a\x04\x86V[a\x03\xF8V[a\x04\x89V[\x90V[a\x04\xB3a\x0E\x10a\x04\x8CV[\x90V[a\x04\xBEa\x04\xA8V[\x90V[a\x04\xCA\x90a\x04\x89V[\x90RV[\x91\x90a\x04\xE1\x90_` \x85\x01\x94\x01\x90a\x04\xC1V[V[4a\x05\x13Wa\x04\xF36`\x04a\x03\x87V[a\x05\x0Fa\x04\xFEa\x04\xB6V[a\x05\x06a\x02\x12V[\x91\x82\x91\x82a\x04\xCEV[\x03\x90\xF3[a\x02\x18V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x05_W[` \x83\x10\x14a\x05ZWV[a\x05+V[\x91`\x7F\x16\x91a\x05OV[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x05\x95a\x05\x8E\x83a\x05?V[\x80\x94a\x05iV[\x91`\x01\x81\x16\x90\x81_\x14a\x05\xECWP`\x01\x14a\x05\xB0W[PPPV[a\x05\xBD\x91\x92\x93\x94Pa\x05rV[\x91_\x92[\x81\x84\x10a\x05\xD4WPP\x01\x90_\x80\x80a\x05\xABV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x05\xC1V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x05\xABV[\x90a\x06\x11\x91a\x05{V[\x90V[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x06<\x90a\x06\x14V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x06VW`@RV[a\x06\x1EV[\x90a\x06{a\x06t\x92a\x06ka\x02\x12V[\x93\x84\x80\x92a\x06\x07V[\x03\x83a\x062V[V[\x90_\x10a\x06\x90Wa\x06\x8D\x90a\x06[V[\x90V[a\x05\x18V[a\x06\xA1`\x05_\x90a\x06}V[\x90V[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[a\x06\xDBa\x06\xE4` \x93a\x06\xE9\x93a\x06\xD2\x81a\x06\xA4V[\x93\x84\x80\x93a\x06\xA8V[\x95\x86\x91\x01a\x06\xB1V[a\x06\x14V[\x01\x90V[a\x07\x02\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x06\xBCV[\x90V[4a\x075Wa\x07\x156`\x04a\x03\x87V[a\x071a\x07 a\x06\x95V[a\x07(a\x02\x12V[\x91\x82\x91\x82a\x06\xEDV[\x03\x90\xF3[a\x02\x18V[\x90V[a\x07F\x81a\x07:V[\x03a\x07MWV[_\x80\xFD[\x90P5\x90a\x07^\x82a\x07=V[V[\x90` \x82\x82\x03\x12a\x07yWa\x07v\x91_\x01a\x07QV[\x90V[a\x02\x1CV[a\x07\x87\x90a\x07:V[\x90RV[\x91\x90a\x07\x9E\x90_` \x85\x01\x94\x01\x90a\x07~V[V[4a\x07\xD0Wa\x07\xCCa\x07\xBBa\x07\xB66`\x04a\x07`V[a\x15\xE2V[a\x07\xC3a\x02\x12V[\x91\x82\x91\x82a\x07\x8BV[\x03\x90\xF3[a\x02\x18V[4a\x08\x03Wa\x07\xE56`\x04a\x03\x87V[a\x07\xEDa\x1CyV[a\x07\xF5a\x02\x12V[\x80a\x07\xFF\x81a\x03NV[\x03\x90\xF3[a\x02\x18V[a\x08\x11\x90a\x03\xEDV[\x90V[a\x08\x1D\x81a\x08\x08V[\x03a\x08$WV[_\x80\xFD[\x90P5\x90a\x085\x82a\x08\x14V[V[\x91\x90`@\x83\x82\x03\x12a\x08_W\x80a\x08Sa\x08\\\x92_\x86\x01a\x07QV[\x93` \x01a\x08(V[\x90V[a\x02\x1CV[4a\x08\x93Wa\x08}a\x08w6`\x04a\x087V[\x90a\x1C\xADV[a\x08\x85a\x02\x12V[\x80a\x08\x8F\x81a\x03NV[\x03\x90\xF3[a\x02\x18V[4a\x08\xC7Wa\x08\xB1a\x08\xAB6`\x04a\x087V[\x90a\x1C\xB9V[a\x08\xB9a\x02\x12V[\x80a\x08\xC3\x81a\x03NV[\x03\x90\xF3[a\x02\x18V[4a\x08\xFAWa\x08\xDC6`\x04a\x03\x87V[a\x08\xE4a\x1D%V[a\x08\xECa\x02\x12V[\x80a\x08\xF6\x81a\x03NV[\x03\x90\xF3[a\x02\x18V[\x1C\x90V[\x90V[a\t\x16\x90`\x08a\t\x1B\x93\x02a\x08\xFFV[a\t\x03V[\x90V[\x90a\t)\x91Ta\t\x06V[\x90V[a\t8`\x03_\x90a\t\x1EV[\x90V[4a\tkWa\tK6`\x04a\x03\x87V[a\tga\tVa\t,V[a\t^a\x02\x12V[\x91\x82\x91\x82a\x04\xCEV[\x03\x90\xF3[a\x02\x18V[4a\t\xA0Wa\t\x806`\x04a\x03\x87V[a\t\x9Ca\t\x8Ba\x1D/V[a\t\x93a\x02\x12V[\x91\x82\x91\x82a\x02\x83V[\x03\x90\xF3[a\x02\x18V[4a\t\xD5Wa\t\xB56`\x04a\x03\x87V[a\t\xD1a\t\xC0a\x1D\x7FV[a\t\xC8a\x02\x12V[\x91\x82\x91\x82a\x02\x83V[\x03\x90\xF3[a\x02\x18V[\x90V[a\t\xF1a\t\xECa\t\xF6\x92a\t\xDAV[a\x03\xF8V[a\x04\x89V[\x90V[a\n\x03`0a\t\xDDV[\x90V[a\n\x0Ea\t\xF9V[\x90V[4a\nAWa\n!6`\x04a\x03\x87V[a\n=a\n,a\n\x06V[a\n4a\x02\x12V[\x91\x82\x91\x82a\x04\xCEV[\x03\x90\xF3[a\x02\x18V[4a\nvWa\nV6`\x04a\x03\x87V[a\nra\naa\x1D\x95V[a\nia\x02\x12V[\x91\x82\x91\x82a\x04\xCEV[\x03\x90\xF3[a\x02\x18V[4a\n\xA9Wa\n\x8B6`\x04a\x03\x87V[a\n\x93a\x1E_V[a\n\x9Ba\x02\x12V[\x80a\n\xA5\x81a\x03NV[\x03\x90\xF3[a\x02\x18V[4a\n\xDFWa\n\xDBa\n\xCAa\n\xC46`\x04a\x087V[\x90a\x1E\x7FV[a\n\xD2a\x02\x12V[\x91\x82\x91\x82a\x02\x83V[\x03\x90\xF3[a\x02\x18V[\x90V[_\x1B\x90V[a\x0B\0a\n\xFBa\x0B\x05\x92a\n\xE4V[a\n\xE7V[a\x07:V[\x90V[a\x0B\x11_a\n\xECV[\x90V[a\x0B\x1Ca\x0B\x08V[\x90V[4a\x0BOWa\x0B/6`\x04a\x03\x87V[a\x0BKa\x0B:a\x0B\x14V[a\x0BBa\x02\x12V[\x91\x82\x91\x82a\x07\x8BV[\x03\x90\xF3[a\x02\x18V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x0Bo\x90`\x08a\x0Bt\x93\x02a\x08\xFFV[a\x0BTV[\x90V[\x90a\x0B\x82\x91Ta\x0B_V[\x90V[a\x0B\x91`\x04_\x90a\x0BwV[\x90V[a\x0B\x9D\x90a\x04\x17V[\x90V[a\x0B\xA9\x90a\x0B\x94V[\x90RV[\x91\x90a\x0B\xC0\x90_` \x85\x01\x94\x01\x90a\x0B\xA0V[V[4a\x0B\xF2Wa\x0B\xD26`\x04a\x03\x87V[a\x0B\xEEa\x0B\xDDa\x0B\x85V[a\x0B\xE5a\x02\x12V[\x91\x82\x91\x82a\x0B\xADV[\x03\x90\xF3[a\x02\x18V[4a\x0C'Wa\x0C\x076`\x04a\x03\x87V[a\x0C#a\x0C\x12a\x1E\xA8V[a\x0C\x1Aa\x02\x12V[\x91\x82\x91\x82a\x02\x83V[\x03\x90\xF3[a\x02\x18V[a\x0C5\x90a\x08\x08V[\x90V[a\x0CA\x81a\x0C,V[\x03a\x0CHWV[_\x80\xFD[\x90P5\x90a\x0CY\x82a\x0C8V[V[\x90` \x82\x82\x03\x12a\x0CtWa\x0Cq\x91_\x01a\x0CLV[\x90V[a\x02\x1CV[4a\x0C\xA7Wa\x0C\x91a\x0C\x8C6`\x04a\x0C[V[a tV[a\x0C\x99a\x02\x12V[\x80a\x0C\xA3\x81a\x03NV[\x03\x90\xF3[a\x02\x18V[4a\x0C\xDCWa\x0C\xBC6`\x04a\x03\x87V[a\x0C\xD8a\x0C\xC7a \xF8V[a\x0C\xCFa\x02\x12V[\x91\x82\x91\x82a\x04\xCEV[\x03\x90\xF3[a\x02\x18V[\x90V[a\x0C\xF8a\x0C\xF3a\x0C\xFD\x92a\x0C\xE1V[a\x03\xF8V[a\x04\x89V[\x90V[a\r\x0Cb'\x8D\0a\x0C\xE4V[\x90V[a\r\x17a\r\0V[\x90V[4a\rJWa\r*6`\x04a\x03\x87V[a\rFa\r5a\r\x0FV[a\r=a\x02\x12V[\x91\x82\x91\x82a\x04\xCEV[\x03\x90\xF3[a\x02\x18V[4a\r\x7FWa\r_6`\x04a\x03\x87V[a\r{a\rja\"9V[a\rra\x02\x12V[\x91\x82\x91\x82a\x04\xCEV[\x03\x90\xF3[a\x02\x18V[a\r\xB9a\r\xC0\x94a\r\xAF``\x94\x98\x97\x95a\r\xA5`\x80\x86\x01\x9A_\x87\x01\x90a\x04\xC1V[` \x85\x01\x90a\x04\xC1V[`@\x83\x01\x90a\x04\xC1V[\x01\x90a\x02vV[V[4a\r\xF6Wa\r\xD26`\x04a\x03\x87V[a\r\xF2a\r\xDDa\"\x97V[\x90a\r\xE9\x94\x92\x94a\x02\x12V[\x94\x85\x94\x85a\r\x84V[\x03\x90\xF3[a\x02\x18V[4a\x0E*Wa\x0E\x14a\x0E\x0E6`\x04a\x087V[\x90a%sV[a\x0E\x1Ca\x02\x12V[\x80a\x0E&\x81a\x03NV[\x03\x90\xF3[a\x02\x18V[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[a\x0E[a\x0E/V[\x90V[4a\x0E\x8EWa\x0En6`\x04a\x03\x87V[a\x0E\x8Aa\x0Eya\x0ESV[a\x0E\x81a\x02\x12V[\x91\x82\x91\x82a\x07\x8BV[\x03\x90\xF3[a\x02\x18V[\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*\x90V[a\x0E\xBFa\x0E\x93V[\x90V[4a\x0E\xF2Wa\x0E\xD26`\x04a\x03\x87V[a\x0E\xEEa\x0E\xDDa\x0E\xB7V[a\x0E\xE5a\x02\x12V[\x91\x82\x91\x82a\x07\x8BV[\x03\x90\xF3[a\x02\x18V[4a\x0F'Wa\x0F\x076`\x04a\x03\x87V[a\x0F#a\x0F\x12a%\x7FV[a\x0F\x1Aa\x02\x12V[\x91\x82\x91\x82a\x04\xCEV[\x03\x90\xF3[a\x02\x18V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[a\x0FXa\x0F,V[\x90V[4a\x0F\x8BWa\x0Fk6`\x04a\x03\x87V[a\x0F\x87a\x0Fva\x0FPV[a\x0F~a\x02\x12V[\x91\x82\x91\x82a\x07\x8BV[\x03\x90\xF3[a\x02\x18V[_\x80\xFD[_\x90V[a\x0F\xA0a\x0F\x94V[P\x80a\x0F\xBBa\x0F\xB5cye\xDB\x0B`\xE0\x1Ba\x02$V[\x91a\x02$V[\x14\x90\x81\x15a\x0F\xC8W[P\x90V[a\x0F\xD2\x91Pa&%V[_a\x0F\xC4V[\x90a\x0F\xF2\x91a\x0F\xEDa\x0F\xE8a\x0F,V[a&KV[a\x12bV[V[a\x0F\xFD\x90a\x06[V[\x90V[P\x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a\x10-\x91\x02\x91a\x10'_\x19\x84a\x10\x0EV[\x92a\x10\x0EV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x10Ka\x10Fa\x10P\x92a\x04\x89V[a\x03\xF8V[a\x04\x89V[\x90V[\x90V[\x91\x90a\x10la\x10ga\x10t\x93a\x107V[a\x10SV[\x90\x83Ta\x10\x12V[\x90UV[_\x90V[a\x10\x8E\x91a\x10\x88a\x10xV[\x91a\x10VV[V[[\x81\x81\x10a\x10\x9CWPPV[\x80a\x10\xA9_`\x01\x93a\x10|V[\x01a\x10\x91V[\x91\x90`\x1F\x81\x11a\x10\xBFW[PPPV[a\x10\xCBa\x10\xF0\x93a\x05rV[\x90` a\x10\xD7\x84a\x10\x04V[\x83\x01\x93\x10a\x10\xF8W[a\x10\xE9\x90a\x10\x04V[\x01\x90a\x10\x90V[_\x80\x80a\x10\xBAV[\x91Pa\x10\xE9\x81\x92\x90Pa\x10\xE0V[\x90a\x11\x16\x90_\x19\x90`\x08\x02a\x08\xFFV[\x19\x16\x90V[\x81a\x11%\x91a\x11\x06V[\x90`\x02\x02\x17\x90V[\x91a\x118\x90\x82a\x10\0V[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x11\xF7Wa\x11\\\x82a\x11V\x85Ta\x05?V[\x85a\x10\xAFV[_\x90`\x1F\x83\x11`\x01\x14a\x11\x8FW\x91\x80\x91a\x11~\x93_\x92a\x11\x83W[PPa\x11\x1BV[\x90U[V[\x90\x91P\x015_\x80a\x11wV[`\x1F\x19\x83\x16\x91a\x11\x9E\x85a\x05rV[\x92_[\x81\x81\x10a\x11\xDFWP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x11\xC5W[PPP\x02\x01\x90Ua\x11\x81V[a\x11\xD5\x91\x015`\x1F\x84\x16\x90a\x11\x06V[\x90U_\x80\x80a\x11\xB9V[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a\x11\xA1V[a\x06\x1EV[\x90a\x12\x07\x92\x91a\x11-V[V[\x90\x82_\x93\x92\x827\x01RV[\x91\x90a\x12.\x81a\x12'\x81a\x123\x95a\x06\xA8V[\x80\x95a\x12\tV[a\x06\x14V[\x01\x90V[\x91a\x12Qa\x12_\x94\x92`@\x85\x01\x90\x85\x82\x03_\x87\x01Ra\x06\xBCV[\x92` \x81\x85\x03\x91\x01Ra\x12\x14V[\x90V[\x90a\x12m`\x05a\x0F\xF4V[a\x12z\x83\x83\x90`\x05a\x11\xFCV[\x91\x90\x91a\x12\xB3\x7F\xB9\xA2\x08\x84&\xF0;0\xA8\x1C\x06B\x80\x94\xFB\xFA\x9E&\x92s\x9B2A\xAFk\x9A\xB1\xDAKUF\xBE\x93a\x12\xAAa\x02\x12V[\x93\x84\x93\x84a\x127V[\x03\x90\xA1V[\x90a\x12\xC2\x91a\x0F\xD8V[V[a\x12\xD4a\x12\xCFa\x0E/V[a&KV[a\x12\xDCa\x13\xFAV[V[_\x1C\x90V[a\x12\xEFa\x12\xF4\x91a\x12\xDEV[a\t\x03V[\x90V[a\x13\x01\x90Ta\x12\xE3V[\x90V[a\x13\x18a\x13\x13a\x13\x1D\x92a\n\xE4V[a\x03\xF8V[a\x04\x89V[\x90V[a\x13,a\x131\x91a\x12\xDEV[a\x0BTV[\x90V[a\x13>\x90Ta\x13 V[\x90V[a\x13Ua\x13Pa\x13Z\x92a\n\xE4V[a\x03\xF8V[a\x03\xEDV[\x90V[a\x13f\x90a\x13AV[\x90V[_\x80\xFD[`\xE0\x1B\x90V[a\x13|\x81a\x02qV[\x03a\x13\x83WV[_\x80\xFD[\x90PQ\x90a\x13\x94\x82a\x13sV[V[\x90` \x82\x82\x03\x12a\x13\xAFWa\x13\xAC\x91_\x01a\x13\x87V[\x90V[a\x02\x1CV[a\x13\xBCa\x02\x12V[=_\x82>=\x90\xFD[\x90a\x13\xD0_\x19\x91a\n\xE7V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x13\xEFa\x13\xEAa\x13\xF6\x92a\x107V[a\x10SV[\x82Ta\x13\xC4V[\x90UV[a\x14\x04`\x03a\x12\xF7V[a\x14\x16a\x14\x10_a\x13\x04V[\x91a\x04\x89V[\x03a\x15rWa\x14-a\x14(`\x04a\x134V[a\x0B\x94V[a\x14Ga\x14Aa\x14<_a\x13]V[a\x08\x08V[\x91a\x08\x08V[\x14a\x15VWa\x14\x90` a\x14z\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04#V[c\x15\x8E\xF9>\x90a\x14\x88a\x02\x12V[\x93\x84\x92a\x13mV[\x82R\x81\x80a\x14\xA0`\x04\x82\x01a\x03NV[\x03\x91Z\xFA\x80\x15a\x15QWa\x14\xBC\x91_\x91a\x15#W[P\x15a\x02qV[a\x15\x07Wa\x14\xCBB`\x03a\x13\xDAV[Ba\x15\x02\x7F\x11\x94\xB04\xCF\xA9\xABX\x07IJ\x1D\\f}\x8B\x0En\x97\xF3\x88\x88t*\xA3\x87\x1A2 4\x11`\x91a\x14\xF9a\x02\x12V[\x91\x82\x91\x82a\x04\xCEV[\x03\x90\xA1V[_c\xA1M\x1B\xE7`\xE0\x1B\x81R\x80a\x15\x1F`\x04\x82\x01a\x03NV[\x03\x90\xFD[a\x15D\x91P` =\x81\x11a\x15JW[a\x15<\x81\x83a\x062V[\x81\x01\x90a\x13\x96V[_a\x14\xB5V[P=a\x152V[a\x13\xB4V[_c;\nH\xBD`\xE1\x1B\x81R\x80a\x15n`\x04\x82\x01a\x03NV[\x03\x90\xFD[_c8\xE9=\xBD`\xE1\x1B\x81R\x80a\x15\x8A`\x04\x82\x01a\x03NV[\x03\x90\xFD[a\x15\x96a\x12\xC4V[V[_\x90V[a\x15\xA5\x90a\x07:V[\x90V[\x90a\x15\xB2\x90a\x15\x9CV[_R` R`@_ \x90V[\x90V[a\x15\xCDa\x15\xD2\x91a\x12\xDEV[a\x15\xBEV[\x90V[a\x15\xDF\x90Ta\x15\xC1V[\x90V[`\x01a\x15\xFAa\x16\0\x92a\x15\xF3a\x15\x98V[P_a\x15\xA8V[\x01a\x15\xD5V[\x90V[a\x16\x0Ba&_V[a\x16\x13a\x16\x15V[V[a\x16\x1Da&\xB5V[a\x16%a\x16/V[a\x16-a'\x1AV[V[a\x16?a\x16:a\x0E/V[a&KV[a\x16Ga\x18lV[V[a\x16R\x81a\x04\x89V[\x03a\x16YWV[_\x80\xFD[\x90PQ\x90a\x16j\x82a\x16IV[V[\x90` \x82\x82\x03\x12a\x16\x85Wa\x16\x82\x91_\x01a\x16]V[\x90V[a\x02\x1CV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x16\xADa\x16\xB3\x91\x93\x92\x93a\x04\x89V[\x92a\x04\x89V[\x82\x03\x91\x82\x11a\x16\xBEWV[a\x16\x8AV[a\x16\xCC\x90a\x04\x17V[\x90V[a\x16\xD8\x90a\x08\x08V[\x90RV[\x91\x90a\x16\xEF\x90_` \x85\x01\x94\x01\x90a\x16\xCFV[V[a\x16\xFA\x90a\x08\x08V[\x90V[a\x17\x06\x81a\x16\xF1V[\x03a\x17\rWV[_\x80\xFD[\x90PQ\x90a\x17\x1E\x82a\x16\xFDV[V[\x90` \x82\x82\x03\x12a\x179Wa\x176\x91_\x01a\x17\x11V[\x90V[a\x02\x1CV[a\x17G\x90a\x04\x17V[\x90V[a\x17S\x90a\x03\xFBV[\x90V[a\x17_\x90a\x17JV[\x90V[a\x17k\x90a\x04\x17V[\x90V[_\x91\x03\x12a\x17xWV[a\x02\x1CV[\x90_\x92\x91\x80T\x90a\x17\x97a\x17\x90\x83a\x05?V[\x80\x94a\x06\xA8V[\x91`\x01\x81\x16\x90\x81_\x14a\x17\xEEWP`\x01\x14a\x17\xB2W[PPPV[a\x17\xBF\x91\x92\x93\x94Pa\x05rV[\x91_\x92[\x81\x84\x10a\x17\xD6WPP\x01\x90_\x80\x80a\x17\xADV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x17\xC3V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x17\xADV[a\x18-a\x18:\x94\x92\x93a\x18#``\x84\x01\x95_\x85\x01\x90a\x16\xCFV[` \x83\x01\x90a\x04\xC1V[`@\x81\x84\x03\x91\x01Ra\x17}V[\x90V[a\x18F\x90a\x04\x17V[\x90V[\x91` a\x18j\x92\x94\x93a\x18c`@\x82\x01\x96_\x83\x01\x90a\x04\xC1V[\x01\x90a\x04\xC1V[V[a\x18v`\x03a\x12\xF7V[a\x18\x88a\x18\x82_a\x13\x04V[\x91a\x04\x89V[\x14a\x1C]Wa\x18\x95a\x1E\xA8V[a\x1CAWa\x18\xA1a\"9V[a\x18\xE5` a\x18\xCF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04#V[cvg\x18\x08\x90a\x18\xDDa\x02\x12V[\x93\x84\x92a\x13mV[\x82R\x81\x80a\x18\xF5`\x04\x82\x01a\x03NV[\x03\x91Z\xFA\x90\x81\x15a\x1C<W_\x91a\x1C\x0EW[P\x90Ba\x194a\x19.a\x19)a\x19\x1Ba \xF8V[a\x19#a\x04\xA8V[\x90a\x16\x9EV[a\x04\x89V[\x91a\x04\x89V[\x10a\x1B\xF2W\x81a\x19La\x19F\x83a\x04\x89V[\x91a\x04\x89V[\x03a\x1B\xB8W[Pa\x19\xB4` a\x19\x81\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04#V[c\xE1\xF2~\xB8\x90a\x19\xA9_a\x19\x940a\x16\xC3V[\x93a\x19\x9Da\x02\x12V[\x96\x87\x95\x86\x94\x85\x93a\x13mV[\x83R`\x04\x83\x01a\x16\xDCV[\x03\x92Z\xF1\x90\x81\x15a\x1B\xB3W_\x91a\x1B\x85W[P\x90a\x1A\x0C` a\x19\xF6\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04#V[c[\xDFl\xA1\x90a\x1A\x04a\x02\x12V[\x93\x84\x92a\x13mV[\x82R\x81\x80a\x1A\x1C`\x04\x82\x01a\x03NV[\x03\x91Z\xFA\x90\x81\x15a\x1B\x80Wa\x1AA\x91a\x1A<\x91_\x91a\x1BRW[Pa\x17>V[a\x17VV[a\x1A^\x81a\x1AWa\x1AR`\x04a\x134V[a\x0B\x94V[\x85\x91a'\xA6V[a\x1Apa\x1Ak`\x04a\x134V[a\x0B\x94V[\x90a\x1A\x7Fc\x18\xB6\x8B\x8C\x91a\x17bV[\x84\x92`\x05\x92\x81;\x15a\x1BMW_a\x1A\xA9\x91a\x1A\xB4\x82\x96a\x1A\x9Da\x02\x12V[\x98\x89\x97\x88\x96\x87\x95a\x13mV[\x85R`\x04\x85\x01a\x18\tV[\x03\x92Z\xF1\x80\x15a\x1BHWa\x1B\x1CW[P\x90a\x1A\xD7a\x1A\xD2`\x04a\x134V[a\x0B\x94V[\x90a\x1B\x02\x7F4\xB7=\x0C\x96\xE9\xFFMS\x11CH\x17\xC8\xEC\xC90\xE7\xD2x,[\xDE.y\xDCD\xB0YgU\xBB\x92a\x18=V[\x92a\x1B\x17a\x1B\x0Ea\x02\x12V[\x92\x83\x92\x83a\x18IV[\x03\x90\xA2V[a\x1B;\x90_=\x81\x11a\x1BAW[a\x1B3\x81\x83a\x062V[\x81\x01\x90a\x17nV[_a\x1A\xC3V[P=a\x1B)V[a\x13\xB4V[a\x13iV[a\x1Bs\x91P` =\x81\x11a\x1ByW[a\x1Bk\x81\x83a\x062V[\x81\x01\x90a\x17 V[_a\x1A6V[P=a\x1BaV[a\x13\xB4V[a\x1B\xA6\x91P` =\x81\x11a\x1B\xACW[a\x1B\x9E\x81\x83a\x062V[\x81\x01\x90a\x16lV[_a\x19\xC6V[P=a\x1B\x94V[a\x13\xB4V[a\x1B\xCBa\x1B\xC5\x83\x92a\x04\x89V[\x91a\x04\x89V[\x11a\x1B\xD6W_a\x19RV[_c\x11UbK`\xE2\x1B\x81R\x80a\x1B\xEE`\x04\x82\x01a\x03NV[\x03\x90\xFD[_c=S\xC7S`\xE0\x1B\x81R\x80a\x1C\n`\x04\x82\x01a\x03NV[\x03\x90\xFD[a\x1C/\x91P` =\x81\x11a\x1C5W[a\x1C'\x81\x83a\x062V[\x81\x01\x90a\x16lV[_a\x19\x07V[P=a\x1C\x1DV[a\x13\xB4V[_c\x11UbK`\xE2\x1B\x81R\x80a\x1CY`\x04\x82\x01a\x03NV[\x03\x90\xFD[_c\x8F\x98@A`\xE0\x1B\x81R\x80a\x1Cu`\x04\x82\x01a\x03NV[\x03\x90\xFD[a\x1C\x81a\x16\x03V[V[\x90a\x1C\x9E\x91a\x1C\x99a\x1C\x94\x82a\x15\xE2V[a&KV[a\x1C\xA0V[V[\x90a\x1C\xAA\x91a(\xA7V[PV[\x90a\x1C\xB7\x91a\x1C\x83V[V[\x90\x80a\x1C\xD4a\x1C\xCEa\x1C\xC9a)VV[a\x08\x08V[\x91a\x08\x08V[\x03a\x1C\xE5Wa\x1C\xE2\x91a)cV[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a\x1C\xFD`\x04\x82\x01a\x03NV[\x03\x90\xFD[a\x1D\x11a\x1D\x0Ca\x0B\x08V[a&KV[a\x1D\x19a\x1D\x1BV[V[a\x1D#a*dV[V[a\x1D-a\x1D\x01V[V[a\x1D7a\x0F\x94V[Pa\x1DB`\x03a\x12\xF7V[a\x1DTa\x1DN_a\x13\x04V[\x91a\x04\x89V[\x11\x90V[`\xFF\x16\x90V[a\x1Dja\x1Do\x91a\x12\xDEV[a\x1DXV[\x90V[a\x1D|\x90Ta\x1D^V[\x90V[a\x1D\x87a\x0F\x94V[Pa\x1D\x92`\x01a\x1DrV[\x90V[a\x1D\x9Da\x10xV[Pa\x1D\xE2` a\x1D\xCC\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04#V[cvg\x18\x08\x90a\x1D\xDAa\x02\x12V[\x93\x84\x92a\x13mV[\x82R\x81\x80a\x1D\xF2`\x04\x82\x01a\x03NV[\x03\x91Z\xFA\x90\x81\x15a\x1E6W_\x91a\x1E\x08W[P\x90V[a\x1E)\x91P` =\x81\x11a\x1E/W[a\x1E!\x81\x83a\x062V[\x81\x01\x90a\x16lV[_a\x1E\x04V[P=a\x1E\x17V[a\x13\xB4V[a\x1EKa\x1EFa\x0E\x93V[a&KV[a\x1ESa\x1EUV[V[a\x1E]a*\xCEV[V[a\x1Ega\x1E;V[V[\x90a\x1Es\x90a\x18=V[_R` R`@_ \x90V[a\x1E\xA5\x91_a\x1E\x9Aa\x1E\xA0\x93a\x1E\x93a\x0F\x94V[P\x82a\x15\xA8V[\x01a\x1EiV[a\x1DrV[\x90V[a\x1E\xB0a\x0F\x94V[Pa\x1E\xF5` a\x1E\xDF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04#V[c\xFA9\x1Cd\x90a\x1E\xEDa\x02\x12V[\x93\x84\x92a\x13mV[\x82R\x81\x80a\x1F\x05`\x04\x82\x01a\x03NV[\x03\x91Z\xFA\x90\x81\x15a\x1FIW_\x91a\x1F\x1BW[P\x90V[a\x1F<\x91P` =\x81\x11a\x1FBW[a\x1F4\x81\x83a\x062V[\x81\x01\x90a\x13\x96V[_a\x1F\x17V[P=a\x1F*V[a\x13\xB4V[a\x1Fg\x90a\x1Fba\x1F]a\x0F,V[a&KV[a\x1F\xBFV[V[\x90a\x1Fz`\x01\x80`\xA0\x1B\x03\x91a\n\xE7V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1F\x8D\x90a\x03\xFBV[\x90V[a\x1F\x99\x90a\x1F\x84V[\x90V[\x90V[\x90a\x1F\xB4a\x1F\xAFa\x1F\xBB\x92a\x1F\x90V[a\x1F\x9CV[\x82Ta\x1FiV[\x90UV[a\x1F\xC8\x81a\x0B\x94V[a\x1F\xE2a\x1F\xDCa\x1F\xD7_a\x13]V[a\x08\x08V[\x91a\x08\x08V[\x14a XWa \ra\x1F\xFCa\x1F\xF7`\x04a\x134V[a\x0B\x94V[a \x07\x83`\x04a\x1F\x9FV[\x91a\x0B\x94V[a @a :\x7F\x07\x01[j\x9F\x05\x911H\xFD_\xAD\xDF*\xCC\x97\x08\xF3\x05\x93\x7F0r\xCA+KF\xFA\xA5\xD0\x89\x8B\x93a\x18=V[\x91a\x18=V[\x91a Ia\x02\x12V[\x80a S\x81a\x03NV[\x03\x90\xA3V[_c\xD9.#=`\xE0\x1B\x81R\x80a p`\x04\x82\x01a\x03NV[\x03\x90\xFD[a }\x90a\x1FNV[V[\x90V[a \x96a \x91a \x9B\x92a \x7FV[a\x03\xF8V[a\x04\x89V[\x90V[a \xADa \xB3\x91\x93\x92\x93a\x04\x89V[\x92a\x04\x89V[\x82\x01\x80\x92\x11a \xBEWV[a\x16\x8AV[a \xD2a \xD8\x91\x93\x92\x93a\x04\x89V[\x92a\x04\x89V[\x91a \xE4\x83\x82\x02a\x04\x89V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a \xF3WV[a\x16\x8AV[a!\0a\x10xV[Pa!\x0B`\x03a\x12\xF7V[a!\x1Da!\x17_a\x13\x04V[\x91a\x04\x89V[\x14a!\xF7Wa!f` a!P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04#V[cvg\x18\x08\x90a!^a\x02\x12V[\x93\x84\x92a\x13mV[\x82R\x81\x80a!v`\x04\x82\x01a\x03NV[\x03\x91Z\xFA\x80\x15a!\xF2Wa!\xC1\x91_\x91a!\xC4W[Pa!\xBBa!\xADa!\x9C`\x03a\x12\xF7V[\x92a!\xA7`\x01a \x82V[\x90a \x9EV[a!\xB5a\r\0V[\x90a \xC3V[\x90a \x9EV[\x90V[a!\xE5\x91P` =\x81\x11a!\xEBW[a!\xDD\x81\x83a\x062V[\x81\x01\x90a\x16lV[_a!\x8BV[P=a!\xD3V[a\x13\xB4V[a\"\0_a\x13\x04V[\x90V[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a\"#a\")\x91a\x04\x89V[\x91a\x04\x89V[\x90\x81\x15a\"4W\x04\x90V[a\"\x03V[a\"Aa\x10xV[Pa\"L`\x03a\x12\xF7V[a\"^a\"X_a\x13\x04V[\x91a\x04\x89V[\x14a\"\x8BWa\"\x88a\"zBa\"t`\x03a\x12\xF7V[\x90a\x16\x9EV[a\"\x82a\r\0V[\x90a\"\x17V[\x90V[a\"\x94_a\x13\x04V[\x90V[a\"\x9Fa\x10xV[Pa\"\xA8a\x10xV[Pa\"\xB1a\x10xV[Pa\"\xBAa\x0F\x94V[Pa\"\xC5`\x03a\x12\xF7V[a\"\xD7a\"\xD1_a\x13\x04V[\x91a\x04\x89V[\x14a%#Wa\"\xE4a\"9V[a#(` a#\x12\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04#V[cvg\x18\x08\x90a# a\x02\x12V[\x93\x84\x92a\x13mV[\x82R\x81\x80a#8`\x04\x82\x01a\x03NV[\x03\x91Z\xFA\x90\x81\x15a%\x1EW_\x91a$\xF0W[P\x91a#Ta \xF8V[\x90a#^_a\x13\x04V[\x93a#pa#ja\x1E\xA8V[\x15a\x02qV[\x80a$\xD6W[a$4W[a#\x85`\x03a\x12\xF7V[a#\x97a#\x91_a\x13\x04V[\x91a\x04\x89V[\x11\x90\x81a$\x17W[P\x80a$\0W[\x80a#\xD4W[\x80a#\xBDW[\x92\x91\x93\x92\x91\x93\x92\x91\x90V[Pa#\xCFa#\xC9a\x1D\x7FV[\x15a\x02qV[a#\xB2V[PBa#\xF9a#\xF3a#\xEE\x85a#\xE8a\x04\xA8V[\x90a\x16\x9EV[a\x04\x89V[\x91a\x04\x89V[\x10\x15a#\xACV[Pa$\x12a$\x0Ca\x1E\xA8V[\x15a\x02qV[a#\xA6V[\x90Pa$,a$&\x85\x92a\x04\x89V[\x91a\x04\x89V[\x10\x15_a#\x9FV[\x93Pa$z` a$d\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04#V[c\x80W/\x18\x90a$ra\x02\x12V[\x93\x84\x92a\x13mV[\x82R\x81\x80a$\x8A`\x04\x82\x01a\x03NV[\x03\x91Z\xFA\x90\x81\x15a$\xD1W_\x91a$\xA3W[P\x93a#{V[a$\xC4\x91P` =\x81\x11a$\xCAW[a$\xBC\x81\x83a\x062V[\x81\x01\x90a\x16lV[_a$\x9CV[P=a$\xB2V[a\x13\xB4V[P\x80a$\xEAa$\xE4\x86a\x04\x89V[\x91a\x04\x89V[\x14a#vV[a%\x11\x91P` =\x81\x11a%\x17W[a%\t\x81\x83a\x062V[\x81\x01\x90a\x16lV[_a#JV[P=a$\xFFV[a\x13\xB4V[_\x90_\x91_\x91a%Ea%?a%9_\x94a\x13\x04V[\x95a\x13\x04V[\x93a\x13\x04V[\x91\x90V[\x90a%d\x91a%_a%Z\x82a\x15\xE2V[a&KV[a%fV[V[\x90a%p\x91a)cV[PV[\x90a%}\x91a%IV[V[a%\x87a\x10xV[Pa%\xCC` a%\xB6\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04#V[c\xDF\x02D\xB1\x90a%\xC4a\x02\x12V[\x93\x84\x92a\x13mV[\x82R\x81\x80a%\xDC`\x04\x82\x01a\x03NV[\x03\x91Z\xFA\x90\x81\x15a& W_\x91a%\xF2W[P\x90V[a&\x13\x91P` =\x81\x11a&\x19W[a&\x0B\x81\x83a\x062V[\x81\x01\x90a\x16lV[_a%\xEEV[P=a&\x01V[a\x13\xB4V[a&-a\x0F\x94V[Pa&Ga&Ac\x01\xFF\xC9\xA7`\xE0\x1Ba\x02$V[\x91a\x02$V[\x14\x90V[a&]\x90a&Wa)VV[\x90a*\xFBV[V[a&ga\x1D\x7FV[a&mWV[_c\xD9<\x06e`\xE0\x1B\x81R\x80a&\x85`\x04\x82\x01a\x03NV[\x03\x90\xFD[\x90V[a&\xA0a&\x9Ba&\xA5\x92a&\x89V[a\x03\xF8V[a\x04\x89V[\x90V[a&\xB2`\x02a&\x8CV[\x90V[a&\xBF`\x02a\x12\xF7V[a&\xD8a&\xD2a&\xCDa&\xA8V[a\x04\x89V[\x91a\x04\x89V[\x14a&\xF1Wa&\xEFa&\xE8a&\xA8V[`\x02a\x13\xDAV[V[_c>\xE5\xAE\xB5`\xE0\x1B\x81R\x80a'\t`\x04\x82\x01a\x03NV[\x03\x90\xFD[a'\x17`\x01a \x82V[\x90V[a',a'%a'\rV[`\x02a\x13\xDAV[V[c\xFF\xFF\xFF\xFF\x16\x90V[a'Ka'Fa'P\x92a'.V[a\x13mV[a\x02$V[\x90V[\x91` a't\x92\x94\x93a'm`@\x82\x01\x96_\x83\x01\x90a\x16\xCFV[\x01\x90a\x04\xC1V[V[a'\x7F\x90a\x13\x04V[\x90RV[\x91` a'\xA4\x92\x94\x93a'\x9D`@\x82\x01\x96_\x83\x01\x90a\x16\xCFV[\x01\x90a'vV[V[\x90\x91a'\xE9`\x04\x91a'\xDAc\t^\xA7\xB3a'\xC1\x87\x93\x91a'7V[\x92a'\xCAa\x02\x12V[\x95\x86\x94` \x86\x01\x90\x81R\x01a'SV[` \x82\x01\x81\x03\x82R\x03\x82a\x062V[\x90a'\xFEa'\xF8\x82\x84\x90a+6V[\x15a\x02qV[a(\x08W[PPPV[a(U`\x04a(Z\x94a(P\x84\x91a(Ac\t^\xA7\xB3a((_\x91a'7V[\x92a(1a\x02\x12V[\x96\x87\x94` \x86\x01\x90\x81R\x01a'\x83V[` \x82\x01\x81\x03\x82R\x03\x83a\x062V[a+\xD8V[a+\xD8V[_\x80\x80a(\x03V[\x90a(n`\xFF\x91a\n\xE7V[\x91\x81\x19\x16\x91\x16\x17\x90V[a(\x81\x90a\x02qV[\x90V[\x90V[\x90a(\x9Ca(\x97a(\xA3\x92a(xV[a(\x84V[\x82Ta(bV[\x90UV[a(\xAFa\x0F\x94V[Pa(\xC4a(\xBE\x82\x84\x90a\x1E\x7FV[\x15a\x02qV[_\x14a)LWa(\xEB`\x01a(\xE6_a(\xDE\x81\x86\x90a\x15\xA8V[\x01\x85\x90a\x1EiV[a(\x87V[\x90a(\xF4a)VV[\x90a)1a)+a)%\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\x15\x9CV[\x92a\x18=V[\x92a\x18=V[\x92a):a\x02\x12V[\x80a)D\x81a\x03NV[\x03\x90\xA4`\x01\x90V[PP_\x90V[_\x90V[a)^a)RV[P3\x90V[a)ka\x0F\x94V[Pa)w\x81\x83\x90a\x1E\x7FV[_\x14a)\xFEWa)\x9D_a)\x98_a)\x90\x81\x86\x90a\x15\xA8V[\x01\x85\x90a\x1EiV[a(\x87V[\x90a)\xA6a)VV[\x90a)\xE3a)\xDDa)\xD7\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a\x15\x9CV[\x92a\x18=V[\x92a\x18=V[\x92a)\xECa\x02\x12V[\x80a)\xF6\x81a\x03NV[\x03\x90\xA4`\x01\x90V[PP_\x90V[a*\x0Ca,\x8CV[a*\x14a*\x16V[V[a*!_`\x01a(\x87V[a*)a)VV[a*_\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA\x91a*Va\x02\x12V[\x91\x82\x91\x82a\x16\xDCV[\x03\x90\xA1V[a*la*\x04V[V[a*va&_V[a*~a*\x80V[V[a*\x8B`\x01\x80a(\x87V[a*\x93a)VV[a*\xC9\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X\x91a*\xC0a\x02\x12V[\x91\x82\x91\x82a\x16\xDCV[\x03\x90\xA1V[a*\xD6a*nV[V[\x91` a*\xF9\x92\x94\x93a*\xF2`@\x82\x01\x96_\x83\x01\x90a\x16\xCFV[\x01\x90a\x07~V[V[\x90a+\x10a+\n\x83\x83\x90a\x1E\x7FV[\x15a\x02qV[a+\x18WPPV[a+2_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01a*\xD8V[\x03\x90\xFD[\x90_` \x91a+Ca\x0F\x94V[Pa+La\x0F\x94V[Pa+Ua\x10xV[Pa+^a\x10xV[P\x82\x81Q\x91\x01\x82\x85Z\xF1=\x91_Q\x91\x92\x83a+zW[PPP\x90V[\x90\x91\x92Pa+\x90a+\x8A_a\x13\x04V[\x91a\x04\x89V[\x14_\x14a+\xBEWa+\xA1\x91Pa\x17bV[;a+\xB4a+\xAE_a\x13\x04V[\x91a\x04\x89V[\x11[_\x80\x80a+tV[Pa+\xD2a+\xCC`\x01a \x82V[\x91a\x04\x89V[\x14a+\xB6V[\x90_` \x91a+\xE5a\x10xV[Pa+\xEEa\x10xV[P\x82\x81Q\x91\x01\x82\x85Z\xF1\x15a,\x81W=_Q\x90a,\x13a,\r_a\x13\x04V[\x91a\x04\x89V[\x14_\x14a,gWPa,$\x81a\x17bV[;a,7a,1_a\x13\x04V[\x91a\x04\x89V[\x14[a,@WPV[a,La,c\x91a\x17bV[_\x91\x82\x91cRt\xAF\xE7`\xE0\x1B\x83R`\x04\x83\x01a\x16\xDCV[\x03\x90\xFD[a,za,t`\x01a \x82V[\x91a\x04\x89V[\x14\x15a,9V[`@Q=_\x82>=\x90\xFD[a,\x9Da,\x97a\x1D\x7FV[\x15a\x02qV[a,\xA3WV[_c\x8D\xFC +`\xE0\x1B\x81R\x80a,\xBB`\x04\x82\x01a\x03NV[\x03\x90\xFD",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610013575b610f90565b61001d5f3561020c565b806301ffc9a71461020757806313beaa5b146102025780631b02f845146101fd5780632312d7d7146101f8578063243a30cc146101f35780632481bb5c146101ee578063248a9ca3146101e9578063284e1333146101e45780632f2ff15d146101df57806336568abe146101da5780633f4ba83a146101d557806348b0daa6146101d05780635adf0021146101cb5780635c975abb146101c65780635f15c3c9146101c157806376671808146101bc5780638456cb59146101b757806391d14854146101b2578063a217fddf146101ad578063a3d4485b146101a8578063a4d7e31d146101a3578063a571e1841461019e578063a5b326be14610199578063a70b9f0c14610194578063b97dd9e21461018f578063babc394f1461018a578063d547741f14610185578063e3abdfcb14610180578063e63ab1e91461017b578063f508e19d146101765763f75e85120361000e57610f5b565b610ef7565b610ec2565b610e5e565b610dfb565b610dc2565b610d4f565b610d1a565b610cac565b610c79565b610bf7565b610bc2565b610b1f565b610aae565b610a7b565b610a46565b610a11565b6109a5565b610970565b61093b565b6108cc565b610898565b610864565b6107d5565b6107a0565b610705565b6104e3565b610451565b610396565b610353565b610298565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61023981610224565b0361024057565b5f80fd5b9050359061025182610230565b565b9060208282031261026c57610269915f01610244565b90565b61021c565b151590565b61027f90610271565b9052565b9190610296905f60208501940190610276565b565b346102c8576102c46102b36102ae366004610253565b610f98565b6102bb610212565b91829182610283565b0390f35b610218565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156103135781359167ffffffffffffffff831161030e57602001926001830284011161030957565b6102d5565b6102d1565b6102cd565b90602082820312610349575f82013567ffffffffffffffff81116103445761034092016102d9565b9091565b610220565b61021c565b5f0190565b346103825761036c610366366004610318565b906112b8565b610374610212565b8061037e8161034e565b0390f35b610218565b5f91031261039157565b61021c565b346103c4576103a6366004610387565b6103ae61158e565b6103b6610212565b806103c08161034e565b0390f35b610218565b7f000000000000000000000000000000000000000000000000000000000000000090565b60018060a01b031690565b90565b61040f61040a610414926103ed565b6103f8565b6103ed565b90565b610420906103fb565b90565b61042c90610417565b90565b61043890610423565b9052565b919061044f905f6020850194019061042f565b565b3461048157610461366004610387565b61047d61046c6103c9565b610474610212565b9182918261043c565b0390f35b610218565b90565b90565b6104a061049b6104a592610486565b6103f8565b610489565b90565b6104b3610e1061048c565b90565b6104be6104a8565b90565b6104ca90610489565b9052565b91906104e1905f602085019401906104c1565b565b34610513576104f3366004610387565b61050f6104fe6104b6565b610506610212565b918291826104ce565b0390f35b610218565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b906001600283049216801561055f575b602083101461055a57565b61052b565b91607f169161054f565b60209181520190565b5f5260205f2090565b905f929180549061059561058e8361053f565b8094610569565b916001811690815f146105ec57506001146105b0575b505050565b6105bd9192939450610572565b915f925b8184106105d457505001905f80806105ab565b600181602092959395548486015201910192906105c1565b92949550505060ff19168252151560200201905f80806105ab565b906106119161057b565b90565b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b9061063c90610614565b810190811067ffffffffffffffff82111761065657604052565b61061e565b9061067b6106749261066b610212565b93848092610607565b0383610632565b565b905f106106905761068d9061065b565b90565b610518565b6106a160055f9061067d565b90565b5190565b60209181520190565b90825f9392825e0152565b6106db6106e46020936106e9936106d2816106a4565b938480936106a8565b958691016106b1565b610614565b0190565b6107029160208201915f8184039101526106bc565b90565b3461073557610715366004610387565b610731610720610695565b610728610212565b918291826106ed565b0390f35b610218565b90565b6107468161073a565b0361074d57565b5f80fd5b9050359061075e8261073d565b565b9060208282031261077957610776915f01610751565b90565b61021c565b6107879061073a565b9052565b919061079e905f6020850194019061077e565b565b346107d0576107cc6107bb6107b6366004610760565b6115e2565b6107c3610212565b9182918261078b565b0390f35b610218565b34610803576107e5366004610387565b6107ed611c79565b6107f5610212565b806107ff8161034e565b0390f35b610218565b610811906103ed565b90565b61081d81610808565b0361082457565b5f80fd5b9050359061083582610814565b565b919060408382031261085f578061085361085c925f8601610751565b93602001610828565b90565b61021c565b346108935761087d610877366004610837565b90611cad565b610885610212565b8061088f8161034e565b0390f35b610218565b346108c7576108b16108ab366004610837565b90611cb9565b6108b9610212565b806108c38161034e565b0390f35b610218565b346108fa576108dc366004610387565b6108e4611d25565b6108ec610212565b806108f68161034e565b0390f35b610218565b1c90565b90565b61091690600861091b93026108ff565b610903565b90565b906109299154610906565b90565b61093860035f9061091e565b90565b3461096b5761094b366004610387565b61096761095661092c565b61095e610212565b918291826104ce565b0390f35b610218565b346109a057610980366004610387565b61099c61098b611d2f565b610993610212565b91829182610283565b0390f35b610218565b346109d5576109b5366004610387565b6109d16109c0611d7f565b6109c8610212565b91829182610283565b0390f35b610218565b90565b6109f16109ec6109f6926109da565b6103f8565b610489565b90565b610a0360306109dd565b90565b610a0e6109f9565b90565b34610a4157610a21366004610387565b610a3d610a2c610a06565b610a34610212565b918291826104ce565b0390f35b610218565b34610a7657610a56366004610387565b610a72610a61611d95565b610a69610212565b918291826104ce565b0390f35b610218565b34610aa957610a8b366004610387565b610a93611e5f565b610a9b610212565b80610aa58161034e565b0390f35b610218565b34610adf57610adb610aca610ac4366004610837565b90611e7f565b610ad2610212565b91829182610283565b0390f35b610218565b90565b5f1b90565b610b00610afb610b0592610ae4565b610ae7565b61073a565b90565b610b115f610aec565b90565b610b1c610b08565b90565b34610b4f57610b2f366004610387565b610b4b610b3a610b14565b610b42610212565b9182918261078b565b0390f35b610218565b60018060a01b031690565b610b6f906008610b7493026108ff565b610b54565b90565b90610b829154610b5f565b90565b610b9160045f90610b77565b90565b610b9d90610417565b90565b610ba990610b94565b9052565b9190610bc0905f60208501940190610ba0565b565b34610bf257610bd2366004610387565b610bee610bdd610b85565b610be5610212565b91829182610bad565b0390f35b610218565b34610c2757610c07366004610387565b610c23610c12611ea8565b610c1a610212565b91829182610283565b0390f35b610218565b610c3590610808565b90565b610c4181610c2c565b03610c4857565b5f80fd5b90503590610c5982610c38565b565b90602082820312610c7457610c71915f01610c4c565b90565b61021c565b34610ca757610c91610c8c366004610c5b565b612074565b610c99610212565b80610ca38161034e565b0390f35b610218565b34610cdc57610cbc366004610387565b610cd8610cc76120f8565b610ccf610212565b918291826104ce565b0390f35b610218565b90565b610cf8610cf3610cfd92610ce1565b6103f8565b610489565b90565b610d0c62278d00610ce4565b90565b610d17610d00565b90565b34610d4a57610d2a366004610387565b610d46610d35610d0f565b610d3d610212565b918291826104ce565b0390f35b610218565b34610d7f57610d5f366004610387565b610d7b610d6a612239565b610d72610212565b918291826104ce565b0390f35b610218565b610db9610dc094610daf606094989795610da5608086019a5f8701906104c1565b60208501906104c1565b60408301906104c1565b0190610276565b565b34610df657610dd2366004610387565b610df2610ddd612297565b90610de9949294610212565b94859485610d84565b0390f35b610218565b34610e2a57610e14610e0e366004610837565b90612573565b610e1c610212565b80610e268161034e565b0390f35b610218565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b610e5b610e2f565b90565b34610e8e57610e6e366004610387565b610e8a610e79610e53565b610e81610212565b9182918261078b565b0390f35b610218565b7f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a90565b610ebf610e93565b90565b34610ef257610ed2366004610387565b610eee610edd610eb7565b610ee5610212565b9182918261078b565b0390f35b610218565b34610f2757610f07366004610387565b610f23610f1261257f565b610f1a610212565b918291826104ce565b0390f35b610218565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b610f58610f2c565b90565b34610f8b57610f6b366004610387565b610f87610f76610f50565b610f7e610212565b9182918261078b565b0390f35b610218565b5f80fd5b5f90565b610fa0610f94565b5080610fbb610fb5637965db0b60e01b610224565b91610224565b14908115610fc8575b5090565b610fd29150612625565b5f610fc4565b90610ff291610fed610fe8610f2c565b61264b565b611262565b565b610ffd9061065b565b90565b5090565b601f602091010490565b1b90565b9190600861102d9102916110275f198461100e565b9261100e565b9181191691161790565b61104b61104661105092610489565b6103f8565b610489565b90565b90565b919061106c61106761107493611037565b611053565b908354611012565b9055565b5f90565b61108e91611088611078565b91611056565b565b5b81811061109c575050565b806110a95f60019361107c565b01611091565b9190601f81116110bf575b505050565b6110cb6110f093610572565b9060206110d784611004565b830193106110f8575b6110e990611004565b0190611090565b5f80806110ba565b91506110e9819290506110e0565b90611116905f19906008026108ff565b191690565b8161112591611106565b906002021790565b916111389082611000565b9067ffffffffffffffff82116111f75761115c82611156855461053f565b856110af565b5f90601f831160011461118f5791809161117e935f92611183575b505061111b565b90555b565b90915001355f80611177565b601f1983169161119e85610572565b925f5b8181106111df575091600293918560019694106111c5575b50505002019055611181565b6111d5910135601f841690611106565b90555f80806111b9565b919360206001819287870135815501950192016111a1565b61061e565b90611207929161112d565b565b90825f939282370152565b919061122e8161122781611233956106a8565b8095611209565b610614565b0190565b9161125161125f949260408501908582035f8701526106bc565b926020818503910152611214565b90565b9061126d6005610ff4565b61127a83839060056111fc565b9190916112b37fb9a2088426f03b30a81c06428094fbfa9e2692739b3241af6b9ab1da4b5546be936112aa610212565b93849384611237565b0390a1565b906112c291610fd8565b565b6112d46112cf610e2f565b61264b565b6112dc6113fa565b565b5f1c90565b6112ef6112f4916112de565b610903565b90565b61130190546112e3565b90565b61131861131361131d92610ae4565b6103f8565b610489565b90565b61132c611331916112de565b610b54565b90565b61133e9054611320565b90565b61135561135061135a92610ae4565b6103f8565b6103ed565b90565b61136690611341565b90565b5f80fd5b60e01b90565b61137c81610271565b0361138357565b5f80fd5b9050519061139482611373565b565b906020828203126113af576113ac915f01611387565b90565b61021c565b6113bc610212565b3d5f823e3d90fd5b906113d05f1991610ae7565b9181191691161790565b906113ef6113ea6113f692611037565b611053565b82546113c4565b9055565b61140460036112f7565b6114166114105f611304565b91610489565b036115725761142d6114286004611334565b610b94565b61144761144161143c5f61135d565b610808565b91610808565b1461155657611490602061147a7f0000000000000000000000000000000000000000000000000000000000000000610423565b63158ef93e90611488610212565b93849261136d565b825281806114a06004820161034e565b03915afa8015611551576114bc915f91611523575b5015610271565b611507576114cb4260036113da565b426115027f1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a3220341160916114f9610212565b918291826104ce565b0390a1565b5f63a14d1be760e01b81528061151f6004820161034e565b0390fd5b611544915060203d811161154a575b61153c8183610632565b810190611396565b5f6114b5565b503d611532565b6113b4565b5f633b0a48bd60e11b81528061156e6004820161034e565b0390fd5b5f6338e93dbd60e11b81528061158a6004820161034e565b0390fd5b6115966112c4565b565b5f90565b6115a59061073a565b90565b906115b29061159c565b5f5260205260405f2090565b90565b6115cd6115d2916112de565b6115be565b90565b6115df90546115c1565b90565b60016115fa611600926115f3611598565b505f6115a8565b016115d5565b90565b61160b61265f565b611613611615565b565b61161d6126b5565b61162561162f565b61162d61271a565b565b61163f61163a610e2f565b61264b565b61164761186c565b565b61165281610489565b0361165957565b5f80fd5b9050519061166a82611649565b565b9060208282031261168557611682915f0161165d565b90565b61021c565b634e487b7160e01b5f52601160045260245ffd5b6116ad6116b391939293610489565b92610489565b82039182116116be57565b61168a565b6116cc90610417565b90565b6116d890610808565b9052565b91906116ef905f602085019401906116cf565b565b6116fa90610808565b90565b611706816116f1565b0361170d57565b5f80fd5b9050519061171e826116fd565b565b9060208282031261173957611736915f01611711565b90565b61021c565b61174790610417565b90565b611753906103fb565b90565b61175f9061174a565b90565b61176b90610417565b90565b5f91031261177857565b61021c565b905f92918054906117976117908361053f565b80946106a8565b916001811690815f146117ee57506001146117b2575b505050565b6117bf9192939450610572565b915f925b8184106117d657505001905f80806117ad565b600181602092959395548486015201910192906117c3565b92949550505060ff19168252151560200201905f80806117ad565b61182d61183a94929361182360608401955f8501906116cf565b60208301906104c1565b604081840391015261177d565b90565b61184690610417565b90565b91602061186a92949361186360408201965f8301906104c1565b01906104c1565b565b61187660036112f7565b6118886118825f611304565b91610489565b14611c5d57611895611ea8565b611c41576118a1612239565b6118e560206118cf7f0000000000000000000000000000000000000000000000000000000000000000610423565b6376671808906118dd610212565b93849261136d565b825281806118f56004820161034e565b03915afa908115611c3c575f91611c0e575b50904261193461192e61192961191b6120f8565b6119236104a8565b9061169e565b610489565b91610489565b10611bf2578161194c61194683610489565b91610489565b03611bb8575b506119b460206119817f0000000000000000000000000000000000000000000000000000000000000000610423565b63e1f27eb8906119a95f611994306116c3565b9361199d610212565b9687958694859361136d565b8352600483016116dc565b03925af1908115611bb3575f91611b85575b5090611a0c60206119f67f0000000000000000000000000000000000000000000000000000000000000000610423565b635bdf6ca190611a04610212565b93849261136d565b82528180611a1c6004820161034e565b03915afa908115611b8057611a4191611a3c915f91611b52575b5061173e565b611756565b611a5e81611a57611a526004611334565b610b94565b85916127a6565b611a70611a6b6004611334565b610b94565b90611a7f6318b68b8c91611762565b8492600592813b15611b4d575f611aa991611ab48296611a9d610212565b9889978896879561136d565b855260048501611809565b03925af18015611b4857611b1c575b5090611ad7611ad26004611334565b610b94565b90611b027f34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb9261183d565b92611b17611b0e610212565b92839283611849565b0390a2565b611b3b905f3d8111611b41575b611b338183610632565b81019061176e565b5f611ac3565b503d611b29565b6113b4565b611369565b611b73915060203d8111611b79575b611b6b8183610632565b810190611720565b5f611a36565b503d611b61565b6113b4565b611ba6915060203d8111611bac575b611b9e8183610632565b81019061166c565b5f6119c6565b503d611b94565b6113b4565b611bcb611bc58392610489565b91610489565b11611bd6575f611952565b5f631155624b60e21b815280611bee6004820161034e565b0390fd5b5f633d53c75360e01b815280611c0a6004820161034e565b0390fd5b611c2f915060203d8111611c35575b611c278183610632565b81019061166c565b5f611907565b503d611c1d565b6113b4565b5f631155624b60e21b815280611c596004820161034e565b0390fd5b5f638f98404160e01b815280611c756004820161034e565b0390fd5b611c81611603565b565b90611c9e91611c99611c94826115e2565b61264b565b611ca0565b565b90611caa916128a7565b50565b90611cb791611c83565b565b9080611cd4611cce611cc9612956565b610808565b91610808565b03611ce557611ce291612963565b50565b5f63334bd91960e11b815280611cfd6004820161034e565b0390fd5b611d11611d0c610b08565b61264b565b611d19611d1b565b565b611d23612a64565b565b611d2d611d01565b565b611d37610f94565b50611d4260036112f7565b611d54611d4e5f611304565b91610489565b1190565b60ff1690565b611d6a611d6f916112de565b611d58565b90565b611d7c9054611d5e565b90565b611d87610f94565b50611d926001611d72565b90565b611d9d611078565b50611de26020611dcc7f0000000000000000000000000000000000000000000000000000000000000000610423565b637667180890611dda610212565b93849261136d565b82528180611df26004820161034e565b03915afa908115611e36575f91611e08575b5090565b611e29915060203d8111611e2f575b611e218183610632565b81019061166c565b5f611e04565b503d611e17565b6113b4565b611e4b611e46610e93565b61264b565b611e53611e55565b565b611e5d612ace565b565b611e67611e3b565b565b90611e739061183d565b5f5260205260405f2090565b611ea5915f611e9a611ea093611e93610f94565b50826115a8565b01611e69565b611d72565b90565b611eb0610f94565b50611ef56020611edf7f0000000000000000000000000000000000000000000000000000000000000000610423565b63fa391c6490611eed610212565b93849261136d565b82528180611f056004820161034e565b03915afa908115611f49575f91611f1b575b5090565b611f3c915060203d8111611f42575b611f348183610632565b810190611396565b5f611f17565b503d611f2a565b6113b4565b611f6790611f62611f5d610f2c565b61264b565b611fbf565b565b90611f7a60018060a01b0391610ae7565b9181191691161790565b611f8d906103fb565b90565b611f9990611f84565b90565b90565b90611fb4611faf611fbb92611f90565b611f9c565b8254611f69565b9055565b611fc881610b94565b611fe2611fdc611fd75f61135d565b610808565b91610808565b146120585761200d611ffc611ff76004611334565b610b94565b612007836004611f9f565b91610b94565b61204061203a7f07015b6a9f05913148fd5faddf2acc9708f305937f3072ca2b4b46faa5d0898b9361183d565b9161183d565b91612049610212565b806120538161034e565b0390a3565b5f63d92e233d60e01b8152806120706004820161034e565b0390fd5b61207d90611f4e565b565b90565b61209661209161209b9261207f565b6103f8565b610489565b90565b6120ad6120b391939293610489565b92610489565b82018092116120be57565b61168a565b6120d26120d891939293610489565b92610489565b916120e4838202610489565b9281840414901517156120f357565b61168a565b612100611078565b5061210b60036112f7565b61211d6121175f611304565b91610489565b146121f75761216660206121507f0000000000000000000000000000000000000000000000000000000000000000610423565b63766718089061215e610212565b93849261136d565b825281806121766004820161034e565b03915afa80156121f2576121c1915f916121c4575b506121bb6121ad61219c60036112f7565b926121a76001612082565b9061209e565b6121b5610d00565b906120c3565b9061209e565b90565b6121e5915060203d81116121eb575b6121dd8183610632565b81019061166c565b5f61218b565b503d6121d3565b6113b4565b6122005f611304565b90565b634e487b7160e01b5f52601260045260245ffd5b61222361222991610489565b91610489565b908115612234570490565b612203565b612241611078565b5061224c60036112f7565b61225e6122585f611304565b91610489565b1461228b5761228861227a4261227460036112f7565b9061169e565b612282610d00565b90612217565b90565b6122945f611304565b90565b61229f611078565b506122a8611078565b506122b1611078565b506122ba610f94565b506122c560036112f7565b6122d76122d15f611304565b91610489565b14612523576122e4612239565b61232860206123127f0000000000000000000000000000000000000000000000000000000000000000610423565b637667180890612320610212565b93849261136d565b825281806123386004820161034e565b03915afa90811561251e575f916124f0575b50916123546120f8565b9061235e5f611304565b9361237061236a611ea8565b15610271565b806124d6575b612434575b61238560036112f7565b6123976123915f611304565b91610489565b119081612417575b5080612400575b806123d4575b806123bd575b929193929193929190565b506123cf6123c9611d7f565b15610271565b6123b2565b50426123f96123f36123ee856123e86104a8565b9061169e565b610489565b91610489565b10156123ac565b5061241261240c611ea8565b15610271565b6123a6565b905061242c6124268592610489565b91610489565b10155f61239f565b935061247a60206124647f0000000000000000000000000000000000000000000000000000000000000000610423565b6380572f1890612472610212565b93849261136d565b8252818061248a6004820161034e565b03915afa9081156124d1575f916124a3575b509361237b565b6124c4915060203d81116124ca575b6124bc8183610632565b81019061166c565b5f61249c565b503d6124b2565b6113b4565b50806124ea6124e486610489565b91610489565b14612376565b612511915060203d8111612517575b6125098183610632565b81019061166c565b5f61234a565b503d6124ff565b6113b4565b5f905f915f9161254561253f6125395f94611304565b95611304565b93611304565b9190565b906125649161255f61255a826115e2565b61264b565b612566565b565b9061257091612963565b50565b9061257d91612549565b565b612587611078565b506125cc60206125b67f0000000000000000000000000000000000000000000000000000000000000000610423565b63df0244b1906125c4610212565b93849261136d565b825281806125dc6004820161034e565b03915afa908115612620575f916125f2575b5090565b612613915060203d8111612619575b61260b8183610632565b81019061166c565b5f6125ee565b503d612601565b6113b4565b61262d610f94565b506126476126416301ffc9a760e01b610224565b91610224565b1490565b61265d90612657612956565b90612afb565b565b612667611d7f565b61266d57565b5f63d93c066560e01b8152806126856004820161034e565b0390fd5b90565b6126a061269b6126a592612689565b6103f8565b610489565b90565b6126b2600261268c565b90565b6126bf60026112f7565b6126d86126d26126cd6126a8565b610489565b91610489565b146126f1576126ef6126e86126a8565b60026113da565b565b5f633ee5aeb560e01b8152806127096004820161034e565b0390fd5b6127176001612082565b90565b61272c61272561270d565b60026113da565b565b63ffffffff1690565b61274b6127466127509261272e565b61136d565b610224565b90565b91602061277492949361276d60408201965f8301906116cf565b01906104c1565b565b61277f90611304565b9052565b9160206127a492949361279d60408201965f8301906116cf565b0190612776565b565b90916127e96004916127da63095ea7b36127c1879391612737565b926127ca610212565b9586946020860190815201612753565b60208201810382520382610632565b906127fe6127f8828490612b36565b15610271565b612808575b505050565b612855600461285a94612850849161284163095ea7b36128285f91612737565b92612831610212565b9687946020860190815201612783565b60208201810382520383610632565b612bd8565b612bd8565b5f8080612803565b9061286e60ff91610ae7565b9181191691161790565b61288190610271565b90565b90565b9061289c6128976128a392612878565b612884565b8254612862565b9055565b6128af610f94565b506128c46128be828490611e7f565b15610271565b5f1461294c576128eb60016128e65f6128de8186906115a8565b018590611e69565b612887565b906128f4612956565b9061293161292b6129257f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d9561159c565b9261183d565b9261183d565b9261293a610212565b806129448161034e565b0390a4600190565b50505f90565b5f90565b61295e612952565b503390565b61296b610f94565b50612977818390611e7f565b5f146129fe5761299d5f6129985f6129908186906115a8565b018590611e69565b612887565b906129a6612956565b906129e36129dd6129d77ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9561159c565b9261183d565b9261183d565b926129ec610212565b806129f68161034e565b0390a4600190565b50505f90565b612a0c612c8c565b612a14612a16565b565b612a215f6001612887565b612a29612956565b612a5f7f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa91612a56610212565b918291826116dc565b0390a1565b612a6c612a04565b565b612a7661265f565b612a7e612a80565b565b612a8b600180612887565b612a93612956565b612ac97f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25891612ac0610212565b918291826116dc565b0390a1565b612ad6612a6e565b565b916020612af9929493612af260408201965f8301906116cf565b019061077e565b565b90612b10612b0a838390611e7f565b15610271565b612b18575050565b612b325f92839263e2517d3f60e01b845260048401612ad8565b0390fd5b905f602091612b43610f94565b50612b4c610f94565b50612b55611078565b50612b5e611078565b50828151910182855af13d915f51919283612b7a575b50505090565b90919250612b90612b8a5f611304565b91610489565b145f14612bbe57612ba19150611762565b3b612bb4612bae5f611304565b91610489565b115b5f8080612b74565b50612bd2612bcc6001612082565b91610489565b14612bb6565b905f602091612be5611078565b50612bee611078565b50828151910182855af115612c81573d5f5190612c13612c0d5f611304565b91610489565b145f14612c675750612c2481611762565b3b612c37612c315f611304565b91610489565b145b612c405750565b612c4c612c6391611762565b5f918291635274afe760e01b8352600483016116dc565b0390fd5b612c7a612c746001612082565b91610489565b1415612c39565b6040513d5f823e3d90fd5b612c9d612c97611d7f565b15610271565b612ca357565b5f638dfc202b60e01b815280612cbb6004820161034e565b0390fd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x13W[a\x0F\x90V[a\0\x1D_5a\x02\x0CV[\x80c\x01\xFF\xC9\xA7\x14a\x02\x07W\x80c\x13\xBE\xAA[\x14a\x02\x02W\x80c\x1B\x02\xF8E\x14a\x01\xFDW\x80c#\x12\xD7\xD7\x14a\x01\xF8W\x80c$:0\xCC\x14a\x01\xF3W\x80c$\x81\xBB\\\x14a\x01\xEEW\x80c$\x8A\x9C\xA3\x14a\x01\xE9W\x80c(N\x133\x14a\x01\xE4W\x80c//\xF1]\x14a\x01\xDFW\x80c6V\x8A\xBE\x14a\x01\xDAW\x80c?K\xA8:\x14a\x01\xD5W\x80cH\xB0\xDA\xA6\x14a\x01\xD0W\x80cZ\xDF\0!\x14a\x01\xCBW\x80c\\\x97Z\xBB\x14a\x01\xC6W\x80c_\x15\xC3\xC9\x14a\x01\xC1W\x80cvg\x18\x08\x14a\x01\xBCW\x80c\x84V\xCBY\x14a\x01\xB7W\x80c\x91\xD1HT\x14a\x01\xB2W\x80c\xA2\x17\xFD\xDF\x14a\x01\xADW\x80c\xA3\xD4H[\x14a\x01\xA8W\x80c\xA4\xD7\xE3\x1D\x14a\x01\xA3W\x80c\xA5q\xE1\x84\x14a\x01\x9EW\x80c\xA5\xB3&\xBE\x14a\x01\x99W\x80c\xA7\x0B\x9F\x0C\x14a\x01\x94W\x80c\xB9}\xD9\xE2\x14a\x01\x8FW\x80c\xBA\xBC9O\x14a\x01\x8AW\x80c\xD5Gt\x1F\x14a\x01\x85W\x80c\xE3\xAB\xDF\xCB\x14a\x01\x80W\x80c\xE6:\xB1\xE9\x14a\x01{W\x80c\xF5\x08\xE1\x9D\x14a\x01vWc\xF7^\x85\x12\x03a\0\x0EWa\x0F[V[a\x0E\xF7V[a\x0E\xC2V[a\x0E^V[a\r\xFBV[a\r\xC2V[a\rOV[a\r\x1AV[a\x0C\xACV[a\x0CyV[a\x0B\xF7V[a\x0B\xC2V[a\x0B\x1FV[a\n\xAEV[a\n{V[a\nFV[a\n\x11V[a\t\xA5V[a\tpV[a\t;V[a\x08\xCCV[a\x08\x98V[a\x08dV[a\x07\xD5V[a\x07\xA0V[a\x07\x05V[a\x04\xE3V[a\x04QV[a\x03\x96V[a\x03SV[a\x02\x98V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x029\x81a\x02$V[\x03a\x02@WV[_\x80\xFD[\x90P5\x90a\x02Q\x82a\x020V[V[\x90` \x82\x82\x03\x12a\x02lWa\x02i\x91_\x01a\x02DV[\x90V[a\x02\x1CV[\x15\x15\x90V[a\x02\x7F\x90a\x02qV[\x90RV[\x91\x90a\x02\x96\x90_` \x85\x01\x94\x01\x90a\x02vV[V[4a\x02\xC8Wa\x02\xC4a\x02\xB3a\x02\xAE6`\x04a\x02SV[a\x0F\x98V[a\x02\xBBa\x02\x12V[\x91\x82\x91\x82a\x02\x83V[\x03\x90\xF3[a\x02\x18V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x03\x13W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x03\x0EW` \x01\x92`\x01\x83\x02\x84\x01\x11a\x03\tWV[a\x02\xD5V[a\x02\xD1V[a\x02\xCDV[\x90` \x82\x82\x03\x12a\x03IW_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03DWa\x03@\x92\x01a\x02\xD9V[\x90\x91V[a\x02 V[a\x02\x1CV[_\x01\x90V[4a\x03\x82Wa\x03la\x03f6`\x04a\x03\x18V[\x90a\x12\xB8V[a\x03ta\x02\x12V[\x80a\x03~\x81a\x03NV[\x03\x90\xF3[a\x02\x18V[_\x91\x03\x12a\x03\x91WV[a\x02\x1CV[4a\x03\xC4Wa\x03\xA66`\x04a\x03\x87V[a\x03\xAEa\x15\x8EV[a\x03\xB6a\x02\x12V[\x80a\x03\xC0\x81a\x03NV[\x03\x90\xF3[a\x02\x18V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[\x90V[a\x04\x0Fa\x04\na\x04\x14\x92a\x03\xEDV[a\x03\xF8V[a\x03\xEDV[\x90V[a\x04 \x90a\x03\xFBV[\x90V[a\x04,\x90a\x04\x17V[\x90V[a\x048\x90a\x04#V[\x90RV[\x91\x90a\x04O\x90_` \x85\x01\x94\x01\x90a\x04/V[V[4a\x04\x81Wa\x04a6`\x04a\x03\x87V[a\x04}a\x04la\x03\xC9V[a\x04ta\x02\x12V[\x91\x82\x91\x82a\x04<V[\x03\x90\xF3[a\x02\x18V[\x90V[\x90V[a\x04\xA0a\x04\x9Ba\x04\xA5\x92a\x04\x86V[a\x03\xF8V[a\x04\x89V[\x90V[a\x04\xB3a\x0E\x10a\x04\x8CV[\x90V[a\x04\xBEa\x04\xA8V[\x90V[a\x04\xCA\x90a\x04\x89V[\x90RV[\x91\x90a\x04\xE1\x90_` \x85\x01\x94\x01\x90a\x04\xC1V[V[4a\x05\x13Wa\x04\xF36`\x04a\x03\x87V[a\x05\x0Fa\x04\xFEa\x04\xB6V[a\x05\x06a\x02\x12V[\x91\x82\x91\x82a\x04\xCEV[\x03\x90\xF3[a\x02\x18V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x05_W[` \x83\x10\x14a\x05ZWV[a\x05+V[\x91`\x7F\x16\x91a\x05OV[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x05\x95a\x05\x8E\x83a\x05?V[\x80\x94a\x05iV[\x91`\x01\x81\x16\x90\x81_\x14a\x05\xECWP`\x01\x14a\x05\xB0W[PPPV[a\x05\xBD\x91\x92\x93\x94Pa\x05rV[\x91_\x92[\x81\x84\x10a\x05\xD4WPP\x01\x90_\x80\x80a\x05\xABV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x05\xC1V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x05\xABV[\x90a\x06\x11\x91a\x05{V[\x90V[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x06<\x90a\x06\x14V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x06VW`@RV[a\x06\x1EV[\x90a\x06{a\x06t\x92a\x06ka\x02\x12V[\x93\x84\x80\x92a\x06\x07V[\x03\x83a\x062V[V[\x90_\x10a\x06\x90Wa\x06\x8D\x90a\x06[V[\x90V[a\x05\x18V[a\x06\xA1`\x05_\x90a\x06}V[\x90V[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[a\x06\xDBa\x06\xE4` \x93a\x06\xE9\x93a\x06\xD2\x81a\x06\xA4V[\x93\x84\x80\x93a\x06\xA8V[\x95\x86\x91\x01a\x06\xB1V[a\x06\x14V[\x01\x90V[a\x07\x02\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x06\xBCV[\x90V[4a\x075Wa\x07\x156`\x04a\x03\x87V[a\x071a\x07 a\x06\x95V[a\x07(a\x02\x12V[\x91\x82\x91\x82a\x06\xEDV[\x03\x90\xF3[a\x02\x18V[\x90V[a\x07F\x81a\x07:V[\x03a\x07MWV[_\x80\xFD[\x90P5\x90a\x07^\x82a\x07=V[V[\x90` \x82\x82\x03\x12a\x07yWa\x07v\x91_\x01a\x07QV[\x90V[a\x02\x1CV[a\x07\x87\x90a\x07:V[\x90RV[\x91\x90a\x07\x9E\x90_` \x85\x01\x94\x01\x90a\x07~V[V[4a\x07\xD0Wa\x07\xCCa\x07\xBBa\x07\xB66`\x04a\x07`V[a\x15\xE2V[a\x07\xC3a\x02\x12V[\x91\x82\x91\x82a\x07\x8BV[\x03\x90\xF3[a\x02\x18V[4a\x08\x03Wa\x07\xE56`\x04a\x03\x87V[a\x07\xEDa\x1CyV[a\x07\xF5a\x02\x12V[\x80a\x07\xFF\x81a\x03NV[\x03\x90\xF3[a\x02\x18V[a\x08\x11\x90a\x03\xEDV[\x90V[a\x08\x1D\x81a\x08\x08V[\x03a\x08$WV[_\x80\xFD[\x90P5\x90a\x085\x82a\x08\x14V[V[\x91\x90`@\x83\x82\x03\x12a\x08_W\x80a\x08Sa\x08\\\x92_\x86\x01a\x07QV[\x93` \x01a\x08(V[\x90V[a\x02\x1CV[4a\x08\x93Wa\x08}a\x08w6`\x04a\x087V[\x90a\x1C\xADV[a\x08\x85a\x02\x12V[\x80a\x08\x8F\x81a\x03NV[\x03\x90\xF3[a\x02\x18V[4a\x08\xC7Wa\x08\xB1a\x08\xAB6`\x04a\x087V[\x90a\x1C\xB9V[a\x08\xB9a\x02\x12V[\x80a\x08\xC3\x81a\x03NV[\x03\x90\xF3[a\x02\x18V[4a\x08\xFAWa\x08\xDC6`\x04a\x03\x87V[a\x08\xE4a\x1D%V[a\x08\xECa\x02\x12V[\x80a\x08\xF6\x81a\x03NV[\x03\x90\xF3[a\x02\x18V[\x1C\x90V[\x90V[a\t\x16\x90`\x08a\t\x1B\x93\x02a\x08\xFFV[a\t\x03V[\x90V[\x90a\t)\x91Ta\t\x06V[\x90V[a\t8`\x03_\x90a\t\x1EV[\x90V[4a\tkWa\tK6`\x04a\x03\x87V[a\tga\tVa\t,V[a\t^a\x02\x12V[\x91\x82\x91\x82a\x04\xCEV[\x03\x90\xF3[a\x02\x18V[4a\t\xA0Wa\t\x806`\x04a\x03\x87V[a\t\x9Ca\t\x8Ba\x1D/V[a\t\x93a\x02\x12V[\x91\x82\x91\x82a\x02\x83V[\x03\x90\xF3[a\x02\x18V[4a\t\xD5Wa\t\xB56`\x04a\x03\x87V[a\t\xD1a\t\xC0a\x1D\x7FV[a\t\xC8a\x02\x12V[\x91\x82\x91\x82a\x02\x83V[\x03\x90\xF3[a\x02\x18V[\x90V[a\t\xF1a\t\xECa\t\xF6\x92a\t\xDAV[a\x03\xF8V[a\x04\x89V[\x90V[a\n\x03`0a\t\xDDV[\x90V[a\n\x0Ea\t\xF9V[\x90V[4a\nAWa\n!6`\x04a\x03\x87V[a\n=a\n,a\n\x06V[a\n4a\x02\x12V[\x91\x82\x91\x82a\x04\xCEV[\x03\x90\xF3[a\x02\x18V[4a\nvWa\nV6`\x04a\x03\x87V[a\nra\naa\x1D\x95V[a\nia\x02\x12V[\x91\x82\x91\x82a\x04\xCEV[\x03\x90\xF3[a\x02\x18V[4a\n\xA9Wa\n\x8B6`\x04a\x03\x87V[a\n\x93a\x1E_V[a\n\x9Ba\x02\x12V[\x80a\n\xA5\x81a\x03NV[\x03\x90\xF3[a\x02\x18V[4a\n\xDFWa\n\xDBa\n\xCAa\n\xC46`\x04a\x087V[\x90a\x1E\x7FV[a\n\xD2a\x02\x12V[\x91\x82\x91\x82a\x02\x83V[\x03\x90\xF3[a\x02\x18V[\x90V[_\x1B\x90V[a\x0B\0a\n\xFBa\x0B\x05\x92a\n\xE4V[a\n\xE7V[a\x07:V[\x90V[a\x0B\x11_a\n\xECV[\x90V[a\x0B\x1Ca\x0B\x08V[\x90V[4a\x0BOWa\x0B/6`\x04a\x03\x87V[a\x0BKa\x0B:a\x0B\x14V[a\x0BBa\x02\x12V[\x91\x82\x91\x82a\x07\x8BV[\x03\x90\xF3[a\x02\x18V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x0Bo\x90`\x08a\x0Bt\x93\x02a\x08\xFFV[a\x0BTV[\x90V[\x90a\x0B\x82\x91Ta\x0B_V[\x90V[a\x0B\x91`\x04_\x90a\x0BwV[\x90V[a\x0B\x9D\x90a\x04\x17V[\x90V[a\x0B\xA9\x90a\x0B\x94V[\x90RV[\x91\x90a\x0B\xC0\x90_` \x85\x01\x94\x01\x90a\x0B\xA0V[V[4a\x0B\xF2Wa\x0B\xD26`\x04a\x03\x87V[a\x0B\xEEa\x0B\xDDa\x0B\x85V[a\x0B\xE5a\x02\x12V[\x91\x82\x91\x82a\x0B\xADV[\x03\x90\xF3[a\x02\x18V[4a\x0C'Wa\x0C\x076`\x04a\x03\x87V[a\x0C#a\x0C\x12a\x1E\xA8V[a\x0C\x1Aa\x02\x12V[\x91\x82\x91\x82a\x02\x83V[\x03\x90\xF3[a\x02\x18V[a\x0C5\x90a\x08\x08V[\x90V[a\x0CA\x81a\x0C,V[\x03a\x0CHWV[_\x80\xFD[\x90P5\x90a\x0CY\x82a\x0C8V[V[\x90` \x82\x82\x03\x12a\x0CtWa\x0Cq\x91_\x01a\x0CLV[\x90V[a\x02\x1CV[4a\x0C\xA7Wa\x0C\x91a\x0C\x8C6`\x04a\x0C[V[a tV[a\x0C\x99a\x02\x12V[\x80a\x0C\xA3\x81a\x03NV[\x03\x90\xF3[a\x02\x18V[4a\x0C\xDCWa\x0C\xBC6`\x04a\x03\x87V[a\x0C\xD8a\x0C\xC7a \xF8V[a\x0C\xCFa\x02\x12V[\x91\x82\x91\x82a\x04\xCEV[\x03\x90\xF3[a\x02\x18V[\x90V[a\x0C\xF8a\x0C\xF3a\x0C\xFD\x92a\x0C\xE1V[a\x03\xF8V[a\x04\x89V[\x90V[a\r\x0Cb'\x8D\0a\x0C\xE4V[\x90V[a\r\x17a\r\0V[\x90V[4a\rJWa\r*6`\x04a\x03\x87V[a\rFa\r5a\r\x0FV[a\r=a\x02\x12V[\x91\x82\x91\x82a\x04\xCEV[\x03\x90\xF3[a\x02\x18V[4a\r\x7FWa\r_6`\x04a\x03\x87V[a\r{a\rja\"9V[a\rra\x02\x12V[\x91\x82\x91\x82a\x04\xCEV[\x03\x90\xF3[a\x02\x18V[a\r\xB9a\r\xC0\x94a\r\xAF``\x94\x98\x97\x95a\r\xA5`\x80\x86\x01\x9A_\x87\x01\x90a\x04\xC1V[` \x85\x01\x90a\x04\xC1V[`@\x83\x01\x90a\x04\xC1V[\x01\x90a\x02vV[V[4a\r\xF6Wa\r\xD26`\x04a\x03\x87V[a\r\xF2a\r\xDDa\"\x97V[\x90a\r\xE9\x94\x92\x94a\x02\x12V[\x94\x85\x94\x85a\r\x84V[\x03\x90\xF3[a\x02\x18V[4a\x0E*Wa\x0E\x14a\x0E\x0E6`\x04a\x087V[\x90a%sV[a\x0E\x1Ca\x02\x12V[\x80a\x0E&\x81a\x03NV[\x03\x90\xF3[a\x02\x18V[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[a\x0E[a\x0E/V[\x90V[4a\x0E\x8EWa\x0En6`\x04a\x03\x87V[a\x0E\x8Aa\x0Eya\x0ESV[a\x0E\x81a\x02\x12V[\x91\x82\x91\x82a\x07\x8BV[\x03\x90\xF3[a\x02\x18V[\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*\x90V[a\x0E\xBFa\x0E\x93V[\x90V[4a\x0E\xF2Wa\x0E\xD26`\x04a\x03\x87V[a\x0E\xEEa\x0E\xDDa\x0E\xB7V[a\x0E\xE5a\x02\x12V[\x91\x82\x91\x82a\x07\x8BV[\x03\x90\xF3[a\x02\x18V[4a\x0F'Wa\x0F\x076`\x04a\x03\x87V[a\x0F#a\x0F\x12a%\x7FV[a\x0F\x1Aa\x02\x12V[\x91\x82\x91\x82a\x04\xCEV[\x03\x90\xF3[a\x02\x18V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[a\x0FXa\x0F,V[\x90V[4a\x0F\x8BWa\x0Fk6`\x04a\x03\x87V[a\x0F\x87a\x0Fva\x0FPV[a\x0F~a\x02\x12V[\x91\x82\x91\x82a\x07\x8BV[\x03\x90\xF3[a\x02\x18V[_\x80\xFD[_\x90V[a\x0F\xA0a\x0F\x94V[P\x80a\x0F\xBBa\x0F\xB5cye\xDB\x0B`\xE0\x1Ba\x02$V[\x91a\x02$V[\x14\x90\x81\x15a\x0F\xC8W[P\x90V[a\x0F\xD2\x91Pa&%V[_a\x0F\xC4V[\x90a\x0F\xF2\x91a\x0F\xEDa\x0F\xE8a\x0F,V[a&KV[a\x12bV[V[a\x0F\xFD\x90a\x06[V[\x90V[P\x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a\x10-\x91\x02\x91a\x10'_\x19\x84a\x10\x0EV[\x92a\x10\x0EV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x10Ka\x10Fa\x10P\x92a\x04\x89V[a\x03\xF8V[a\x04\x89V[\x90V[\x90V[\x91\x90a\x10la\x10ga\x10t\x93a\x107V[a\x10SV[\x90\x83Ta\x10\x12V[\x90UV[_\x90V[a\x10\x8E\x91a\x10\x88a\x10xV[\x91a\x10VV[V[[\x81\x81\x10a\x10\x9CWPPV[\x80a\x10\xA9_`\x01\x93a\x10|V[\x01a\x10\x91V[\x91\x90`\x1F\x81\x11a\x10\xBFW[PPPV[a\x10\xCBa\x10\xF0\x93a\x05rV[\x90` a\x10\xD7\x84a\x10\x04V[\x83\x01\x93\x10a\x10\xF8W[a\x10\xE9\x90a\x10\x04V[\x01\x90a\x10\x90V[_\x80\x80a\x10\xBAV[\x91Pa\x10\xE9\x81\x92\x90Pa\x10\xE0V[\x90a\x11\x16\x90_\x19\x90`\x08\x02a\x08\xFFV[\x19\x16\x90V[\x81a\x11%\x91a\x11\x06V[\x90`\x02\x02\x17\x90V[\x91a\x118\x90\x82a\x10\0V[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x11\xF7Wa\x11\\\x82a\x11V\x85Ta\x05?V[\x85a\x10\xAFV[_\x90`\x1F\x83\x11`\x01\x14a\x11\x8FW\x91\x80\x91a\x11~\x93_\x92a\x11\x83W[PPa\x11\x1BV[\x90U[V[\x90\x91P\x015_\x80a\x11wV[`\x1F\x19\x83\x16\x91a\x11\x9E\x85a\x05rV[\x92_[\x81\x81\x10a\x11\xDFWP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x11\xC5W[PPP\x02\x01\x90Ua\x11\x81V[a\x11\xD5\x91\x015`\x1F\x84\x16\x90a\x11\x06V[\x90U_\x80\x80a\x11\xB9V[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a\x11\xA1V[a\x06\x1EV[\x90a\x12\x07\x92\x91a\x11-V[V[\x90\x82_\x93\x92\x827\x01RV[\x91\x90a\x12.\x81a\x12'\x81a\x123\x95a\x06\xA8V[\x80\x95a\x12\tV[a\x06\x14V[\x01\x90V[\x91a\x12Qa\x12_\x94\x92`@\x85\x01\x90\x85\x82\x03_\x87\x01Ra\x06\xBCV[\x92` \x81\x85\x03\x91\x01Ra\x12\x14V[\x90V[\x90a\x12m`\x05a\x0F\xF4V[a\x12z\x83\x83\x90`\x05a\x11\xFCV[\x91\x90\x91a\x12\xB3\x7F\xB9\xA2\x08\x84&\xF0;0\xA8\x1C\x06B\x80\x94\xFB\xFA\x9E&\x92s\x9B2A\xAFk\x9A\xB1\xDAKUF\xBE\x93a\x12\xAAa\x02\x12V[\x93\x84\x93\x84a\x127V[\x03\x90\xA1V[\x90a\x12\xC2\x91a\x0F\xD8V[V[a\x12\xD4a\x12\xCFa\x0E/V[a&KV[a\x12\xDCa\x13\xFAV[V[_\x1C\x90V[a\x12\xEFa\x12\xF4\x91a\x12\xDEV[a\t\x03V[\x90V[a\x13\x01\x90Ta\x12\xE3V[\x90V[a\x13\x18a\x13\x13a\x13\x1D\x92a\n\xE4V[a\x03\xF8V[a\x04\x89V[\x90V[a\x13,a\x131\x91a\x12\xDEV[a\x0BTV[\x90V[a\x13>\x90Ta\x13 V[\x90V[a\x13Ua\x13Pa\x13Z\x92a\n\xE4V[a\x03\xF8V[a\x03\xEDV[\x90V[a\x13f\x90a\x13AV[\x90V[_\x80\xFD[`\xE0\x1B\x90V[a\x13|\x81a\x02qV[\x03a\x13\x83WV[_\x80\xFD[\x90PQ\x90a\x13\x94\x82a\x13sV[V[\x90` \x82\x82\x03\x12a\x13\xAFWa\x13\xAC\x91_\x01a\x13\x87V[\x90V[a\x02\x1CV[a\x13\xBCa\x02\x12V[=_\x82>=\x90\xFD[\x90a\x13\xD0_\x19\x91a\n\xE7V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x13\xEFa\x13\xEAa\x13\xF6\x92a\x107V[a\x10SV[\x82Ta\x13\xC4V[\x90UV[a\x14\x04`\x03a\x12\xF7V[a\x14\x16a\x14\x10_a\x13\x04V[\x91a\x04\x89V[\x03a\x15rWa\x14-a\x14(`\x04a\x134V[a\x0B\x94V[a\x14Ga\x14Aa\x14<_a\x13]V[a\x08\x08V[\x91a\x08\x08V[\x14a\x15VWa\x14\x90` a\x14z\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04#V[c\x15\x8E\xF9>\x90a\x14\x88a\x02\x12V[\x93\x84\x92a\x13mV[\x82R\x81\x80a\x14\xA0`\x04\x82\x01a\x03NV[\x03\x91Z\xFA\x80\x15a\x15QWa\x14\xBC\x91_\x91a\x15#W[P\x15a\x02qV[a\x15\x07Wa\x14\xCBB`\x03a\x13\xDAV[Ba\x15\x02\x7F\x11\x94\xB04\xCF\xA9\xABX\x07IJ\x1D\\f}\x8B\x0En\x97\xF3\x88\x88t*\xA3\x87\x1A2 4\x11`\x91a\x14\xF9a\x02\x12V[\x91\x82\x91\x82a\x04\xCEV[\x03\x90\xA1V[_c\xA1M\x1B\xE7`\xE0\x1B\x81R\x80a\x15\x1F`\x04\x82\x01a\x03NV[\x03\x90\xFD[a\x15D\x91P` =\x81\x11a\x15JW[a\x15<\x81\x83a\x062V[\x81\x01\x90a\x13\x96V[_a\x14\xB5V[P=a\x152V[a\x13\xB4V[_c;\nH\xBD`\xE1\x1B\x81R\x80a\x15n`\x04\x82\x01a\x03NV[\x03\x90\xFD[_c8\xE9=\xBD`\xE1\x1B\x81R\x80a\x15\x8A`\x04\x82\x01a\x03NV[\x03\x90\xFD[a\x15\x96a\x12\xC4V[V[_\x90V[a\x15\xA5\x90a\x07:V[\x90V[\x90a\x15\xB2\x90a\x15\x9CV[_R` R`@_ \x90V[\x90V[a\x15\xCDa\x15\xD2\x91a\x12\xDEV[a\x15\xBEV[\x90V[a\x15\xDF\x90Ta\x15\xC1V[\x90V[`\x01a\x15\xFAa\x16\0\x92a\x15\xF3a\x15\x98V[P_a\x15\xA8V[\x01a\x15\xD5V[\x90V[a\x16\x0Ba&_V[a\x16\x13a\x16\x15V[V[a\x16\x1Da&\xB5V[a\x16%a\x16/V[a\x16-a'\x1AV[V[a\x16?a\x16:a\x0E/V[a&KV[a\x16Ga\x18lV[V[a\x16R\x81a\x04\x89V[\x03a\x16YWV[_\x80\xFD[\x90PQ\x90a\x16j\x82a\x16IV[V[\x90` \x82\x82\x03\x12a\x16\x85Wa\x16\x82\x91_\x01a\x16]V[\x90V[a\x02\x1CV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x16\xADa\x16\xB3\x91\x93\x92\x93a\x04\x89V[\x92a\x04\x89V[\x82\x03\x91\x82\x11a\x16\xBEWV[a\x16\x8AV[a\x16\xCC\x90a\x04\x17V[\x90V[a\x16\xD8\x90a\x08\x08V[\x90RV[\x91\x90a\x16\xEF\x90_` \x85\x01\x94\x01\x90a\x16\xCFV[V[a\x16\xFA\x90a\x08\x08V[\x90V[a\x17\x06\x81a\x16\xF1V[\x03a\x17\rWV[_\x80\xFD[\x90PQ\x90a\x17\x1E\x82a\x16\xFDV[V[\x90` \x82\x82\x03\x12a\x179Wa\x176\x91_\x01a\x17\x11V[\x90V[a\x02\x1CV[a\x17G\x90a\x04\x17V[\x90V[a\x17S\x90a\x03\xFBV[\x90V[a\x17_\x90a\x17JV[\x90V[a\x17k\x90a\x04\x17V[\x90V[_\x91\x03\x12a\x17xWV[a\x02\x1CV[\x90_\x92\x91\x80T\x90a\x17\x97a\x17\x90\x83a\x05?V[\x80\x94a\x06\xA8V[\x91`\x01\x81\x16\x90\x81_\x14a\x17\xEEWP`\x01\x14a\x17\xB2W[PPPV[a\x17\xBF\x91\x92\x93\x94Pa\x05rV[\x91_\x92[\x81\x84\x10a\x17\xD6WPP\x01\x90_\x80\x80a\x17\xADV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x17\xC3V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x17\xADV[a\x18-a\x18:\x94\x92\x93a\x18#``\x84\x01\x95_\x85\x01\x90a\x16\xCFV[` \x83\x01\x90a\x04\xC1V[`@\x81\x84\x03\x91\x01Ra\x17}V[\x90V[a\x18F\x90a\x04\x17V[\x90V[\x91` a\x18j\x92\x94\x93a\x18c`@\x82\x01\x96_\x83\x01\x90a\x04\xC1V[\x01\x90a\x04\xC1V[V[a\x18v`\x03a\x12\xF7V[a\x18\x88a\x18\x82_a\x13\x04V[\x91a\x04\x89V[\x14a\x1C]Wa\x18\x95a\x1E\xA8V[a\x1CAWa\x18\xA1a\"9V[a\x18\xE5` a\x18\xCF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04#V[cvg\x18\x08\x90a\x18\xDDa\x02\x12V[\x93\x84\x92a\x13mV[\x82R\x81\x80a\x18\xF5`\x04\x82\x01a\x03NV[\x03\x91Z\xFA\x90\x81\x15a\x1C<W_\x91a\x1C\x0EW[P\x90Ba\x194a\x19.a\x19)a\x19\x1Ba \xF8V[a\x19#a\x04\xA8V[\x90a\x16\x9EV[a\x04\x89V[\x91a\x04\x89V[\x10a\x1B\xF2W\x81a\x19La\x19F\x83a\x04\x89V[\x91a\x04\x89V[\x03a\x1B\xB8W[Pa\x19\xB4` a\x19\x81\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04#V[c\xE1\xF2~\xB8\x90a\x19\xA9_a\x19\x940a\x16\xC3V[\x93a\x19\x9Da\x02\x12V[\x96\x87\x95\x86\x94\x85\x93a\x13mV[\x83R`\x04\x83\x01a\x16\xDCV[\x03\x92Z\xF1\x90\x81\x15a\x1B\xB3W_\x91a\x1B\x85W[P\x90a\x1A\x0C` a\x19\xF6\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04#V[c[\xDFl\xA1\x90a\x1A\x04a\x02\x12V[\x93\x84\x92a\x13mV[\x82R\x81\x80a\x1A\x1C`\x04\x82\x01a\x03NV[\x03\x91Z\xFA\x90\x81\x15a\x1B\x80Wa\x1AA\x91a\x1A<\x91_\x91a\x1BRW[Pa\x17>V[a\x17VV[a\x1A^\x81a\x1AWa\x1AR`\x04a\x134V[a\x0B\x94V[\x85\x91a'\xA6V[a\x1Apa\x1Ak`\x04a\x134V[a\x0B\x94V[\x90a\x1A\x7Fc\x18\xB6\x8B\x8C\x91a\x17bV[\x84\x92`\x05\x92\x81;\x15a\x1BMW_a\x1A\xA9\x91a\x1A\xB4\x82\x96a\x1A\x9Da\x02\x12V[\x98\x89\x97\x88\x96\x87\x95a\x13mV[\x85R`\x04\x85\x01a\x18\tV[\x03\x92Z\xF1\x80\x15a\x1BHWa\x1B\x1CW[P\x90a\x1A\xD7a\x1A\xD2`\x04a\x134V[a\x0B\x94V[\x90a\x1B\x02\x7F4\xB7=\x0C\x96\xE9\xFFMS\x11CH\x17\xC8\xEC\xC90\xE7\xD2x,[\xDE.y\xDCD\xB0YgU\xBB\x92a\x18=V[\x92a\x1B\x17a\x1B\x0Ea\x02\x12V[\x92\x83\x92\x83a\x18IV[\x03\x90\xA2V[a\x1B;\x90_=\x81\x11a\x1BAW[a\x1B3\x81\x83a\x062V[\x81\x01\x90a\x17nV[_a\x1A\xC3V[P=a\x1B)V[a\x13\xB4V[a\x13iV[a\x1Bs\x91P` =\x81\x11a\x1ByW[a\x1Bk\x81\x83a\x062V[\x81\x01\x90a\x17 V[_a\x1A6V[P=a\x1BaV[a\x13\xB4V[a\x1B\xA6\x91P` =\x81\x11a\x1B\xACW[a\x1B\x9E\x81\x83a\x062V[\x81\x01\x90a\x16lV[_a\x19\xC6V[P=a\x1B\x94V[a\x13\xB4V[a\x1B\xCBa\x1B\xC5\x83\x92a\x04\x89V[\x91a\x04\x89V[\x11a\x1B\xD6W_a\x19RV[_c\x11UbK`\xE2\x1B\x81R\x80a\x1B\xEE`\x04\x82\x01a\x03NV[\x03\x90\xFD[_c=S\xC7S`\xE0\x1B\x81R\x80a\x1C\n`\x04\x82\x01a\x03NV[\x03\x90\xFD[a\x1C/\x91P` =\x81\x11a\x1C5W[a\x1C'\x81\x83a\x062V[\x81\x01\x90a\x16lV[_a\x19\x07V[P=a\x1C\x1DV[a\x13\xB4V[_c\x11UbK`\xE2\x1B\x81R\x80a\x1CY`\x04\x82\x01a\x03NV[\x03\x90\xFD[_c\x8F\x98@A`\xE0\x1B\x81R\x80a\x1Cu`\x04\x82\x01a\x03NV[\x03\x90\xFD[a\x1C\x81a\x16\x03V[V[\x90a\x1C\x9E\x91a\x1C\x99a\x1C\x94\x82a\x15\xE2V[a&KV[a\x1C\xA0V[V[\x90a\x1C\xAA\x91a(\xA7V[PV[\x90a\x1C\xB7\x91a\x1C\x83V[V[\x90\x80a\x1C\xD4a\x1C\xCEa\x1C\xC9a)VV[a\x08\x08V[\x91a\x08\x08V[\x03a\x1C\xE5Wa\x1C\xE2\x91a)cV[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a\x1C\xFD`\x04\x82\x01a\x03NV[\x03\x90\xFD[a\x1D\x11a\x1D\x0Ca\x0B\x08V[a&KV[a\x1D\x19a\x1D\x1BV[V[a\x1D#a*dV[V[a\x1D-a\x1D\x01V[V[a\x1D7a\x0F\x94V[Pa\x1DB`\x03a\x12\xF7V[a\x1DTa\x1DN_a\x13\x04V[\x91a\x04\x89V[\x11\x90V[`\xFF\x16\x90V[a\x1Dja\x1Do\x91a\x12\xDEV[a\x1DXV[\x90V[a\x1D|\x90Ta\x1D^V[\x90V[a\x1D\x87a\x0F\x94V[Pa\x1D\x92`\x01a\x1DrV[\x90V[a\x1D\x9Da\x10xV[Pa\x1D\xE2` a\x1D\xCC\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04#V[cvg\x18\x08\x90a\x1D\xDAa\x02\x12V[\x93\x84\x92a\x13mV[\x82R\x81\x80a\x1D\xF2`\x04\x82\x01a\x03NV[\x03\x91Z\xFA\x90\x81\x15a\x1E6W_\x91a\x1E\x08W[P\x90V[a\x1E)\x91P` =\x81\x11a\x1E/W[a\x1E!\x81\x83a\x062V[\x81\x01\x90a\x16lV[_a\x1E\x04V[P=a\x1E\x17V[a\x13\xB4V[a\x1EKa\x1EFa\x0E\x93V[a&KV[a\x1ESa\x1EUV[V[a\x1E]a*\xCEV[V[a\x1Ega\x1E;V[V[\x90a\x1Es\x90a\x18=V[_R` R`@_ \x90V[a\x1E\xA5\x91_a\x1E\x9Aa\x1E\xA0\x93a\x1E\x93a\x0F\x94V[P\x82a\x15\xA8V[\x01a\x1EiV[a\x1DrV[\x90V[a\x1E\xB0a\x0F\x94V[Pa\x1E\xF5` a\x1E\xDF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04#V[c\xFA9\x1Cd\x90a\x1E\xEDa\x02\x12V[\x93\x84\x92a\x13mV[\x82R\x81\x80a\x1F\x05`\x04\x82\x01a\x03NV[\x03\x91Z\xFA\x90\x81\x15a\x1FIW_\x91a\x1F\x1BW[P\x90V[a\x1F<\x91P` =\x81\x11a\x1FBW[a\x1F4\x81\x83a\x062V[\x81\x01\x90a\x13\x96V[_a\x1F\x17V[P=a\x1F*V[a\x13\xB4V[a\x1Fg\x90a\x1Fba\x1F]a\x0F,V[a&KV[a\x1F\xBFV[V[\x90a\x1Fz`\x01\x80`\xA0\x1B\x03\x91a\n\xE7V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1F\x8D\x90a\x03\xFBV[\x90V[a\x1F\x99\x90a\x1F\x84V[\x90V[\x90V[\x90a\x1F\xB4a\x1F\xAFa\x1F\xBB\x92a\x1F\x90V[a\x1F\x9CV[\x82Ta\x1FiV[\x90UV[a\x1F\xC8\x81a\x0B\x94V[a\x1F\xE2a\x1F\xDCa\x1F\xD7_a\x13]V[a\x08\x08V[\x91a\x08\x08V[\x14a XWa \ra\x1F\xFCa\x1F\xF7`\x04a\x134V[a\x0B\x94V[a \x07\x83`\x04a\x1F\x9FV[\x91a\x0B\x94V[a @a :\x7F\x07\x01[j\x9F\x05\x911H\xFD_\xAD\xDF*\xCC\x97\x08\xF3\x05\x93\x7F0r\xCA+KF\xFA\xA5\xD0\x89\x8B\x93a\x18=V[\x91a\x18=V[\x91a Ia\x02\x12V[\x80a S\x81a\x03NV[\x03\x90\xA3V[_c\xD9.#=`\xE0\x1B\x81R\x80a p`\x04\x82\x01a\x03NV[\x03\x90\xFD[a }\x90a\x1FNV[V[\x90V[a \x96a \x91a \x9B\x92a \x7FV[a\x03\xF8V[a\x04\x89V[\x90V[a \xADa \xB3\x91\x93\x92\x93a\x04\x89V[\x92a\x04\x89V[\x82\x01\x80\x92\x11a \xBEWV[a\x16\x8AV[a \xD2a \xD8\x91\x93\x92\x93a\x04\x89V[\x92a\x04\x89V[\x91a \xE4\x83\x82\x02a\x04\x89V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a \xF3WV[a\x16\x8AV[a!\0a\x10xV[Pa!\x0B`\x03a\x12\xF7V[a!\x1Da!\x17_a\x13\x04V[\x91a\x04\x89V[\x14a!\xF7Wa!f` a!P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04#V[cvg\x18\x08\x90a!^a\x02\x12V[\x93\x84\x92a\x13mV[\x82R\x81\x80a!v`\x04\x82\x01a\x03NV[\x03\x91Z\xFA\x80\x15a!\xF2Wa!\xC1\x91_\x91a!\xC4W[Pa!\xBBa!\xADa!\x9C`\x03a\x12\xF7V[\x92a!\xA7`\x01a \x82V[\x90a \x9EV[a!\xB5a\r\0V[\x90a \xC3V[\x90a \x9EV[\x90V[a!\xE5\x91P` =\x81\x11a!\xEBW[a!\xDD\x81\x83a\x062V[\x81\x01\x90a\x16lV[_a!\x8BV[P=a!\xD3V[a\x13\xB4V[a\"\0_a\x13\x04V[\x90V[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a\"#a\")\x91a\x04\x89V[\x91a\x04\x89V[\x90\x81\x15a\"4W\x04\x90V[a\"\x03V[a\"Aa\x10xV[Pa\"L`\x03a\x12\xF7V[a\"^a\"X_a\x13\x04V[\x91a\x04\x89V[\x14a\"\x8BWa\"\x88a\"zBa\"t`\x03a\x12\xF7V[\x90a\x16\x9EV[a\"\x82a\r\0V[\x90a\"\x17V[\x90V[a\"\x94_a\x13\x04V[\x90V[a\"\x9Fa\x10xV[Pa\"\xA8a\x10xV[Pa\"\xB1a\x10xV[Pa\"\xBAa\x0F\x94V[Pa\"\xC5`\x03a\x12\xF7V[a\"\xD7a\"\xD1_a\x13\x04V[\x91a\x04\x89V[\x14a%#Wa\"\xE4a\"9V[a#(` a#\x12\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04#V[cvg\x18\x08\x90a# a\x02\x12V[\x93\x84\x92a\x13mV[\x82R\x81\x80a#8`\x04\x82\x01a\x03NV[\x03\x91Z\xFA\x90\x81\x15a%\x1EW_\x91a$\xF0W[P\x91a#Ta \xF8V[\x90a#^_a\x13\x04V[\x93a#pa#ja\x1E\xA8V[\x15a\x02qV[\x80a$\xD6W[a$4W[a#\x85`\x03a\x12\xF7V[a#\x97a#\x91_a\x13\x04V[\x91a\x04\x89V[\x11\x90\x81a$\x17W[P\x80a$\0W[\x80a#\xD4W[\x80a#\xBDW[\x92\x91\x93\x92\x91\x93\x92\x91\x90V[Pa#\xCFa#\xC9a\x1D\x7FV[\x15a\x02qV[a#\xB2V[PBa#\xF9a#\xF3a#\xEE\x85a#\xE8a\x04\xA8V[\x90a\x16\x9EV[a\x04\x89V[\x91a\x04\x89V[\x10\x15a#\xACV[Pa$\x12a$\x0Ca\x1E\xA8V[\x15a\x02qV[a#\xA6V[\x90Pa$,a$&\x85\x92a\x04\x89V[\x91a\x04\x89V[\x10\x15_a#\x9FV[\x93Pa$z` a$d\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04#V[c\x80W/\x18\x90a$ra\x02\x12V[\x93\x84\x92a\x13mV[\x82R\x81\x80a$\x8A`\x04\x82\x01a\x03NV[\x03\x91Z\xFA\x90\x81\x15a$\xD1W_\x91a$\xA3W[P\x93a#{V[a$\xC4\x91P` =\x81\x11a$\xCAW[a$\xBC\x81\x83a\x062V[\x81\x01\x90a\x16lV[_a$\x9CV[P=a$\xB2V[a\x13\xB4V[P\x80a$\xEAa$\xE4\x86a\x04\x89V[\x91a\x04\x89V[\x14a#vV[a%\x11\x91P` =\x81\x11a%\x17W[a%\t\x81\x83a\x062V[\x81\x01\x90a\x16lV[_a#JV[P=a$\xFFV[a\x13\xB4V[_\x90_\x91_\x91a%Ea%?a%9_\x94a\x13\x04V[\x95a\x13\x04V[\x93a\x13\x04V[\x91\x90V[\x90a%d\x91a%_a%Z\x82a\x15\xE2V[a&KV[a%fV[V[\x90a%p\x91a)cV[PV[\x90a%}\x91a%IV[V[a%\x87a\x10xV[Pa%\xCC` a%\xB6\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04#V[c\xDF\x02D\xB1\x90a%\xC4a\x02\x12V[\x93\x84\x92a\x13mV[\x82R\x81\x80a%\xDC`\x04\x82\x01a\x03NV[\x03\x91Z\xFA\x90\x81\x15a& W_\x91a%\xF2W[P\x90V[a&\x13\x91P` =\x81\x11a&\x19W[a&\x0B\x81\x83a\x062V[\x81\x01\x90a\x16lV[_a%\xEEV[P=a&\x01V[a\x13\xB4V[a&-a\x0F\x94V[Pa&Ga&Ac\x01\xFF\xC9\xA7`\xE0\x1Ba\x02$V[\x91a\x02$V[\x14\x90V[a&]\x90a&Wa)VV[\x90a*\xFBV[V[a&ga\x1D\x7FV[a&mWV[_c\xD9<\x06e`\xE0\x1B\x81R\x80a&\x85`\x04\x82\x01a\x03NV[\x03\x90\xFD[\x90V[a&\xA0a&\x9Ba&\xA5\x92a&\x89V[a\x03\xF8V[a\x04\x89V[\x90V[a&\xB2`\x02a&\x8CV[\x90V[a&\xBF`\x02a\x12\xF7V[a&\xD8a&\xD2a&\xCDa&\xA8V[a\x04\x89V[\x91a\x04\x89V[\x14a&\xF1Wa&\xEFa&\xE8a&\xA8V[`\x02a\x13\xDAV[V[_c>\xE5\xAE\xB5`\xE0\x1B\x81R\x80a'\t`\x04\x82\x01a\x03NV[\x03\x90\xFD[a'\x17`\x01a \x82V[\x90V[a',a'%a'\rV[`\x02a\x13\xDAV[V[c\xFF\xFF\xFF\xFF\x16\x90V[a'Ka'Fa'P\x92a'.V[a\x13mV[a\x02$V[\x90V[\x91` a't\x92\x94\x93a'm`@\x82\x01\x96_\x83\x01\x90a\x16\xCFV[\x01\x90a\x04\xC1V[V[a'\x7F\x90a\x13\x04V[\x90RV[\x91` a'\xA4\x92\x94\x93a'\x9D`@\x82\x01\x96_\x83\x01\x90a\x16\xCFV[\x01\x90a'vV[V[\x90\x91a'\xE9`\x04\x91a'\xDAc\t^\xA7\xB3a'\xC1\x87\x93\x91a'7V[\x92a'\xCAa\x02\x12V[\x95\x86\x94` \x86\x01\x90\x81R\x01a'SV[` \x82\x01\x81\x03\x82R\x03\x82a\x062V[\x90a'\xFEa'\xF8\x82\x84\x90a+6V[\x15a\x02qV[a(\x08W[PPPV[a(U`\x04a(Z\x94a(P\x84\x91a(Ac\t^\xA7\xB3a((_\x91a'7V[\x92a(1a\x02\x12V[\x96\x87\x94` \x86\x01\x90\x81R\x01a'\x83V[` \x82\x01\x81\x03\x82R\x03\x83a\x062V[a+\xD8V[a+\xD8V[_\x80\x80a(\x03V[\x90a(n`\xFF\x91a\n\xE7V[\x91\x81\x19\x16\x91\x16\x17\x90V[a(\x81\x90a\x02qV[\x90V[\x90V[\x90a(\x9Ca(\x97a(\xA3\x92a(xV[a(\x84V[\x82Ta(bV[\x90UV[a(\xAFa\x0F\x94V[Pa(\xC4a(\xBE\x82\x84\x90a\x1E\x7FV[\x15a\x02qV[_\x14a)LWa(\xEB`\x01a(\xE6_a(\xDE\x81\x86\x90a\x15\xA8V[\x01\x85\x90a\x1EiV[a(\x87V[\x90a(\xF4a)VV[\x90a)1a)+a)%\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\x15\x9CV[\x92a\x18=V[\x92a\x18=V[\x92a):a\x02\x12V[\x80a)D\x81a\x03NV[\x03\x90\xA4`\x01\x90V[PP_\x90V[_\x90V[a)^a)RV[P3\x90V[a)ka\x0F\x94V[Pa)w\x81\x83\x90a\x1E\x7FV[_\x14a)\xFEWa)\x9D_a)\x98_a)\x90\x81\x86\x90a\x15\xA8V[\x01\x85\x90a\x1EiV[a(\x87V[\x90a)\xA6a)VV[\x90a)\xE3a)\xDDa)\xD7\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a\x15\x9CV[\x92a\x18=V[\x92a\x18=V[\x92a)\xECa\x02\x12V[\x80a)\xF6\x81a\x03NV[\x03\x90\xA4`\x01\x90V[PP_\x90V[a*\x0Ca,\x8CV[a*\x14a*\x16V[V[a*!_`\x01a(\x87V[a*)a)VV[a*_\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA\x91a*Va\x02\x12V[\x91\x82\x91\x82a\x16\xDCV[\x03\x90\xA1V[a*la*\x04V[V[a*va&_V[a*~a*\x80V[V[a*\x8B`\x01\x80a(\x87V[a*\x93a)VV[a*\xC9\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X\x91a*\xC0a\x02\x12V[\x91\x82\x91\x82a\x16\xDCV[\x03\x90\xA1V[a*\xD6a*nV[V[\x91` a*\xF9\x92\x94\x93a*\xF2`@\x82\x01\x96_\x83\x01\x90a\x16\xCFV[\x01\x90a\x07~V[V[\x90a+\x10a+\n\x83\x83\x90a\x1E\x7FV[\x15a\x02qV[a+\x18WPPV[a+2_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01a*\xD8V[\x03\x90\xFD[\x90_` \x91a+Ca\x0F\x94V[Pa+La\x0F\x94V[Pa+Ua\x10xV[Pa+^a\x10xV[P\x82\x81Q\x91\x01\x82\x85Z\xF1=\x91_Q\x91\x92\x83a+zW[PPP\x90V[\x90\x91\x92Pa+\x90a+\x8A_a\x13\x04V[\x91a\x04\x89V[\x14_\x14a+\xBEWa+\xA1\x91Pa\x17bV[;a+\xB4a+\xAE_a\x13\x04V[\x91a\x04\x89V[\x11[_\x80\x80a+tV[Pa+\xD2a+\xCC`\x01a \x82V[\x91a\x04\x89V[\x14a+\xB6V[\x90_` \x91a+\xE5a\x10xV[Pa+\xEEa\x10xV[P\x82\x81Q\x91\x01\x82\x85Z\xF1\x15a,\x81W=_Q\x90a,\x13a,\r_a\x13\x04V[\x91a\x04\x89V[\x14_\x14a,gWPa,$\x81a\x17bV[;a,7a,1_a\x13\x04V[\x91a\x04\x89V[\x14[a,@WPV[a,La,c\x91a\x17bV[_\x91\x82\x91cRt\xAF\xE7`\xE0\x1B\x83R`\x04\x83\x01a\x16\xDCV[\x03\x90\xFD[a,za,t`\x01a \x82V[\x91a\x04\x89V[\x14\x15a,9V[`@Q=_\x82>=\x90\xFD[a,\x9Da,\x97a\x1D\x7FV[\x15a\x02qV[a,\xA3WV[_c\x8D\xFC +`\xE0\x1B\x81R\x80a,\xBB`\x04\x82\x01a\x03NV[\x03\x90\xFD",
    );
    /**Custom error with signature `AccessControlBadConfirmation()` and selector `0x6697b232`.
```solidity
error AccessControlBadConfirmation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlBadConfirmation {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlBadConfirmation>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlBadConfirmation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlBadConfirmation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlBadConfirmation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlBadConfirmation()";
            const SELECTOR: [u8; 4] = [102u8, 151u8, 178u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `AccessControlUnauthorizedAccount(address,bytes32)` and selector `0xe2517d3f`.
```solidity
error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub neededRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlUnauthorizedAccount) -> Self {
                (value.account, value.neededRole)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    neededRole: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlUnauthorizedAccount(address,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 81u8, 125u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.neededRole),
                )
            }
        }
    };
    /**Custom error with signature `AllEmissionsCompleted()` and selector `0x4555892c`.
```solidity
error AllEmissionsCompleted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AllEmissionsCompleted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AllEmissionsCompleted> for UnderlyingRustTuple<'_> {
            fn from(value: AllEmissionsCompleted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AllEmissionsCompleted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AllEmissionsCompleted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AllEmissionsCompleted()";
            const SELECTOR: [u8; 4] = [69u8, 85u8, 137u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `BridgeNotConfigured()` and selector `0x7614917a`.
```solidity
error BridgeNotConfigured();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BridgeNotConfigured {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BridgeNotConfigured> for UnderlyingRustTuple<'_> {
            fn from(value: BridgeNotConfigured) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BridgeNotConfigured {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BridgeNotConfigured {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BridgeNotConfigured()";
            const SELECTOR: [u8; 4] = [118u8, 20u8, 145u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `CalculatorNotInitialized()` and selector `0xa14d1be7`.
```solidity
error CalculatorNotInitialized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CalculatorNotInitialized {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CalculatorNotInitialized>
        for UnderlyingRustTuple<'_> {
            fn from(value: CalculatorNotInitialized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for CalculatorNotInitialized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CalculatorNotInitialized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CalculatorNotInitialized()";
            const SELECTOR: [u8; 4] = [161u8, 77u8, 27u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionTooEarly()` and selector `0x3d53c753`.
```solidity
error EmissionTooEarly();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionTooEarly {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionTooEarly> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionTooEarly) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionTooEarly {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionTooEarly {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionTooEarly()";
            const SELECTOR: [u8; 4] = [61u8, 83u8, 199u8, 83u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionsAlreadyStarted()` and selector `0x71d27b7a`.
```solidity
error EmissionsAlreadyStarted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionsAlreadyStarted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionsAlreadyStarted> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionsAlreadyStarted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionsAlreadyStarted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionsAlreadyStarted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionsAlreadyStarted()";
            const SELECTOR: [u8; 4] = [113u8, 210u8, 123u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionsNotStarted()` and selector `0x8f984041`.
```solidity
error EmissionsNotStarted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionsNotStarted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionsNotStarted> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionsNotStarted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionsNotStarted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionsNotStarted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionsNotStarted()";
            const SELECTOR: [u8; 4] = [143u8, 152u8, 64u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EnforcedPause()` and selector `0xd93c0665`.
```solidity
error EnforcedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EnforcedPause {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EnforcedPause> for UnderlyingRustTuple<'_> {
            fn from(value: EnforcedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EnforcedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EnforcedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EnforcedPause()";
            const SELECTOR: [u8; 4] = [217u8, 60u8, 6u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ExpectedPause()` and selector `0x8dfc202b`.
```solidity
error ExpectedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExpectedPause {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExpectedPause> for UnderlyingRustTuple<'_> {
            fn from(value: ExpectedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExpectedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExpectedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExpectedPause()";
            const SELECTOR: [u8; 4] = [141u8, 252u8, 32u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ReentrancyGuardReentrantCall()` and selector `0x3ee5aeb5`.
```solidity
error ReentrancyGuardReentrantCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ReentrancyGuardReentrantCall {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ReentrancyGuardReentrantCall>
        for UnderlyingRustTuple<'_> {
            fn from(value: ReentrancyGuardReentrantCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ReentrancyGuardReentrantCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ReentrancyGuardReentrantCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ReentrancyGuardReentrantCall()";
            const SELECTOR: [u8; 4] = [62u8, 229u8, 174u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `SafeERC20FailedOperation(address)` and selector `0x5274afe7`.
```solidity
error SafeERC20FailedOperation(address token);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SafeERC20FailedOperation {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SafeERC20FailedOperation>
        for UnderlyingRustTuple<'_> {
            fn from(value: SafeERC20FailedOperation) -> Self {
                (value.token,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SafeERC20FailedOperation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { token: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SafeERC20FailedOperation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SafeERC20FailedOperation(address)";
            const SELECTOR: [u8; 4] = [82u8, 116u8, 175u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ZeroAddress()` and selector `0xd92e233d`.
```solidity
error ZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAddress {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAddress()";
            const SELECTOR: [u8; 4] = [217u8, 46u8, 35u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Event with signature `BridgeDataUpdated(bytes,bytes)` and selector `0xb9a2088426f03b30a81c06428094fbfa9e2692739b3241af6b9ab1da4b5546be`.
```solidity
event BridgeDataUpdated(bytes oldData, bytes newData);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeDataUpdated {
        #[allow(missing_docs)]
        pub oldData: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub newData: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeDataUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "BridgeDataUpdated(bytes,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                185u8,
                162u8,
                8u8,
                132u8,
                38u8,
                240u8,
                59u8,
                48u8,
                168u8,
                28u8,
                6u8,
                66u8,
                128u8,
                148u8,
                251u8,
                250u8,
                158u8,
                38u8,
                146u8,
                115u8,
                155u8,
                50u8,
                65u8,
                175u8,
                107u8,
                154u8,
                177u8,
                218u8,
                75u8,
                85u8,
                70u8,
                190u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldData: data.0,
                    newData: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.oldData,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.newData,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeDataUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeDataUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeDataUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeProxyUpdated(address,address)` and selector `0x07015b6a9f05913148fd5faddf2acc9708f305937f3072ca2b4b46faa5d0898b`.
```solidity
event BridgeProxyUpdated(address indexed oldProxy, address indexed newProxy);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeProxyUpdated {
        #[allow(missing_docs)]
        pub oldProxy: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newProxy: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeProxyUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeProxyUpdated(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                7u8,
                1u8,
                91u8,
                106u8,
                159u8,
                5u8,
                145u8,
                49u8,
                72u8,
                253u8,
                95u8,
                173u8,
                223u8,
                42u8,
                204u8,
                151u8,
                8u8,
                243u8,
                5u8,
                147u8,
                127u8,
                48u8,
                114u8,
                202u8,
                43u8,
                75u8,
                70u8,
                250u8,
                165u8,
                208u8,
                137u8,
                139u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldProxy: topics.1,
                    newProxy: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.oldProxy.clone(),
                    self.newProxy.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.oldProxy,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newProxy,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeProxyUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeProxyUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeProxyUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionMinted(uint256,uint256,address)` and selector `0x34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb`.
```solidity
event EmissionMinted(uint256 epoch, uint256 amount, address indexed destination);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionMinted {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub destination: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionMinted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "EmissionMinted(uint256,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                52u8,
                183u8,
                61u8,
                12u8,
                150u8,
                233u8,
                255u8,
                77u8,
                83u8,
                17u8,
                67u8,
                72u8,
                23u8,
                200u8,
                236u8,
                201u8,
                48u8,
                231u8,
                210u8,
                120u8,
                44u8,
                91u8,
                222u8,
                46u8,
                121u8,
                220u8,
                68u8,
                176u8,
                89u8,
                103u8,
                85u8,
                187u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    epoch: data.0,
                    amount: data.1,
                    destination: topics.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epoch),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.destination.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.destination,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionMinted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionMinted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionMinted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionsStarted(uint256)` and selector `0x1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a3220341160`.
```solidity
event EmissionsStarted(uint256 startTime);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionsStarted {
        #[allow(missing_docs)]
        pub startTime: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionsStarted {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EmissionsStarted(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                17u8,
                148u8,
                176u8,
                52u8,
                207u8,
                169u8,
                171u8,
                88u8,
                7u8,
                73u8,
                74u8,
                29u8,
                92u8,
                102u8,
                125u8,
                139u8,
                14u8,
                110u8,
                151u8,
                243u8,
                136u8,
                136u8,
                116u8,
                42u8,
                163u8,
                135u8,
                26u8,
                50u8,
                32u8,
                52u8,
                17u8,
                96u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { startTime: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startTime),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionsStarted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionsStarted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionsStarted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Paused(address)` and selector `0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258`.
```solidity
event Paused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Paused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Paused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Paused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                98u8,
                231u8,
                140u8,
                234u8,
                1u8,
                190u8,
                227u8,
                32u8,
                205u8,
                78u8,
                66u8,
                2u8,
                112u8,
                181u8,
                234u8,
                116u8,
                0u8,
                13u8,
                17u8,
                176u8,
                201u8,
                247u8,
                71u8,
                84u8,
                235u8,
                219u8,
                252u8,
                84u8,
                75u8,
                5u8,
                162u8,
                88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Paused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Paused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Paused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Unpaused(address)` and selector `0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa`.
```solidity
event Unpaused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Unpaused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Unpaused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Unpaused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8,
                185u8,
                238u8,
                10u8,
                73u8,
                91u8,
                242u8,
                230u8,
                255u8,
                156u8,
                145u8,
                167u8,
                131u8,
                76u8,
                27u8,
                164u8,
                253u8,
                210u8,
                68u8,
                165u8,
                232u8,
                170u8,
                78u8,
                83u8,
                123u8,
                211u8,
                138u8,
                234u8,
                228u8,
                176u8,
                115u8,
                170u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Unpaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Unpaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Unpaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address _emissionsCalculator, address defaultAdmin, address emissionsManager, address pauser);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub _emissionsCalculator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub defaultAdmin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub emissionsManager: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub pauser: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value._emissionsCalculator,
                        value.defaultAdmin,
                        value.emissionsManager,
                        value.pauser,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _emissionsCalculator: tuple.0,
                        defaultAdmin: tuple.1,
                        emissionsManager: tuple.2,
                        pauser: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._emissionsCalculator,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.defaultAdmin,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.emissionsManager,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.pauser,
                    ),
                )
            }
        }
    };
    /**Function with signature `BRIDGE_MANAGER_ROLE()` and selector `0xf75e8512`.
```solidity
function BRIDGE_MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_MANAGER_ROLECall {}
    ///Container type for the return parameters of the [`BRIDGE_MANAGER_ROLE()`](BRIDGE_MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_MANAGER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_MANAGER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BRIDGE_MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BRIDGE_MANAGER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BRIDGE_MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [247u8, 94u8, 133u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall {}
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DEFAULT_ADMIN_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSIONS_MANAGER_ROLE()` and selector `0xe3abdfcb`.
```solidity
function EMISSIONS_MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_MANAGER_ROLECall {}
    ///Container type for the return parameters of the [`EMISSIONS_MANAGER_ROLE()`](EMISSIONS_MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_MANAGER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_MANAGER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSIONS_MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSIONS_MANAGER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSIONS_MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [227u8, 171u8, 223u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSION_BUFFER_TIME()` and selector `0x243a30cc`.
```solidity
function EMISSION_BUFFER_TIME() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_BUFFER_TIMECall {}
    ///Container type for the return parameters of the [`EMISSION_BUFFER_TIME()`](EMISSION_BUFFER_TIMECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_BUFFER_TIMEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_BUFFER_TIMECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_BUFFER_TIMECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_BUFFER_TIMECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_BUFFER_TIMEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_BUFFER_TIMEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_BUFFER_TIMEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSION_BUFFER_TIMECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSION_BUFFER_TIMEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSION_BUFFER_TIME()";
            const SELECTOR: [u8; 4] = [36u8, 58u8, 48u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EPOCH_DURATION()` and selector `0xa70b9f0c`.
```solidity
function EPOCH_DURATION() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EPOCH_DURATIONCall {}
    ///Container type for the return parameters of the [`EPOCH_DURATION()`](EPOCH_DURATIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EPOCH_DURATIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EPOCH_DURATIONCall> for UnderlyingRustTuple<'_> {
                fn from(value: EPOCH_DURATIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for EPOCH_DURATIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EPOCH_DURATIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EPOCH_DURATIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EPOCH_DURATIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EPOCH_DURATIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EPOCH_DURATIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EPOCH_DURATION()";
            const SELECTOR: [u8; 4] = [167u8, 11u8, 159u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PAUSER_ROLE()` and selector `0xe63ab1e9`.
```solidity
function PAUSER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PAUSER_ROLECall {}
    ///Container type for the return parameters of the [`PAUSER_ROLE()`](PAUSER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PAUSER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PAUSER_ROLECall> for UnderlyingRustTuple<'_> {
                fn from(value: PAUSER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PAUSER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PAUSER_ROLEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: PAUSER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PAUSER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PAUSER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PAUSER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PAUSER_ROLE()";
            const SELECTOR: [u8; 4] = [230u8, 58u8, 177u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `TOTAL_EPOCHS()` and selector `0x5f15c3c9`.
```solidity
function TOTAL_EPOCHS() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_EPOCHSCall {}
    ///Container type for the return parameters of the [`TOTAL_EPOCHS()`](TOTAL_EPOCHSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_EPOCHSReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_EPOCHSCall> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_EPOCHSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_EPOCHSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_EPOCHSReturn> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_EPOCHSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_EPOCHSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TOTAL_EPOCHSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = TOTAL_EPOCHSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TOTAL_EPOCHS()";
            const SELECTOR: [u8; 4] = [95u8, 21u8, 195u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeData()` and selector `0x2481bb5c`.
```solidity
function bridgeData() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeDataCall {}
    ///Container type for the return parameters of the [`bridgeData()`](bridgeDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeDataReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeDataReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeDataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeDataReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeData()";
            const SELECTOR: [u8; 4] = [36u8, 129u8, 187u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeProxy()` and selector `0xa3d4485b`.
```solidity
function bridgeProxy() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeProxyCall {}
    ///Container type for the return parameters of the [`bridgeProxy()`](bridgeProxyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeProxyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeProxyCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeProxyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeProxyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeProxyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeProxyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeProxyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeProxyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeProxyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeProxy()";
            const SELECTOR: [u8; 4] = [163u8, 212u8, 72u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `currentEpoch()` and selector `0x76671808`.
```solidity
function currentEpoch() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentEpochCall {}
    ///Container type for the return parameters of the [`currentEpoch()`](currentEpochCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentEpochReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentEpochCall> for UnderlyingRustTuple<'_> {
                fn from(value: currentEpochCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentEpochCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentEpochReturn> for UnderlyingRustTuple<'_> {
                fn from(value: currentEpochReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentEpochReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for currentEpochCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = currentEpochReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "currentEpoch()";
            const SELECTOR: [u8; 4] = [118u8, 103u8, 24u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsCalculator()` and selector `0x2312d7d7`.
```solidity
function emissionsCalculator() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsCalculatorCall {}
    ///Container type for the return parameters of the [`emissionsCalculator()`](emissionsCalculatorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsCalculatorReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsCalculatorCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsCalculatorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsCalculatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsCalculatorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsCalculatorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsCalculatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsCalculatorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsCalculatorReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsCalculator()";
            const SELECTOR: [u8; 4] = [35u8, 18u8, 215u8, 215u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsEnded()` and selector `0xa4d7e31d`.
```solidity
function emissionsEnded() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsEndedCall {}
    ///Container type for the return parameters of the [`emissionsEnded()`](emissionsEndedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsEndedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsEndedCall> for UnderlyingRustTuple<'_> {
                fn from(value: emissionsEndedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for emissionsEndedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsEndedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsEndedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsEndedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsEndedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsEndedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsEnded()";
            const SELECTOR: [u8; 4] = [164u8, 215u8, 227u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsStartTime()` and selector `0x48b0daa6`.
```solidity
function emissionsStartTime() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartTimeCall {}
    ///Container type for the return parameters of the [`emissionsStartTime()`](emissionsStartTimeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartTimeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartTimeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartTimeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartTimeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartTimeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartTimeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartTimeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsStartTimeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsStartTimeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsStartTime()";
            const SELECTOR: [u8; 4] = [72u8, 176u8, 218u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsStarted()` and selector `0x5adf0021`.
```solidity
function emissionsStarted() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartedCall {}
    ///Container type for the return parameters of the [`emissionsStarted()`](emissionsStartedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsStartedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsStartedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsStarted()";
            const SELECTOR: [u8; 4] = [90u8, 223u8, 0u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCurrentEpoch()` and selector `0xb97dd9e2`.
```solidity
function getCurrentEpoch() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochCall {}
    ///Container type for the return parameters of the [`getCurrentEpoch()`](getCurrentEpochCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochCall> for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getCurrentEpochCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentEpochReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentEpochCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCurrentEpochReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentEpoch()";
            const SELECTOR: [u8; 4] = [185u8, 125u8, 217u8, 226u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCurrentEpochInfo()` and selector `0xbabc394f`.
```solidity
function getCurrentEpochInfo() external view returns (uint256 epoch, uint256 nextEmissionTime, uint256 nextEmissionAmount, bool canMintEmission);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochInfoCall {}
    ///Container type for the return parameters of the [`getCurrentEpochInfo()`](getCurrentEpochInfoCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochInfoReturn {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nextEmissionTime: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nextEmissionAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub canMintEmission: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochInfoCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochInfoCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentEpochInfoCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                bool,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochInfoReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochInfoReturn) -> Self {
                    (
                        value.epoch,
                        value.nextEmissionTime,
                        value.nextEmissionAmount,
                        value.canMintEmission,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentEpochInfoReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epoch: tuple.0,
                        nextEmissionTime: tuple.1,
                        nextEmissionAmount: tuple.2,
                        canMintEmission: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentEpochInfoCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCurrentEpochInfoReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentEpochInfo()";
            const SELECTOR: [u8; 4] = [186u8, 188u8, 57u8, 79u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getNextEmissionTime()` and selector `0xa5b326be`.
```solidity
function getNextEmissionTime() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getNextEmissionTimeCall {}
    ///Container type for the return parameters of the [`getNextEmissionTime()`](getNextEmissionTimeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getNextEmissionTimeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getNextEmissionTimeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getNextEmissionTimeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getNextEmissionTimeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getNextEmissionTimeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getNextEmissionTimeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getNextEmissionTimeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getNextEmissionTimeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getNextEmissionTimeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getNextEmissionTime()";
            const SELECTOR: [u8; 4] = [165u8, 179u8, 38u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRoleAdminReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasRoleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mintEmission()` and selector `0x284e1333`.
```solidity
function mintEmission() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintEmissionCall {}
    ///Container type for the return parameters of the [`mintEmission()`](mintEmissionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintEmissionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintEmissionCall> for UnderlyingRustTuple<'_> {
                fn from(value: mintEmissionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintEmissionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintEmissionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: mintEmissionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintEmissionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintEmissionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintEmissionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mintEmission()";
            const SELECTOR: [u8; 4] = [40u8, 78u8, 19u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pause()` and selector `0x8456cb59`.
```solidity
function pause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseCall {}
    ///Container type for the return parameters of the [`pause()`](pauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause()";
            const SELECTOR: [u8; 4] = [132u8, 86u8, 203u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `paused()` and selector `0x5c975abb`.
```solidity
function paused() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedCall {}
    ///Container type for the return parameters of the [`paused()`](pausedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedCall> for UnderlyingRustTuple<'_> {
                fn from(value: pausedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pausedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pausedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pausedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address callerConfirmation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub callerConfirmation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.callerConfirmation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        callerConfirmation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callerConfirmation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeData(bytes)` and selector `0x13beaa5b`.
```solidity
function setBridgeData(bytes memory _bridgeData) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeDataCall {
        #[allow(missing_docs)]
        pub _bridgeData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`setBridgeData(bytes)`](setBridgeDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeDataReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeDataCall) -> Self {
                    (value._bridgeData,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridgeData: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeDataReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeDataReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeDataCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeDataReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeData(bytes)";
            const SELECTOR: [u8; 4] = [19u8, 190u8, 170u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._bridgeData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeProxy(address)` and selector `0xa571e184`.
```solidity
function setBridgeProxy(address _bridgeProxy) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeProxyCall {
        #[allow(missing_docs)]
        pub _bridgeProxy: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setBridgeProxy(address)`](setBridgeProxyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeProxyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeProxyCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeProxyCall) -> Self {
                    (value._bridgeProxy,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeProxyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridgeProxy: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeProxyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeProxyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBridgeProxyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeProxyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeProxyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeProxy(address)";
            const SELECTOR: [u8; 4] = [165u8, 113u8, 225u8, 132u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridgeProxy,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `startEmissions()` and selector `0x1b02f845`.
```solidity
function startEmissions() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startEmissionsCall {}
    ///Container type for the return parameters of the [`startEmissions()`](startEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startEmissionsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startEmissionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: startEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: startEmissionsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for startEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for startEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = startEmissionsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "startEmissions()";
            const SELECTOR: [u8; 4] = [27u8, 2u8, 248u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = supportsInterfaceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `totalEmissionsMinted()` and selector `0xf508e19d`.
```solidity
function totalEmissionsMinted() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalEmissionsMintedCall {}
    ///Container type for the return parameters of the [`totalEmissionsMinted()`](totalEmissionsMintedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalEmissionsMintedReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalEmissionsMintedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: totalEmissionsMintedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for totalEmissionsMintedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalEmissionsMintedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: totalEmissionsMintedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for totalEmissionsMintedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalEmissionsMintedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = totalEmissionsMintedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalEmissionsMinted()";
            const SELECTOR: [u8; 4] = [245u8, 8u8, 225u8, 157u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `unpause()` and selector `0x3f4ba83a`.
```solidity
function unpause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseCall {}
    ///Container type for the return parameters of the [`unpause()`](unpauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unpauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unpauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unpause()";
            const SELECTOR: [u8; 4] = [63u8, 75u8, 168u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`SyndicateTokenEmissionSchedulerV2`](self) function calls.
    pub enum SyndicateTokenEmissionSchedulerV2Calls {
        #[allow(missing_docs)]
        BRIDGE_MANAGER_ROLE(BRIDGE_MANAGER_ROLECall),
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        EMISSIONS_MANAGER_ROLE(EMISSIONS_MANAGER_ROLECall),
        #[allow(missing_docs)]
        EMISSION_BUFFER_TIME(EMISSION_BUFFER_TIMECall),
        #[allow(missing_docs)]
        EPOCH_DURATION(EPOCH_DURATIONCall),
        #[allow(missing_docs)]
        PAUSER_ROLE(PAUSER_ROLECall),
        #[allow(missing_docs)]
        TOTAL_EPOCHS(TOTAL_EPOCHSCall),
        #[allow(missing_docs)]
        bridgeData(bridgeDataCall),
        #[allow(missing_docs)]
        bridgeProxy(bridgeProxyCall),
        #[allow(missing_docs)]
        currentEpoch(currentEpochCall),
        #[allow(missing_docs)]
        emissionsCalculator(emissionsCalculatorCall),
        #[allow(missing_docs)]
        emissionsEnded(emissionsEndedCall),
        #[allow(missing_docs)]
        emissionsStartTime(emissionsStartTimeCall),
        #[allow(missing_docs)]
        emissionsStarted(emissionsStartedCall),
        #[allow(missing_docs)]
        getCurrentEpoch(getCurrentEpochCall),
        #[allow(missing_docs)]
        getCurrentEpochInfo(getCurrentEpochInfoCall),
        #[allow(missing_docs)]
        getNextEmissionTime(getNextEmissionTimeCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        mintEmission(mintEmissionCall),
        #[allow(missing_docs)]
        pause(pauseCall),
        #[allow(missing_docs)]
        paused(pausedCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        setBridgeData(setBridgeDataCall),
        #[allow(missing_docs)]
        setBridgeProxy(setBridgeProxyCall),
        #[allow(missing_docs)]
        startEmissions(startEmissionsCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
        #[allow(missing_docs)]
        totalEmissionsMinted(totalEmissionsMintedCall),
        #[allow(missing_docs)]
        unpause(unpauseCall),
    }
    #[automatically_derived]
    impl SyndicateTokenEmissionSchedulerV2Calls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 255u8, 201u8, 167u8],
            [19u8, 190u8, 170u8, 91u8],
            [27u8, 2u8, 248u8, 69u8],
            [35u8, 18u8, 215u8, 215u8],
            [36u8, 58u8, 48u8, 204u8],
            [36u8, 129u8, 187u8, 92u8],
            [36u8, 138u8, 156u8, 163u8],
            [40u8, 78u8, 19u8, 51u8],
            [47u8, 47u8, 241u8, 93u8],
            [54u8, 86u8, 138u8, 190u8],
            [63u8, 75u8, 168u8, 58u8],
            [72u8, 176u8, 218u8, 166u8],
            [90u8, 223u8, 0u8, 33u8],
            [92u8, 151u8, 90u8, 187u8],
            [95u8, 21u8, 195u8, 201u8],
            [118u8, 103u8, 24u8, 8u8],
            [132u8, 86u8, 203u8, 89u8],
            [145u8, 209u8, 72u8, 84u8],
            [162u8, 23u8, 253u8, 223u8],
            [163u8, 212u8, 72u8, 91u8],
            [164u8, 215u8, 227u8, 29u8],
            [165u8, 113u8, 225u8, 132u8],
            [165u8, 179u8, 38u8, 190u8],
            [167u8, 11u8, 159u8, 12u8],
            [185u8, 125u8, 217u8, 226u8],
            [186u8, 188u8, 57u8, 79u8],
            [213u8, 71u8, 116u8, 31u8],
            [227u8, 171u8, 223u8, 203u8],
            [230u8, 58u8, 177u8, 233u8],
            [245u8, 8u8, 225u8, 157u8],
            [247u8, 94u8, 133u8, 18u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateTokenEmissionSchedulerV2Calls {
        const NAME: &'static str = "SyndicateTokenEmissionSchedulerV2Calls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 31usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::BRIDGE_MANAGER_ROLE(_) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSIONS_MANAGER_ROLE(_) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSION_BUFFER_TIME(_) => {
                    <EMISSION_BUFFER_TIMECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EPOCH_DURATION(_) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PAUSER_ROLE(_) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TOTAL_EPOCHS(_) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeData(_) => {
                    <bridgeDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeProxy(_) => {
                    <bridgeProxyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::currentEpoch(_) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsCalculator(_) => {
                    <emissionsCalculatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsEnded(_) => {
                    <emissionsEndedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsStartTime(_) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsStarted(_) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCurrentEpoch(_) => {
                    <getCurrentEpochCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCurrentEpochInfo(_) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getNextEmissionTime(_) => {
                    <getNextEmissionTimeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::mintEmission(_) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::paused(_) => <pausedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeData(_) => {
                    <setBridgeDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeProxy(_) => {
                    <setBridgeProxyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::startEmissions(_) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::totalEmissionsMinted(_) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unpause(_) => <unpauseCall as alloy_sol_types::SolCall>::SELECTOR,
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerV2Calls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Calls::supportsInterface,
                            )
                    }
                    supportsInterface
                },
                {
                    fn setBridgeData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <setBridgeDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Calls::setBridgeData)
                    }
                    setBridgeData
                },
                {
                    fn startEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <startEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Calls::startEmissions)
                    }
                    startEmissions
                },
                {
                    fn emissionsCalculator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <emissionsCalculatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Calls::emissionsCalculator,
                            )
                    }
                    emissionsCalculator
                },
                {
                    fn EMISSION_BUFFER_TIME(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <EMISSION_BUFFER_TIMECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Calls::EMISSION_BUFFER_TIME,
                            )
                    }
                    EMISSION_BUFFER_TIME
                },
                {
                    fn bridgeData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <bridgeDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Calls::bridgeData)
                    }
                    bridgeData
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Calls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn mintEmission(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <mintEmissionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Calls::mintEmission)
                    }
                    mintEmission
                },
                {
                    fn grantRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Calls::grantRole)
                    }
                    grantRole
                },
                {
                    fn renounceRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Calls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn unpause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Calls::unpause)
                    }
                    unpause
                },
                {
                    fn emissionsStartTime(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Calls::emissionsStartTime,
                            )
                    }
                    emissionsStartTime
                },
                {
                    fn emissionsStarted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <emissionsStartedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Calls::emissionsStarted,
                            )
                    }
                    emissionsStarted
                },
                {
                    fn paused(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Calls::paused)
                    }
                    paused
                },
                {
                    fn TOTAL_EPOCHS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Calls::TOTAL_EPOCHS)
                    }
                    TOTAL_EPOCHS
                },
                {
                    fn currentEpoch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <currentEpochCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Calls::currentEpoch)
                    }
                    currentEpoch
                },
                {
                    fn pause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Calls::pause)
                    }
                    pause
                },
                {
                    fn hasRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Calls::hasRole)
                    }
                    hasRole
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Calls::DEFAULT_ADMIN_ROLE,
                            )
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn bridgeProxy(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <bridgeProxyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Calls::bridgeProxy)
                    }
                    bridgeProxy
                },
                {
                    fn emissionsEnded(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <emissionsEndedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Calls::emissionsEnded)
                    }
                    emissionsEnded
                },
                {
                    fn setBridgeProxy(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <setBridgeProxyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Calls::setBridgeProxy)
                    }
                    setBridgeProxy
                },
                {
                    fn getNextEmissionTime(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <getNextEmissionTimeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Calls::getNextEmissionTime,
                            )
                    }
                    getNextEmissionTime
                },
                {
                    fn EPOCH_DURATION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Calls::EPOCH_DURATION)
                    }
                    EPOCH_DURATION
                },
                {
                    fn getCurrentEpoch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <getCurrentEpochCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Calls::getCurrentEpoch)
                    }
                    getCurrentEpoch
                },
                {
                    fn getCurrentEpochInfo(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Calls::getCurrentEpochInfo,
                            )
                    }
                    getCurrentEpochInfo
                },
                {
                    fn revokeRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Calls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn EMISSIONS_MANAGER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Calls::EMISSIONS_MANAGER_ROLE,
                            )
                    }
                    EMISSIONS_MANAGER_ROLE
                },
                {
                    fn PAUSER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Calls::PAUSER_ROLE)
                    }
                    PAUSER_ROLE
                },
                {
                    fn totalEmissionsMinted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Calls::totalEmissionsMinted,
                            )
                    }
                    totalEmissionsMinted
                },
                {
                    fn BRIDGE_MANAGER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Calls,
                    > {
                        <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Calls::BRIDGE_MANAGER_ROLE,
                            )
                    }
                    BRIDGE_MANAGER_ROLE
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::BRIDGE_MANAGER_ROLE(inner) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSIONS_MANAGER_ROLE(inner) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSION_BUFFER_TIME(inner) => {
                    <EMISSION_BUFFER_TIMECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EPOCH_DURATION(inner) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PAUSER_ROLE(inner) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TOTAL_EPOCHS(inner) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridgeData(inner) => {
                    <bridgeDataCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::bridgeProxy(inner) => {
                    <bridgeProxyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::currentEpoch(inner) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsCalculator(inner) => {
                    <emissionsCalculatorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsEnded(inner) => {
                    <emissionsEndedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsStartTime(inner) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsStarted(inner) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCurrentEpoch(inner) => {
                    <getCurrentEpochCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCurrentEpochInfo(inner) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getNextEmissionTime(inner) => {
                    <getNextEmissionTimeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::mintEmission(inner) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setBridgeData(inner) => {
                    <setBridgeDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setBridgeProxy(inner) => {
                    <setBridgeProxyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::startEmissions(inner) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::totalEmissionsMinted(inner) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::BRIDGE_MANAGER_ROLE(inner) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSIONS_MANAGER_ROLE(inner) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSION_BUFFER_TIME(inner) => {
                    <EMISSION_BUFFER_TIMECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EPOCH_DURATION(inner) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PAUSER_ROLE(inner) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TOTAL_EPOCHS(inner) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeData(inner) => {
                    <bridgeDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeProxy(inner) => {
                    <bridgeProxyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::currentEpoch(inner) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsCalculator(inner) => {
                    <emissionsCalculatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsEnded(inner) => {
                    <emissionsEndedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsStartTime(inner) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsStarted(inner) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCurrentEpoch(inner) => {
                    <getCurrentEpochCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCurrentEpochInfo(inner) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getNextEmissionTime(inner) => {
                    <getNextEmissionTimeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::mintEmission(inner) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeData(inner) => {
                    <setBridgeDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeProxy(inner) => {
                    <setBridgeProxyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::startEmissions(inner) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::totalEmissionsMinted(inner) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`SyndicateTokenEmissionSchedulerV2`](self) custom errors.
    pub enum SyndicateTokenEmissionSchedulerV2Errors {
        #[allow(missing_docs)]
        AccessControlBadConfirmation(AccessControlBadConfirmation),
        #[allow(missing_docs)]
        AccessControlUnauthorizedAccount(AccessControlUnauthorizedAccount),
        #[allow(missing_docs)]
        AllEmissionsCompleted(AllEmissionsCompleted),
        #[allow(missing_docs)]
        BridgeNotConfigured(BridgeNotConfigured),
        #[allow(missing_docs)]
        CalculatorNotInitialized(CalculatorNotInitialized),
        #[allow(missing_docs)]
        EmissionTooEarly(EmissionTooEarly),
        #[allow(missing_docs)]
        EmissionsAlreadyStarted(EmissionsAlreadyStarted),
        #[allow(missing_docs)]
        EmissionsNotStarted(EmissionsNotStarted),
        #[allow(missing_docs)]
        EnforcedPause(EnforcedPause),
        #[allow(missing_docs)]
        ExpectedPause(ExpectedPause),
        #[allow(missing_docs)]
        ReentrancyGuardReentrantCall(ReentrancyGuardReentrantCall),
        #[allow(missing_docs)]
        SafeERC20FailedOperation(SafeERC20FailedOperation),
        #[allow(missing_docs)]
        ZeroAddress(ZeroAddress),
    }
    #[automatically_derived]
    impl SyndicateTokenEmissionSchedulerV2Errors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [61u8, 83u8, 199u8, 83u8],
            [62u8, 229u8, 174u8, 181u8],
            [69u8, 85u8, 137u8, 44u8],
            [82u8, 116u8, 175u8, 231u8],
            [102u8, 151u8, 178u8, 50u8],
            [113u8, 210u8, 123u8, 122u8],
            [118u8, 20u8, 145u8, 122u8],
            [141u8, 252u8, 32u8, 43u8],
            [143u8, 152u8, 64u8, 65u8],
            [161u8, 77u8, 27u8, 231u8],
            [217u8, 46u8, 35u8, 61u8],
            [217u8, 60u8, 6u8, 101u8],
            [226u8, 81u8, 125u8, 63u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateTokenEmissionSchedulerV2Errors {
        const NAME: &'static str = "SyndicateTokenEmissionSchedulerV2Errors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 13usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccessControlBadConfirmation(_) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AccessControlUnauthorizedAccount(_) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AllEmissionsCompleted(_) => {
                    <AllEmissionsCompleted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BridgeNotConfigured(_) => {
                    <BridgeNotConfigured as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CalculatorNotInitialized(_) => {
                    <CalculatorNotInitialized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionTooEarly(_) => {
                    <EmissionTooEarly as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionsAlreadyStarted(_) => {
                    <EmissionsAlreadyStarted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionsNotStarted(_) => {
                    <EmissionsNotStarted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EnforcedPause(_) => {
                    <EnforcedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExpectedPause(_) => {
                    <ExpectedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ReentrancyGuardReentrantCall(_) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SafeERC20FailedOperation(_) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAddress(_) => {
                    <ZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerV2Errors>] = &[
                {
                    fn EmissionTooEarly(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Errors,
                    > {
                        <EmissionTooEarly as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Errors::EmissionTooEarly,
                            )
                    }
                    EmissionTooEarly
                },
                {
                    fn ReentrancyGuardReentrantCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Errors,
                    > {
                        <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Errors::ReentrancyGuardReentrantCall,
                            )
                    }
                    ReentrancyGuardReentrantCall
                },
                {
                    fn AllEmissionsCompleted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Errors,
                    > {
                        <AllEmissionsCompleted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Errors::AllEmissionsCompleted,
                            )
                    }
                    AllEmissionsCompleted
                },
                {
                    fn SafeERC20FailedOperation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Errors,
                    > {
                        <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Errors::SafeERC20FailedOperation,
                            )
                    }
                    SafeERC20FailedOperation
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Errors,
                    > {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Errors::AccessControlBadConfirmation,
                            )
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn EmissionsAlreadyStarted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Errors,
                    > {
                        <EmissionsAlreadyStarted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Errors::EmissionsAlreadyStarted,
                            )
                    }
                    EmissionsAlreadyStarted
                },
                {
                    fn BridgeNotConfigured(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Errors,
                    > {
                        <BridgeNotConfigured as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Errors::BridgeNotConfigured,
                            )
                    }
                    BridgeNotConfigured
                },
                {
                    fn ExpectedPause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Errors,
                    > {
                        <ExpectedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Errors::ExpectedPause)
                    }
                    ExpectedPause
                },
                {
                    fn EmissionsNotStarted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Errors,
                    > {
                        <EmissionsNotStarted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Errors::EmissionsNotStarted,
                            )
                    }
                    EmissionsNotStarted
                },
                {
                    fn CalculatorNotInitialized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Errors,
                    > {
                        <CalculatorNotInitialized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Errors::CalculatorNotInitialized,
                            )
                    }
                    CalculatorNotInitialized
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Errors,
                    > {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Errors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn EnforcedPause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Errors,
                    > {
                        <EnforcedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerV2Errors::EnforcedPause)
                    }
                    EnforcedPause
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<
                        SyndicateTokenEmissionSchedulerV2Errors,
                    > {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerV2Errors::AccessControlUnauthorizedAccount,
                            )
                    }
                    AccessControlUnauthorizedAccount
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AllEmissionsCompleted(inner) => {
                    <AllEmissionsCompleted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BridgeNotConfigured(inner) => {
                    <BridgeNotConfigured as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CalculatorNotInitialized(inner) => {
                    <CalculatorNotInitialized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionTooEarly(inner) => {
                    <EmissionTooEarly as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionsAlreadyStarted(inner) => {
                    <EmissionsAlreadyStarted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionsNotStarted(inner) => {
                    <EmissionsNotStarted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SafeERC20FailedOperation(inner) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AllEmissionsCompleted(inner) => {
                    <AllEmissionsCompleted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BridgeNotConfigured(inner) => {
                    <BridgeNotConfigured as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CalculatorNotInitialized(inner) => {
                    <CalculatorNotInitialized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionTooEarly(inner) => {
                    <EmissionTooEarly as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionsAlreadyStarted(inner) => {
                    <EmissionsAlreadyStarted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionsNotStarted(inner) => {
                    <EmissionsNotStarted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SafeERC20FailedOperation(inner) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`SyndicateTokenEmissionSchedulerV2`](self) events.
    pub enum SyndicateTokenEmissionSchedulerV2Events {
        #[allow(missing_docs)]
        BridgeDataUpdated(BridgeDataUpdated),
        #[allow(missing_docs)]
        BridgeProxyUpdated(BridgeProxyUpdated),
        #[allow(missing_docs)]
        EmissionMinted(EmissionMinted),
        #[allow(missing_docs)]
        EmissionsStarted(EmissionsStarted),
        #[allow(missing_docs)]
        Paused(Paused),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
        #[allow(missing_docs)]
        Unpaused(Unpaused),
    }
    #[automatically_derived]
    impl SyndicateTokenEmissionSchedulerV2Events {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                7u8,
                1u8,
                91u8,
                106u8,
                159u8,
                5u8,
                145u8,
                49u8,
                72u8,
                253u8,
                95u8,
                173u8,
                223u8,
                42u8,
                204u8,
                151u8,
                8u8,
                243u8,
                5u8,
                147u8,
                127u8,
                48u8,
                114u8,
                202u8,
                43u8,
                75u8,
                70u8,
                250u8,
                165u8,
                208u8,
                137u8,
                139u8,
            ],
            [
                17u8,
                148u8,
                176u8,
                52u8,
                207u8,
                169u8,
                171u8,
                88u8,
                7u8,
                73u8,
                74u8,
                29u8,
                92u8,
                102u8,
                125u8,
                139u8,
                14u8,
                110u8,
                151u8,
                243u8,
                136u8,
                136u8,
                116u8,
                42u8,
                163u8,
                135u8,
                26u8,
                50u8,
                32u8,
                52u8,
                17u8,
                96u8,
            ],
            [
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ],
            [
                52u8,
                183u8,
                61u8,
                12u8,
                150u8,
                233u8,
                255u8,
                77u8,
                83u8,
                17u8,
                67u8,
                72u8,
                23u8,
                200u8,
                236u8,
                201u8,
                48u8,
                231u8,
                210u8,
                120u8,
                44u8,
                91u8,
                222u8,
                46u8,
                121u8,
                220u8,
                68u8,
                176u8,
                89u8,
                103u8,
                85u8,
                187u8,
            ],
            [
                93u8,
                185u8,
                238u8,
                10u8,
                73u8,
                91u8,
                242u8,
                230u8,
                255u8,
                156u8,
                145u8,
                167u8,
                131u8,
                76u8,
                27u8,
                164u8,
                253u8,
                210u8,
                68u8,
                165u8,
                232u8,
                170u8,
                78u8,
                83u8,
                123u8,
                211u8,
                138u8,
                234u8,
                228u8,
                176u8,
                115u8,
                170u8,
            ],
            [
                98u8,
                231u8,
                140u8,
                234u8,
                1u8,
                190u8,
                227u8,
                32u8,
                205u8,
                78u8,
                66u8,
                2u8,
                112u8,
                181u8,
                234u8,
                116u8,
                0u8,
                13u8,
                17u8,
                176u8,
                201u8,
                247u8,
                71u8,
                84u8,
                235u8,
                219u8,
                252u8,
                84u8,
                75u8,
                5u8,
                162u8,
                88u8,
            ],
            [
                185u8,
                162u8,
                8u8,
                132u8,
                38u8,
                240u8,
                59u8,
                48u8,
                168u8,
                28u8,
                6u8,
                66u8,
                128u8,
                148u8,
                251u8,
                250u8,
                158u8,
                38u8,
                146u8,
                115u8,
                155u8,
                50u8,
                65u8,
                175u8,
                107u8,
                154u8,
                177u8,
                218u8,
                75u8,
                85u8,
                70u8,
                190u8,
            ],
            [
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ],
            [
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for SyndicateTokenEmissionSchedulerV2Events {
        const NAME: &'static str = "SyndicateTokenEmissionSchedulerV2Events";
        const COUNT: usize = 9usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <BridgeDataUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeDataUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeDataUpdated)
                }
                Some(
                    <BridgeProxyUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeProxyUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeProxyUpdated)
                }
                Some(<EmissionMinted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionMinted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionMinted)
                }
                Some(<EmissionsStarted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionsStarted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionsStarted)
                }
                Some(<Paused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Paused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Paused)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleRevoked)
                }
                Some(<Unpaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Unpaused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Unpaused)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData
    for SyndicateTokenEmissionSchedulerV2Events {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::BridgeDataUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeProxyUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionMinted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionsStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::BridgeDataUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeProxyUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionMinted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionsStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`SyndicateTokenEmissionSchedulerV2`](self) contract instance.

See the [wrapper's documentation](`SyndicateTokenEmissionSchedulerV2Instance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> SyndicateTokenEmissionSchedulerV2Instance<T, P, N> {
        SyndicateTokenEmissionSchedulerV2Instance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _emissionsCalculator: alloy::sol_types::private::Address,
        defaultAdmin: alloy::sol_types::private::Address,
        emissionsManager: alloy::sol_types::private::Address,
        pauser: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<
            SyndicateTokenEmissionSchedulerV2Instance<T, P, N>,
        >,
    > {
        SyndicateTokenEmissionSchedulerV2Instance::<
            T,
            P,
            N,
        >::deploy(provider, _emissionsCalculator, defaultAdmin, emissionsManager, pauser)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _emissionsCalculator: alloy::sol_types::private::Address,
        defaultAdmin: alloy::sol_types::private::Address,
        emissionsManager: alloy::sol_types::private::Address,
        pauser: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        SyndicateTokenEmissionSchedulerV2Instance::<
            T,
            P,
            N,
        >::deploy_builder(
            provider,
            _emissionsCalculator,
            defaultAdmin,
            emissionsManager,
            pauser,
        )
    }
    /**A [`SyndicateTokenEmissionSchedulerV2`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`SyndicateTokenEmissionSchedulerV2`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct SyndicateTokenEmissionSchedulerV2Instance<
        T,
        P,
        N = alloy_contract::private::Ethereum,
    > {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug
    for SyndicateTokenEmissionSchedulerV2Instance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("SyndicateTokenEmissionSchedulerV2Instance")
                .field(&self.address)
                .finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenEmissionSchedulerV2Instance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`SyndicateTokenEmissionSchedulerV2`](self) contract instance.

See the [wrapper's documentation](`SyndicateTokenEmissionSchedulerV2Instance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            _emissionsCalculator: alloy::sol_types::private::Address,
            defaultAdmin: alloy::sol_types::private::Address,
            emissionsManager: alloy::sol_types::private::Address,
            pauser: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<SyndicateTokenEmissionSchedulerV2Instance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                _emissionsCalculator,
                defaultAdmin,
                emissionsManager,
                pauser,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            _emissionsCalculator: alloy::sol_types::private::Address,
            defaultAdmin: alloy::sol_types::private::Address,
            emissionsManager: alloy::sol_types::private::Address,
            pauser: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            _emissionsCalculator,
                            defaultAdmin,
                            emissionsManager,
                            pauser,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<
        T,
        P: ::core::clone::Clone,
        N,
    > SyndicateTokenEmissionSchedulerV2Instance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(
            self,
        ) -> SyndicateTokenEmissionSchedulerV2Instance<T, P, N> {
            SyndicateTokenEmissionSchedulerV2Instance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenEmissionSchedulerV2Instance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`BRIDGE_MANAGER_ROLE`] function.
        pub fn BRIDGE_MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BRIDGE_MANAGER_ROLECall, N> {
            self.call_builder(&BRIDGE_MANAGER_ROLECall {})
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall {})
        }
        ///Creates a new call builder for the [`EMISSIONS_MANAGER_ROLE`] function.
        pub fn EMISSIONS_MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSIONS_MANAGER_ROLECall, N> {
            self.call_builder(&EMISSIONS_MANAGER_ROLECall {})
        }
        ///Creates a new call builder for the [`EMISSION_BUFFER_TIME`] function.
        pub fn EMISSION_BUFFER_TIME(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSION_BUFFER_TIMECall, N> {
            self.call_builder(&EMISSION_BUFFER_TIMECall {})
        }
        ///Creates a new call builder for the [`EPOCH_DURATION`] function.
        pub fn EPOCH_DURATION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EPOCH_DURATIONCall, N> {
            self.call_builder(&EPOCH_DURATIONCall {})
        }
        ///Creates a new call builder for the [`PAUSER_ROLE`] function.
        pub fn PAUSER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PAUSER_ROLECall, N> {
            self.call_builder(&PAUSER_ROLECall {})
        }
        ///Creates a new call builder for the [`TOTAL_EPOCHS`] function.
        pub fn TOTAL_EPOCHS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, TOTAL_EPOCHSCall, N> {
            self.call_builder(&TOTAL_EPOCHSCall {})
        }
        ///Creates a new call builder for the [`bridgeData`] function.
        pub fn bridgeData(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeDataCall, N> {
            self.call_builder(&bridgeDataCall {})
        }
        ///Creates a new call builder for the [`bridgeProxy`] function.
        pub fn bridgeProxy(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeProxyCall, N> {
            self.call_builder(&bridgeProxyCall {})
        }
        ///Creates a new call builder for the [`currentEpoch`] function.
        pub fn currentEpoch(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, currentEpochCall, N> {
            self.call_builder(&currentEpochCall {})
        }
        ///Creates a new call builder for the [`emissionsCalculator`] function.
        pub fn emissionsCalculator(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsCalculatorCall, N> {
            self.call_builder(&emissionsCalculatorCall {})
        }
        ///Creates a new call builder for the [`emissionsEnded`] function.
        pub fn emissionsEnded(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsEndedCall, N> {
            self.call_builder(&emissionsEndedCall {})
        }
        ///Creates a new call builder for the [`emissionsStartTime`] function.
        pub fn emissionsStartTime(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsStartTimeCall, N> {
            self.call_builder(&emissionsStartTimeCall {})
        }
        ///Creates a new call builder for the [`emissionsStarted`] function.
        pub fn emissionsStarted(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsStartedCall, N> {
            self.call_builder(&emissionsStartedCall {})
        }
        ///Creates a new call builder for the [`getCurrentEpoch`] function.
        pub fn getCurrentEpoch(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getCurrentEpochCall, N> {
            self.call_builder(&getCurrentEpochCall {})
        }
        ///Creates a new call builder for the [`getCurrentEpochInfo`] function.
        pub fn getCurrentEpochInfo(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getCurrentEpochInfoCall, N> {
            self.call_builder(&getCurrentEpochInfoCall {})
        }
        ///Creates a new call builder for the [`getNextEmissionTime`] function.
        pub fn getNextEmissionTime(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getNextEmissionTimeCall, N> {
            self.call_builder(&getNextEmissionTimeCall {})
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`mintEmission`] function.
        pub fn mintEmission(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintEmissionCall, N> {
            self.call_builder(&mintEmissionCall {})
        }
        ///Creates a new call builder for the [`pause`] function.
        pub fn pause(&self) -> alloy_contract::SolCallBuilder<T, &P, pauseCall, N> {
            self.call_builder(&pauseCall {})
        }
        ///Creates a new call builder for the [`paused`] function.
        pub fn paused(&self) -> alloy_contract::SolCallBuilder<T, &P, pausedCall, N> {
            self.call_builder(&pausedCall {})
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            callerConfirmation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceRoleCall, N> {
            self.call_builder(
                &renounceRoleCall {
                    role,
                    callerConfirmation,
                },
            )
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`setBridgeData`] function.
        pub fn setBridgeData(
            &self,
            _bridgeData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeDataCall, N> {
            self.call_builder(&setBridgeDataCall { _bridgeData })
        }
        ///Creates a new call builder for the [`setBridgeProxy`] function.
        pub fn setBridgeProxy(
            &self,
            _bridgeProxy: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeProxyCall, N> {
            self.call_builder(&setBridgeProxyCall { _bridgeProxy })
        }
        ///Creates a new call builder for the [`startEmissions`] function.
        pub fn startEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, startEmissionsCall, N> {
            self.call_builder(&startEmissionsCall {})
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<T, &P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`totalEmissionsMinted`] function.
        pub fn totalEmissionsMinted(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, totalEmissionsMintedCall, N> {
            self.call_builder(&totalEmissionsMintedCall {})
        }
        ///Creates a new call builder for the [`unpause`] function.
        pub fn unpause(&self) -> alloy_contract::SolCallBuilder<T, &P, unpauseCall, N> {
            self.call_builder(&unpauseCall {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenEmissionSchedulerV2Instance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`BridgeDataUpdated`] event.
        pub fn BridgeDataUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeDataUpdated, N> {
            self.event_filter::<BridgeDataUpdated>()
        }
        ///Creates a new event filter for the [`BridgeProxyUpdated`] event.
        pub fn BridgeProxyUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeProxyUpdated, N> {
            self.event_filter::<BridgeProxyUpdated>()
        }
        ///Creates a new event filter for the [`EmissionMinted`] event.
        pub fn EmissionMinted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionMinted, N> {
            self.event_filter::<EmissionMinted>()
        }
        ///Creates a new event filter for the [`EmissionsStarted`] event.
        pub fn EmissionsStarted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionsStarted, N> {
            self.event_filter::<EmissionsStarted>()
        }
        ///Creates a new event filter for the [`Paused`] event.
        pub fn Paused_filter(&self) -> alloy_contract::Event<T, &P, Paused, N> {
            self.event_filter::<Paused>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
        ///Creates a new event filter for the [`Unpaused`] event.
        pub fn Unpaused_filter(&self) -> alloy_contract::Event<T, &P, Unpaused, N> {
            self.event_filter::<Unpaused>()
        }
    }
}
