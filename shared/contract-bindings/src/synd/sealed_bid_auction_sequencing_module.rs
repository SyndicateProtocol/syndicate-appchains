/**

Generated by the following Solidity interface...
```solidity
interface SealedBidAuctionSequencingModule {
    error AddressNotAllowed();
    error AuctionNotActive();
    error AuctionNotEnded();
    error BidExceedsDeposit();
    error InvalidBidDeposit();
    error InvalidBidReveal();
    error InvalidDuration();
    error NoBidFound();
    error NoFundsToWithdraw();
    error TransactionFailed();

    event BidRevealed(address indexed bidder, uint256 bid, bool isHighestBid);

    constructor(uint256 _duration, address _treasury);

    function auctionActive() external view returns (bool);
    function auctionType() external view returns (string memory);
    function bid(bytes32 _sealedBid) external payable;
    function bids(address) external view returns (bytes32 sealedBid, uint256 deposit);
    function endTime() external view returns (uint256);
    function finalizeAuction() external;
    function getAuctionEndTime() external view returns (uint256);
    function getAuctionType() external view returns (string memory);
    function getAuctionWinner() external view returns (address);
    function getCurrentPrice() external view returns (uint256);
    function highestBid() external view returns (uint256);
    function highestBidder() external view returns (address);
    function isAllowed(address proposer, address, bytes memory) external view returns (bool);
    function isAuctionActive() external view returns (bool);
    function refunds(address) external view returns (uint256);
    function revealBid(uint256 _bid, string memory _salt) external;
    function treasury() external view returns (address);
    function withdrawFunds() external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_duration",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_treasury",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "auctionActive",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "auctionType",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bid",
    "inputs": [
      {
        "name": "_sealedBid",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "bids",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "sealedBid",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "deposit",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "endTime",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "finalizeAuction",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getAuctionEndTime",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAuctionType",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAuctionWinner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCurrentPrice",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "highestBid",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "highestBidder",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isAllowed",
    "inputs": [
      {
        "name": "proposer",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isAuctionActive",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "refunds",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "revealBid",
    "inputs": [
      {
        "name": "_bid",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_salt",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "treasury",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "withdrawFunds",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "BidRevealed",
    "inputs": [
      {
        "name": "bidder",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "bid",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "isHighestBid",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AddressNotAllowed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AuctionNotActive",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AuctionNotEnded",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BidExceedsDeposit",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidBidDeposit",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidBidReveal",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidDuration",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NoBidFound",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NoFundsToWithdraw",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TransactionFailed",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod SealedBidAuctionSequencingModule {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60803461016c57601f610b4238819003918201601f19168301916001600160401b0383118484101761017057808492604094855283398101031261016c5780516020909101516001600160a01b0381169081900361016c57801561015d57811561014e575f80546001600160a01b0319169190911790556001805480821c91168015610144575b602082101461013057601f81116100e8575b5060126814d9585b1959109a5960ba1b01600155600160ff19600254161760025542018042116100d4576003556040516109bd90816101858239f35b634e487b7160e01b5f52601160045260245ffd5b60015f52601f0160051c7fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6908101905b8181106101255750610098565b5f8155600101610118565b634e487b7160e01b5f52602260045260245ffd5b90607f1690610086565b637616640160e01b5f5260045ffd5b6315a9bc2760e11b5f5260045ffd5b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60806040526004361015610011575f80fd5b5f3560e01c806311163b2c146102495780632163b8c5146104d257806324600fc3146104695780633197cbb6146103cc5780634c583d8a1461031357806361d027b31461043757806362ea82db146103e9578063787c0a6c146103cc5780637a3979dc1461034657806391f901571461031357806392228006146101e2578063957bb1e014610274578063994595e114610249578063bc3da53514610204578063d1b4b9a3146101e2578063d57bde79146101c5578063eb91d37e146101c55763f77282ab146100df575f80fd5b346101c1575f6003193601126101c1576003544210610199577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff006002541660025573ffffffffffffffffffffffffffffffffffffffff6004541661013f57005b5f80808073ffffffffffffffffffffffffffffffffffffffff815416600554905af161016961098e565b501561017157005b7fbf961a28000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f64637389000000000000000000000000000000000000000000000000000000005f5260045ffd5b5f80fd5b346101c1575f6003193601126101c1576020600554604051908152f35b346101c1575f6003193601126101c157602060ff600254166040519015158152f35b346101c15760206003193601126101c15773ffffffffffffffffffffffffffffffffffffffff61023261082f565b165f526007602052602060405f2054604051908152f35b346101c1575f6003193601126101c157610270610264610875565b60405191829182610723565b0390f35b60206003193601126101c15760ff60025416156102eb5734156102c35760405161029d8161076b565b6004358152600160208201348152335f52600660205260405f2092518355519101555f80f35b7f61700f91000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f69b8d0fe000000000000000000000000000000000000000000000000000000005f5260045ffd5b346101c1575f6003193601126101c157602073ffffffffffffffffffffffffffffffffffffffff60045416604051908152f35b346101c15760606003193601126101c15761035f61082f565b610367610852565b5060443567ffffffffffffffff81116101c157366023820112156101c157806004013567ffffffffffffffff81116101c157369101602401116101c15760209073ffffffffffffffffffffffffffffffffffffffff8060045416911614604051908152f35b346101c1575f6003193601126101c1576020600354604051908152f35b346101c15760206003193601126101c15773ffffffffffffffffffffffffffffffffffffffff61041761082f565b165f5260066020526040805f206001815491015482519182526020820152f35b346101c1575f6003193601126101c157602073ffffffffffffffffffffffffffffffffffffffff5f5416604051908152f35b346101c1575f6003193601126101c157335f52600760205260405f205480156104aa575f808080933382526007602052816040812055335af161016961098e565b7f67e3990d000000000000000000000000000000000000000000000000000000005f5260045ffd5b346101c15760406003193601126101c15760043560243567ffffffffffffffff81116101c157366023820112156101c1578060040135610511816107f5565b9061051f60405192836107b4565b808252602082019236602483830101116101c157815f9260246020930186378301015260ff60025416156102eb57335f52600660205260405f20906001604051926105698461076b565b805484520154926020830193808552156106fb57835185116106d3576105d160408051809360208201958987525180918484015e81015f8382015203017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081018352826107b4565b5190209051036106ab575f9060055483115f1461069857505073ffffffffffffffffffffffffffffffffffffffff6004541680610682575b5080600555337fffffffffffffffffffffffff0000000000000000000000000000000000000000600454161760045560015b604051918252151560208201527f9c2d1dff1e244149eef8b49255674d40752acd825b23d4ad303807f98fe5953260403392a2335f90815260066020526040812060010155005b600554905f52600760205260405f205581610609565b51335f52600760205260405f205561063b565b7fa49935ac000000000000000000000000000000000000000000000000000000005f5260045ffd5b7ff3baba56000000000000000000000000000000000000000000000000000000005f5260045ffd5b7fb82eb6b7000000000000000000000000000000000000000000000000000000005f5260045ffd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f602060409481855280519182918282880152018686015e5f8582860101520116010190565b6040810190811067ffffffffffffffff82111761078757604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761078757604052565b67ffffffffffffffff811161078757601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b6004359073ffffffffffffffffffffffffffffffffffffffff821682036101c157565b6024359073ffffffffffffffffffffffffffffffffffffffff821682036101c157565b604051905f6001548060011c9160018216918215610984575b60208410831461095757838652859290811561091a57506001146108bb575b6108b9925003836107b4565b565b5060015f90815290917fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf65b8183106108fe5750509060206108b9928201016108ad565b60209193508060019154838589010152019101909184926108e6565b602092506108b99491507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001682840152151560051b8201016108ad565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b92607f169261088e565b3d156109b8573d9061099f826107f5565b916109ad60405193846107b4565b82523d5f602084013e565b60609056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x804a\x01lW`\x1Fa\x0BB8\x81\x90\x03\x91\x82\x01`\x1F\x19\x16\x83\x01\x91`\x01`\x01`@\x1B\x03\x83\x11\x84\x84\x10\x17a\x01pW\x80\x84\x92`@\x94\x85R\x839\x81\x01\x03\x12a\x01lW\x80Q` \x90\x91\x01Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x90\x81\x90\x03a\x01lW\x80\x15a\x01]W\x81\x15a\x01NW_\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x91\x90\x91\x17\x90U`\x01\x80T\x80\x82\x1C\x91\x16\x80\x15a\x01DW[` \x82\x10\x14a\x010W`\x1F\x81\x11a\0\xE8W[P`\x12h\x14\xD9X[\x19Y\x10\x9AY`\xBA\x1B\x01`\x01U`\x01`\xFF\x19`\x02T\x16\x17`\x02UB\x01\x80B\x11a\0\xD4W`\x03U`@Qa\t\xBD\x90\x81a\x01\x85\x829\xF3[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[`\x01_R`\x1F\x01`\x05\x1C\x7F\xB1\x0E-Rv\x12\x07;&\xEE\xCD\xFDq~j2\x0C\xF4KJ\xFA\xC2\xB0s-\x9F\xCB\xE2\xB7\xFA\x0C\xF6\x90\x81\x01\x90[\x81\x81\x10a\x01%WPa\0\x98V[_\x81U`\x01\x01a\x01\x18V[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x7F\x16\x90a\0\x86V[cv\x16d\x01`\xE0\x1B_R`\x04_\xFD[c\x15\xA9\xBC'`\xE1\x1B_R`\x04_\xFD[_\x80\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD\xFE`\x80`@R`\x046\x10\x15a\0\x11W_\x80\xFD[_5`\xE0\x1C\x80c\x11\x16;,\x14a\x02IW\x80c!c\xB8\xC5\x14a\x04\xD2W\x80c$`\x0F\xC3\x14a\x04iW\x80c1\x97\xCB\xB6\x14a\x03\xCCW\x80cLX=\x8A\x14a\x03\x13W\x80ca\xD0'\xB3\x14a\x047W\x80cb\xEA\x82\xDB\x14a\x03\xE9W\x80cx|\nl\x14a\x03\xCCW\x80cz9y\xDC\x14a\x03FW\x80c\x91\xF9\x01W\x14a\x03\x13W\x80c\x92\"\x80\x06\x14a\x01\xE2W\x80c\x95{\xB1\xE0\x14a\x02tW\x80c\x99E\x95\xE1\x14a\x02IW\x80c\xBC=\xA55\x14a\x02\x04W\x80c\xD1\xB4\xB9\xA3\x14a\x01\xE2W\x80c\xD5{\xDEy\x14a\x01\xC5W\x80c\xEB\x91\xD3~\x14a\x01\xC5Wc\xF7r\x82\xAB\x14a\0\xDFW_\x80\xFD[4a\x01\xC1W_`\x03\x196\x01\x12a\x01\xC1W`\x03TB\x10a\x01\x99W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0`\x02T\x16`\x02Us\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x04T\x16a\x01?W\0[_\x80\x80\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81T\x16`\x05T\x90Z\xF1a\x01ia\t\x8EV[P\x15a\x01qW\0[\x7F\xBF\x96\x1A(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7Fdcs\x89\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[_\x80\xFD[4a\x01\xC1W_`\x03\x196\x01\x12a\x01\xC1W` `\x05T`@Q\x90\x81R\xF3[4a\x01\xC1W_`\x03\x196\x01\x12a\x01\xC1W` `\xFF`\x02T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x01\xC1W` `\x03\x196\x01\x12a\x01\xC1Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x022a\x08/V[\x16_R`\x07` R` `@_ T`@Q\x90\x81R\xF3[4a\x01\xC1W_`\x03\x196\x01\x12a\x01\xC1Wa\x02pa\x02da\x08uV[`@Q\x91\x82\x91\x82a\x07#V[\x03\x90\xF3[` `\x03\x196\x01\x12a\x01\xC1W`\xFF`\x02T\x16\x15a\x02\xEBW4\x15a\x02\xC3W`@Qa\x02\x9D\x81a\x07kV[`\x045\x81R`\x01` \x82\x014\x81R3_R`\x06` R`@_ \x92Q\x83UQ\x91\x01U_\x80\xF3[\x7Fap\x0F\x91\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7Fi\xB8\xD0\xFE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x01\xC1W_`\x03\x196\x01\x12a\x01\xC1W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x04T\x16`@Q\x90\x81R\xF3[4a\x01\xC1W```\x03\x196\x01\x12a\x01\xC1Wa\x03_a\x08/V[a\x03ga\x08RV[P`D5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x01\xC1W6`#\x82\x01\x12\x15a\x01\xC1W\x80`\x04\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x01\xC1W6\x91\x01`$\x01\x11a\x01\xC1W` \x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80`\x04T\x16\x91\x16\x14`@Q\x90\x81R\xF3[4a\x01\xC1W_`\x03\x196\x01\x12a\x01\xC1W` `\x03T`@Q\x90\x81R\xF3[4a\x01\xC1W` `\x03\x196\x01\x12a\x01\xC1Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x04\x17a\x08/V[\x16_R`\x06` R`@\x80_ `\x01\x81T\x91\x01T\x82Q\x91\x82R` \x82\x01R\xF3[4a\x01\xC1W_`\x03\x196\x01\x12a\x01\xC1W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF_T\x16`@Q\x90\x81R\xF3[4a\x01\xC1W_`\x03\x196\x01\x12a\x01\xC1W3_R`\x07` R`@_ T\x80\x15a\x04\xAAW_\x80\x80\x80\x933\x82R`\x07` R\x81`@\x81 U3Z\xF1a\x01ia\t\x8EV[\x7Fg\xE3\x99\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x01\xC1W`@`\x03\x196\x01\x12a\x01\xC1W`\x045`$5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x01\xC1W6`#\x82\x01\x12\x15a\x01\xC1W\x80`\x04\x015a\x05\x11\x81a\x07\xF5V[\x90a\x05\x1F`@Q\x92\x83a\x07\xB4V[\x80\x82R` \x82\x01\x926`$\x83\x83\x01\x01\x11a\x01\xC1W\x81_\x92`$` \x93\x01\x867\x83\x01\x01R`\xFF`\x02T\x16\x15a\x02\xEBW3_R`\x06` R`@_ \x90`\x01`@Q\x92a\x05i\x84a\x07kV[\x80T\x84R\x01T\x92` \x83\x01\x93\x80\x85R\x15a\x06\xFBW\x83Q\x85\x11a\x06\xD3Wa\x05\xD1`@\x80Q\x80\x93` \x82\x01\x95\x89\x87RQ\x80\x91\x84\x84\x01^\x81\x01_\x83\x82\x01R\x03\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x81\x01\x83R\x82a\x07\xB4V[Q\x90 \x90Q\x03a\x06\xABW_\x90`\x05T\x83\x11_\x14a\x06\x98WPPs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x04T\x16\x80a\x06\x82W[P\x80`\x05U3\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x04T\x16\x17`\x04U`\x01[`@Q\x91\x82R\x15\x15` \x82\x01R\x7F\x9C-\x1D\xFF\x1E$AI\xEE\xF8\xB4\x92UgM@u*\xCD\x82[#\xD4\xAD08\x07\xF9\x8F\xE5\x952`@3\x92\xA23_\x90\x81R`\x06` R`@\x81 `\x01\x01U\0[`\x05T\x90_R`\x07` R`@_ U\x81a\x06\tV[Q3_R`\x07` R`@_ Ua\x06;V[\x7F\xA4\x995\xAC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\xF3\xBA\xBAV\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\xB8.\xB6\xB7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F` `@\x94\x81\x85R\x80Q\x91\x82\x91\x82\x82\x88\x01R\x01\x86\x86\x01^_\x85\x82\x86\x01\x01R\x01\x16\x01\x01\x90V[`@\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x07\x87W`@RV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[\x90`\x1F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x07\x87W`@RV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x07\x87W`\x1F\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x16` \x01\x90V[`\x045\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x01\xC1WV[`$5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x01\xC1WV[`@Q\x90_`\x01T\x80`\x01\x1C\x91`\x01\x82\x16\x91\x82\x15a\t\x84W[` \x84\x10\x83\x14a\tWW\x83\x86R\x85\x92\x90\x81\x15a\t\x1AWP`\x01\x14a\x08\xBBW[a\x08\xB9\x92P\x03\x83a\x07\xB4V[V[P`\x01_\x90\x81R\x90\x91\x7F\xB1\x0E-Rv\x12\x07;&\xEE\xCD\xFDq~j2\x0C\xF4KJ\xFA\xC2\xB0s-\x9F\xCB\xE2\xB7\xFA\x0C\xF6[\x81\x83\x10a\x08\xFEWPP\x90` a\x08\xB9\x92\x82\x01\x01a\x08\xADV[` \x91\x93P\x80`\x01\x91T\x83\x85\x89\x01\x01R\x01\x91\x01\x90\x91\x84\x92a\x08\xE6V[` \x92Pa\x08\xB9\x94\x91P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x16\x82\x84\x01R\x15\x15`\x05\x1B\x82\x01\x01a\x08\xADV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\"`\x04R`$_\xFD[\x92`\x7F\x16\x92a\x08\x8EV[=\x15a\t\xB8W=\x90a\t\x9F\x82a\x07\xF5V[\x91a\t\xAD`@Q\x93\x84a\x07\xB4V[\x82R=_` \x84\x01>V[``\x90V",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610011575f80fd5b5f3560e01c806311163b2c146102495780632163b8c5146104d257806324600fc3146104695780633197cbb6146103cc5780634c583d8a1461031357806361d027b31461043757806362ea82db146103e9578063787c0a6c146103cc5780637a3979dc1461034657806391f901571461031357806392228006146101e2578063957bb1e014610274578063994595e114610249578063bc3da53514610204578063d1b4b9a3146101e2578063d57bde79146101c5578063eb91d37e146101c55763f77282ab146100df575f80fd5b346101c1575f6003193601126101c1576003544210610199577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff006002541660025573ffffffffffffffffffffffffffffffffffffffff6004541661013f57005b5f80808073ffffffffffffffffffffffffffffffffffffffff815416600554905af161016961098e565b501561017157005b7fbf961a28000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f64637389000000000000000000000000000000000000000000000000000000005f5260045ffd5b5f80fd5b346101c1575f6003193601126101c1576020600554604051908152f35b346101c1575f6003193601126101c157602060ff600254166040519015158152f35b346101c15760206003193601126101c15773ffffffffffffffffffffffffffffffffffffffff61023261082f565b165f526007602052602060405f2054604051908152f35b346101c1575f6003193601126101c157610270610264610875565b60405191829182610723565b0390f35b60206003193601126101c15760ff60025416156102eb5734156102c35760405161029d8161076b565b6004358152600160208201348152335f52600660205260405f2092518355519101555f80f35b7f61700f91000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f69b8d0fe000000000000000000000000000000000000000000000000000000005f5260045ffd5b346101c1575f6003193601126101c157602073ffffffffffffffffffffffffffffffffffffffff60045416604051908152f35b346101c15760606003193601126101c15761035f61082f565b610367610852565b5060443567ffffffffffffffff81116101c157366023820112156101c157806004013567ffffffffffffffff81116101c157369101602401116101c15760209073ffffffffffffffffffffffffffffffffffffffff8060045416911614604051908152f35b346101c1575f6003193601126101c1576020600354604051908152f35b346101c15760206003193601126101c15773ffffffffffffffffffffffffffffffffffffffff61041761082f565b165f5260066020526040805f206001815491015482519182526020820152f35b346101c1575f6003193601126101c157602073ffffffffffffffffffffffffffffffffffffffff5f5416604051908152f35b346101c1575f6003193601126101c157335f52600760205260405f205480156104aa575f808080933382526007602052816040812055335af161016961098e565b7f67e3990d000000000000000000000000000000000000000000000000000000005f5260045ffd5b346101c15760406003193601126101c15760043560243567ffffffffffffffff81116101c157366023820112156101c1578060040135610511816107f5565b9061051f60405192836107b4565b808252602082019236602483830101116101c157815f9260246020930186378301015260ff60025416156102eb57335f52600660205260405f20906001604051926105698461076b565b805484520154926020830193808552156106fb57835185116106d3576105d160408051809360208201958987525180918484015e81015f8382015203017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081018352826107b4565b5190209051036106ab575f9060055483115f1461069857505073ffffffffffffffffffffffffffffffffffffffff6004541680610682575b5080600555337fffffffffffffffffffffffff0000000000000000000000000000000000000000600454161760045560015b604051918252151560208201527f9c2d1dff1e244149eef8b49255674d40752acd825b23d4ad303807f98fe5953260403392a2335f90815260066020526040812060010155005b600554905f52600760205260405f205581610609565b51335f52600760205260405f205561063b565b7fa49935ac000000000000000000000000000000000000000000000000000000005f5260045ffd5b7ff3baba56000000000000000000000000000000000000000000000000000000005f5260045ffd5b7fb82eb6b7000000000000000000000000000000000000000000000000000000005f5260045ffd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f602060409481855280519182918282880152018686015e5f8582860101520116010190565b6040810190811067ffffffffffffffff82111761078757604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761078757604052565b67ffffffffffffffff811161078757601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b6004359073ffffffffffffffffffffffffffffffffffffffff821682036101c157565b6024359073ffffffffffffffffffffffffffffffffffffffff821682036101c157565b604051905f6001548060011c9160018216918215610984575b60208410831461095757838652859290811561091a57506001146108bb575b6108b9925003836107b4565b565b5060015f90815290917fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf65b8183106108fe5750509060206108b9928201016108ad565b60209193508060019154838589010152019101909184926108e6565b602092506108b99491507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001682840152151560051b8201016108ad565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b92607f169261088e565b3d156109b8573d9061099f826107f5565b916109ad60405193846107b4565b82523d5f602084013e565b60609056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x11W_\x80\xFD[_5`\xE0\x1C\x80c\x11\x16;,\x14a\x02IW\x80c!c\xB8\xC5\x14a\x04\xD2W\x80c$`\x0F\xC3\x14a\x04iW\x80c1\x97\xCB\xB6\x14a\x03\xCCW\x80cLX=\x8A\x14a\x03\x13W\x80ca\xD0'\xB3\x14a\x047W\x80cb\xEA\x82\xDB\x14a\x03\xE9W\x80cx|\nl\x14a\x03\xCCW\x80cz9y\xDC\x14a\x03FW\x80c\x91\xF9\x01W\x14a\x03\x13W\x80c\x92\"\x80\x06\x14a\x01\xE2W\x80c\x95{\xB1\xE0\x14a\x02tW\x80c\x99E\x95\xE1\x14a\x02IW\x80c\xBC=\xA55\x14a\x02\x04W\x80c\xD1\xB4\xB9\xA3\x14a\x01\xE2W\x80c\xD5{\xDEy\x14a\x01\xC5W\x80c\xEB\x91\xD3~\x14a\x01\xC5Wc\xF7r\x82\xAB\x14a\0\xDFW_\x80\xFD[4a\x01\xC1W_`\x03\x196\x01\x12a\x01\xC1W`\x03TB\x10a\x01\x99W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0`\x02T\x16`\x02Us\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x04T\x16a\x01?W\0[_\x80\x80\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81T\x16`\x05T\x90Z\xF1a\x01ia\t\x8EV[P\x15a\x01qW\0[\x7F\xBF\x96\x1A(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7Fdcs\x89\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[_\x80\xFD[4a\x01\xC1W_`\x03\x196\x01\x12a\x01\xC1W` `\x05T`@Q\x90\x81R\xF3[4a\x01\xC1W_`\x03\x196\x01\x12a\x01\xC1W` `\xFF`\x02T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x01\xC1W` `\x03\x196\x01\x12a\x01\xC1Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x022a\x08/V[\x16_R`\x07` R` `@_ T`@Q\x90\x81R\xF3[4a\x01\xC1W_`\x03\x196\x01\x12a\x01\xC1Wa\x02pa\x02da\x08uV[`@Q\x91\x82\x91\x82a\x07#V[\x03\x90\xF3[` `\x03\x196\x01\x12a\x01\xC1W`\xFF`\x02T\x16\x15a\x02\xEBW4\x15a\x02\xC3W`@Qa\x02\x9D\x81a\x07kV[`\x045\x81R`\x01` \x82\x014\x81R3_R`\x06` R`@_ \x92Q\x83UQ\x91\x01U_\x80\xF3[\x7Fap\x0F\x91\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7Fi\xB8\xD0\xFE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x01\xC1W_`\x03\x196\x01\x12a\x01\xC1W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x04T\x16`@Q\x90\x81R\xF3[4a\x01\xC1W```\x03\x196\x01\x12a\x01\xC1Wa\x03_a\x08/V[a\x03ga\x08RV[P`D5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x01\xC1W6`#\x82\x01\x12\x15a\x01\xC1W\x80`\x04\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x01\xC1W6\x91\x01`$\x01\x11a\x01\xC1W` \x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80`\x04T\x16\x91\x16\x14`@Q\x90\x81R\xF3[4a\x01\xC1W_`\x03\x196\x01\x12a\x01\xC1W` `\x03T`@Q\x90\x81R\xF3[4a\x01\xC1W` `\x03\x196\x01\x12a\x01\xC1Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x04\x17a\x08/V[\x16_R`\x06` R`@\x80_ `\x01\x81T\x91\x01T\x82Q\x91\x82R` \x82\x01R\xF3[4a\x01\xC1W_`\x03\x196\x01\x12a\x01\xC1W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF_T\x16`@Q\x90\x81R\xF3[4a\x01\xC1W_`\x03\x196\x01\x12a\x01\xC1W3_R`\x07` R`@_ T\x80\x15a\x04\xAAW_\x80\x80\x80\x933\x82R`\x07` R\x81`@\x81 U3Z\xF1a\x01ia\t\x8EV[\x7Fg\xE3\x99\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x01\xC1W`@`\x03\x196\x01\x12a\x01\xC1W`\x045`$5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x01\xC1W6`#\x82\x01\x12\x15a\x01\xC1W\x80`\x04\x015a\x05\x11\x81a\x07\xF5V[\x90a\x05\x1F`@Q\x92\x83a\x07\xB4V[\x80\x82R` \x82\x01\x926`$\x83\x83\x01\x01\x11a\x01\xC1W\x81_\x92`$` \x93\x01\x867\x83\x01\x01R`\xFF`\x02T\x16\x15a\x02\xEBW3_R`\x06` R`@_ \x90`\x01`@Q\x92a\x05i\x84a\x07kV[\x80T\x84R\x01T\x92` \x83\x01\x93\x80\x85R\x15a\x06\xFBW\x83Q\x85\x11a\x06\xD3Wa\x05\xD1`@\x80Q\x80\x93` \x82\x01\x95\x89\x87RQ\x80\x91\x84\x84\x01^\x81\x01_\x83\x82\x01R\x03\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x81\x01\x83R\x82a\x07\xB4V[Q\x90 \x90Q\x03a\x06\xABW_\x90`\x05T\x83\x11_\x14a\x06\x98WPPs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x04T\x16\x80a\x06\x82W[P\x80`\x05U3\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x04T\x16\x17`\x04U`\x01[`@Q\x91\x82R\x15\x15` \x82\x01R\x7F\x9C-\x1D\xFF\x1E$AI\xEE\xF8\xB4\x92UgM@u*\xCD\x82[#\xD4\xAD08\x07\xF9\x8F\xE5\x952`@3\x92\xA23_\x90\x81R`\x06` R`@\x81 `\x01\x01U\0[`\x05T\x90_R`\x07` R`@_ U\x81a\x06\tV[Q3_R`\x07` R`@_ Ua\x06;V[\x7F\xA4\x995\xAC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\xF3\xBA\xBAV\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\xB8.\xB6\xB7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F` `@\x94\x81\x85R\x80Q\x91\x82\x91\x82\x82\x88\x01R\x01\x86\x86\x01^_\x85\x82\x86\x01\x01R\x01\x16\x01\x01\x90V[`@\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x07\x87W`@RV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[\x90`\x1F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x07\x87W`@RV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x07\x87W`\x1F\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x16` \x01\x90V[`\x045\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x01\xC1WV[`$5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x01\xC1WV[`@Q\x90_`\x01T\x80`\x01\x1C\x91`\x01\x82\x16\x91\x82\x15a\t\x84W[` \x84\x10\x83\x14a\tWW\x83\x86R\x85\x92\x90\x81\x15a\t\x1AWP`\x01\x14a\x08\xBBW[a\x08\xB9\x92P\x03\x83a\x07\xB4V[V[P`\x01_\x90\x81R\x90\x91\x7F\xB1\x0E-Rv\x12\x07;&\xEE\xCD\xFDq~j2\x0C\xF4KJ\xFA\xC2\xB0s-\x9F\xCB\xE2\xB7\xFA\x0C\xF6[\x81\x83\x10a\x08\xFEWPP\x90` a\x08\xB9\x92\x82\x01\x01a\x08\xADV[` \x91\x93P\x80`\x01\x91T\x83\x85\x89\x01\x01R\x01\x91\x01\x90\x91\x84\x92a\x08\xE6V[` \x92Pa\x08\xB9\x94\x91P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x16\x82\x84\x01R\x15\x15`\x05\x1B\x82\x01\x01a\x08\xADV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\"`\x04R`$_\xFD[\x92`\x7F\x16\x92a\x08\x8EV[=\x15a\t\xB8W=\x90a\t\x9F\x82a\x07\xF5V[\x91a\t\xAD`@Q\x93\x84a\x07\xB4V[\x82R=_` \x84\x01>V[``\x90V",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AddressNotAllowed()` and selector `0x2b53784e`.
```solidity
error AddressNotAllowed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AddressNotAllowed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressNotAllowed> for UnderlyingRustTuple<'_> {
            fn from(value: AddressNotAllowed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AddressNotAllowed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressNotAllowed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressNotAllowed()";
            const SELECTOR: [u8; 4] = [43u8, 83u8, 120u8, 78u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AuctionNotActive()` and selector `0x69b8d0fe`.
```solidity
error AuctionNotActive();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AuctionNotActive;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AuctionNotActive> for UnderlyingRustTuple<'_> {
            fn from(value: AuctionNotActive) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AuctionNotActive {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AuctionNotActive {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AuctionNotActive()";
            const SELECTOR: [u8; 4] = [105u8, 184u8, 208u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AuctionNotEnded()` and selector `0x64637389`.
```solidity
error AuctionNotEnded();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AuctionNotEnded;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AuctionNotEnded> for UnderlyingRustTuple<'_> {
            fn from(value: AuctionNotEnded) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AuctionNotEnded {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AuctionNotEnded {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AuctionNotEnded()";
            const SELECTOR: [u8; 4] = [100u8, 99u8, 115u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `BidExceedsDeposit()` and selector `0xf3baba56`.
```solidity
error BidExceedsDeposit();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BidExceedsDeposit;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BidExceedsDeposit> for UnderlyingRustTuple<'_> {
            fn from(value: BidExceedsDeposit) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BidExceedsDeposit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BidExceedsDeposit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BidExceedsDeposit()";
            const SELECTOR: [u8; 4] = [243u8, 186u8, 186u8, 86u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidBidDeposit()` and selector `0x61700f91`.
```solidity
error InvalidBidDeposit();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidBidDeposit;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidBidDeposit> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidBidDeposit) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidBidDeposit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidBidDeposit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidBidDeposit()";
            const SELECTOR: [u8; 4] = [97u8, 112u8, 15u8, 145u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidBidReveal()` and selector `0xa49935ac`.
```solidity
error InvalidBidReveal();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidBidReveal;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidBidReveal> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidBidReveal) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidBidReveal {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidBidReveal {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidBidReveal()";
            const SELECTOR: [u8; 4] = [164u8, 153u8, 53u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidDuration()` and selector `0x76166401`.
```solidity
error InvalidDuration();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidDuration;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidDuration> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidDuration) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidDuration {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidDuration {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidDuration()";
            const SELECTOR: [u8; 4] = [118u8, 22u8, 100u8, 1u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NoBidFound()` and selector `0xb82eb6b7`.
```solidity
error NoBidFound();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoBidFound;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoBidFound> for UnderlyingRustTuple<'_> {
            fn from(value: NoBidFound) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NoBidFound {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoBidFound {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoBidFound()";
            const SELECTOR: [u8; 4] = [184u8, 46u8, 182u8, 183u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NoFundsToWithdraw()` and selector `0x67e3990d`.
```solidity
error NoFundsToWithdraw();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoFundsToWithdraw;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoFundsToWithdraw> for UnderlyingRustTuple<'_> {
            fn from(value: NoFundsToWithdraw) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NoFundsToWithdraw {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoFundsToWithdraw {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoFundsToWithdraw()";
            const SELECTOR: [u8; 4] = [103u8, 227u8, 153u8, 13u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `TransactionFailed()` and selector `0xbf961a28`.
```solidity
error TransactionFailed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TransactionFailed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TransactionFailed> for UnderlyingRustTuple<'_> {
            fn from(value: TransactionFailed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TransactionFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TransactionFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TransactionFailed()";
            const SELECTOR: [u8; 4] = [191u8, 150u8, 26u8, 40u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `BidRevealed(address,uint256,bool)` and selector `0x9c2d1dff1e244149eef8b49255674d40752acd825b23d4ad303807f98fe59532`.
```solidity
event BidRevealed(address indexed bidder, uint256 bid, bool isHighestBid);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BidRevealed {
        #[allow(missing_docs)]
        pub bidder: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub bid: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub isHighestBid: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BidRevealed {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BidRevealed(address,uint256,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                156u8, 45u8, 29u8, 255u8, 30u8, 36u8, 65u8, 73u8, 238u8, 248u8, 180u8,
                146u8, 85u8, 103u8, 77u8, 64u8, 117u8, 42u8, 205u8, 130u8, 91u8, 35u8,
                212u8, 173u8, 48u8, 56u8, 7u8, 249u8, 143u8, 229u8, 149u8, 50u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    bidder: topics.1,
                    bid: data.0,
                    isHighestBid: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.bid),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isHighestBid,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bidder.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bidder,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BidRevealed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BidRevealed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BidRevealed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(uint256 _duration, address _treasury);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub _duration: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _treasury: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value._duration, value._treasury)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _duration: tuple.0,
                        _treasury: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._duration),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._treasury,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `auctionActive()` and selector `0x92228006`.
```solidity
function auctionActive() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct auctionActiveCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`auctionActive()`](auctionActiveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct auctionActiveReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<auctionActiveCall> for UnderlyingRustTuple<'_> {
                fn from(value: auctionActiveCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for auctionActiveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<auctionActiveReturn> for UnderlyingRustTuple<'_> {
                fn from(value: auctionActiveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for auctionActiveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for auctionActiveCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "auctionActive()";
            const SELECTOR: [u8; 4] = [146u8, 34u8, 128u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: auctionActiveReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: auctionActiveReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `auctionType()` and selector `0x994595e1`.
```solidity
function auctionType() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct auctionTypeCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`auctionType()`](auctionTypeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct auctionTypeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<auctionTypeCall> for UnderlyingRustTuple<'_> {
                fn from(value: auctionTypeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for auctionTypeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<auctionTypeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: auctionTypeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for auctionTypeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for auctionTypeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "auctionType()";
            const SELECTOR: [u8; 4] = [153u8, 69u8, 149u8, 225u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: auctionTypeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: auctionTypeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `bid(bytes32)` and selector `0x957bb1e0`.
```solidity
function bid(bytes32 _sealedBid) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bidCall {
        #[allow(missing_docs)]
        pub _sealedBid: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`bid(bytes32)`](bidCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bidReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bidCall> for UnderlyingRustTuple<'_> {
                fn from(value: bidCall) -> Self {
                    (value._sealedBid,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bidCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _sealedBid: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bidReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bidReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bidReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl bidReturn {
            fn _tokenize(
                &self,
            ) -> <bidCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bidCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bidReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bid(bytes32)";
            const SELECTOR: [u8; 4] = [149u8, 123u8, 177u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._sealedBid),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                bidReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `bids(address)` and selector `0x62ea82db`.
```solidity
function bids(address) external view returns (bytes32 sealedBid, uint256 deposit);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bidsCall(pub alloy::sol_types::private::Address);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`bids(address)`](bidsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bidsReturn {
        #[allow(missing_docs)]
        pub sealedBid: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub deposit: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bidsCall> for UnderlyingRustTuple<'_> {
                fn from(value: bidsCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bidsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bidsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bidsReturn) -> Self {
                    (value.sealedBid, value.deposit)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bidsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        sealedBid: tuple.0,
                        deposit: tuple.1,
                    }
                }
            }
        }
        impl bidsReturn {
            fn _tokenize(
                &self,
            ) -> <bidsCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.sealedBid),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deposit),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bidsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bidsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bids(address)";
            const SELECTOR: [u8; 4] = [98u8, 234u8, 130u8, 219u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                bidsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `endTime()` and selector `0x3197cbb6`.
```solidity
function endTime() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct endTimeCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`endTime()`](endTimeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct endTimeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<endTimeCall> for UnderlyingRustTuple<'_> {
                fn from(value: endTimeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for endTimeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<endTimeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: endTimeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for endTimeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for endTimeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "endTime()";
            const SELECTOR: [u8; 4] = [49u8, 151u8, 203u8, 182u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: endTimeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: endTimeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `finalizeAuction()` and selector `0xf77282ab`.
```solidity
function finalizeAuction() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeAuctionCall;
    ///Container type for the return parameters of the [`finalizeAuction()`](finalizeAuctionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeAuctionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeAuctionCall> for UnderlyingRustTuple<'_> {
                fn from(value: finalizeAuctionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for finalizeAuctionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeAuctionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeAuctionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeAuctionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl finalizeAuctionReturn {
            fn _tokenize(
                &self,
            ) -> <finalizeAuctionCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for finalizeAuctionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = finalizeAuctionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "finalizeAuction()";
            const SELECTOR: [u8; 4] = [247u8, 114u8, 130u8, 171u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                finalizeAuctionReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getAuctionEndTime()` and selector `0x787c0a6c`.
```solidity
function getAuctionEndTime() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAuctionEndTimeCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getAuctionEndTime()`](getAuctionEndTimeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAuctionEndTimeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAuctionEndTimeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAuctionEndTimeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAuctionEndTimeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAuctionEndTimeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAuctionEndTimeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAuctionEndTimeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAuctionEndTimeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAuctionEndTime()";
            const SELECTOR: [u8; 4] = [120u8, 124u8, 10u8, 108u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getAuctionEndTimeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getAuctionEndTimeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getAuctionType()` and selector `0x11163b2c`.
```solidity
function getAuctionType() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAuctionTypeCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getAuctionType()`](getAuctionTypeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAuctionTypeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAuctionTypeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getAuctionTypeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getAuctionTypeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAuctionTypeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAuctionTypeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAuctionTypeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAuctionTypeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAuctionType()";
            const SELECTOR: [u8; 4] = [17u8, 22u8, 59u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getAuctionTypeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getAuctionTypeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getAuctionWinner()` and selector `0x4c583d8a`.
```solidity
function getAuctionWinner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAuctionWinnerCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getAuctionWinner()`](getAuctionWinnerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAuctionWinnerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAuctionWinnerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAuctionWinnerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAuctionWinnerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAuctionWinnerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAuctionWinnerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAuctionWinnerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAuctionWinnerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAuctionWinner()";
            const SELECTOR: [u8; 4] = [76u8, 88u8, 61u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getAuctionWinnerReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getAuctionWinnerReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getCurrentPrice()` and selector `0xeb91d37e`.
```solidity
function getCurrentPrice() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentPriceCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getCurrentPrice()`](getCurrentPriceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentPriceReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentPriceCall> for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentPriceCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getCurrentPriceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentPriceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentPriceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentPriceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentPriceCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentPrice()";
            const SELECTOR: [u8; 4] = [235u8, 145u8, 211u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getCurrentPriceReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getCurrentPriceReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `highestBid()` and selector `0xd57bde79`.
```solidity
function highestBid() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct highestBidCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`highestBid()`](highestBidCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct highestBidReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<highestBidCall> for UnderlyingRustTuple<'_> {
                fn from(value: highestBidCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for highestBidCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<highestBidReturn> for UnderlyingRustTuple<'_> {
                fn from(value: highestBidReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for highestBidReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for highestBidCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "highestBid()";
            const SELECTOR: [u8; 4] = [213u8, 123u8, 222u8, 121u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: highestBidReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: highestBidReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `highestBidder()` and selector `0x91f90157`.
```solidity
function highestBidder() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct highestBidderCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`highestBidder()`](highestBidderCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct highestBidderReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<highestBidderCall> for UnderlyingRustTuple<'_> {
                fn from(value: highestBidderCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for highestBidderCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<highestBidderReturn> for UnderlyingRustTuple<'_> {
                fn from(value: highestBidderReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for highestBidderReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for highestBidderCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "highestBidder()";
            const SELECTOR: [u8; 4] = [145u8, 249u8, 1u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: highestBidderReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: highestBidderReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isAllowed(address,address,bytes)` and selector `0x7a3979dc`.
```solidity
function isAllowed(address proposer, address, bytes memory) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isAllowedCall {
        #[allow(missing_docs)]
        pub proposer: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _2: alloy::sol_types::private::Bytes,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isAllowed(address,address,bytes)`](isAllowedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isAllowedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isAllowedCall> for UnderlyingRustTuple<'_> {
                fn from(value: isAllowedCall) -> Self {
                    (value.proposer, value._1, value._2)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isAllowedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        proposer: tuple.0,
                        _1: tuple.1,
                        _2: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isAllowedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isAllowedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isAllowedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isAllowedCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isAllowed(address,address,bytes)";
            const SELECTOR: [u8; 4] = [122u8, 57u8, 121u8, 220u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.proposer,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._1,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._2,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isAllowedReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isAllowedReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isAuctionActive()` and selector `0xd1b4b9a3`.
```solidity
function isAuctionActive() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isAuctionActiveCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isAuctionActive()`](isAuctionActiveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isAuctionActiveReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isAuctionActiveCall> for UnderlyingRustTuple<'_> {
                fn from(value: isAuctionActiveCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isAuctionActiveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isAuctionActiveReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isAuctionActiveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isAuctionActiveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isAuctionActiveCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isAuctionActive()";
            const SELECTOR: [u8; 4] = [209u8, 180u8, 185u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isAuctionActiveReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isAuctionActiveReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `refunds(address)` and selector `0xbc3da535`.
```solidity
function refunds(address) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct refundsCall(pub alloy::sol_types::private::Address);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`refunds(address)`](refundsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct refundsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<refundsCall> for UnderlyingRustTuple<'_> {
                fn from(value: refundsCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for refundsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<refundsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: refundsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for refundsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for refundsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "refunds(address)";
            const SELECTOR: [u8; 4] = [188u8, 61u8, 165u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: refundsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: refundsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `revealBid(uint256,string)` and selector `0x2163b8c5`.
```solidity
function revealBid(uint256 _bid, string memory _salt) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revealBidCall {
        #[allow(missing_docs)]
        pub _bid: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _salt: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`revealBid(uint256,string)`](revealBidCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revealBidReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revealBidCall> for UnderlyingRustTuple<'_> {
                fn from(value: revealBidCall) -> Self {
                    (value._bid, value._salt)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revealBidCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _bid: tuple.0,
                        _salt: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revealBidReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revealBidReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revealBidReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl revealBidReturn {
            fn _tokenize(
                &self,
            ) -> <revealBidCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revealBidCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revealBidReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revealBid(uint256,string)";
            const SELECTOR: [u8; 4] = [33u8, 99u8, 184u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._bid),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self._salt,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                revealBidReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `treasury()` and selector `0x61d027b3`.
```solidity
function treasury() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct treasuryCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`treasury()`](treasuryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct treasuryReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<treasuryCall> for UnderlyingRustTuple<'_> {
                fn from(value: treasuryCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for treasuryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<treasuryReturn> for UnderlyingRustTuple<'_> {
                fn from(value: treasuryReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for treasuryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for treasuryCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "treasury()";
            const SELECTOR: [u8; 4] = [97u8, 208u8, 39u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: treasuryReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: treasuryReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `withdrawFunds()` and selector `0x24600fc3`.
```solidity
function withdrawFunds() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawFundsCall;
    ///Container type for the return parameters of the [`withdrawFunds()`](withdrawFundsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawFundsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawFundsCall> for UnderlyingRustTuple<'_> {
                fn from(value: withdrawFundsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for withdrawFundsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawFundsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: withdrawFundsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for withdrawFundsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl withdrawFundsReturn {
            fn _tokenize(
                &self,
            ) -> <withdrawFundsCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for withdrawFundsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = withdrawFundsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "withdrawFunds()";
            const SELECTOR: [u8; 4] = [36u8, 96u8, 15u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                withdrawFundsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`SealedBidAuctionSequencingModule`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum SealedBidAuctionSequencingModuleCalls {
        #[allow(missing_docs)]
        auctionActive(auctionActiveCall),
        #[allow(missing_docs)]
        auctionType(auctionTypeCall),
        #[allow(missing_docs)]
        bid(bidCall),
        #[allow(missing_docs)]
        bids(bidsCall),
        #[allow(missing_docs)]
        endTime(endTimeCall),
        #[allow(missing_docs)]
        finalizeAuction(finalizeAuctionCall),
        #[allow(missing_docs)]
        getAuctionEndTime(getAuctionEndTimeCall),
        #[allow(missing_docs)]
        getAuctionType(getAuctionTypeCall),
        #[allow(missing_docs)]
        getAuctionWinner(getAuctionWinnerCall),
        #[allow(missing_docs)]
        getCurrentPrice(getCurrentPriceCall),
        #[allow(missing_docs)]
        highestBid(highestBidCall),
        #[allow(missing_docs)]
        highestBidder(highestBidderCall),
        #[allow(missing_docs)]
        isAllowed(isAllowedCall),
        #[allow(missing_docs)]
        isAuctionActive(isAuctionActiveCall),
        #[allow(missing_docs)]
        refunds(refundsCall),
        #[allow(missing_docs)]
        revealBid(revealBidCall),
        #[allow(missing_docs)]
        treasury(treasuryCall),
        #[allow(missing_docs)]
        withdrawFunds(withdrawFundsCall),
    }
    #[automatically_derived]
    impl SealedBidAuctionSequencingModuleCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [17u8, 22u8, 59u8, 44u8],
            [33u8, 99u8, 184u8, 197u8],
            [36u8, 96u8, 15u8, 195u8],
            [49u8, 151u8, 203u8, 182u8],
            [76u8, 88u8, 61u8, 138u8],
            [97u8, 208u8, 39u8, 179u8],
            [98u8, 234u8, 130u8, 219u8],
            [120u8, 124u8, 10u8, 108u8],
            [122u8, 57u8, 121u8, 220u8],
            [145u8, 249u8, 1u8, 87u8],
            [146u8, 34u8, 128u8, 6u8],
            [149u8, 123u8, 177u8, 224u8],
            [153u8, 69u8, 149u8, 225u8],
            [188u8, 61u8, 165u8, 53u8],
            [209u8, 180u8, 185u8, 163u8],
            [213u8, 123u8, 222u8, 121u8],
            [235u8, 145u8, 211u8, 126u8],
            [247u8, 114u8, 130u8, 171u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SealedBidAuctionSequencingModuleCalls {
        const NAME: &'static str = "SealedBidAuctionSequencingModuleCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 18usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::auctionActive(_) => {
                    <auctionActiveCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::auctionType(_) => {
                    <auctionTypeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bid(_) => <bidCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::bids(_) => <bidsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::endTime(_) => <endTimeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::finalizeAuction(_) => {
                    <finalizeAuctionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAuctionEndTime(_) => {
                    <getAuctionEndTimeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAuctionType(_) => {
                    <getAuctionTypeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAuctionWinner(_) => {
                    <getAuctionWinnerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCurrentPrice(_) => {
                    <getCurrentPriceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::highestBid(_) => {
                    <highestBidCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::highestBidder(_) => {
                    <highestBidderCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isAllowed(_) => {
                    <isAllowedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isAuctionActive(_) => {
                    <isAuctionActiveCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::refunds(_) => <refundsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::revealBid(_) => {
                    <revealBidCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::treasury(_) => <treasuryCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::withdrawFunds(_) => {
                    <withdrawFundsCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls>] = &[
                {
                    fn getAuctionType(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <getAuctionTypeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::getAuctionType)
                    }
                    getAuctionType
                },
                {
                    fn revealBid(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <revealBidCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SealedBidAuctionSequencingModuleCalls::revealBid)
                    }
                    revealBid
                },
                {
                    fn withdrawFunds(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <withdrawFundsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::withdrawFunds)
                    }
                    withdrawFunds
                },
                {
                    fn endTime(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <endTimeCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SealedBidAuctionSequencingModuleCalls::endTime)
                    }
                    endTime
                },
                {
                    fn getAuctionWinner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <getAuctionWinnerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::getAuctionWinner)
                    }
                    getAuctionWinner
                },
                {
                    fn treasury(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <treasuryCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SealedBidAuctionSequencingModuleCalls::treasury)
                    }
                    treasury
                },
                {
                    fn bids(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <bidsCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SealedBidAuctionSequencingModuleCalls::bids)
                    }
                    bids
                },
                {
                    fn getAuctionEndTime(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <getAuctionEndTimeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                SealedBidAuctionSequencingModuleCalls::getAuctionEndTime,
                            )
                    }
                    getAuctionEndTime
                },
                {
                    fn isAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <isAllowedCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SealedBidAuctionSequencingModuleCalls::isAllowed)
                    }
                    isAllowed
                },
                {
                    fn highestBidder(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <highestBidderCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::highestBidder)
                    }
                    highestBidder
                },
                {
                    fn auctionActive(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <auctionActiveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::auctionActive)
                    }
                    auctionActive
                },
                {
                    fn bid(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <bidCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SealedBidAuctionSequencingModuleCalls::bid)
                    }
                    bid
                },
                {
                    fn auctionType(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <auctionTypeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::auctionType)
                    }
                    auctionType
                },
                {
                    fn refunds(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <refundsCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SealedBidAuctionSequencingModuleCalls::refunds)
                    }
                    refunds
                },
                {
                    fn isAuctionActive(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <isAuctionActiveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::isAuctionActive)
                    }
                    isAuctionActive
                },
                {
                    fn highestBid(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <highestBidCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::highestBid)
                    }
                    highestBid
                },
                {
                    fn getCurrentPrice(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <getCurrentPriceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::getCurrentPrice)
                    }
                    getCurrentPrice
                },
                {
                    fn finalizeAuction(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <finalizeAuctionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::finalizeAuction)
                    }
                    finalizeAuction
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls>] = &[
                {
                    fn getAuctionType(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <getAuctionTypeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::getAuctionType)
                    }
                    getAuctionType
                },
                {
                    fn revealBid(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <revealBidCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::revealBid)
                    }
                    revealBid
                },
                {
                    fn withdrawFunds(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <withdrawFundsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::withdrawFunds)
                    }
                    withdrawFunds
                },
                {
                    fn endTime(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <endTimeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::endTime)
                    }
                    endTime
                },
                {
                    fn getAuctionWinner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <getAuctionWinnerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::getAuctionWinner)
                    }
                    getAuctionWinner
                },
                {
                    fn treasury(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <treasuryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::treasury)
                    }
                    treasury
                },
                {
                    fn bids(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <bidsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::bids)
                    }
                    bids
                },
                {
                    fn getAuctionEndTime(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <getAuctionEndTimeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                SealedBidAuctionSequencingModuleCalls::getAuctionEndTime,
                            )
                    }
                    getAuctionEndTime
                },
                {
                    fn isAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <isAllowedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::isAllowed)
                    }
                    isAllowed
                },
                {
                    fn highestBidder(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <highestBidderCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::highestBidder)
                    }
                    highestBidder
                },
                {
                    fn auctionActive(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <auctionActiveCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::auctionActive)
                    }
                    auctionActive
                },
                {
                    fn bid(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <bidCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::bid)
                    }
                    bid
                },
                {
                    fn auctionType(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <auctionTypeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::auctionType)
                    }
                    auctionType
                },
                {
                    fn refunds(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <refundsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::refunds)
                    }
                    refunds
                },
                {
                    fn isAuctionActive(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <isAuctionActiveCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::isAuctionActive)
                    }
                    isAuctionActive
                },
                {
                    fn highestBid(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <highestBidCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::highestBid)
                    }
                    highestBid
                },
                {
                    fn getCurrentPrice(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <getCurrentPriceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::getCurrentPrice)
                    }
                    getCurrentPrice
                },
                {
                    fn finalizeAuction(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleCalls> {
                        <finalizeAuctionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleCalls::finalizeAuction)
                    }
                    finalizeAuction
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::auctionActive(inner) => {
                    <auctionActiveCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::auctionType(inner) => {
                    <auctionTypeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bid(inner) => {
                    <bidCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::bids(inner) => {
                    <bidsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::endTime(inner) => {
                    <endTimeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::finalizeAuction(inner) => {
                    <finalizeAuctionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAuctionEndTime(inner) => {
                    <getAuctionEndTimeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAuctionType(inner) => {
                    <getAuctionTypeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAuctionWinner(inner) => {
                    <getAuctionWinnerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCurrentPrice(inner) => {
                    <getCurrentPriceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::highestBid(inner) => {
                    <highestBidCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::highestBidder(inner) => {
                    <highestBidderCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isAllowed(inner) => {
                    <isAllowedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isAuctionActive(inner) => {
                    <isAuctionActiveCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::refunds(inner) => {
                    <refundsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::revealBid(inner) => {
                    <revealBidCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::treasury(inner) => {
                    <treasuryCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::withdrawFunds(inner) => {
                    <withdrawFundsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::auctionActive(inner) => {
                    <auctionActiveCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::auctionType(inner) => {
                    <auctionTypeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bid(inner) => {
                    <bidCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::bids(inner) => {
                    <bidsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::endTime(inner) => {
                    <endTimeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::finalizeAuction(inner) => {
                    <finalizeAuctionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAuctionEndTime(inner) => {
                    <getAuctionEndTimeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAuctionType(inner) => {
                    <getAuctionTypeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAuctionWinner(inner) => {
                    <getAuctionWinnerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCurrentPrice(inner) => {
                    <getCurrentPriceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::highestBid(inner) => {
                    <highestBidCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::highestBidder(inner) => {
                    <highestBidderCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isAllowed(inner) => {
                    <isAllowedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isAuctionActive(inner) => {
                    <isAuctionActiveCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::refunds(inner) => {
                    <refundsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::revealBid(inner) => {
                    <revealBidCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::treasury(inner) => {
                    <treasuryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::withdrawFunds(inner) => {
                    <withdrawFundsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`SealedBidAuctionSequencingModule`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum SealedBidAuctionSequencingModuleErrors {
        #[allow(missing_docs)]
        AddressNotAllowed(AddressNotAllowed),
        #[allow(missing_docs)]
        AuctionNotActive(AuctionNotActive),
        #[allow(missing_docs)]
        AuctionNotEnded(AuctionNotEnded),
        #[allow(missing_docs)]
        BidExceedsDeposit(BidExceedsDeposit),
        #[allow(missing_docs)]
        InvalidBidDeposit(InvalidBidDeposit),
        #[allow(missing_docs)]
        InvalidBidReveal(InvalidBidReveal),
        #[allow(missing_docs)]
        InvalidDuration(InvalidDuration),
        #[allow(missing_docs)]
        NoBidFound(NoBidFound),
        #[allow(missing_docs)]
        NoFundsToWithdraw(NoFundsToWithdraw),
        #[allow(missing_docs)]
        TransactionFailed(TransactionFailed),
    }
    #[automatically_derived]
    impl SealedBidAuctionSequencingModuleErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [43u8, 83u8, 120u8, 78u8],
            [97u8, 112u8, 15u8, 145u8],
            [100u8, 99u8, 115u8, 137u8],
            [103u8, 227u8, 153u8, 13u8],
            [105u8, 184u8, 208u8, 254u8],
            [118u8, 22u8, 100u8, 1u8],
            [164u8, 153u8, 53u8, 172u8],
            [184u8, 46u8, 182u8, 183u8],
            [191u8, 150u8, 26u8, 40u8],
            [243u8, 186u8, 186u8, 86u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SealedBidAuctionSequencingModuleErrors {
        const NAME: &'static str = "SealedBidAuctionSequencingModuleErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 10usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AddressNotAllowed(_) => {
                    <AddressNotAllowed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AuctionNotActive(_) => {
                    <AuctionNotActive as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AuctionNotEnded(_) => {
                    <AuctionNotEnded as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BidExceedsDeposit(_) => {
                    <BidExceedsDeposit as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidBidDeposit(_) => {
                    <InvalidBidDeposit as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidBidReveal(_) => {
                    <InvalidBidReveal as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidDuration(_) => {
                    <InvalidDuration as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NoBidFound(_) => {
                    <NoBidFound as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NoFundsToWithdraw(_) => {
                    <NoFundsToWithdraw as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TransactionFailed(_) => {
                    <TransactionFailed as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleErrors>] = &[
                {
                    fn AddressNotAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<
                        SealedBidAuctionSequencingModuleErrors,
                    > {
                        <AddressNotAllowed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                SealedBidAuctionSequencingModuleErrors::AddressNotAllowed,
                            )
                    }
                    AddressNotAllowed
                },
                {
                    fn InvalidBidDeposit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<
                        SealedBidAuctionSequencingModuleErrors,
                    > {
                        <InvalidBidDeposit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                SealedBidAuctionSequencingModuleErrors::InvalidBidDeposit,
                            )
                    }
                    InvalidBidDeposit
                },
                {
                    fn AuctionNotEnded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<
                        SealedBidAuctionSequencingModuleErrors,
                    > {
                        <AuctionNotEnded as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleErrors::AuctionNotEnded)
                    }
                    AuctionNotEnded
                },
                {
                    fn NoFundsToWithdraw(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<
                        SealedBidAuctionSequencingModuleErrors,
                    > {
                        <NoFundsToWithdraw as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                SealedBidAuctionSequencingModuleErrors::NoFundsToWithdraw,
                            )
                    }
                    NoFundsToWithdraw
                },
                {
                    fn AuctionNotActive(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<
                        SealedBidAuctionSequencingModuleErrors,
                    > {
                        <AuctionNotActive as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                SealedBidAuctionSequencingModuleErrors::AuctionNotActive,
                            )
                    }
                    AuctionNotActive
                },
                {
                    fn InvalidDuration(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<
                        SealedBidAuctionSequencingModuleErrors,
                    > {
                        <InvalidDuration as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleErrors::InvalidDuration)
                    }
                    InvalidDuration
                },
                {
                    fn InvalidBidReveal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<
                        SealedBidAuctionSequencingModuleErrors,
                    > {
                        <InvalidBidReveal as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                SealedBidAuctionSequencingModuleErrors::InvalidBidReveal,
                            )
                    }
                    InvalidBidReveal
                },
                {
                    fn NoBidFound(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<
                        SealedBidAuctionSequencingModuleErrors,
                    > {
                        <NoBidFound as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(SealedBidAuctionSequencingModuleErrors::NoBidFound)
                    }
                    NoBidFound
                },
                {
                    fn TransactionFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<
                        SealedBidAuctionSequencingModuleErrors,
                    > {
                        <TransactionFailed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                SealedBidAuctionSequencingModuleErrors::TransactionFailed,
                            )
                    }
                    TransactionFailed
                },
                {
                    fn BidExceedsDeposit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<
                        SealedBidAuctionSequencingModuleErrors,
                    > {
                        <BidExceedsDeposit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                SealedBidAuctionSequencingModuleErrors::BidExceedsDeposit,
                            )
                    }
                    BidExceedsDeposit
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SealedBidAuctionSequencingModuleErrors>] = &[
                {
                    fn AddressNotAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<
                        SealedBidAuctionSequencingModuleErrors,
                    > {
                        <AddressNotAllowed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                SealedBidAuctionSequencingModuleErrors::AddressNotAllowed,
                            )
                    }
                    AddressNotAllowed
                },
                {
                    fn InvalidBidDeposit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<
                        SealedBidAuctionSequencingModuleErrors,
                    > {
                        <InvalidBidDeposit as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                SealedBidAuctionSequencingModuleErrors::InvalidBidDeposit,
                            )
                    }
                    InvalidBidDeposit
                },
                {
                    fn AuctionNotEnded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<
                        SealedBidAuctionSequencingModuleErrors,
                    > {
                        <AuctionNotEnded as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleErrors::AuctionNotEnded)
                    }
                    AuctionNotEnded
                },
                {
                    fn NoFundsToWithdraw(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<
                        SealedBidAuctionSequencingModuleErrors,
                    > {
                        <NoFundsToWithdraw as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                SealedBidAuctionSequencingModuleErrors::NoFundsToWithdraw,
                            )
                    }
                    NoFundsToWithdraw
                },
                {
                    fn AuctionNotActive(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<
                        SealedBidAuctionSequencingModuleErrors,
                    > {
                        <AuctionNotActive as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                SealedBidAuctionSequencingModuleErrors::AuctionNotActive,
                            )
                    }
                    AuctionNotActive
                },
                {
                    fn InvalidDuration(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<
                        SealedBidAuctionSequencingModuleErrors,
                    > {
                        <InvalidDuration as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleErrors::InvalidDuration)
                    }
                    InvalidDuration
                },
                {
                    fn InvalidBidReveal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<
                        SealedBidAuctionSequencingModuleErrors,
                    > {
                        <InvalidBidReveal as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                SealedBidAuctionSequencingModuleErrors::InvalidBidReveal,
                            )
                    }
                    InvalidBidReveal
                },
                {
                    fn NoBidFound(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<
                        SealedBidAuctionSequencingModuleErrors,
                    > {
                        <NoBidFound as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SealedBidAuctionSequencingModuleErrors::NoBidFound)
                    }
                    NoBidFound
                },
                {
                    fn TransactionFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<
                        SealedBidAuctionSequencingModuleErrors,
                    > {
                        <TransactionFailed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                SealedBidAuctionSequencingModuleErrors::TransactionFailed,
                            )
                    }
                    TransactionFailed
                },
                {
                    fn BidExceedsDeposit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<
                        SealedBidAuctionSequencingModuleErrors,
                    > {
                        <BidExceedsDeposit as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                SealedBidAuctionSequencingModuleErrors::BidExceedsDeposit,
                            )
                    }
                    BidExceedsDeposit
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AddressNotAllowed(inner) => {
                    <AddressNotAllowed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AuctionNotActive(inner) => {
                    <AuctionNotActive as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AuctionNotEnded(inner) => {
                    <AuctionNotEnded as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BidExceedsDeposit(inner) => {
                    <BidExceedsDeposit as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidBidDeposit(inner) => {
                    <InvalidBidDeposit as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidBidReveal(inner) => {
                    <InvalidBidReveal as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidDuration(inner) => {
                    <InvalidDuration as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NoBidFound(inner) => {
                    <NoBidFound as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NoFundsToWithdraw(inner) => {
                    <NoFundsToWithdraw as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TransactionFailed(inner) => {
                    <TransactionFailed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AddressNotAllowed(inner) => {
                    <AddressNotAllowed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AuctionNotActive(inner) => {
                    <AuctionNotActive as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AuctionNotEnded(inner) => {
                    <AuctionNotEnded as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BidExceedsDeposit(inner) => {
                    <BidExceedsDeposit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidBidDeposit(inner) => {
                    <InvalidBidDeposit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidBidReveal(inner) => {
                    <InvalidBidReveal as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidDuration(inner) => {
                    <InvalidDuration as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NoBidFound(inner) => {
                    <NoBidFound as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::NoFundsToWithdraw(inner) => {
                    <NoFundsToWithdraw as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TransactionFailed(inner) => {
                    <TransactionFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`SealedBidAuctionSequencingModule`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum SealedBidAuctionSequencingModuleEvents {
        #[allow(missing_docs)]
        BidRevealed(BidRevealed),
    }
    #[automatically_derived]
    impl SealedBidAuctionSequencingModuleEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                156u8, 45u8, 29u8, 255u8, 30u8, 36u8, 65u8, 73u8, 238u8, 248u8, 180u8,
                146u8, 85u8, 103u8, 77u8, 64u8, 117u8, 42u8, 205u8, 130u8, 91u8, 35u8,
                212u8, 173u8, 48u8, 56u8, 7u8, 249u8, 143u8, 229u8, 149u8, 50u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for SealedBidAuctionSequencingModuleEvents {
        const NAME: &'static str = "SealedBidAuctionSequencingModuleEvents";
        const COUNT: usize = 1usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<BidRevealed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BidRevealed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::BidRevealed)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData
    for SealedBidAuctionSequencingModuleEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::BidRevealed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::BidRevealed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`SealedBidAuctionSequencingModule`](self) contract instance.

See the [wrapper's documentation](`SealedBidAuctionSequencingModuleInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> SealedBidAuctionSequencingModuleInstance<P, N> {
        SealedBidAuctionSequencingModuleInstance::<P, N>::new(address, __provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        _duration: alloy::sol_types::private::primitives::aliases::U256,
        _treasury: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<SealedBidAuctionSequencingModuleInstance<P, N>>,
    > {
        SealedBidAuctionSequencingModuleInstance::<
            P,
            N,
        >::deploy(__provider, _duration, _treasury)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        _duration: alloy::sol_types::private::primitives::aliases::U256,
        _treasury: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<P, N> {
        SealedBidAuctionSequencingModuleInstance::<
            P,
            N,
        >::deploy_builder(__provider, _duration, _treasury)
    }
    /**A [`SealedBidAuctionSequencingModule`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`SealedBidAuctionSequencingModule`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct SealedBidAuctionSequencingModuleInstance<
        P,
        N = alloy_contract::private::Ethereum,
    > {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for SealedBidAuctionSequencingModuleInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("SealedBidAuctionSequencingModuleInstance")
                .field(&self.address)
                .finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SealedBidAuctionSequencingModuleInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`SealedBidAuctionSequencingModule`](self) contract instance.

See the [wrapper's documentation](`SealedBidAuctionSequencingModuleInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            __provider: P,
            _duration: alloy::sol_types::private::primitives::aliases::U256,
            _treasury: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<SealedBidAuctionSequencingModuleInstance<P, N>> {
            let call_builder = Self::deploy_builder(__provider, _duration, _treasury);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            __provider: P,
            _duration: alloy::sol_types::private::primitives::aliases::U256,
            _treasury: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                __provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            _duration,
                            _treasury,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> SealedBidAuctionSequencingModuleInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(
            self,
        ) -> SealedBidAuctionSequencingModuleInstance<P, N> {
            SealedBidAuctionSequencingModuleInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SealedBidAuctionSequencingModuleInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`auctionActive`] function.
        pub fn auctionActive(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, auctionActiveCall, N> {
            self.call_builder(&auctionActiveCall)
        }
        ///Creates a new call builder for the [`auctionType`] function.
        pub fn auctionType(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, auctionTypeCall, N> {
            self.call_builder(&auctionTypeCall)
        }
        ///Creates a new call builder for the [`bid`] function.
        pub fn bid(
            &self,
            _sealedBid: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, bidCall, N> {
            self.call_builder(&bidCall { _sealedBid })
        }
        ///Creates a new call builder for the [`bids`] function.
        pub fn bids(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, bidsCall, N> {
            self.call_builder(&bidsCall(_0))
        }
        ///Creates a new call builder for the [`endTime`] function.
        pub fn endTime(&self) -> alloy_contract::SolCallBuilder<&P, endTimeCall, N> {
            self.call_builder(&endTimeCall)
        }
        ///Creates a new call builder for the [`finalizeAuction`] function.
        pub fn finalizeAuction(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, finalizeAuctionCall, N> {
            self.call_builder(&finalizeAuctionCall)
        }
        ///Creates a new call builder for the [`getAuctionEndTime`] function.
        pub fn getAuctionEndTime(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getAuctionEndTimeCall, N> {
            self.call_builder(&getAuctionEndTimeCall)
        }
        ///Creates a new call builder for the [`getAuctionType`] function.
        pub fn getAuctionType(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getAuctionTypeCall, N> {
            self.call_builder(&getAuctionTypeCall)
        }
        ///Creates a new call builder for the [`getAuctionWinner`] function.
        pub fn getAuctionWinner(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getAuctionWinnerCall, N> {
            self.call_builder(&getAuctionWinnerCall)
        }
        ///Creates a new call builder for the [`getCurrentPrice`] function.
        pub fn getCurrentPrice(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getCurrentPriceCall, N> {
            self.call_builder(&getCurrentPriceCall)
        }
        ///Creates a new call builder for the [`highestBid`] function.
        pub fn highestBid(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, highestBidCall, N> {
            self.call_builder(&highestBidCall)
        }
        ///Creates a new call builder for the [`highestBidder`] function.
        pub fn highestBidder(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, highestBidderCall, N> {
            self.call_builder(&highestBidderCall)
        }
        ///Creates a new call builder for the [`isAllowed`] function.
        pub fn isAllowed(
            &self,
            proposer: alloy::sol_types::private::Address,
            _1: alloy::sol_types::private::Address,
            _2: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, isAllowedCall, N> {
            self.call_builder(&isAllowedCall { proposer, _1, _2 })
        }
        ///Creates a new call builder for the [`isAuctionActive`] function.
        pub fn isAuctionActive(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, isAuctionActiveCall, N> {
            self.call_builder(&isAuctionActiveCall)
        }
        ///Creates a new call builder for the [`refunds`] function.
        pub fn refunds(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, refundsCall, N> {
            self.call_builder(&refundsCall(_0))
        }
        ///Creates a new call builder for the [`revealBid`] function.
        pub fn revealBid(
            &self,
            _bid: alloy::sol_types::private::primitives::aliases::U256,
            _salt: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<&P, revealBidCall, N> {
            self.call_builder(&revealBidCall { _bid, _salt })
        }
        ///Creates a new call builder for the [`treasury`] function.
        pub fn treasury(&self) -> alloy_contract::SolCallBuilder<&P, treasuryCall, N> {
            self.call_builder(&treasuryCall)
        }
        ///Creates a new call builder for the [`withdrawFunds`] function.
        pub fn withdrawFunds(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, withdrawFundsCall, N> {
            self.call_builder(&withdrawFundsCall)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SealedBidAuctionSequencingModuleInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`BidRevealed`] event.
        pub fn BidRevealed_filter(&self) -> alloy_contract::Event<&P, BidRevealed, N> {
            self.event_filter::<BidRevealed>()
        }
    }
}
