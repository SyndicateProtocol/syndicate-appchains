/**

Generated by the following Solidity interface...
```solidity
interface SyndStaking {
    struct ClaimRequest {
        uint256 epochIndex;
        address poolAddress;
    }

    error FailedCall();
    error InsufficientBalance(uint256 balance, uint256 needed);
    error InsufficientStake();
    error InvalidAmount();
    error InvalidAppchainId();
    error InvalidInput();
    error InvalidStakingAmount(uint256 totalAmount, uint256 sentAmount);
    error InvalidWithdrawal();
    error NoClaimsProvided();
    error ReentrancyGuardReentrantCall();
    error WithdrawalNotReady();
    error ZeroEpochIndex();

    event Stake(uint256 epochIndex, address user, uint256 amount, uint256 appchainId);
    event StakeTransfer(uint256 epochIndex, address user, uint256 amount, uint256 fromAppchainId, uint256 toAppchainId);
    event WithdrawalCompleted(address user, address destination, uint256 amount);
    event WithdrawalInitialized(address user, uint256 appchainId, uint256 amount);

    function EPOCH_DURATION() external view returns (uint256);
    function START_TIMESTAMP() external view returns (uint256);
    function appchainFinalizedEpochCount(uint256 appchainId) external view returns (uint256 finalizedEpochCount);
    function appchainTotal(uint256 appchainId) external view returns (uint256 total);
    function claimAllRewards(ClaimRequest[] memory claims, address destination) external;
    function epochAdditions(uint256 epochIndex) external view returns (uint256 additions);
    function epochAppchainAdditions(uint256 epochIndex, uint256 appchainId) external view returns (uint256 additions);
    function epochAppchainTotal(uint256 epochIndex, uint256 appchainId) external view returns (uint256 total);
    function epochAppchainWithdrawals(uint256 epochIndex, uint256 appchainId) external view returns (uint256 withdrawals);
    function epochStakeShare(uint256 epochIndex) external view returns (uint256 stakeShare);
    function epochTotal(uint256 epochIndex) external view returns (uint256 total);
    function epochUserAdditions(uint256 epochIndex, address user) external view returns (uint256 additions);
    function epochUserAppchainAdditions(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256 additions);
    function epochUserAppchainTotal(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256 total);
    function epochUserAppchainWithdrawals(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256 withdrawals);
    function epochUserStakeShare(uint256 epochIndex, address user) external view returns (uint256 stakeShare);
    function epochUserTotal(uint256 epochIndex, address user) external view returns (uint256 total);
    function epochUserWithdrawals(uint256 epochIndex, address user) external view returns (uint256 withdrawals);
    function epochWithdrawals(uint256 epochIndex) external view returns (uint256 withdrawals);
    function finalizeAppchainEpochs(uint256 appchainId) external;
    function finalizeEpochs() external;
    function finalizeUserAppchainEpochs(address user, uint256 appchainId) external;
    function finalizeUserEpochs(address user) external;
    function finalizedEpochCount() external view returns (uint256);
    function getAppchainStake(uint256 epochIndex, uint256 appchainId) external view returns (uint256);
    function getCurrentEpoch() external view returns (uint256);
    function getEpochEnd(uint256 epochIndex) external pure returns (uint256);
    function getEpochStart(uint256 epochIndex) external pure returns (uint256);
    function getTotalStake(uint256 epochIndex) external view returns (uint256);
    function getTotalStakeShare(uint256 epochIndex) external view returns (uint256);
    function getUserAppchainStake(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256);
    function getUserStake(uint256 epochIndex, address user) external view returns (uint256);
    function getUserStakeShare(uint256 epochIndex, address user) external view returns (uint256);
    function getWithdrawalAmount(address user, uint256 appchainId) external view returns (uint256);
    function initializeWithdrawal(uint256 appchainId) external;
    function initializeWithdrawal(uint256 appchainId, uint256 amount) external;
    function initializeWithdrawals(uint256[] memory appchainIds, uint256[] memory amounts) external;
    function initializeWithdrawals(uint256[] memory appchainIds) external;
    function stageStakeTransfer(uint256 fromAppchainId, uint256 toAppchainId, uint256 amount) external payable;
    function stakeMultipleAppchains(uint256[] memory appchainIds, uint256[] memory amounts) external payable;
    function stakeSynd(uint256 appchainId) external payable;
    function totalStake() external view returns (uint256);
    function userAppchainFinalizedEpochCount(address user, uint256 appchainId) external view returns (uint256 finalizedEpochCount);
    function userAppchainTotal(address user, uint256 appchainId) external view returns (uint256 total);
    function userFinalizedEpochCount(address user) external view returns (uint256 finalizedEpochCount);
    function userTotal(address user) external view returns (uint256 total);
    function withdraw(uint256 epochIndex, address destination) external;
    function withdrawBulk(uint256[] memory epochIndices, address destination) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "EPOCH_DURATION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "START_TIMESTAMP",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "appchainFinalizedEpochCount",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "finalizedEpochCount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "appchainTotal",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "claimAllRewards",
    "inputs": [
      {
        "name": "claims",
        "type": "tuple[]",
        "internalType": "struct SyndStaking.ClaimRequest[]",
        "components": [
          {
            "name": "epochIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "poolAddress",
            "type": "address",
            "internalType": "address"
          }
        ]
      },
      {
        "name": "destination",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "epochAdditions",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "additions",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochAppchainAdditions",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "additions",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochAppchainTotal",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochAppchainWithdrawals",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "withdrawals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochStakeShare",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "stakeShare",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochTotal",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserAdditions",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "additions",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserAppchainAdditions",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "additions",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserAppchainTotal",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserAppchainWithdrawals",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "withdrawals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserStakeShare",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "stakeShare",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserTotal",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserWithdrawals",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "withdrawals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochWithdrawals",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "withdrawals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "finalizeAppchainEpochs",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "finalizeEpochs",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "finalizeUserAppchainEpochs",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "finalizeUserEpochs",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "finalizedEpochCount",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAppchainStake",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCurrentEpoch",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getEpochEnd",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "getEpochStart",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "getTotalStake",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getTotalStakeShare",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getUserAppchainStake",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getUserStake",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getUserStakeShare",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getWithdrawalAmount",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initializeWithdrawal",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "initializeWithdrawal",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "initializeWithdrawals",
    "inputs": [
      {
        "name": "appchainIds",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "amounts",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "initializeWithdrawals",
    "inputs": [
      {
        "name": "appchainIds",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "stageStakeTransfer",
    "inputs": [
      {
        "name": "fromAppchainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "toAppchainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "stakeMultipleAppchains",
    "inputs": [
      {
        "name": "appchainIds",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "amounts",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "stakeSynd",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "totalStake",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "userAppchainFinalizedEpochCount",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "finalizedEpochCount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "userAppchainTotal",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "userFinalizedEpochCount",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "finalizedEpochCount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "userTotal",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "withdraw",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "destination",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "withdrawBulk",
    "inputs": [
      {
        "name": "epochIndices",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "destination",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Stake",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "StakeTransfer",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "fromAppchainId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "toAppchainId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "WithdrawalCompleted",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "destination",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "WithdrawalInitialized",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "FailedCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientBalance",
    "inputs": [
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientStake",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidAmount",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidAppchainId",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidInput",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidStakingAmount",
    "inputs": [
      {
        "name": "totalAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "sentAmount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidWithdrawal",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NoClaimsProvided",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ReentrancyGuardReentrantCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "WithdrawalNotReady",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroEpochIndex",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod SyndStaking {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080806040523460195760015f55612196908161001e8239f35b5f80fdfe60806040526004361015610011575f80fd5b5f3560e01c8062f714ce146111e55780630175e23b146111195780630458296f14611101578063053dcd25146110af5780630b281bf8146110855780631057e9bc1461105b57806312e973bc146110315780631a8a738c146110145780631b533b5a14610fc25780631e0e848914610f985780633ba00fae14610f6e578063408c32ea14610f3a5780634197a4b114610ee357806345367f2314610ec5578063585a627a14610d4a57806359193f37146109965780635d3d8cd214610cf8578063629454fd14610ca957806368a5556414610c75578063693d0b7e14610c26578063781cd99d14610c085780637bda1cfb14610bd95780637c5dd5d914610b945780637c6eaaee14610b655780637e5f5ca714610b4057806385d8121714610a755780638b0e9f3f14610a585780638c67903e14610a2e5780639626a23014610a085780639deb66c9146109e7578063a09d7a3014610996578063a70b9f0c14610979578063b97dd9e21461095f578063c3ddb3b314610946578063ce7d8e5a146108bd578063d5176d231461089f578063e58e5382146105cd578063e601cf4414610588578063ed86ba6f14610571578063ee7514e81461051f578063f03021a114610503578063f156e06f14610392578063f89ee78d14610341578063f965652d14610312578063f9d663e0146102b6578063fa457be614610295578063fa73ce59146102465763fe07bb0714610228575f80fd5b34610242575f60031936011261024257610240611d5d565b005b5f80fd5b3461024257610254366113c2565b915f52601360205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f20905f52602052602060405f2054604051908152f35b346102425760206102ae6102a8366113f9565b90611cc2565b604051908152f35b346102425760406003193601126102425760206102ae6004356102d76112f9565b6102e1818361163d565b915f526016845273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52835260405f20549061141c565b3461024257610320366113f9565b905f52600e60205260405f20905f52602052602060405f2054604051908152f35b346102425760406003193601126102425773ffffffffffffffffffffffffffffffffffffffff61036f61131c565b165f52601460205260405f206024355f52602052602060405f2054604051908152f35b346102425760406003193601126102425760043567ffffffffffffffff8111610242573660238201121561024257806004013567ffffffffffffffff8111610242576024820191602436918360061b010111610242576103f06112f9565b906103f9611df8565b80156104db579073ffffffffffffffffffffffffffffffffffffffff165f5b8281106104255760015f55005b6020610432828587611c44565b01359073ffffffffffffffffffffffffffffffffffffffff82168092036102425761045e818587611c44565b35823b15610242575f926064849260405195869384927f69bc274700000000000000000000000000000000000000000000000000000000845260048401523360248401528860448401525af19182156104d0576001926104c0575b5001610418565b5f6104ca91611c54565b856104b9565b6040513d5f823e3d90fd5b7fbbcd3f33000000000000000000000000000000000000000000000000000000005f5260045ffd5b3461024257602060031936011261024257610240600435611b69565b34610242576040600319360112610242576105386112f9565b6004355f52601660205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b3461024257610240610582366113f9565b9061193f565b346102425760206003193601126102425773ffffffffffffffffffffffffffffffffffffffff6105b661131c565b165f526006602052602060405f2054604051908152f35b6060600319360112610242576024356004356044356105ea611df8565b8015610877578115801561086f575b61084757335f52601060205260405f20825f526020528060405f20541061081f577fb312903ce207d21e84e57d1005e0aa5385b783eb27e258817174d00cfbbc32789260a0926106476117e3565b92335f52600a6020528360405f205410610811575b815f52600f6020528360405f205410610803575b335f52601460205260405f20825f526020528360405f2054106107f4575b835f52601160205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20825f5260205260405f206106cf82825461141c565b9055835f52600c60205260405f20825f5260205260405f206106f282825461141c565b9055335f52601060205260405f20825f5260205260405f2061071582825461140f565b9055815f52600b60205260405f2061072e82825461140f565b9055835f52601260205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20835f5260205260405f2061077182825461141c565b9055835f52600d60205260405f20835f5260205260405f2061079482825461141c565b9055335f52601060205260405f20835f5260205260405f206107b782825461141c565b9055825f52600b60205260405f206107d082825461141c565b9055604051938452336020850152604084015260608301526080820152a160015f55005b6107fe82336114f4565b61068e565b61080c82611b69565b610670565b61081a336116f2565b61065c565b7ff1bc94d2000000000000000000000000000000000000000000000000000000005f5260045ffd5b7ff6b4131c000000000000000000000000000000000000000000000000000000005f5260045ffd5b5082156105f9565b7f2c5211c6000000000000000000000000000000000000000000000000000000005f5260045ffd5b346102425760206003193601126102425760206102ae600435611913565b346102425760206003193601126102425760043567ffffffffffffffff8111610242576108ee90369060040161133f565b6108f6611df8565b5f5b8181106109055760015f55005b806109406109166001938587611429565b35610922838688611429565b35335f52601060205260405f20905f5260205260405f20549061193f565b016108f8565b346102425760206102ae610959366113c2565b91611821565b34610242575f6003193601126102425760206102ae6117e3565b34610242575f60031936011261024257602060405162278d008152f35b346102425760406003193601126102425773ffffffffffffffffffffffffffffffffffffffff6109c461131c565b165f52601060205260405f206024355f52602052602060405f2054604051908152f35b3461024257602060031936011261024257610240610a0361131c565b6116f2565b346102425760406003193601126102425760206102ae610a266112f9565b60043561163d565b34610242576020600319360112610242576004355f526004602052602060405f2054604051908152f35b34610242575f600319360112610242576020600154604051908152f35b610a7e36611370565b8083949303610b18579291905f935f935b808510610acf5785348103610aa057005b7fa2dd20ef000000000000000000000000000000000000000000000000000000005f526004523460245260445ffd5b9091929394610aec600191610ae5888688611429565b359061141c565b95610b0e610afb828589611429565b35610b07838789611429565b3590611f22565b0193929190610a8f565b7fb4fa3fb3000000000000000000000000000000000000000000000000000000005f5260045ffd5b3461024257604060031936011261024257610240610b5c61131c565b602435906114f4565b3461024257610b73366113f9565b905f52600d60205260405f20905f52602052602060405f2054604051908152f35b346102425760206003193601126102425773ffffffffffffffffffffffffffffffffffffffff610bc261131c565b165f52600a602052602060405f2054604051908152f35b3461024257610be7366113f9565b905f52600c60205260405f20905f52602052602060405f2054604051908152f35b34610242575f60031936011261024257602060405163688d46f08152f35b3461024257610c34366113c2565b915f52601260205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f20905f52602052602060405f2054604051908152f35b3461024257602060031936011261024257610240600435335f52601060205260405f20815f5260205260405f20549061193f565b3461024257610cb7366113c2565b915f52601160205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f20905f52602052602060405f2054604051908152f35b3461024257604060031936011261024257610d116112f9565b6004355f52600960205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b346102425760406003193601126102425760043567ffffffffffffffff811161024257610d7b90369060040161133f565b610d836112f9565b5f91829033905b808310610e05577fb00382203b46c3b6ad0a2d7af0268e334bd9406256a7c7ba8f7fc8bc47f8cde98585610dd48273ffffffffffffffffffffffffffffffffffffffff8316611e2f565b6040805133815273ffffffffffffffffffffffffffffffffffffffff929092166020830152810191909152606090a1005b909193610e13858388611429565b35610e1c6117e3565b811015610e9d57805f52600960205260405f20845f5260205260405f20548015610e7557600192610e6c92610e50336116f2565b5f52600960205260405f20865f526020525f604081205561141c565b94019190610d8a565b7fc945242d000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f0f2ca6e7000000000000000000000000000000000000000000000000000000005f5260045ffd5b346102425760206003193601126102425760206102ae600435611466565b3461024257610ef136611370565b90610efa611df8565b818303610e75575f5b838110610f105760015f55005b80610f34610f216001938789611429565b35610f2d838787611429565b359061193f565b01610f03565b346102425760206003193601126102425760206102ae600435610f5c81611466565b905f526015835260405f20549061141c565b34610242576020600319360112610242576004355f52600f602052602060405f2054604051908152f35b34610242576020600319360112610242576004355f526002602052602060405f2054604051908152f35b3461024257604060031936011261024257610fdb6112f9565b6004355f52600860205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b34610242575f600319360112610242576020600554604051908152f35b34610242576020600319360112610242576004355f526015602052602060405f2054604051908152f35b34610242576020600319360112610242576004355f52600b602052602060405f2054604051908152f35b34610242576020600319360112610242576004355f526003602052602060405f2054604051908152f35b34610242576040600319360112610242576110c86112f9565b6004355f52600760205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b60206003193601126102425761024034600435611f22565b346102425760206003193601126102425760043580156111bd577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81019081116111905762278d0081029080820462278d0014901517156111905763688d46f0018063688d46f01161119057602090604051908152f35b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b7fd69368d4000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610242576040600319360112610242576004356112016112f9565b611209611df8565b6112116117e3565b821015610e9d57815f52600960205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f2054908115610e75577fb00382203b46c3b6ad0a2d7af0268e334bd9406256a7c7ba8f7fc8bc47f8cde992611277336116f2565b5f52600960205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f526020525f60408120556112c48273ffffffffffffffffffffffffffffffffffffffff8316611e2f565b6040805133815273ffffffffffffffffffffffffffffffffffffffff929092166020830152810191909152606090a160015f55005b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361024257565b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361024257565b9181601f840112156102425782359167ffffffffffffffff8311610242576020808501948460051b01011161024257565b60406003198201126102425760043567ffffffffffffffff8111610242578161139b9160040161133f565b929092916024359067ffffffffffffffff8211610242576113be9160040161133f565b9091565b6003196060910112610242576004359060243573ffffffffffffffffffffffffffffffffffffffff81168103610242579060443590565b6003196040910112610242576004359060243590565b9190820391821161119057565b9190820180921161119057565b91908110156114395760051b0190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b60055481106114b8576114b5906114a261148f600154835f52600260205260405f20549061141c565b825f52600460205260405f20549061141c565b905f52600360205260405f20549061140f565b90565b5f52600260205260405f205490565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81146111905760010190565b9073ffffffffffffffffffffffffffffffffffffffff6115126117e3565b9216805f52601460205260405f20825f5260205260405f2054925b80841061154d57505f52601460205260405f20905f5260205260405f2055565b9261163790825f52601060205260405f20845f5260205260405f2054815f52601160205260405f20845f5260205260405f20855f5260205261159460405f2091825461141c565b9055805f52601360205260405f20835f5260205260405f20845f5260205260405f2054815f52601160205260405f20845f5260205260405f20855f526020526115e260405f2091825461141c565b9055805f52601260205260405f20835f5260205260405f20845f5260205260405f2054815f52601160205260405f20845f5260205260405f20855f5260205261163060405f2091825461140f565b90556114c7565b9261152d565b9073ffffffffffffffffffffffffffffffffffffffff1690815f52600a60205260405f20548110155f146116d957816114b5925f5260066020526116bc61169f60405f2054845f52600760205260405f20845f5260205260405f20549061141c565b835f52600960205260405f20835f5260205260405f20549061141c565b915f52600860205260405f20905f5260205260405f20549061140f565b5f52600760205260405f20905f5260205260405f205490565b73ffffffffffffffffffffffffffffffffffffffff61170f6117e3565b9116805f52600a60205260405f2054915b80831061173657505f52600a60205260405f2055565b916117dd90825f52600660205260405f2054815f52600760205260405f20845f5260205261176960405f2091825461141c565b9055805f52600960205260405f20835f5260205260405f2054815f52600760205260405f20845f526020526117a360405f2091825461141c565b9055805f52600860205260405f20835f5260205260405f2054815f52600760205260405f20845f5260205261163060405f2091825461140f565b91611720565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff9772b91042014281116111905762278d009004600181018091116111905790565b9073ffffffffffffffffffffffffffffffffffffffff16805f52601460205260405f20835f5260205260405f20548210155f146118ef5791826114b5935f52601060205260405f20825f526020526118c86118a160405f2054855f52601160205260405f20845f5260205260405f20855f5260205260405f20549061141c565b845f52601360205260405f20835f5260205260405f20845f5260205260405f20549061141c565b925f52601260205260405f20905f5260205260405f20905f5260205260405f20549061140f565b905f52601160205260405f20905f5260205260405f20905f5260205260405f205490565b80156111bd5762278d00810290810462278d00036111905763688d46f0018063688d46f0116111905790565b90801561087757811561084757335f52601060205260405f20825f5260205260405f205481118015611b54575b61081f577f8bd4728ee9ca3f99ddcffa24eb4f15de015cda9a27ccc427dfdaf711943ebca09160609161199d6117e3565b8060055410611b47575b335f52600a6020528060405f205410611b39575b825f52600f6020528060405f205410611b2b575b335f52601460205260405f20835f526020528060405f205410611b1c575b805f52600460205260405f20611a0483825461141c565b9055805f52600960205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20611a3d83825461141c565b9055805f52600e60205260405f20835f5260205260405f20611a6083825461141c565b90555f52601360205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20825f5260205260405f20611aa282825461141c565b9055611ab08160015461140f565b600155335f52600660205260405f20611aca82825461140f565b9055815f52600b60205260405f20611ae382825461140f565b9055335f52601060205260405f20825f5260205260405f20611b0682825461140f565b90556040519133835260208301526040820152a1565b611b2683336114f4565b6119ed565b611b3483611b69565b6119cf565b611b42336116f2565b6119bb565b611b4f611d5d565b6119a7565b50335f52600660205260405f2054811161196c565b611b716117e3565b90805f52600f60205260405f2054915b808310611b9757505f52600f60205260405f2055565b91611c3e90825f52600b60205260405f2054815f52600c60205260405f20845f52602052611bca60405f2091825461141c565b9055805f52600e60205260405f20835f5260205260405f2054815f52600c60205260405f20845f52602052611c0460405f2091825461141c565b9055805f52600d60205260405f20835f5260205260405f2054815f52600c60205260405f20845f5260205261163060405f2091825461140f565b91611b81565b91908110156114395760061b0190565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117611c9557604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b5f828152600f60205260409020548110611d4457816114b5925f52600b602052611d27611d0a60405f2054845f52600c60205260405f20845f5260205260405f20549061141c565b835f52600e60205260405f20835f5260205260405f20549061141c565b915f52600d60205260405f20905f5260205260405f20549061140f565b5f52600c60205260405f20905f5260205260405f205490565b611d656117e3565b905b60055482811015611df357600154905f526002602052611d8c60405f2091825461141c565b9055600554805f52600460205260405f2054905f526002602052611db560405f2091825461141c565b9055600554805f52600360205260405f2054905f526002602052611dde60405f2091825461140f565b9055611deb6005546114c7565b600555611d67565b509050565b60025f5414611e075760025f55565b7f3ee5aeb5000000000000000000000000000000000000000000000000000000005f5260045ffd5b814710611ef2575f80809373ffffffffffffffffffffffffffffffffffffffff8294165af13d15611eea573d9067ffffffffffffffff8211611c955760405191611ea160207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8401160184611c54565b82523d5f602084013e5b15611eb35750565b805115611ec257805190602001fd5b7fd6bda275000000000000000000000000000000000000000000000000000000005f5260045ffd5b606090611eab565b50477fcf479181000000000000000000000000000000000000000000000000000000005f5260045260245260445ffd5b811561087757801561084757611f366117e3565b8060055410612189575b335f52600a6020528060405f20541061217b575b815f52600f6020528060405f20541061216d575b335f52601460205260405f20825f526020528060405f20541061215e575b611fa0611f99611f946117e3565b611913565b429061140f565b918284029284840403611190577f507ac39eb33610191cd8fd54286e91c5cc464c262861643be3978f5a9f18ab029362278d0060809404835f52601560205260405f20611fee82825461141c565b9055835f52601660205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205261202760405f2091825461141c565b9055825f52600360205260405f2061204082825461141c565b905561204e8160015461141c565b600155825f52600860205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f2061208882825461141c565b9055335f52600660205260405f206120a182825461141c565b9055825f52600d60205260405f20825f5260205260405f206120c482825461141c565b9055815f52600b60205260405f206120dd82825461141c565b9055825f52601260205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20825f5260205260405f2061212082825461141c565b9055335f52601060205260405f20825f5260205260405f2061214382825461141c565b905560405192835233602084015260408301526060820152a1565b61216882336114f4565b611f86565b61217682611b69565b611f68565b612184336116f2565b611f54565b612191611d5d565b611f4056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80\x80`@R4`\x19W`\x01_Ua!\x96\x90\x81a\0\x1E\x829\xF3[_\x80\xFD\xFE`\x80`@R`\x046\x10\x15a\0\x11W_\x80\xFD[_5`\xE0\x1C\x80b\xF7\x14\xCE\x14a\x11\xE5W\x80c\x01u\xE2;\x14a\x11\x19W\x80c\x04X)o\x14a\x11\x01W\x80c\x05=\xCD%\x14a\x10\xAFW\x80c\x0B(\x1B\xF8\x14a\x10\x85W\x80c\x10W\xE9\xBC\x14a\x10[W\x80c\x12\xE9s\xBC\x14a\x101W\x80c\x1A\x8As\x8C\x14a\x10\x14W\x80c\x1BS;Z\x14a\x0F\xC2W\x80c\x1E\x0E\x84\x89\x14a\x0F\x98W\x80c;\xA0\x0F\xAE\x14a\x0FnW\x80c@\x8C2\xEA\x14a\x0F:W\x80cA\x97\xA4\xB1\x14a\x0E\xE3W\x80cE6\x7F#\x14a\x0E\xC5W\x80cXZbz\x14a\rJW\x80cY\x19?7\x14a\t\x96W\x80c]=\x8C\xD2\x14a\x0C\xF8W\x80cb\x94T\xFD\x14a\x0C\xA9W\x80ch\xA5Ud\x14a\x0CuW\x80ci=\x0B~\x14a\x0C&W\x80cx\x1C\xD9\x9D\x14a\x0C\x08W\x80c{\xDA\x1C\xFB\x14a\x0B\xD9W\x80c|]\xD5\xD9\x14a\x0B\x94W\x80c|n\xAA\xEE\x14a\x0BeW\x80c~_\\\xA7\x14a\x0B@W\x80c\x85\xD8\x12\x17\x14a\nuW\x80c\x8B\x0E\x9F?\x14a\nXW\x80c\x8Cg\x90>\x14a\n.W\x80c\x96&\xA20\x14a\n\x08W\x80c\x9D\xEBf\xC9\x14a\t\xE7W\x80c\xA0\x9Dz0\x14a\t\x96W\x80c\xA7\x0B\x9F\x0C\x14a\tyW\x80c\xB9}\xD9\xE2\x14a\t_W\x80c\xC3\xDD\xB3\xB3\x14a\tFW\x80c\xCE}\x8EZ\x14a\x08\xBDW\x80c\xD5\x17m#\x14a\x08\x9FW\x80c\xE5\x8ES\x82\x14a\x05\xCDW\x80c\xE6\x01\xCFD\x14a\x05\x88W\x80c\xED\x86\xBAo\x14a\x05qW\x80c\xEEu\x14\xE8\x14a\x05\x1FW\x80c\xF00!\xA1\x14a\x05\x03W\x80c\xF1V\xE0o\x14a\x03\x92W\x80c\xF8\x9E\xE7\x8D\x14a\x03AW\x80c\xF9ee-\x14a\x03\x12W\x80c\xF9\xD6c\xE0\x14a\x02\xB6W\x80c\xFAE{\xE6\x14a\x02\x95W\x80c\xFAs\xCEY\x14a\x02FWc\xFE\x07\xBB\x07\x14a\x02(W_\x80\xFD[4a\x02BW_`\x03\x196\x01\x12a\x02BWa\x02@a\x1D]V[\0[_\x80\xFD[4a\x02BWa\x02T6a\x13\xC2V[\x91_R`\x13` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW` a\x02\xAEa\x02\xA86a\x13\xF9V[\x90a\x1C\xC2V[`@Q\x90\x81R\xF3[4a\x02BW`@`\x03\x196\x01\x12a\x02BW` a\x02\xAE`\x045a\x02\xD7a\x12\xF9V[a\x02\xE1\x81\x83a\x16=V[\x91_R`\x16\x84Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R\x83R`@_ T\x90a\x14\x1CV[4a\x02BWa\x03 6a\x13\xF9V[\x90_R`\x0E` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW`@`\x03\x196\x01\x12a\x02BWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x03oa\x13\x1CV[\x16_R`\x14` R`@_ `$5_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW`@`\x03\x196\x01\x12a\x02BW`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02BW6`#\x82\x01\x12\x15a\x02BW\x80`\x04\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02BW`$\x82\x01\x91`$6\x91\x83`\x06\x1B\x01\x01\x11a\x02BWa\x03\xF0a\x12\xF9V[\x90a\x03\xF9a\x1D\xF8V[\x80\x15a\x04\xDBW\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_[\x82\x81\x10a\x04%W`\x01_U\0[` a\x042\x82\x85\x87a\x1CDV[\x015\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x80\x92\x03a\x02BWa\x04^\x81\x85\x87a\x1CDV[5\x82;\x15a\x02BW_\x92`d\x84\x92`@Q\x95\x86\x93\x84\x92\x7Fi\xBC'G\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84R`\x04\x84\x01R3`$\x84\x01R\x88`D\x84\x01RZ\xF1\x91\x82\x15a\x04\xD0W`\x01\x92a\x04\xC0W[P\x01a\x04\x18V[_a\x04\xCA\x91a\x1CTV[\x85a\x04\xB9V[`@Q=_\x82>=\x90\xFD[\x7F\xBB\xCD?3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02BW` `\x03\x196\x01\x12a\x02BWa\x02@`\x045a\x1BiV[4a\x02BW`@`\x03\x196\x01\x12a\x02BWa\x058a\x12\xF9V[`\x045_R`\x16` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BWa\x02@a\x05\x826a\x13\xF9V[\x90a\x19?V[4a\x02BW` `\x03\x196\x01\x12a\x02BWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x05\xB6a\x13\x1CV[\x16_R`\x06` R` `@_ T`@Q\x90\x81R\xF3[```\x03\x196\x01\x12a\x02BW`$5`\x045`D5a\x05\xEAa\x1D\xF8V[\x80\x15a\x08wW\x81\x15\x80\x15a\x08oW[a\x08GW3_R`\x10` R`@_ \x82_R` R\x80`@_ T\x10a\x08\x1FW\x7F\xB3\x12\x90<\xE2\x07\xD2\x1E\x84\xE5}\x10\x05\xE0\xAAS\x85\xB7\x83\xEB'\xE2X\x81qt\xD0\x0C\xFB\xBC2x\x92`\xA0\x92a\x06Ga\x17\xE3V[\x923_R`\n` R\x83`@_ T\x10a\x08\x11W[\x81_R`\x0F` R\x83`@_ T\x10a\x08\x03W[3_R`\x14` R`@_ \x82_R` R\x83`@_ T\x10a\x07\xF4W[\x83_R`\x11` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x82_R` R`@_ a\x06\xCF\x82\x82Ta\x14\x1CV[\x90U\x83_R`\x0C` R`@_ \x82_R` R`@_ a\x06\xF2\x82\x82Ta\x14\x1CV[\x90U3_R`\x10` R`@_ \x82_R` R`@_ a\x07\x15\x82\x82Ta\x14\x0FV[\x90U\x81_R`\x0B` R`@_ a\x07.\x82\x82Ta\x14\x0FV[\x90U\x83_R`\x12` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x83_R` R`@_ a\x07q\x82\x82Ta\x14\x1CV[\x90U\x83_R`\r` R`@_ \x83_R` R`@_ a\x07\x94\x82\x82Ta\x14\x1CV[\x90U3_R`\x10` R`@_ \x83_R` R`@_ a\x07\xB7\x82\x82Ta\x14\x1CV[\x90U\x82_R`\x0B` R`@_ a\x07\xD0\x82\x82Ta\x14\x1CV[\x90U`@Q\x93\x84R3` \x85\x01R`@\x84\x01R``\x83\x01R`\x80\x82\x01R\xA1`\x01_U\0[a\x07\xFE\x823a\x14\xF4V[a\x06\x8EV[a\x08\x0C\x82a\x1BiV[a\x06pV[a\x08\x1A3a\x16\xF2V[a\x06\\V[\x7F\xF1\xBC\x94\xD2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\xF6\xB4\x13\x1C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[P\x82\x15a\x05\xF9V[\x7F,R\x11\xC6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02BW` `\x03\x196\x01\x12a\x02BW` a\x02\xAE`\x045a\x19\x13V[4a\x02BW` `\x03\x196\x01\x12a\x02BW`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02BWa\x08\xEE\x906\x90`\x04\x01a\x13?V[a\x08\xF6a\x1D\xF8V[_[\x81\x81\x10a\t\x05W`\x01_U\0[\x80a\t@a\t\x16`\x01\x93\x85\x87a\x14)V[5a\t\"\x83\x86\x88a\x14)V[53_R`\x10` R`@_ \x90_R` R`@_ T\x90a\x19?V[\x01a\x08\xF8V[4a\x02BW` a\x02\xAEa\tY6a\x13\xC2V[\x91a\x18!V[4a\x02BW_`\x03\x196\x01\x12a\x02BW` a\x02\xAEa\x17\xE3V[4a\x02BW_`\x03\x196\x01\x12a\x02BW` `@Qb'\x8D\0\x81R\xF3[4a\x02BW`@`\x03\x196\x01\x12a\x02BWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\t\xC4a\x13\x1CV[\x16_R`\x10` R`@_ `$5_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW` `\x03\x196\x01\x12a\x02BWa\x02@a\n\x03a\x13\x1CV[a\x16\xF2V[4a\x02BW`@`\x03\x196\x01\x12a\x02BW` a\x02\xAEa\n&a\x12\xF9V[`\x045a\x16=V[4a\x02BW` `\x03\x196\x01\x12a\x02BW`\x045_R`\x04` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW_`\x03\x196\x01\x12a\x02BW` `\x01T`@Q\x90\x81R\xF3[a\n~6a\x13pV[\x80\x83\x94\x93\x03a\x0B\x18W\x92\x91\x90_\x93_\x93[\x80\x85\x10a\n\xCFW\x854\x81\x03a\n\xA0W\0[\x7F\xA2\xDD \xEF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R4`$R`D_\xFD[\x90\x91\x92\x93\x94a\n\xEC`\x01\x91a\n\xE5\x88\x86\x88a\x14)V[5\x90a\x14\x1CV[\x95a\x0B\x0Ea\n\xFB\x82\x85\x89a\x14)V[5a\x0B\x07\x83\x87\x89a\x14)V[5\x90a\x1F\"V[\x01\x93\x92\x91\x90a\n\x8FV[\x7F\xB4\xFA?\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02BW`@`\x03\x196\x01\x12a\x02BWa\x02@a\x0B\\a\x13\x1CV[`$5\x90a\x14\xF4V[4a\x02BWa\x0Bs6a\x13\xF9V[\x90_R`\r` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW` `\x03\x196\x01\x12a\x02BWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x0B\xC2a\x13\x1CV[\x16_R`\n` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BWa\x0B\xE76a\x13\xF9V[\x90_R`\x0C` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW_`\x03\x196\x01\x12a\x02BW` `@Qch\x8DF\xF0\x81R\xF3[4a\x02BWa\x0C46a\x13\xC2V[\x91_R`\x12` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW` `\x03\x196\x01\x12a\x02BWa\x02@`\x0453_R`\x10` R`@_ \x81_R` R`@_ T\x90a\x19?V[4a\x02BWa\x0C\xB76a\x13\xC2V[\x91_R`\x11` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW`@`\x03\x196\x01\x12a\x02BWa\r\x11a\x12\xF9V[`\x045_R`\t` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW`@`\x03\x196\x01\x12a\x02BW`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02BWa\r{\x906\x90`\x04\x01a\x13?V[a\r\x83a\x12\xF9V[_\x91\x82\x903\x90[\x80\x83\x10a\x0E\x05W\x7F\xB0\x03\x82 ;F\xC3\xB6\xAD\n-z\xF0&\x8E3K\xD9@bV\xA7\xC7\xBA\x8F\x7F\xC8\xBCG\xF8\xCD\xE9\x85\x85a\r\xD4\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16a\x1E/V[`@\x80Q3\x81Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x90\x92\x16` \x83\x01R\x81\x01\x91\x90\x91R``\x90\xA1\0[\x90\x91\x93a\x0E\x13\x85\x83\x88a\x14)V[5a\x0E\x1Ca\x17\xE3V[\x81\x10\x15a\x0E\x9DW\x80_R`\t` R`@_ \x84_R` R`@_ T\x80\x15a\x0EuW`\x01\x92a\x0El\x92a\x0EP3a\x16\xF2V[_R`\t` R`@_ \x86_R` R_`@\x81 Ua\x14\x1CV[\x94\x01\x91\x90a\r\x8AV[\x7F\xC9E$-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\x0F,\xA6\xE7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02BW` `\x03\x196\x01\x12a\x02BW` a\x02\xAE`\x045a\x14fV[4a\x02BWa\x0E\xF16a\x13pV[\x90a\x0E\xFAa\x1D\xF8V[\x81\x83\x03a\x0EuW_[\x83\x81\x10a\x0F\x10W`\x01_U\0[\x80a\x0F4a\x0F!`\x01\x93\x87\x89a\x14)V[5a\x0F-\x83\x87\x87a\x14)V[5\x90a\x19?V[\x01a\x0F\x03V[4a\x02BW` `\x03\x196\x01\x12a\x02BW` a\x02\xAE`\x045a\x0F\\\x81a\x14fV[\x90_R`\x15\x83R`@_ T\x90a\x14\x1CV[4a\x02BW` `\x03\x196\x01\x12a\x02BW`\x045_R`\x0F` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW` `\x03\x196\x01\x12a\x02BW`\x045_R`\x02` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW`@`\x03\x196\x01\x12a\x02BWa\x0F\xDBa\x12\xF9V[`\x045_R`\x08` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW_`\x03\x196\x01\x12a\x02BW` `\x05T`@Q\x90\x81R\xF3[4a\x02BW` `\x03\x196\x01\x12a\x02BW`\x045_R`\x15` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW` `\x03\x196\x01\x12a\x02BW`\x045_R`\x0B` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW` `\x03\x196\x01\x12a\x02BW`\x045_R`\x03` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW`@`\x03\x196\x01\x12a\x02BWa\x10\xC8a\x12\xF9V[`\x045_R`\x07` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[` `\x03\x196\x01\x12a\x02BWa\x02@4`\x045a\x1F\"V[4a\x02BW` `\x03\x196\x01\x12a\x02BW`\x045\x80\x15a\x11\xBDW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x01\x90\x81\x11a\x11\x90Wb'\x8D\0\x81\x02\x90\x80\x82\x04b'\x8D\0\x14\x90\x15\x17\x15a\x11\x90Wch\x8DF\xF0\x01\x80ch\x8DF\xF0\x11a\x11\x90W` \x90`@Q\x90\x81R\xF3[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[\x7F\xD6\x93h\xD4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02BW`@`\x03\x196\x01\x12a\x02BW`\x045a\x12\x01a\x12\xF9V[a\x12\ta\x1D\xF8V[a\x12\x11a\x17\xE3V[\x82\x10\x15a\x0E\x9DW\x81_R`\t` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ T\x90\x81\x15a\x0EuW\x7F\xB0\x03\x82 ;F\xC3\xB6\xAD\n-z\xF0&\x8E3K\xD9@bV\xA7\xC7\xBA\x8F\x7F\xC8\xBCG\xF8\xCD\xE9\x92a\x12w3a\x16\xF2V[_R`\t` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R_`@\x81 Ua\x12\xC4\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16a\x1E/V[`@\x80Q3\x81Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x90\x92\x16` \x83\x01R\x81\x01\x91\x90\x91R``\x90\xA1`\x01_U\0[`$5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x02BWV[`\x045\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x02BWV[\x91\x81`\x1F\x84\x01\x12\x15a\x02BW\x825\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x02BW` \x80\x85\x01\x94\x84`\x05\x1B\x01\x01\x11a\x02BWV[`@`\x03\x19\x82\x01\x12a\x02BW`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02BW\x81a\x13\x9B\x91`\x04\x01a\x13?V[\x92\x90\x92\x91`$5\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x02BWa\x13\xBE\x91`\x04\x01a\x13?V[\x90\x91V[`\x03\x19``\x91\x01\x12a\x02BW`\x045\x90`$5s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x02BW\x90`D5\x90V[`\x03\x19`@\x91\x01\x12a\x02BW`\x045\x90`$5\x90V[\x91\x90\x82\x03\x91\x82\x11a\x11\x90WV[\x91\x90\x82\x01\x80\x92\x11a\x11\x90WV[\x91\x90\x81\x10\x15a\x149W`\x05\x1B\x01\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[`\x05T\x81\x10a\x14\xB8Wa\x14\xB5\x90a\x14\xA2a\x14\x8F`\x01T\x83_R`\x02` R`@_ T\x90a\x14\x1CV[\x82_R`\x04` R`@_ T\x90a\x14\x1CV[\x90_R`\x03` R`@_ T\x90a\x14\x0FV[\x90V[_R`\x02` R`@_ T\x90V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x14a\x11\x90W`\x01\x01\x90V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x15\x12a\x17\xE3V[\x92\x16\x80_R`\x14` R`@_ \x82_R` R`@_ T\x92[\x80\x84\x10a\x15MWP_R`\x14` R`@_ \x90_R` R`@_ UV[\x92a\x167\x90\x82_R`\x10` R`@_ \x84_R` R`@_ T\x81_R`\x11` R`@_ \x84_R` R`@_ \x85_R` Ra\x15\x94`@_ \x91\x82Ta\x14\x1CV[\x90U\x80_R`\x13` R`@_ \x83_R` R`@_ \x84_R` R`@_ T\x81_R`\x11` R`@_ \x84_R` R`@_ \x85_R` Ra\x15\xE2`@_ \x91\x82Ta\x14\x1CV[\x90U\x80_R`\x12` R`@_ \x83_R` R`@_ \x84_R` R`@_ T\x81_R`\x11` R`@_ \x84_R` R`@_ \x85_R` Ra\x160`@_ \x91\x82Ta\x14\x0FV[\x90Ua\x14\xC7V[\x92a\x15-V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81_R`\n` R`@_ T\x81\x10\x15_\x14a\x16\xD9W\x81a\x14\xB5\x92_R`\x06` Ra\x16\xBCa\x16\x9F`@_ T\x84_R`\x07` R`@_ \x84_R` R`@_ T\x90a\x14\x1CV[\x83_R`\t` R`@_ \x83_R` R`@_ T\x90a\x14\x1CV[\x91_R`\x08` R`@_ \x90_R` R`@_ T\x90a\x14\x0FV[_R`\x07` R`@_ \x90_R` R`@_ T\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x17\x0Fa\x17\xE3V[\x91\x16\x80_R`\n` R`@_ T\x91[\x80\x83\x10a\x176WP_R`\n` R`@_ UV[\x91a\x17\xDD\x90\x82_R`\x06` R`@_ T\x81_R`\x07` R`@_ \x84_R` Ra\x17i`@_ \x91\x82Ta\x14\x1CV[\x90U\x80_R`\t` R`@_ \x83_R` R`@_ T\x81_R`\x07` R`@_ \x84_R` Ra\x17\xA3`@_ \x91\x82Ta\x14\x1CV[\x90U\x80_R`\x08` R`@_ \x83_R` R`@_ T\x81_R`\x07` R`@_ \x84_R` Ra\x160`@_ \x91\x82Ta\x14\x0FV[\x91a\x17 V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x97r\xB9\x10B\x01B\x81\x11a\x11\x90Wb'\x8D\0\x90\x04`\x01\x81\x01\x80\x91\x11a\x11\x90W\x90V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80_R`\x14` R`@_ \x83_R` R`@_ T\x82\x10\x15_\x14a\x18\xEFW\x91\x82a\x14\xB5\x93_R`\x10` R`@_ \x82_R` Ra\x18\xC8a\x18\xA1`@_ T\x85_R`\x11` R`@_ \x84_R` R`@_ \x85_R` R`@_ T\x90a\x14\x1CV[\x84_R`\x13` R`@_ \x83_R` R`@_ \x84_R` R`@_ T\x90a\x14\x1CV[\x92_R`\x12` R`@_ \x90_R` R`@_ \x90_R` R`@_ T\x90a\x14\x0FV[\x90_R`\x11` R`@_ \x90_R` R`@_ \x90_R` R`@_ T\x90V[\x80\x15a\x11\xBDWb'\x8D\0\x81\x02\x90\x81\x04b'\x8D\0\x03a\x11\x90Wch\x8DF\xF0\x01\x80ch\x8DF\xF0\x11a\x11\x90W\x90V[\x90\x80\x15a\x08wW\x81\x15a\x08GW3_R`\x10` R`@_ \x82_R` R`@_ T\x81\x11\x80\x15a\x1BTW[a\x08\x1FW\x7F\x8B\xD4r\x8E\xE9\xCA?\x99\xDD\xCF\xFA$\xEBO\x15\xDE\x01\\\xDA\x9A'\xCC\xC4'\xDF\xDA\xF7\x11\x94>\xBC\xA0\x91``\x91a\x19\x9Da\x17\xE3V[\x80`\x05T\x10a\x1BGW[3_R`\n` R\x80`@_ T\x10a\x1B9W[\x82_R`\x0F` R\x80`@_ T\x10a\x1B+W[3_R`\x14` R`@_ \x83_R` R\x80`@_ T\x10a\x1B\x1CW[\x80_R`\x04` R`@_ a\x1A\x04\x83\x82Ta\x14\x1CV[\x90U\x80_R`\t` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ a\x1A=\x83\x82Ta\x14\x1CV[\x90U\x80_R`\x0E` R`@_ \x83_R` R`@_ a\x1A`\x83\x82Ta\x14\x1CV[\x90U_R`\x13` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x82_R` R`@_ a\x1A\xA2\x82\x82Ta\x14\x1CV[\x90Ua\x1A\xB0\x81`\x01Ta\x14\x0FV[`\x01U3_R`\x06` R`@_ a\x1A\xCA\x82\x82Ta\x14\x0FV[\x90U\x81_R`\x0B` R`@_ a\x1A\xE3\x82\x82Ta\x14\x0FV[\x90U3_R`\x10` R`@_ \x82_R` R`@_ a\x1B\x06\x82\x82Ta\x14\x0FV[\x90U`@Q\x913\x83R` \x83\x01R`@\x82\x01R\xA1V[a\x1B&\x833a\x14\xF4V[a\x19\xEDV[a\x1B4\x83a\x1BiV[a\x19\xCFV[a\x1BB3a\x16\xF2V[a\x19\xBBV[a\x1BOa\x1D]V[a\x19\xA7V[P3_R`\x06` R`@_ T\x81\x11a\x19lV[a\x1Bqa\x17\xE3V[\x90\x80_R`\x0F` R`@_ T\x91[\x80\x83\x10a\x1B\x97WP_R`\x0F` R`@_ UV[\x91a\x1C>\x90\x82_R`\x0B` R`@_ T\x81_R`\x0C` R`@_ \x84_R` Ra\x1B\xCA`@_ \x91\x82Ta\x14\x1CV[\x90U\x80_R`\x0E` R`@_ \x83_R` R`@_ T\x81_R`\x0C` R`@_ \x84_R` Ra\x1C\x04`@_ \x91\x82Ta\x14\x1CV[\x90U\x80_R`\r` R`@_ \x83_R` R`@_ T\x81_R`\x0C` R`@_ \x84_R` Ra\x160`@_ \x91\x82Ta\x14\x0FV[\x91a\x1B\x81V[\x91\x90\x81\x10\x15a\x149W`\x06\x1B\x01\x90V[\x90`\x1F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x1C\x95W`@RV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[_\x82\x81R`\x0F` R`@\x90 T\x81\x10a\x1DDW\x81a\x14\xB5\x92_R`\x0B` Ra\x1D'a\x1D\n`@_ T\x84_R`\x0C` R`@_ \x84_R` R`@_ T\x90a\x14\x1CV[\x83_R`\x0E` R`@_ \x83_R` R`@_ T\x90a\x14\x1CV[\x91_R`\r` R`@_ \x90_R` R`@_ T\x90a\x14\x0FV[_R`\x0C` R`@_ \x90_R` R`@_ T\x90V[a\x1Dea\x17\xE3V[\x90[`\x05T\x82\x81\x10\x15a\x1D\xF3W`\x01T\x90_R`\x02` Ra\x1D\x8C`@_ \x91\x82Ta\x14\x1CV[\x90U`\x05T\x80_R`\x04` R`@_ T\x90_R`\x02` Ra\x1D\xB5`@_ \x91\x82Ta\x14\x1CV[\x90U`\x05T\x80_R`\x03` R`@_ T\x90_R`\x02` Ra\x1D\xDE`@_ \x91\x82Ta\x14\x0FV[\x90Ua\x1D\xEB`\x05Ta\x14\xC7V[`\x05Ua\x1DgV[P\x90PV[`\x02_T\x14a\x1E\x07W`\x02_UV[\x7F>\xE5\xAE\xB5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x81G\x10a\x1E\xF2W_\x80\x80\x93s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x94\x16Z\xF1=\x15a\x1E\xEAW=\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x1C\x95W`@Q\x91a\x1E\xA1` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x84\x01\x16\x01\x84a\x1CTV[\x82R=_` \x84\x01>[\x15a\x1E\xB3WPV[\x80Q\x15a\x1E\xC2W\x80Q\x90` \x01\xFD[\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[``\x90a\x1E\xABV[PG\x7F\xCFG\x91\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$R`D_\xFD[\x81\x15a\x08wW\x80\x15a\x08GWa\x1F6a\x17\xE3V[\x80`\x05T\x10a!\x89W[3_R`\n` R\x80`@_ T\x10a!{W[\x81_R`\x0F` R\x80`@_ T\x10a!mW[3_R`\x14` R`@_ \x82_R` R\x80`@_ T\x10a!^W[a\x1F\xA0a\x1F\x99a\x1F\x94a\x17\xE3V[a\x19\x13V[B\x90a\x14\x0FV[\x91\x82\x84\x02\x92\x84\x84\x04\x03a\x11\x90W\x7FPz\xC3\x9E\xB36\x10\x19\x1C\xD8\xFDT(n\x91\xC5\xCCFL&(ad;\xE3\x97\x8FZ\x9F\x18\xAB\x02\x93b'\x8D\0`\x80\x94\x04\x83_R`\x15` R`@_ a\x1F\xEE\x82\x82Ta\x14\x1CV[\x90U\x83_R`\x16` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` Ra '`@_ \x91\x82Ta\x14\x1CV[\x90U\x82_R`\x03` R`@_ a @\x82\x82Ta\x14\x1CV[\x90Ua N\x81`\x01Ta\x14\x1CV[`\x01U\x82_R`\x08` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ a \x88\x82\x82Ta\x14\x1CV[\x90U3_R`\x06` R`@_ a \xA1\x82\x82Ta\x14\x1CV[\x90U\x82_R`\r` R`@_ \x82_R` R`@_ a \xC4\x82\x82Ta\x14\x1CV[\x90U\x81_R`\x0B` R`@_ a \xDD\x82\x82Ta\x14\x1CV[\x90U\x82_R`\x12` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x82_R` R`@_ a! \x82\x82Ta\x14\x1CV[\x90U3_R`\x10` R`@_ \x82_R` R`@_ a!C\x82\x82Ta\x14\x1CV[\x90U`@Q\x92\x83R3` \x84\x01R`@\x83\x01R``\x82\x01R\xA1V[a!h\x823a\x14\xF4V[a\x1F\x86V[a!v\x82a\x1BiV[a\x1FhV[a!\x843a\x16\xF2V[a\x1FTV[a!\x91a\x1D]V[a\x1F@V",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610011575f80fd5b5f3560e01c8062f714ce146111e55780630175e23b146111195780630458296f14611101578063053dcd25146110af5780630b281bf8146110855780631057e9bc1461105b57806312e973bc146110315780631a8a738c146110145780631b533b5a14610fc25780631e0e848914610f985780633ba00fae14610f6e578063408c32ea14610f3a5780634197a4b114610ee357806345367f2314610ec5578063585a627a14610d4a57806359193f37146109965780635d3d8cd214610cf8578063629454fd14610ca957806368a5556414610c75578063693d0b7e14610c26578063781cd99d14610c085780637bda1cfb14610bd95780637c5dd5d914610b945780637c6eaaee14610b655780637e5f5ca714610b4057806385d8121714610a755780638b0e9f3f14610a585780638c67903e14610a2e5780639626a23014610a085780639deb66c9146109e7578063a09d7a3014610996578063a70b9f0c14610979578063b97dd9e21461095f578063c3ddb3b314610946578063ce7d8e5a146108bd578063d5176d231461089f578063e58e5382146105cd578063e601cf4414610588578063ed86ba6f14610571578063ee7514e81461051f578063f03021a114610503578063f156e06f14610392578063f89ee78d14610341578063f965652d14610312578063f9d663e0146102b6578063fa457be614610295578063fa73ce59146102465763fe07bb0714610228575f80fd5b34610242575f60031936011261024257610240611d5d565b005b5f80fd5b3461024257610254366113c2565b915f52601360205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f20905f52602052602060405f2054604051908152f35b346102425760206102ae6102a8366113f9565b90611cc2565b604051908152f35b346102425760406003193601126102425760206102ae6004356102d76112f9565b6102e1818361163d565b915f526016845273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52835260405f20549061141c565b3461024257610320366113f9565b905f52600e60205260405f20905f52602052602060405f2054604051908152f35b346102425760406003193601126102425773ffffffffffffffffffffffffffffffffffffffff61036f61131c565b165f52601460205260405f206024355f52602052602060405f2054604051908152f35b346102425760406003193601126102425760043567ffffffffffffffff8111610242573660238201121561024257806004013567ffffffffffffffff8111610242576024820191602436918360061b010111610242576103f06112f9565b906103f9611df8565b80156104db579073ffffffffffffffffffffffffffffffffffffffff165f5b8281106104255760015f55005b6020610432828587611c44565b01359073ffffffffffffffffffffffffffffffffffffffff82168092036102425761045e818587611c44565b35823b15610242575f926064849260405195869384927f69bc274700000000000000000000000000000000000000000000000000000000845260048401523360248401528860448401525af19182156104d0576001926104c0575b5001610418565b5f6104ca91611c54565b856104b9565b6040513d5f823e3d90fd5b7fbbcd3f33000000000000000000000000000000000000000000000000000000005f5260045ffd5b3461024257602060031936011261024257610240600435611b69565b34610242576040600319360112610242576105386112f9565b6004355f52601660205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b3461024257610240610582366113f9565b9061193f565b346102425760206003193601126102425773ffffffffffffffffffffffffffffffffffffffff6105b661131c565b165f526006602052602060405f2054604051908152f35b6060600319360112610242576024356004356044356105ea611df8565b8015610877578115801561086f575b61084757335f52601060205260405f20825f526020528060405f20541061081f577fb312903ce207d21e84e57d1005e0aa5385b783eb27e258817174d00cfbbc32789260a0926106476117e3565b92335f52600a6020528360405f205410610811575b815f52600f6020528360405f205410610803575b335f52601460205260405f20825f526020528360405f2054106107f4575b835f52601160205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20825f5260205260405f206106cf82825461141c565b9055835f52600c60205260405f20825f5260205260405f206106f282825461141c565b9055335f52601060205260405f20825f5260205260405f2061071582825461140f565b9055815f52600b60205260405f2061072e82825461140f565b9055835f52601260205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20835f5260205260405f2061077182825461141c565b9055835f52600d60205260405f20835f5260205260405f2061079482825461141c565b9055335f52601060205260405f20835f5260205260405f206107b782825461141c565b9055825f52600b60205260405f206107d082825461141c565b9055604051938452336020850152604084015260608301526080820152a160015f55005b6107fe82336114f4565b61068e565b61080c82611b69565b610670565b61081a336116f2565b61065c565b7ff1bc94d2000000000000000000000000000000000000000000000000000000005f5260045ffd5b7ff6b4131c000000000000000000000000000000000000000000000000000000005f5260045ffd5b5082156105f9565b7f2c5211c6000000000000000000000000000000000000000000000000000000005f5260045ffd5b346102425760206003193601126102425760206102ae600435611913565b346102425760206003193601126102425760043567ffffffffffffffff8111610242576108ee90369060040161133f565b6108f6611df8565b5f5b8181106109055760015f55005b806109406109166001938587611429565b35610922838688611429565b35335f52601060205260405f20905f5260205260405f20549061193f565b016108f8565b346102425760206102ae610959366113c2565b91611821565b34610242575f6003193601126102425760206102ae6117e3565b34610242575f60031936011261024257602060405162278d008152f35b346102425760406003193601126102425773ffffffffffffffffffffffffffffffffffffffff6109c461131c565b165f52601060205260405f206024355f52602052602060405f2054604051908152f35b3461024257602060031936011261024257610240610a0361131c565b6116f2565b346102425760406003193601126102425760206102ae610a266112f9565b60043561163d565b34610242576020600319360112610242576004355f526004602052602060405f2054604051908152f35b34610242575f600319360112610242576020600154604051908152f35b610a7e36611370565b8083949303610b18579291905f935f935b808510610acf5785348103610aa057005b7fa2dd20ef000000000000000000000000000000000000000000000000000000005f526004523460245260445ffd5b9091929394610aec600191610ae5888688611429565b359061141c565b95610b0e610afb828589611429565b35610b07838789611429565b3590611f22565b0193929190610a8f565b7fb4fa3fb3000000000000000000000000000000000000000000000000000000005f5260045ffd5b3461024257604060031936011261024257610240610b5c61131c565b602435906114f4565b3461024257610b73366113f9565b905f52600d60205260405f20905f52602052602060405f2054604051908152f35b346102425760206003193601126102425773ffffffffffffffffffffffffffffffffffffffff610bc261131c565b165f52600a602052602060405f2054604051908152f35b3461024257610be7366113f9565b905f52600c60205260405f20905f52602052602060405f2054604051908152f35b34610242575f60031936011261024257602060405163688d46f08152f35b3461024257610c34366113c2565b915f52601260205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f20905f52602052602060405f2054604051908152f35b3461024257602060031936011261024257610240600435335f52601060205260405f20815f5260205260405f20549061193f565b3461024257610cb7366113c2565b915f52601160205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f20905f52602052602060405f2054604051908152f35b3461024257604060031936011261024257610d116112f9565b6004355f52600960205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b346102425760406003193601126102425760043567ffffffffffffffff811161024257610d7b90369060040161133f565b610d836112f9565b5f91829033905b808310610e05577fb00382203b46c3b6ad0a2d7af0268e334bd9406256a7c7ba8f7fc8bc47f8cde98585610dd48273ffffffffffffffffffffffffffffffffffffffff8316611e2f565b6040805133815273ffffffffffffffffffffffffffffffffffffffff929092166020830152810191909152606090a1005b909193610e13858388611429565b35610e1c6117e3565b811015610e9d57805f52600960205260405f20845f5260205260405f20548015610e7557600192610e6c92610e50336116f2565b5f52600960205260405f20865f526020525f604081205561141c565b94019190610d8a565b7fc945242d000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f0f2ca6e7000000000000000000000000000000000000000000000000000000005f5260045ffd5b346102425760206003193601126102425760206102ae600435611466565b3461024257610ef136611370565b90610efa611df8565b818303610e75575f5b838110610f105760015f55005b80610f34610f216001938789611429565b35610f2d838787611429565b359061193f565b01610f03565b346102425760206003193601126102425760206102ae600435610f5c81611466565b905f526015835260405f20549061141c565b34610242576020600319360112610242576004355f52600f602052602060405f2054604051908152f35b34610242576020600319360112610242576004355f526002602052602060405f2054604051908152f35b3461024257604060031936011261024257610fdb6112f9565b6004355f52600860205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b34610242575f600319360112610242576020600554604051908152f35b34610242576020600319360112610242576004355f526015602052602060405f2054604051908152f35b34610242576020600319360112610242576004355f52600b602052602060405f2054604051908152f35b34610242576020600319360112610242576004355f526003602052602060405f2054604051908152f35b34610242576040600319360112610242576110c86112f9565b6004355f52600760205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b60206003193601126102425761024034600435611f22565b346102425760206003193601126102425760043580156111bd577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81019081116111905762278d0081029080820462278d0014901517156111905763688d46f0018063688d46f01161119057602090604051908152f35b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b7fd69368d4000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610242576040600319360112610242576004356112016112f9565b611209611df8565b6112116117e3565b821015610e9d57815f52600960205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f2054908115610e75577fb00382203b46c3b6ad0a2d7af0268e334bd9406256a7c7ba8f7fc8bc47f8cde992611277336116f2565b5f52600960205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f526020525f60408120556112c48273ffffffffffffffffffffffffffffffffffffffff8316611e2f565b6040805133815273ffffffffffffffffffffffffffffffffffffffff929092166020830152810191909152606090a160015f55005b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361024257565b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361024257565b9181601f840112156102425782359167ffffffffffffffff8311610242576020808501948460051b01011161024257565b60406003198201126102425760043567ffffffffffffffff8111610242578161139b9160040161133f565b929092916024359067ffffffffffffffff8211610242576113be9160040161133f565b9091565b6003196060910112610242576004359060243573ffffffffffffffffffffffffffffffffffffffff81168103610242579060443590565b6003196040910112610242576004359060243590565b9190820391821161119057565b9190820180921161119057565b91908110156114395760051b0190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b60055481106114b8576114b5906114a261148f600154835f52600260205260405f20549061141c565b825f52600460205260405f20549061141c565b905f52600360205260405f20549061140f565b90565b5f52600260205260405f205490565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81146111905760010190565b9073ffffffffffffffffffffffffffffffffffffffff6115126117e3565b9216805f52601460205260405f20825f5260205260405f2054925b80841061154d57505f52601460205260405f20905f5260205260405f2055565b9261163790825f52601060205260405f20845f5260205260405f2054815f52601160205260405f20845f5260205260405f20855f5260205261159460405f2091825461141c565b9055805f52601360205260405f20835f5260205260405f20845f5260205260405f2054815f52601160205260405f20845f5260205260405f20855f526020526115e260405f2091825461141c565b9055805f52601260205260405f20835f5260205260405f20845f5260205260405f2054815f52601160205260405f20845f5260205260405f20855f5260205261163060405f2091825461140f565b90556114c7565b9261152d565b9073ffffffffffffffffffffffffffffffffffffffff1690815f52600a60205260405f20548110155f146116d957816114b5925f5260066020526116bc61169f60405f2054845f52600760205260405f20845f5260205260405f20549061141c565b835f52600960205260405f20835f5260205260405f20549061141c565b915f52600860205260405f20905f5260205260405f20549061140f565b5f52600760205260405f20905f5260205260405f205490565b73ffffffffffffffffffffffffffffffffffffffff61170f6117e3565b9116805f52600a60205260405f2054915b80831061173657505f52600a60205260405f2055565b916117dd90825f52600660205260405f2054815f52600760205260405f20845f5260205261176960405f2091825461141c565b9055805f52600960205260405f20835f5260205260405f2054815f52600760205260405f20845f526020526117a360405f2091825461141c565b9055805f52600860205260405f20835f5260205260405f2054815f52600760205260405f20845f5260205261163060405f2091825461140f565b91611720565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff9772b91042014281116111905762278d009004600181018091116111905790565b9073ffffffffffffffffffffffffffffffffffffffff16805f52601460205260405f20835f5260205260405f20548210155f146118ef5791826114b5935f52601060205260405f20825f526020526118c86118a160405f2054855f52601160205260405f20845f5260205260405f20855f5260205260405f20549061141c565b845f52601360205260405f20835f5260205260405f20845f5260205260405f20549061141c565b925f52601260205260405f20905f5260205260405f20905f5260205260405f20549061140f565b905f52601160205260405f20905f5260205260405f20905f5260205260405f205490565b80156111bd5762278d00810290810462278d00036111905763688d46f0018063688d46f0116111905790565b90801561087757811561084757335f52601060205260405f20825f5260205260405f205481118015611b54575b61081f577f8bd4728ee9ca3f99ddcffa24eb4f15de015cda9a27ccc427dfdaf711943ebca09160609161199d6117e3565b8060055410611b47575b335f52600a6020528060405f205410611b39575b825f52600f6020528060405f205410611b2b575b335f52601460205260405f20835f526020528060405f205410611b1c575b805f52600460205260405f20611a0483825461141c565b9055805f52600960205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20611a3d83825461141c565b9055805f52600e60205260405f20835f5260205260405f20611a6083825461141c565b90555f52601360205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20825f5260205260405f20611aa282825461141c565b9055611ab08160015461140f565b600155335f52600660205260405f20611aca82825461140f565b9055815f52600b60205260405f20611ae382825461140f565b9055335f52601060205260405f20825f5260205260405f20611b0682825461140f565b90556040519133835260208301526040820152a1565b611b2683336114f4565b6119ed565b611b3483611b69565b6119cf565b611b42336116f2565b6119bb565b611b4f611d5d565b6119a7565b50335f52600660205260405f2054811161196c565b611b716117e3565b90805f52600f60205260405f2054915b808310611b9757505f52600f60205260405f2055565b91611c3e90825f52600b60205260405f2054815f52600c60205260405f20845f52602052611bca60405f2091825461141c565b9055805f52600e60205260405f20835f5260205260405f2054815f52600c60205260405f20845f52602052611c0460405f2091825461141c565b9055805f52600d60205260405f20835f5260205260405f2054815f52600c60205260405f20845f5260205261163060405f2091825461140f565b91611b81565b91908110156114395760061b0190565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117611c9557604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b5f828152600f60205260409020548110611d4457816114b5925f52600b602052611d27611d0a60405f2054845f52600c60205260405f20845f5260205260405f20549061141c565b835f52600e60205260405f20835f5260205260405f20549061141c565b915f52600d60205260405f20905f5260205260405f20549061140f565b5f52600c60205260405f20905f5260205260405f205490565b611d656117e3565b905b60055482811015611df357600154905f526002602052611d8c60405f2091825461141c565b9055600554805f52600460205260405f2054905f526002602052611db560405f2091825461141c565b9055600554805f52600360205260405f2054905f526002602052611dde60405f2091825461140f565b9055611deb6005546114c7565b600555611d67565b509050565b60025f5414611e075760025f55565b7f3ee5aeb5000000000000000000000000000000000000000000000000000000005f5260045ffd5b814710611ef2575f80809373ffffffffffffffffffffffffffffffffffffffff8294165af13d15611eea573d9067ffffffffffffffff8211611c955760405191611ea160207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8401160184611c54565b82523d5f602084013e5b15611eb35750565b805115611ec257805190602001fd5b7fd6bda275000000000000000000000000000000000000000000000000000000005f5260045ffd5b606090611eab565b50477fcf479181000000000000000000000000000000000000000000000000000000005f5260045260245260445ffd5b811561087757801561084757611f366117e3565b8060055410612189575b335f52600a6020528060405f20541061217b575b815f52600f6020528060405f20541061216d575b335f52601460205260405f20825f526020528060405f20541061215e575b611fa0611f99611f946117e3565b611913565b429061140f565b918284029284840403611190577f507ac39eb33610191cd8fd54286e91c5cc464c262861643be3978f5a9f18ab029362278d0060809404835f52601560205260405f20611fee82825461141c565b9055835f52601660205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205261202760405f2091825461141c565b9055825f52600360205260405f2061204082825461141c565b905561204e8160015461141c565b600155825f52600860205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f2061208882825461141c565b9055335f52600660205260405f206120a182825461141c565b9055825f52600d60205260405f20825f5260205260405f206120c482825461141c565b9055815f52600b60205260405f206120dd82825461141c565b9055825f52601260205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20825f5260205260405f2061212082825461141c565b9055335f52601060205260405f20825f5260205260405f2061214382825461141c565b905560405192835233602084015260408301526060820152a1565b61216882336114f4565b611f86565b61217682611b69565b611f68565b612184336116f2565b611f54565b612191611d5d565b611f4056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x11W_\x80\xFD[_5`\xE0\x1C\x80b\xF7\x14\xCE\x14a\x11\xE5W\x80c\x01u\xE2;\x14a\x11\x19W\x80c\x04X)o\x14a\x11\x01W\x80c\x05=\xCD%\x14a\x10\xAFW\x80c\x0B(\x1B\xF8\x14a\x10\x85W\x80c\x10W\xE9\xBC\x14a\x10[W\x80c\x12\xE9s\xBC\x14a\x101W\x80c\x1A\x8As\x8C\x14a\x10\x14W\x80c\x1BS;Z\x14a\x0F\xC2W\x80c\x1E\x0E\x84\x89\x14a\x0F\x98W\x80c;\xA0\x0F\xAE\x14a\x0FnW\x80c@\x8C2\xEA\x14a\x0F:W\x80cA\x97\xA4\xB1\x14a\x0E\xE3W\x80cE6\x7F#\x14a\x0E\xC5W\x80cXZbz\x14a\rJW\x80cY\x19?7\x14a\t\x96W\x80c]=\x8C\xD2\x14a\x0C\xF8W\x80cb\x94T\xFD\x14a\x0C\xA9W\x80ch\xA5Ud\x14a\x0CuW\x80ci=\x0B~\x14a\x0C&W\x80cx\x1C\xD9\x9D\x14a\x0C\x08W\x80c{\xDA\x1C\xFB\x14a\x0B\xD9W\x80c|]\xD5\xD9\x14a\x0B\x94W\x80c|n\xAA\xEE\x14a\x0BeW\x80c~_\\\xA7\x14a\x0B@W\x80c\x85\xD8\x12\x17\x14a\nuW\x80c\x8B\x0E\x9F?\x14a\nXW\x80c\x8Cg\x90>\x14a\n.W\x80c\x96&\xA20\x14a\n\x08W\x80c\x9D\xEBf\xC9\x14a\t\xE7W\x80c\xA0\x9Dz0\x14a\t\x96W\x80c\xA7\x0B\x9F\x0C\x14a\tyW\x80c\xB9}\xD9\xE2\x14a\t_W\x80c\xC3\xDD\xB3\xB3\x14a\tFW\x80c\xCE}\x8EZ\x14a\x08\xBDW\x80c\xD5\x17m#\x14a\x08\x9FW\x80c\xE5\x8ES\x82\x14a\x05\xCDW\x80c\xE6\x01\xCFD\x14a\x05\x88W\x80c\xED\x86\xBAo\x14a\x05qW\x80c\xEEu\x14\xE8\x14a\x05\x1FW\x80c\xF00!\xA1\x14a\x05\x03W\x80c\xF1V\xE0o\x14a\x03\x92W\x80c\xF8\x9E\xE7\x8D\x14a\x03AW\x80c\xF9ee-\x14a\x03\x12W\x80c\xF9\xD6c\xE0\x14a\x02\xB6W\x80c\xFAE{\xE6\x14a\x02\x95W\x80c\xFAs\xCEY\x14a\x02FWc\xFE\x07\xBB\x07\x14a\x02(W_\x80\xFD[4a\x02BW_`\x03\x196\x01\x12a\x02BWa\x02@a\x1D]V[\0[_\x80\xFD[4a\x02BWa\x02T6a\x13\xC2V[\x91_R`\x13` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW` a\x02\xAEa\x02\xA86a\x13\xF9V[\x90a\x1C\xC2V[`@Q\x90\x81R\xF3[4a\x02BW`@`\x03\x196\x01\x12a\x02BW` a\x02\xAE`\x045a\x02\xD7a\x12\xF9V[a\x02\xE1\x81\x83a\x16=V[\x91_R`\x16\x84Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R\x83R`@_ T\x90a\x14\x1CV[4a\x02BWa\x03 6a\x13\xF9V[\x90_R`\x0E` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW`@`\x03\x196\x01\x12a\x02BWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x03oa\x13\x1CV[\x16_R`\x14` R`@_ `$5_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW`@`\x03\x196\x01\x12a\x02BW`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02BW6`#\x82\x01\x12\x15a\x02BW\x80`\x04\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02BW`$\x82\x01\x91`$6\x91\x83`\x06\x1B\x01\x01\x11a\x02BWa\x03\xF0a\x12\xF9V[\x90a\x03\xF9a\x1D\xF8V[\x80\x15a\x04\xDBW\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_[\x82\x81\x10a\x04%W`\x01_U\0[` a\x042\x82\x85\x87a\x1CDV[\x015\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x80\x92\x03a\x02BWa\x04^\x81\x85\x87a\x1CDV[5\x82;\x15a\x02BW_\x92`d\x84\x92`@Q\x95\x86\x93\x84\x92\x7Fi\xBC'G\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84R`\x04\x84\x01R3`$\x84\x01R\x88`D\x84\x01RZ\xF1\x91\x82\x15a\x04\xD0W`\x01\x92a\x04\xC0W[P\x01a\x04\x18V[_a\x04\xCA\x91a\x1CTV[\x85a\x04\xB9V[`@Q=_\x82>=\x90\xFD[\x7F\xBB\xCD?3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02BW` `\x03\x196\x01\x12a\x02BWa\x02@`\x045a\x1BiV[4a\x02BW`@`\x03\x196\x01\x12a\x02BWa\x058a\x12\xF9V[`\x045_R`\x16` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BWa\x02@a\x05\x826a\x13\xF9V[\x90a\x19?V[4a\x02BW` `\x03\x196\x01\x12a\x02BWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x05\xB6a\x13\x1CV[\x16_R`\x06` R` `@_ T`@Q\x90\x81R\xF3[```\x03\x196\x01\x12a\x02BW`$5`\x045`D5a\x05\xEAa\x1D\xF8V[\x80\x15a\x08wW\x81\x15\x80\x15a\x08oW[a\x08GW3_R`\x10` R`@_ \x82_R` R\x80`@_ T\x10a\x08\x1FW\x7F\xB3\x12\x90<\xE2\x07\xD2\x1E\x84\xE5}\x10\x05\xE0\xAAS\x85\xB7\x83\xEB'\xE2X\x81qt\xD0\x0C\xFB\xBC2x\x92`\xA0\x92a\x06Ga\x17\xE3V[\x923_R`\n` R\x83`@_ T\x10a\x08\x11W[\x81_R`\x0F` R\x83`@_ T\x10a\x08\x03W[3_R`\x14` R`@_ \x82_R` R\x83`@_ T\x10a\x07\xF4W[\x83_R`\x11` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x82_R` R`@_ a\x06\xCF\x82\x82Ta\x14\x1CV[\x90U\x83_R`\x0C` R`@_ \x82_R` R`@_ a\x06\xF2\x82\x82Ta\x14\x1CV[\x90U3_R`\x10` R`@_ \x82_R` R`@_ a\x07\x15\x82\x82Ta\x14\x0FV[\x90U\x81_R`\x0B` R`@_ a\x07.\x82\x82Ta\x14\x0FV[\x90U\x83_R`\x12` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x83_R` R`@_ a\x07q\x82\x82Ta\x14\x1CV[\x90U\x83_R`\r` R`@_ \x83_R` R`@_ a\x07\x94\x82\x82Ta\x14\x1CV[\x90U3_R`\x10` R`@_ \x83_R` R`@_ a\x07\xB7\x82\x82Ta\x14\x1CV[\x90U\x82_R`\x0B` R`@_ a\x07\xD0\x82\x82Ta\x14\x1CV[\x90U`@Q\x93\x84R3` \x85\x01R`@\x84\x01R``\x83\x01R`\x80\x82\x01R\xA1`\x01_U\0[a\x07\xFE\x823a\x14\xF4V[a\x06\x8EV[a\x08\x0C\x82a\x1BiV[a\x06pV[a\x08\x1A3a\x16\xF2V[a\x06\\V[\x7F\xF1\xBC\x94\xD2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\xF6\xB4\x13\x1C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[P\x82\x15a\x05\xF9V[\x7F,R\x11\xC6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02BW` `\x03\x196\x01\x12a\x02BW` a\x02\xAE`\x045a\x19\x13V[4a\x02BW` `\x03\x196\x01\x12a\x02BW`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02BWa\x08\xEE\x906\x90`\x04\x01a\x13?V[a\x08\xF6a\x1D\xF8V[_[\x81\x81\x10a\t\x05W`\x01_U\0[\x80a\t@a\t\x16`\x01\x93\x85\x87a\x14)V[5a\t\"\x83\x86\x88a\x14)V[53_R`\x10` R`@_ \x90_R` R`@_ T\x90a\x19?V[\x01a\x08\xF8V[4a\x02BW` a\x02\xAEa\tY6a\x13\xC2V[\x91a\x18!V[4a\x02BW_`\x03\x196\x01\x12a\x02BW` a\x02\xAEa\x17\xE3V[4a\x02BW_`\x03\x196\x01\x12a\x02BW` `@Qb'\x8D\0\x81R\xF3[4a\x02BW`@`\x03\x196\x01\x12a\x02BWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\t\xC4a\x13\x1CV[\x16_R`\x10` R`@_ `$5_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW` `\x03\x196\x01\x12a\x02BWa\x02@a\n\x03a\x13\x1CV[a\x16\xF2V[4a\x02BW`@`\x03\x196\x01\x12a\x02BW` a\x02\xAEa\n&a\x12\xF9V[`\x045a\x16=V[4a\x02BW` `\x03\x196\x01\x12a\x02BW`\x045_R`\x04` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW_`\x03\x196\x01\x12a\x02BW` `\x01T`@Q\x90\x81R\xF3[a\n~6a\x13pV[\x80\x83\x94\x93\x03a\x0B\x18W\x92\x91\x90_\x93_\x93[\x80\x85\x10a\n\xCFW\x854\x81\x03a\n\xA0W\0[\x7F\xA2\xDD \xEF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R4`$R`D_\xFD[\x90\x91\x92\x93\x94a\n\xEC`\x01\x91a\n\xE5\x88\x86\x88a\x14)V[5\x90a\x14\x1CV[\x95a\x0B\x0Ea\n\xFB\x82\x85\x89a\x14)V[5a\x0B\x07\x83\x87\x89a\x14)V[5\x90a\x1F\"V[\x01\x93\x92\x91\x90a\n\x8FV[\x7F\xB4\xFA?\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02BW`@`\x03\x196\x01\x12a\x02BWa\x02@a\x0B\\a\x13\x1CV[`$5\x90a\x14\xF4V[4a\x02BWa\x0Bs6a\x13\xF9V[\x90_R`\r` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW` `\x03\x196\x01\x12a\x02BWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x0B\xC2a\x13\x1CV[\x16_R`\n` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BWa\x0B\xE76a\x13\xF9V[\x90_R`\x0C` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW_`\x03\x196\x01\x12a\x02BW` `@Qch\x8DF\xF0\x81R\xF3[4a\x02BWa\x0C46a\x13\xC2V[\x91_R`\x12` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW` `\x03\x196\x01\x12a\x02BWa\x02@`\x0453_R`\x10` R`@_ \x81_R` R`@_ T\x90a\x19?V[4a\x02BWa\x0C\xB76a\x13\xC2V[\x91_R`\x11` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW`@`\x03\x196\x01\x12a\x02BWa\r\x11a\x12\xF9V[`\x045_R`\t` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW`@`\x03\x196\x01\x12a\x02BW`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02BWa\r{\x906\x90`\x04\x01a\x13?V[a\r\x83a\x12\xF9V[_\x91\x82\x903\x90[\x80\x83\x10a\x0E\x05W\x7F\xB0\x03\x82 ;F\xC3\xB6\xAD\n-z\xF0&\x8E3K\xD9@bV\xA7\xC7\xBA\x8F\x7F\xC8\xBCG\xF8\xCD\xE9\x85\x85a\r\xD4\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16a\x1E/V[`@\x80Q3\x81Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x90\x92\x16` \x83\x01R\x81\x01\x91\x90\x91R``\x90\xA1\0[\x90\x91\x93a\x0E\x13\x85\x83\x88a\x14)V[5a\x0E\x1Ca\x17\xE3V[\x81\x10\x15a\x0E\x9DW\x80_R`\t` R`@_ \x84_R` R`@_ T\x80\x15a\x0EuW`\x01\x92a\x0El\x92a\x0EP3a\x16\xF2V[_R`\t` R`@_ \x86_R` R_`@\x81 Ua\x14\x1CV[\x94\x01\x91\x90a\r\x8AV[\x7F\xC9E$-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\x0F,\xA6\xE7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02BW` `\x03\x196\x01\x12a\x02BW` a\x02\xAE`\x045a\x14fV[4a\x02BWa\x0E\xF16a\x13pV[\x90a\x0E\xFAa\x1D\xF8V[\x81\x83\x03a\x0EuW_[\x83\x81\x10a\x0F\x10W`\x01_U\0[\x80a\x0F4a\x0F!`\x01\x93\x87\x89a\x14)V[5a\x0F-\x83\x87\x87a\x14)V[5\x90a\x19?V[\x01a\x0F\x03V[4a\x02BW` `\x03\x196\x01\x12a\x02BW` a\x02\xAE`\x045a\x0F\\\x81a\x14fV[\x90_R`\x15\x83R`@_ T\x90a\x14\x1CV[4a\x02BW` `\x03\x196\x01\x12a\x02BW`\x045_R`\x0F` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW` `\x03\x196\x01\x12a\x02BW`\x045_R`\x02` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW`@`\x03\x196\x01\x12a\x02BWa\x0F\xDBa\x12\xF9V[`\x045_R`\x08` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW_`\x03\x196\x01\x12a\x02BW` `\x05T`@Q\x90\x81R\xF3[4a\x02BW` `\x03\x196\x01\x12a\x02BW`\x045_R`\x15` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW` `\x03\x196\x01\x12a\x02BW`\x045_R`\x0B` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW` `\x03\x196\x01\x12a\x02BW`\x045_R`\x03` R` `@_ T`@Q\x90\x81R\xF3[4a\x02BW`@`\x03\x196\x01\x12a\x02BWa\x10\xC8a\x12\xF9V[`\x045_R`\x07` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[` `\x03\x196\x01\x12a\x02BWa\x02@4`\x045a\x1F\"V[4a\x02BW` `\x03\x196\x01\x12a\x02BW`\x045\x80\x15a\x11\xBDW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x01\x90\x81\x11a\x11\x90Wb'\x8D\0\x81\x02\x90\x80\x82\x04b'\x8D\0\x14\x90\x15\x17\x15a\x11\x90Wch\x8DF\xF0\x01\x80ch\x8DF\xF0\x11a\x11\x90W` \x90`@Q\x90\x81R\xF3[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[\x7F\xD6\x93h\xD4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02BW`@`\x03\x196\x01\x12a\x02BW`\x045a\x12\x01a\x12\xF9V[a\x12\ta\x1D\xF8V[a\x12\x11a\x17\xE3V[\x82\x10\x15a\x0E\x9DW\x81_R`\t` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ T\x90\x81\x15a\x0EuW\x7F\xB0\x03\x82 ;F\xC3\xB6\xAD\n-z\xF0&\x8E3K\xD9@bV\xA7\xC7\xBA\x8F\x7F\xC8\xBCG\xF8\xCD\xE9\x92a\x12w3a\x16\xF2V[_R`\t` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R_`@\x81 Ua\x12\xC4\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16a\x1E/V[`@\x80Q3\x81Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x90\x92\x16` \x83\x01R\x81\x01\x91\x90\x91R``\x90\xA1`\x01_U\0[`$5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x02BWV[`\x045\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x02BWV[\x91\x81`\x1F\x84\x01\x12\x15a\x02BW\x825\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x02BW` \x80\x85\x01\x94\x84`\x05\x1B\x01\x01\x11a\x02BWV[`@`\x03\x19\x82\x01\x12a\x02BW`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02BW\x81a\x13\x9B\x91`\x04\x01a\x13?V[\x92\x90\x92\x91`$5\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x02BWa\x13\xBE\x91`\x04\x01a\x13?V[\x90\x91V[`\x03\x19``\x91\x01\x12a\x02BW`\x045\x90`$5s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x02BW\x90`D5\x90V[`\x03\x19`@\x91\x01\x12a\x02BW`\x045\x90`$5\x90V[\x91\x90\x82\x03\x91\x82\x11a\x11\x90WV[\x91\x90\x82\x01\x80\x92\x11a\x11\x90WV[\x91\x90\x81\x10\x15a\x149W`\x05\x1B\x01\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[`\x05T\x81\x10a\x14\xB8Wa\x14\xB5\x90a\x14\xA2a\x14\x8F`\x01T\x83_R`\x02` R`@_ T\x90a\x14\x1CV[\x82_R`\x04` R`@_ T\x90a\x14\x1CV[\x90_R`\x03` R`@_ T\x90a\x14\x0FV[\x90V[_R`\x02` R`@_ T\x90V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x14a\x11\x90W`\x01\x01\x90V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x15\x12a\x17\xE3V[\x92\x16\x80_R`\x14` R`@_ \x82_R` R`@_ T\x92[\x80\x84\x10a\x15MWP_R`\x14` R`@_ \x90_R` R`@_ UV[\x92a\x167\x90\x82_R`\x10` R`@_ \x84_R` R`@_ T\x81_R`\x11` R`@_ \x84_R` R`@_ \x85_R` Ra\x15\x94`@_ \x91\x82Ta\x14\x1CV[\x90U\x80_R`\x13` R`@_ \x83_R` R`@_ \x84_R` R`@_ T\x81_R`\x11` R`@_ \x84_R` R`@_ \x85_R` Ra\x15\xE2`@_ \x91\x82Ta\x14\x1CV[\x90U\x80_R`\x12` R`@_ \x83_R` R`@_ \x84_R` R`@_ T\x81_R`\x11` R`@_ \x84_R` R`@_ \x85_R` Ra\x160`@_ \x91\x82Ta\x14\x0FV[\x90Ua\x14\xC7V[\x92a\x15-V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81_R`\n` R`@_ T\x81\x10\x15_\x14a\x16\xD9W\x81a\x14\xB5\x92_R`\x06` Ra\x16\xBCa\x16\x9F`@_ T\x84_R`\x07` R`@_ \x84_R` R`@_ T\x90a\x14\x1CV[\x83_R`\t` R`@_ \x83_R` R`@_ T\x90a\x14\x1CV[\x91_R`\x08` R`@_ \x90_R` R`@_ T\x90a\x14\x0FV[_R`\x07` R`@_ \x90_R` R`@_ T\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x17\x0Fa\x17\xE3V[\x91\x16\x80_R`\n` R`@_ T\x91[\x80\x83\x10a\x176WP_R`\n` R`@_ UV[\x91a\x17\xDD\x90\x82_R`\x06` R`@_ T\x81_R`\x07` R`@_ \x84_R` Ra\x17i`@_ \x91\x82Ta\x14\x1CV[\x90U\x80_R`\t` R`@_ \x83_R` R`@_ T\x81_R`\x07` R`@_ \x84_R` Ra\x17\xA3`@_ \x91\x82Ta\x14\x1CV[\x90U\x80_R`\x08` R`@_ \x83_R` R`@_ T\x81_R`\x07` R`@_ \x84_R` Ra\x160`@_ \x91\x82Ta\x14\x0FV[\x91a\x17 V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x97r\xB9\x10B\x01B\x81\x11a\x11\x90Wb'\x8D\0\x90\x04`\x01\x81\x01\x80\x91\x11a\x11\x90W\x90V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80_R`\x14` R`@_ \x83_R` R`@_ T\x82\x10\x15_\x14a\x18\xEFW\x91\x82a\x14\xB5\x93_R`\x10` R`@_ \x82_R` Ra\x18\xC8a\x18\xA1`@_ T\x85_R`\x11` R`@_ \x84_R` R`@_ \x85_R` R`@_ T\x90a\x14\x1CV[\x84_R`\x13` R`@_ \x83_R` R`@_ \x84_R` R`@_ T\x90a\x14\x1CV[\x92_R`\x12` R`@_ \x90_R` R`@_ \x90_R` R`@_ T\x90a\x14\x0FV[\x90_R`\x11` R`@_ \x90_R` R`@_ \x90_R` R`@_ T\x90V[\x80\x15a\x11\xBDWb'\x8D\0\x81\x02\x90\x81\x04b'\x8D\0\x03a\x11\x90Wch\x8DF\xF0\x01\x80ch\x8DF\xF0\x11a\x11\x90W\x90V[\x90\x80\x15a\x08wW\x81\x15a\x08GW3_R`\x10` R`@_ \x82_R` R`@_ T\x81\x11\x80\x15a\x1BTW[a\x08\x1FW\x7F\x8B\xD4r\x8E\xE9\xCA?\x99\xDD\xCF\xFA$\xEBO\x15\xDE\x01\\\xDA\x9A'\xCC\xC4'\xDF\xDA\xF7\x11\x94>\xBC\xA0\x91``\x91a\x19\x9Da\x17\xE3V[\x80`\x05T\x10a\x1BGW[3_R`\n` R\x80`@_ T\x10a\x1B9W[\x82_R`\x0F` R\x80`@_ T\x10a\x1B+W[3_R`\x14` R`@_ \x83_R` R\x80`@_ T\x10a\x1B\x1CW[\x80_R`\x04` R`@_ a\x1A\x04\x83\x82Ta\x14\x1CV[\x90U\x80_R`\t` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ a\x1A=\x83\x82Ta\x14\x1CV[\x90U\x80_R`\x0E` R`@_ \x83_R` R`@_ a\x1A`\x83\x82Ta\x14\x1CV[\x90U_R`\x13` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x82_R` R`@_ a\x1A\xA2\x82\x82Ta\x14\x1CV[\x90Ua\x1A\xB0\x81`\x01Ta\x14\x0FV[`\x01U3_R`\x06` R`@_ a\x1A\xCA\x82\x82Ta\x14\x0FV[\x90U\x81_R`\x0B` R`@_ a\x1A\xE3\x82\x82Ta\x14\x0FV[\x90U3_R`\x10` R`@_ \x82_R` R`@_ a\x1B\x06\x82\x82Ta\x14\x0FV[\x90U`@Q\x913\x83R` \x83\x01R`@\x82\x01R\xA1V[a\x1B&\x833a\x14\xF4V[a\x19\xEDV[a\x1B4\x83a\x1BiV[a\x19\xCFV[a\x1BB3a\x16\xF2V[a\x19\xBBV[a\x1BOa\x1D]V[a\x19\xA7V[P3_R`\x06` R`@_ T\x81\x11a\x19lV[a\x1Bqa\x17\xE3V[\x90\x80_R`\x0F` R`@_ T\x91[\x80\x83\x10a\x1B\x97WP_R`\x0F` R`@_ UV[\x91a\x1C>\x90\x82_R`\x0B` R`@_ T\x81_R`\x0C` R`@_ \x84_R` Ra\x1B\xCA`@_ \x91\x82Ta\x14\x1CV[\x90U\x80_R`\x0E` R`@_ \x83_R` R`@_ T\x81_R`\x0C` R`@_ \x84_R` Ra\x1C\x04`@_ \x91\x82Ta\x14\x1CV[\x90U\x80_R`\r` R`@_ \x83_R` R`@_ T\x81_R`\x0C` R`@_ \x84_R` Ra\x160`@_ \x91\x82Ta\x14\x0FV[\x91a\x1B\x81V[\x91\x90\x81\x10\x15a\x149W`\x06\x1B\x01\x90V[\x90`\x1F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x1C\x95W`@RV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[_\x82\x81R`\x0F` R`@\x90 T\x81\x10a\x1DDW\x81a\x14\xB5\x92_R`\x0B` Ra\x1D'a\x1D\n`@_ T\x84_R`\x0C` R`@_ \x84_R` R`@_ T\x90a\x14\x1CV[\x83_R`\x0E` R`@_ \x83_R` R`@_ T\x90a\x14\x1CV[\x91_R`\r` R`@_ \x90_R` R`@_ T\x90a\x14\x0FV[_R`\x0C` R`@_ \x90_R` R`@_ T\x90V[a\x1Dea\x17\xE3V[\x90[`\x05T\x82\x81\x10\x15a\x1D\xF3W`\x01T\x90_R`\x02` Ra\x1D\x8C`@_ \x91\x82Ta\x14\x1CV[\x90U`\x05T\x80_R`\x04` R`@_ T\x90_R`\x02` Ra\x1D\xB5`@_ \x91\x82Ta\x14\x1CV[\x90U`\x05T\x80_R`\x03` R`@_ T\x90_R`\x02` Ra\x1D\xDE`@_ \x91\x82Ta\x14\x0FV[\x90Ua\x1D\xEB`\x05Ta\x14\xC7V[`\x05Ua\x1DgV[P\x90PV[`\x02_T\x14a\x1E\x07W`\x02_UV[\x7F>\xE5\xAE\xB5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x81G\x10a\x1E\xF2W_\x80\x80\x93s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x94\x16Z\xF1=\x15a\x1E\xEAW=\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x1C\x95W`@Q\x91a\x1E\xA1` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x84\x01\x16\x01\x84a\x1CTV[\x82R=_` \x84\x01>[\x15a\x1E\xB3WPV[\x80Q\x15a\x1E\xC2W\x80Q\x90` \x01\xFD[\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[``\x90a\x1E\xABV[PG\x7F\xCFG\x91\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$R`D_\xFD[\x81\x15a\x08wW\x80\x15a\x08GWa\x1F6a\x17\xE3V[\x80`\x05T\x10a!\x89W[3_R`\n` R\x80`@_ T\x10a!{W[\x81_R`\x0F` R\x80`@_ T\x10a!mW[3_R`\x14` R`@_ \x82_R` R\x80`@_ T\x10a!^W[a\x1F\xA0a\x1F\x99a\x1F\x94a\x17\xE3V[a\x19\x13V[B\x90a\x14\x0FV[\x91\x82\x84\x02\x92\x84\x84\x04\x03a\x11\x90W\x7FPz\xC3\x9E\xB36\x10\x19\x1C\xD8\xFDT(n\x91\xC5\xCCFL&(ad;\xE3\x97\x8FZ\x9F\x18\xAB\x02\x93b'\x8D\0`\x80\x94\x04\x83_R`\x15` R`@_ a\x1F\xEE\x82\x82Ta\x14\x1CV[\x90U\x83_R`\x16` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` Ra '`@_ \x91\x82Ta\x14\x1CV[\x90U\x82_R`\x03` R`@_ a @\x82\x82Ta\x14\x1CV[\x90Ua N\x81`\x01Ta\x14\x1CV[`\x01U\x82_R`\x08` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ a \x88\x82\x82Ta\x14\x1CV[\x90U3_R`\x06` R`@_ a \xA1\x82\x82Ta\x14\x1CV[\x90U\x82_R`\r` R`@_ \x82_R` R`@_ a \xC4\x82\x82Ta\x14\x1CV[\x90U\x81_R`\x0B` R`@_ a \xDD\x82\x82Ta\x14\x1CV[\x90U\x82_R`\x12` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x82_R` R`@_ a! \x82\x82Ta\x14\x1CV[\x90U3_R`\x10` R`@_ \x82_R` R`@_ a!C\x82\x82Ta\x14\x1CV[\x90U`@Q\x92\x83R3` \x84\x01R`@\x83\x01R``\x82\x01R\xA1V[a!h\x823a\x14\xF4V[a\x1F\x86V[a!v\x82a\x1BiV[a\x1FhV[a!\x843a\x16\xF2V[a\x1FTV[a!\x91a\x1D]V[a\x1F@V",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct ClaimRequest { uint256 epochIndex; address poolAddress; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ClaimRequest {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub poolAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ClaimRequest> for UnderlyingRustTuple<'_> {
            fn from(value: ClaimRequest) -> Self {
                (value.epochIndex, value.poolAddress)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ClaimRequest {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    epochIndex: tuple.0,
                    poolAddress: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ClaimRequest {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ClaimRequest {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.poolAddress,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ClaimRequest {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ClaimRequest {
            const NAME: &'static str = "ClaimRequest";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ClaimRequest(uint256 epochIndex,address poolAddress)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.epochIndex)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.poolAddress,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ClaimRequest {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.epochIndex,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.poolAddress,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.epochIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.poolAddress,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedCall()` and selector `0xd6bda275`.
```solidity
error FailedCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedCall;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedCall()";
            const SELECTOR: [u8; 4] = [214u8, 189u8, 162u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientBalance(uint256,uint256)` and selector `0xcf479181`.
```solidity
error InsufficientBalance(uint256 balance, uint256 needed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientBalance {
        #[allow(missing_docs)]
        pub balance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientBalance> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientBalance) -> Self {
                (value.balance, value.needed)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    balance: tuple.0,
                    needed: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientBalance(uint256,uint256)";
            const SELECTOR: [u8; 4] = [207u8, 71u8, 145u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.needed),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientStake()` and selector `0xf1bc94d2`.
```solidity
error InsufficientStake();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientStake;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientStake> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientStake) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientStake {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientStake {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientStake()";
            const SELECTOR: [u8; 4] = [241u8, 188u8, 148u8, 210u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidAmount()` and selector `0x2c5211c6`.
```solidity
error InvalidAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidAmount;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidAmount> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidAmount()";
            const SELECTOR: [u8; 4] = [44u8, 82u8, 17u8, 198u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidAppchainId()` and selector `0xf6b4131c`.
```solidity
error InvalidAppchainId();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidAppchainId;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidAppchainId> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidAppchainId) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidAppchainId {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidAppchainId {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidAppchainId()";
            const SELECTOR: [u8; 4] = [246u8, 180u8, 19u8, 28u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidInput()` and selector `0xb4fa3fb3`.
```solidity
error InvalidInput();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidInput;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidInput> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidInput) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidInput {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidInput {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidInput()";
            const SELECTOR: [u8; 4] = [180u8, 250u8, 63u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidStakingAmount(uint256,uint256)` and selector `0xa2dd20ef`.
```solidity
error InvalidStakingAmount(uint256 totalAmount, uint256 sentAmount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidStakingAmount {
        #[allow(missing_docs)]
        pub totalAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub sentAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidStakingAmount> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidStakingAmount) -> Self {
                (value.totalAmount, value.sentAmount)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidStakingAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    totalAmount: tuple.0,
                    sentAmount: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidStakingAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidStakingAmount(uint256,uint256)";
            const SELECTOR: [u8; 4] = [162u8, 221u8, 32u8, 239u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalAmount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.sentAmount),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidWithdrawal()` and selector `0xc945242d`.
```solidity
error InvalidWithdrawal();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidWithdrawal;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidWithdrawal> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidWithdrawal) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidWithdrawal {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidWithdrawal {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidWithdrawal()";
            const SELECTOR: [u8; 4] = [201u8, 69u8, 36u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NoClaimsProvided()` and selector `0xbbcd3f33`.
```solidity
error NoClaimsProvided();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoClaimsProvided;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoClaimsProvided> for UnderlyingRustTuple<'_> {
            fn from(value: NoClaimsProvided) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NoClaimsProvided {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoClaimsProvided {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoClaimsProvided()";
            const SELECTOR: [u8; 4] = [187u8, 205u8, 63u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ReentrancyGuardReentrantCall()` and selector `0x3ee5aeb5`.
```solidity
error ReentrancyGuardReentrantCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ReentrancyGuardReentrantCall;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ReentrancyGuardReentrantCall>
        for UnderlyingRustTuple<'_> {
            fn from(value: ReentrancyGuardReentrantCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ReentrancyGuardReentrantCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ReentrancyGuardReentrantCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ReentrancyGuardReentrantCall()";
            const SELECTOR: [u8; 4] = [62u8, 229u8, 174u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `WithdrawalNotReady()` and selector `0x0f2ca6e7`.
```solidity
error WithdrawalNotReady();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct WithdrawalNotReady;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<WithdrawalNotReady> for UnderlyingRustTuple<'_> {
            fn from(value: WithdrawalNotReady) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for WithdrawalNotReady {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for WithdrawalNotReady {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "WithdrawalNotReady()";
            const SELECTOR: [u8; 4] = [15u8, 44u8, 166u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ZeroEpochIndex()` and selector `0xd69368d4`.
```solidity
error ZeroEpochIndex();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroEpochIndex;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroEpochIndex> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroEpochIndex) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroEpochIndex {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroEpochIndex {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroEpochIndex()";
            const SELECTOR: [u8; 4] = [214u8, 147u8, 104u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Stake(uint256,address,uint256,uint256)` and selector `0x507ac39eb33610191cd8fd54286e91c5cc464c262861643be3978f5a9f18ab02`.
```solidity
event Stake(uint256 epochIndex, address user, uint256 amount, uint256 appchainId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Stake {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Stake {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Stake(uint256,address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                80u8, 122u8, 195u8, 158u8, 179u8, 54u8, 16u8, 25u8, 28u8, 216u8, 253u8,
                84u8, 40u8, 110u8, 145u8, 197u8, 204u8, 70u8, 76u8, 38u8, 40u8, 97u8,
                100u8, 59u8, 227u8, 151u8, 143u8, 90u8, 159u8, 24u8, 171u8, 2u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    epochIndex: data.0,
                    user: data.1,
                    amount: data.2,
                    appchainId: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Stake {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Stake> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Stake) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `StakeTransfer(uint256,address,uint256,uint256,uint256)` and selector `0xb312903ce207d21e84e57d1005e0aa5385b783eb27e258817174d00cfbbc3278`.
```solidity
event StakeTransfer(uint256 epochIndex, address user, uint256 amount, uint256 fromAppchainId, uint256 toAppchainId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct StakeTransfer {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub fromAppchainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub toAppchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for StakeTransfer {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "StakeTransfer(uint256,address,uint256,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                179u8, 18u8, 144u8, 60u8, 226u8, 7u8, 210u8, 30u8, 132u8, 229u8, 125u8,
                16u8, 5u8, 224u8, 170u8, 83u8, 133u8, 183u8, 131u8, 235u8, 39u8, 226u8,
                88u8, 129u8, 113u8, 116u8, 208u8, 12u8, 251u8, 188u8, 50u8, 120u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    epochIndex: data.0,
                    user: data.1,
                    amount: data.2,
                    fromAppchainId: data.3,
                    toAppchainId: data.4,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.fromAppchainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.toAppchainId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for StakeTransfer {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&StakeTransfer> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &StakeTransfer) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `WithdrawalCompleted(address,address,uint256)` and selector `0xb00382203b46c3b6ad0a2d7af0268e334bd9406256a7c7ba8f7fc8bc47f8cde9`.
```solidity
event WithdrawalCompleted(address user, address destination, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct WithdrawalCompleted {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub destination: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for WithdrawalCompleted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "WithdrawalCompleted(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                176u8, 3u8, 130u8, 32u8, 59u8, 70u8, 195u8, 182u8, 173u8, 10u8, 45u8,
                122u8, 240u8, 38u8, 142u8, 51u8, 75u8, 217u8, 64u8, 98u8, 86u8, 167u8,
                199u8, 186u8, 143u8, 127u8, 200u8, 188u8, 71u8, 248u8, 205u8, 233u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    user: data.0,
                    destination: data.1,
                    amount: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.destination,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for WithdrawalCompleted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&WithdrawalCompleted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &WithdrawalCompleted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `WithdrawalInitialized(address,uint256,uint256)` and selector `0x8bd4728ee9ca3f99ddcffa24eb4f15de015cda9a27ccc427dfdaf711943ebca0`.
```solidity
event WithdrawalInitialized(address user, uint256 appchainId, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct WithdrawalInitialized {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for WithdrawalInitialized {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "WithdrawalInitialized(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8, 212u8, 114u8, 142u8, 233u8, 202u8, 63u8, 153u8, 221u8, 207u8,
                250u8, 36u8, 235u8, 79u8, 21u8, 222u8, 1u8, 92u8, 218u8, 154u8, 39u8,
                204u8, 196u8, 39u8, 223u8, 218u8, 247u8, 17u8, 148u8, 62u8, 188u8, 160u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    user: data.0,
                    appchainId: data.1,
                    amount: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for WithdrawalInitialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&WithdrawalInitialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &WithdrawalInitialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `EPOCH_DURATION()` and selector `0xa70b9f0c`.
```solidity
function EPOCH_DURATION() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EPOCH_DURATIONCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`EPOCH_DURATION()`](EPOCH_DURATIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EPOCH_DURATIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EPOCH_DURATIONCall> for UnderlyingRustTuple<'_> {
                fn from(value: EPOCH_DURATIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for EPOCH_DURATIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EPOCH_DURATIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EPOCH_DURATIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EPOCH_DURATIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EPOCH_DURATIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EPOCH_DURATION()";
            const SELECTOR: [u8; 4] = [167u8, 11u8, 159u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: EPOCH_DURATIONReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: EPOCH_DURATIONReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `START_TIMESTAMP()` and selector `0x781cd99d`.
```solidity
function START_TIMESTAMP() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct START_TIMESTAMPCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`START_TIMESTAMP()`](START_TIMESTAMPCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct START_TIMESTAMPReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<START_TIMESTAMPCall> for UnderlyingRustTuple<'_> {
                fn from(value: START_TIMESTAMPCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for START_TIMESTAMPCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<START_TIMESTAMPReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: START_TIMESTAMPReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for START_TIMESTAMPReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for START_TIMESTAMPCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "START_TIMESTAMP()";
            const SELECTOR: [u8; 4] = [120u8, 28u8, 217u8, 157u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: START_TIMESTAMPReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: START_TIMESTAMPReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `appchainFinalizedEpochCount(uint256)` and selector `0x3ba00fae`.
```solidity
function appchainFinalizedEpochCount(uint256 appchainId) external view returns (uint256 finalizedEpochCount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appchainFinalizedEpochCountCall {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`appchainFinalizedEpochCount(uint256)`](appchainFinalizedEpochCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appchainFinalizedEpochCountReturn {
        #[allow(missing_docs)]
        pub finalizedEpochCount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appchainFinalizedEpochCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: appchainFinalizedEpochCountCall) -> Self {
                    (value.appchainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for appchainFinalizedEpochCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { appchainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appchainFinalizedEpochCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: appchainFinalizedEpochCountReturn) -> Self {
                    (value.finalizedEpochCount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for appchainFinalizedEpochCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        finalizedEpochCount: tuple.0,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for appchainFinalizedEpochCountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "appchainFinalizedEpochCount(uint256)";
            const SELECTOR: [u8; 4] = [59u8, 160u8, 15u8, 174u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: appchainFinalizedEpochCountReturn = r.into();
                        r.finalizedEpochCount
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: appchainFinalizedEpochCountReturn = r.into();
                        r.finalizedEpochCount
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `appchainTotal(uint256)` and selector `0x1057e9bc`.
```solidity
function appchainTotal(uint256 appchainId) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appchainTotalCall {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`appchainTotal(uint256)`](appchainTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appchainTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appchainTotalCall> for UnderlyingRustTuple<'_> {
                fn from(value: appchainTotalCall) -> Self {
                    (value.appchainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for appchainTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { appchainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appchainTotalReturn> for UnderlyingRustTuple<'_> {
                fn from(value: appchainTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for appchainTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for appchainTotalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "appchainTotal(uint256)";
            const SELECTOR: [u8; 4] = [16u8, 87u8, 233u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: appchainTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: appchainTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `claimAllRewards((uint256,address)[],address)` and selector `0xf156e06f`.
```solidity
function claimAllRewards(ClaimRequest[] memory claims, address destination) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAllRewardsCall {
        #[allow(missing_docs)]
        pub claims: alloy::sol_types::private::Vec<
            <ClaimRequest as alloy::sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub destination: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`claimAllRewards((uint256,address)[],address)`](claimAllRewardsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAllRewardsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<ClaimRequest>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    <ClaimRequest as alloy::sol_types::SolType>::RustType,
                >,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAllRewardsCall> for UnderlyingRustTuple<'_> {
                fn from(value: claimAllRewardsCall) -> Self {
                    (value.claims, value.destination)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claimAllRewardsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        claims: tuple.0,
                        destination: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAllRewardsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAllRewardsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAllRewardsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl claimAllRewardsReturn {
            fn _tokenize(
                &self,
            ) -> <claimAllRewardsCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAllRewardsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<ClaimRequest>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAllRewardsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAllRewards((uint256,address)[],address)";
            const SELECTOR: [u8; 4] = [241u8, 86u8, 224u8, 111u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        ClaimRequest,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.destination,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                claimAllRewardsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochAdditions(uint256)` and selector `0x0b281bf8`.
```solidity
function epochAdditions(uint256 epochIndex) external view returns (uint256 additions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAdditionsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochAdditions(uint256)`](epochAdditionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAdditionsReturn {
        #[allow(missing_docs)]
        pub additions: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAdditionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: epochAdditionsCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for epochAdditionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAdditionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAdditionsReturn) -> Self {
                    (value.additions,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAdditionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { additions: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochAdditionsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochAdditions(uint256)";
            const SELECTOR: [u8; 4] = [11u8, 40u8, 27u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochAdditionsReturn = r.into();
                        r.additions
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochAdditionsReturn = r.into();
                        r.additions
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochAppchainAdditions(uint256,uint256)` and selector `0x7c6eaaee`.
```solidity
function epochAppchainAdditions(uint256 epochIndex, uint256 appchainId) external view returns (uint256 additions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainAdditionsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochAppchainAdditions(uint256,uint256)`](epochAppchainAdditionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainAdditionsReturn {
        #[allow(missing_docs)]
        pub additions: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainAdditionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainAdditionsCall) -> Self {
                    (value.epochIndex, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainAdditionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainAdditionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainAdditionsReturn) -> Self {
                    (value.additions,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainAdditionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { additions: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochAppchainAdditionsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochAppchainAdditions(uint256,uint256)";
            const SELECTOR: [u8; 4] = [124u8, 110u8, 170u8, 238u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochAppchainAdditionsReturn = r.into();
                        r.additions
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochAppchainAdditionsReturn = r.into();
                        r.additions
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochAppchainTotal(uint256,uint256)` and selector `0x7bda1cfb`.
```solidity
function epochAppchainTotal(uint256 epochIndex, uint256 appchainId) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainTotalCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochAppchainTotal(uint256,uint256)`](epochAppchainTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainTotalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainTotalCall) -> Self {
                    (value.epochIndex, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainTotalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochAppchainTotalCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochAppchainTotal(uint256,uint256)";
            const SELECTOR: [u8; 4] = [123u8, 218u8, 28u8, 251u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochAppchainTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochAppchainTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochAppchainWithdrawals(uint256,uint256)` and selector `0xf965652d`.
```solidity
function epochAppchainWithdrawals(uint256 epochIndex, uint256 appchainId) external view returns (uint256 withdrawals);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainWithdrawalsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochAppchainWithdrawals(uint256,uint256)`](epochAppchainWithdrawalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainWithdrawalsReturn {
        #[allow(missing_docs)]
        pub withdrawals: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainWithdrawalsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainWithdrawalsCall) -> Self {
                    (value.epochIndex, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainWithdrawalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainWithdrawalsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainWithdrawalsReturn) -> Self {
                    (value.withdrawals,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainWithdrawalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { withdrawals: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochAppchainWithdrawalsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochAppchainWithdrawals(uint256,uint256)";
            const SELECTOR: [u8; 4] = [249u8, 101u8, 101u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochAppchainWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochAppchainWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochStakeShare(uint256)` and selector `0x12e973bc`.
```solidity
function epochStakeShare(uint256 epochIndex) external view returns (uint256 stakeShare);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochStakeShareCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochStakeShare(uint256)`](epochStakeShareCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochStakeShareReturn {
        #[allow(missing_docs)]
        pub stakeShare: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochStakeShareCall> for UnderlyingRustTuple<'_> {
                fn from(value: epochStakeShareCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for epochStakeShareCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochStakeShareReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochStakeShareReturn) -> Self {
                    (value.stakeShare,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochStakeShareReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stakeShare: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochStakeShareCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochStakeShare(uint256)";
            const SELECTOR: [u8; 4] = [18u8, 233u8, 115u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochStakeShareReturn = r.into();
                        r.stakeShare
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochStakeShareReturn = r.into();
                        r.stakeShare
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochTotal(uint256)` and selector `0x1e0e8489`.
```solidity
function epochTotal(uint256 epochIndex) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochTotalCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochTotal(uint256)`](epochTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochTotalCall> for UnderlyingRustTuple<'_> {
                fn from(value: epochTotalCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for epochTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochTotalReturn> for UnderlyingRustTuple<'_> {
                fn from(value: epochTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for epochTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochTotalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochTotal(uint256)";
            const SELECTOR: [u8; 4] = [30u8, 14u8, 132u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserAdditions(uint256,address)` and selector `0x1b533b5a`.
```solidity
function epochUserAdditions(uint256 epochIndex, address user) external view returns (uint256 additions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAdditionsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserAdditions(uint256,address)`](epochUserAdditionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAdditionsReturn {
        #[allow(missing_docs)]
        pub additions: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAdditionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAdditionsCall) -> Self {
                    (value.epochIndex, value.user)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAdditionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAdditionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAdditionsReturn) -> Self {
                    (value.additions,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAdditionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { additions: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserAdditionsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserAdditions(uint256,address)";
            const SELECTOR: [u8; 4] = [27u8, 83u8, 59u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserAdditionsReturn = r.into();
                        r.additions
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserAdditionsReturn = r.into();
                        r.additions
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserAppchainAdditions(uint256,address,uint256)` and selector `0x693d0b7e`.
```solidity
function epochUserAppchainAdditions(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256 additions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAppchainAdditionsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserAppchainAdditions(uint256,address,uint256)`](epochUserAppchainAdditionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAppchainAdditionsReturn {
        #[allow(missing_docs)]
        pub additions: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAppchainAdditionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAppchainAdditionsCall) -> Self {
                    (value.epochIndex, value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAppchainAdditionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                        appchainId: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAppchainAdditionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAppchainAdditionsReturn) -> Self {
                    (value.additions,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAppchainAdditionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { additions: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserAppchainAdditionsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserAppchainAdditions(uint256,address,uint256)";
            const SELECTOR: [u8; 4] = [105u8, 61u8, 11u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserAppchainAdditionsReturn = r.into();
                        r.additions
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserAppchainAdditionsReturn = r.into();
                        r.additions
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserAppchainTotal(uint256,address,uint256)` and selector `0x629454fd`.
```solidity
function epochUserAppchainTotal(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAppchainTotalCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserAppchainTotal(uint256,address,uint256)`](epochUserAppchainTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAppchainTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAppchainTotalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAppchainTotalCall) -> Self {
                    (value.epochIndex, value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAppchainTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                        appchainId: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAppchainTotalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAppchainTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAppchainTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserAppchainTotalCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserAppchainTotal(uint256,address,uint256)";
            const SELECTOR: [u8; 4] = [98u8, 148u8, 84u8, 253u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserAppchainTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserAppchainTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserAppchainWithdrawals(uint256,address,uint256)` and selector `0xfa73ce59`.
```solidity
function epochUserAppchainWithdrawals(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256 withdrawals);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAppchainWithdrawalsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserAppchainWithdrawals(uint256,address,uint256)`](epochUserAppchainWithdrawalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAppchainWithdrawalsReturn {
        #[allow(missing_docs)]
        pub withdrawals: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAppchainWithdrawalsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAppchainWithdrawalsCall) -> Self {
                    (value.epochIndex, value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAppchainWithdrawalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                        appchainId: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAppchainWithdrawalsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAppchainWithdrawalsReturn) -> Self {
                    (value.withdrawals,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAppchainWithdrawalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { withdrawals: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserAppchainWithdrawalsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserAppchainWithdrawals(uint256,address,uint256)";
            const SELECTOR: [u8; 4] = [250u8, 115u8, 206u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserAppchainWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserAppchainWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserStakeShare(uint256,address)` and selector `0xee7514e8`.
```solidity
function epochUserStakeShare(uint256 epochIndex, address user) external view returns (uint256 stakeShare);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserStakeShareCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserStakeShare(uint256,address)`](epochUserStakeShareCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserStakeShareReturn {
        #[allow(missing_docs)]
        pub stakeShare: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserStakeShareCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserStakeShareCall) -> Self {
                    (value.epochIndex, value.user)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserStakeShareCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserStakeShareReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserStakeShareReturn) -> Self {
                    (value.stakeShare,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserStakeShareReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stakeShare: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserStakeShareCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserStakeShare(uint256,address)";
            const SELECTOR: [u8; 4] = [238u8, 117u8, 20u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserStakeShareReturn = r.into();
                        r.stakeShare
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserStakeShareReturn = r.into();
                        r.stakeShare
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserTotal(uint256,address)` and selector `0x053dcd25`.
```solidity
function epochUserTotal(uint256 epochIndex, address user) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserTotalCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserTotal(uint256,address)`](epochUserTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserTotalCall> for UnderlyingRustTuple<'_> {
                fn from(value: epochUserTotalCall) -> Self {
                    (value.epochIndex, value.user)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for epochUserTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserTotalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserTotalCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserTotal(uint256,address)";
            const SELECTOR: [u8; 4] = [5u8, 61u8, 205u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserWithdrawals(uint256,address)` and selector `0x5d3d8cd2`.
```solidity
function epochUserWithdrawals(uint256 epochIndex, address user) external view returns (uint256 withdrawals);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserWithdrawalsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserWithdrawals(uint256,address)`](epochUserWithdrawalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserWithdrawalsReturn {
        #[allow(missing_docs)]
        pub withdrawals: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserWithdrawalsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserWithdrawalsCall) -> Self {
                    (value.epochIndex, value.user)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserWithdrawalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserWithdrawalsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserWithdrawalsReturn) -> Self {
                    (value.withdrawals,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserWithdrawalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { withdrawals: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserWithdrawalsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserWithdrawals(uint256,address)";
            const SELECTOR: [u8; 4] = [93u8, 61u8, 140u8, 210u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochWithdrawals(uint256)` and selector `0x8c67903e`.
```solidity
function epochWithdrawals(uint256 epochIndex) external view returns (uint256 withdrawals);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochWithdrawalsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochWithdrawals(uint256)`](epochWithdrawalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochWithdrawalsReturn {
        #[allow(missing_docs)]
        pub withdrawals: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochWithdrawalsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochWithdrawalsCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochWithdrawalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochWithdrawalsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochWithdrawalsReturn) -> Self {
                    (value.withdrawals,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochWithdrawalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { withdrawals: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochWithdrawalsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochWithdrawals(uint256)";
            const SELECTOR: [u8; 4] = [140u8, 103u8, 144u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `finalizeAppchainEpochs(uint256)` and selector `0xf03021a1`.
```solidity
function finalizeAppchainEpochs(uint256 appchainId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeAppchainEpochsCall {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`finalizeAppchainEpochs(uint256)`](finalizeAppchainEpochsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeAppchainEpochsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeAppchainEpochsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeAppchainEpochsCall) -> Self {
                    (value.appchainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeAppchainEpochsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { appchainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeAppchainEpochsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeAppchainEpochsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeAppchainEpochsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl finalizeAppchainEpochsReturn {
            fn _tokenize(
                &self,
            ) -> <finalizeAppchainEpochsCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for finalizeAppchainEpochsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = finalizeAppchainEpochsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "finalizeAppchainEpochs(uint256)";
            const SELECTOR: [u8; 4] = [240u8, 48u8, 33u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                finalizeAppchainEpochsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `finalizeEpochs()` and selector `0xfe07bb07`.
```solidity
function finalizeEpochs() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeEpochsCall;
    ///Container type for the return parameters of the [`finalizeEpochs()`](finalizeEpochsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeEpochsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeEpochsCall> for UnderlyingRustTuple<'_> {
                fn from(value: finalizeEpochsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for finalizeEpochsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeEpochsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeEpochsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeEpochsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl finalizeEpochsReturn {
            fn _tokenize(
                &self,
            ) -> <finalizeEpochsCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for finalizeEpochsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = finalizeEpochsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "finalizeEpochs()";
            const SELECTOR: [u8; 4] = [254u8, 7u8, 187u8, 7u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                finalizeEpochsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `finalizeUserAppchainEpochs(address,uint256)` and selector `0x7e5f5ca7`.
```solidity
function finalizeUserAppchainEpochs(address user, uint256 appchainId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeUserAppchainEpochsCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`finalizeUserAppchainEpochs(address,uint256)`](finalizeUserAppchainEpochsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeUserAppchainEpochsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeUserAppchainEpochsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeUserAppchainEpochsCall) -> Self {
                    (value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeUserAppchainEpochsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        user: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeUserAppchainEpochsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeUserAppchainEpochsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeUserAppchainEpochsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl finalizeUserAppchainEpochsReturn {
            fn _tokenize(
                &self,
            ) -> <finalizeUserAppchainEpochsCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for finalizeUserAppchainEpochsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = finalizeUserAppchainEpochsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "finalizeUserAppchainEpochs(address,uint256)";
            const SELECTOR: [u8; 4] = [126u8, 95u8, 92u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                finalizeUserAppchainEpochsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `finalizeUserEpochs(address)` and selector `0x9deb66c9`.
```solidity
function finalizeUserEpochs(address user) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeUserEpochsCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`finalizeUserEpochs(address)`](finalizeUserEpochsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeUserEpochsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeUserEpochsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeUserEpochsCall) -> Self {
                    (value.user,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeUserEpochsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { user: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeUserEpochsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeUserEpochsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeUserEpochsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl finalizeUserEpochsReturn {
            fn _tokenize(
                &self,
            ) -> <finalizeUserEpochsCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for finalizeUserEpochsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = finalizeUserEpochsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "finalizeUserEpochs(address)";
            const SELECTOR: [u8; 4] = [157u8, 235u8, 102u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                finalizeUserEpochsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `finalizedEpochCount()` and selector `0x1a8a738c`.
```solidity
function finalizedEpochCount() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizedEpochCountCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`finalizedEpochCount()`](finalizedEpochCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizedEpochCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizedEpochCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizedEpochCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizedEpochCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizedEpochCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizedEpochCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizedEpochCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for finalizedEpochCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "finalizedEpochCount()";
            const SELECTOR: [u8; 4] = [26u8, 138u8, 115u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: finalizedEpochCountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: finalizedEpochCountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getAppchainStake(uint256,uint256)` and selector `0xfa457be6`.
```solidity
function getAppchainStake(uint256 epochIndex, uint256 appchainId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAppchainStakeCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getAppchainStake(uint256,uint256)`](getAppchainStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAppchainStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAppchainStakeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAppchainStakeCall) -> Self {
                    (value.epochIndex, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAppchainStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAppchainStakeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAppchainStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAppchainStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAppchainStakeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAppchainStake(uint256,uint256)";
            const SELECTOR: [u8; 4] = [250u8, 69u8, 123u8, 230u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getAppchainStakeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getAppchainStakeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getCurrentEpoch()` and selector `0xb97dd9e2`.
```solidity
function getCurrentEpoch() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getCurrentEpoch()`](getCurrentEpochCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochCall> for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getCurrentEpochCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentEpochReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentEpochCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentEpoch()";
            const SELECTOR: [u8; 4] = [185u8, 125u8, 217u8, 226u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getCurrentEpochReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getCurrentEpochReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getEpochEnd(uint256)` and selector `0xd5176d23`.
```solidity
function getEpochEnd(uint256 epochIndex) external pure returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEpochEndCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getEpochEnd(uint256)`](getEpochEndCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEpochEndReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEpochEndCall> for UnderlyingRustTuple<'_> {
                fn from(value: getEpochEndCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getEpochEndCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEpochEndReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getEpochEndReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getEpochEndReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getEpochEndCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getEpochEnd(uint256)";
            const SELECTOR: [u8; 4] = [213u8, 23u8, 109u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getEpochEndReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getEpochEndReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getEpochStart(uint256)` and selector `0x0175e23b`.
```solidity
function getEpochStart(uint256 epochIndex) external pure returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEpochStartCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getEpochStart(uint256)`](getEpochStartCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEpochStartReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEpochStartCall> for UnderlyingRustTuple<'_> {
                fn from(value: getEpochStartCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getEpochStartCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEpochStartReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getEpochStartReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getEpochStartReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getEpochStartCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getEpochStart(uint256)";
            const SELECTOR: [u8; 4] = [1u8, 117u8, 226u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getEpochStartReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getEpochStartReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getTotalStake(uint256)` and selector `0x45367f23`.
```solidity
function getTotalStake(uint256 epochIndex) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTotalStakeCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getTotalStake(uint256)`](getTotalStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTotalStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTotalStakeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getTotalStakeCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getTotalStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTotalStakeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getTotalStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getTotalStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getTotalStakeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getTotalStake(uint256)";
            const SELECTOR: [u8; 4] = [69u8, 54u8, 127u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getTotalStakeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getTotalStakeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getTotalStakeShare(uint256)` and selector `0x408c32ea`.
```solidity
function getTotalStakeShare(uint256 epochIndex) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTotalStakeShareCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getTotalStakeShare(uint256)`](getTotalStakeShareCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTotalStakeShareReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTotalStakeShareCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getTotalStakeShareCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getTotalStakeShareCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTotalStakeShareReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getTotalStakeShareReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getTotalStakeShareReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getTotalStakeShareCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getTotalStakeShare(uint256)";
            const SELECTOR: [u8; 4] = [64u8, 140u8, 50u8, 234u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getTotalStakeShareReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getTotalStakeShareReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getUserAppchainStake(uint256,address,uint256)` and selector `0xc3ddb3b3`.
```solidity
function getUserAppchainStake(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserAppchainStakeCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getUserAppchainStake(uint256,address,uint256)`](getUserAppchainStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserAppchainStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserAppchainStakeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getUserAppchainStakeCall) -> Self {
                    (value.epochIndex, value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getUserAppchainStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                        appchainId: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserAppchainStakeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getUserAppchainStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getUserAppchainStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getUserAppchainStakeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getUserAppchainStake(uint256,address,uint256)";
            const SELECTOR: [u8; 4] = [195u8, 221u8, 179u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getUserAppchainStakeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getUserAppchainStakeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getUserStake(uint256,address)` and selector `0x9626a230`.
```solidity
function getUserStake(uint256 epochIndex, address user) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserStakeCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getUserStake(uint256,address)`](getUserStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserStakeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getUserStakeCall) -> Self {
                    (value.epochIndex, value.user)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getUserStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserStakeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getUserStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getUserStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getUserStakeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getUserStake(uint256,address)";
            const SELECTOR: [u8; 4] = [150u8, 38u8, 162u8, 48u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getUserStakeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getUserStakeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getUserStakeShare(uint256,address)` and selector `0xf9d663e0`.
```solidity
function getUserStakeShare(uint256 epochIndex, address user) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserStakeShareCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getUserStakeShare(uint256,address)`](getUserStakeShareCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserStakeShareReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserStakeShareCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getUserStakeShareCall) -> Self {
                    (value.epochIndex, value.user)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getUserStakeShareCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserStakeShareReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getUserStakeShareReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getUserStakeShareReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getUserStakeShareCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getUserStakeShare(uint256,address)";
            const SELECTOR: [u8; 4] = [249u8, 214u8, 99u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getUserStakeShareReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getUserStakeShareReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getWithdrawalAmount(address,uint256)` and selector `0x59193f37`.
```solidity
function getWithdrawalAmount(address user, uint256 appchainId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getWithdrawalAmountCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getWithdrawalAmount(address,uint256)`](getWithdrawalAmountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getWithdrawalAmountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getWithdrawalAmountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getWithdrawalAmountCall) -> Self {
                    (value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getWithdrawalAmountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        user: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getWithdrawalAmountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getWithdrawalAmountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getWithdrawalAmountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getWithdrawalAmountCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getWithdrawalAmount(address,uint256)";
            const SELECTOR: [u8; 4] = [89u8, 25u8, 63u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getWithdrawalAmountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getWithdrawalAmountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initializeWithdrawal(uint256)` and selector `0x68a55564`.
```solidity
function initializeWithdrawal(uint256 appchainId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeWithdrawal_0Call {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`initializeWithdrawal(uint256)`](initializeWithdrawal_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeWithdrawal_0Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeWithdrawal_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeWithdrawal_0Call) -> Self {
                    (value.appchainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeWithdrawal_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { appchainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeWithdrawal_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeWithdrawal_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeWithdrawal_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeWithdrawal_0Return {
            fn _tokenize(
                &self,
            ) -> <initializeWithdrawal_0Call as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeWithdrawal_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeWithdrawal_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initializeWithdrawal(uint256)";
            const SELECTOR: [u8; 4] = [104u8, 165u8, 85u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeWithdrawal_0Return::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initializeWithdrawal(uint256,uint256)` and selector `0xed86ba6f`.
```solidity
function initializeWithdrawal(uint256 appchainId, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeWithdrawal_1Call {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`initializeWithdrawal(uint256,uint256)`](initializeWithdrawal_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeWithdrawal_1Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeWithdrawal_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeWithdrawal_1Call) -> Self {
                    (value.appchainId, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeWithdrawal_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        appchainId: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeWithdrawal_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeWithdrawal_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeWithdrawal_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeWithdrawal_1Return {
            fn _tokenize(
                &self,
            ) -> <initializeWithdrawal_1Call as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeWithdrawal_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeWithdrawal_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initializeWithdrawal(uint256,uint256)";
            const SELECTOR: [u8; 4] = [237u8, 134u8, 186u8, 111u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeWithdrawal_1Return::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initializeWithdrawals(uint256[],uint256[])` and selector `0x4197a4b1`.
```solidity
function initializeWithdrawals(uint256[] memory appchainIds, uint256[] memory amounts) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeWithdrawals_0Call {
        #[allow(missing_docs)]
        pub appchainIds: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
        #[allow(missing_docs)]
        pub amounts: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    ///Container type for the return parameters of the [`initializeWithdrawals(uint256[],uint256[])`](initializeWithdrawals_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeWithdrawals_0Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeWithdrawals_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeWithdrawals_0Call) -> Self {
                    (value.appchainIds, value.amounts)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeWithdrawals_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        appchainIds: tuple.0,
                        amounts: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeWithdrawals_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeWithdrawals_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeWithdrawals_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeWithdrawals_0Return {
            fn _tokenize(
                &self,
            ) -> <initializeWithdrawals_0Call as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeWithdrawals_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeWithdrawals_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initializeWithdrawals(uint256[],uint256[])";
            const SELECTOR: [u8; 4] = [65u8, 151u8, 164u8, 177u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainIds),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.amounts),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeWithdrawals_0Return::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initializeWithdrawals(uint256[])` and selector `0xce7d8e5a`.
```solidity
function initializeWithdrawals(uint256[] memory appchainIds) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeWithdrawals_1Call {
        #[allow(missing_docs)]
        pub appchainIds: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    ///Container type for the return parameters of the [`initializeWithdrawals(uint256[])`](initializeWithdrawals_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeWithdrawals_1Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeWithdrawals_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeWithdrawals_1Call) -> Self {
                    (value.appchainIds,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeWithdrawals_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { appchainIds: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeWithdrawals_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeWithdrawals_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeWithdrawals_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeWithdrawals_1Return {
            fn _tokenize(
                &self,
            ) -> <initializeWithdrawals_1Call as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeWithdrawals_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeWithdrawals_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initializeWithdrawals(uint256[])";
            const SELECTOR: [u8; 4] = [206u8, 125u8, 142u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainIds),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeWithdrawals_1Return::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `stageStakeTransfer(uint256,uint256,uint256)` and selector `0xe58e5382`.
```solidity
function stageStakeTransfer(uint256 fromAppchainId, uint256 toAppchainId, uint256 amount) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stageStakeTransferCall {
        #[allow(missing_docs)]
        pub fromAppchainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub toAppchainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`stageStakeTransfer(uint256,uint256,uint256)`](stageStakeTransferCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stageStakeTransferReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stageStakeTransferCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: stageStakeTransferCall) -> Self {
                    (value.fromAppchainId, value.toAppchainId, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for stageStakeTransferCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        fromAppchainId: tuple.0,
                        toAppchainId: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stageStakeTransferReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: stageStakeTransferReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for stageStakeTransferReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl stageStakeTransferReturn {
            fn _tokenize(
                &self,
            ) -> <stageStakeTransferCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stageStakeTransferCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = stageStakeTransferReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stageStakeTransfer(uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [229u8, 142u8, 83u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.fromAppchainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.toAppchainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                stageStakeTransferReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `stakeMultipleAppchains(uint256[],uint256[])` and selector `0x85d81217`.
```solidity
function stakeMultipleAppchains(uint256[] memory appchainIds, uint256[] memory amounts) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stakeMultipleAppchainsCall {
        #[allow(missing_docs)]
        pub appchainIds: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
        #[allow(missing_docs)]
        pub amounts: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    ///Container type for the return parameters of the [`stakeMultipleAppchains(uint256[],uint256[])`](stakeMultipleAppchainsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stakeMultipleAppchainsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeMultipleAppchainsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: stakeMultipleAppchainsCall) -> Self {
                    (value.appchainIds, value.amounts)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for stakeMultipleAppchainsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        appchainIds: tuple.0,
                        amounts: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeMultipleAppchainsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: stakeMultipleAppchainsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for stakeMultipleAppchainsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl stakeMultipleAppchainsReturn {
            fn _tokenize(
                &self,
            ) -> <stakeMultipleAppchainsCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stakeMultipleAppchainsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = stakeMultipleAppchainsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stakeMultipleAppchains(uint256[],uint256[])";
            const SELECTOR: [u8; 4] = [133u8, 216u8, 18u8, 23u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainIds),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.amounts),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                stakeMultipleAppchainsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `stakeSynd(uint256)` and selector `0x0458296f`.
```solidity
function stakeSynd(uint256 appchainId) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stakeSyndCall {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`stakeSynd(uint256)`](stakeSyndCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stakeSyndReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeSyndCall> for UnderlyingRustTuple<'_> {
                fn from(value: stakeSyndCall) -> Self {
                    (value.appchainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stakeSyndCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { appchainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeSyndReturn> for UnderlyingRustTuple<'_> {
                fn from(value: stakeSyndReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stakeSyndReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl stakeSyndReturn {
            fn _tokenize(
                &self,
            ) -> <stakeSyndCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stakeSyndCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = stakeSyndReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stakeSynd(uint256)";
            const SELECTOR: [u8; 4] = [4u8, 88u8, 41u8, 111u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                stakeSyndReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `totalStake()` and selector `0x8b0e9f3f`.
```solidity
function totalStake() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalStakeCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`totalStake()`](totalStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalStakeCall> for UnderlyingRustTuple<'_> {
                fn from(value: totalStakeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalStakeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: totalStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalStakeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalStake()";
            const SELECTOR: [u8; 4] = [139u8, 14u8, 159u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: totalStakeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: totalStakeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `userAppchainFinalizedEpochCount(address,uint256)` and selector `0xf89ee78d`.
```solidity
function userAppchainFinalizedEpochCount(address user, uint256 appchainId) external view returns (uint256 finalizedEpochCount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userAppchainFinalizedEpochCountCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`userAppchainFinalizedEpochCount(address,uint256)`](userAppchainFinalizedEpochCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userAppchainFinalizedEpochCountReturn {
        #[allow(missing_docs)]
        pub finalizedEpochCount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userAppchainFinalizedEpochCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: userAppchainFinalizedEpochCountCall) -> Self {
                    (value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for userAppchainFinalizedEpochCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        user: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userAppchainFinalizedEpochCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: userAppchainFinalizedEpochCountReturn) -> Self {
                    (value.finalizedEpochCount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for userAppchainFinalizedEpochCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        finalizedEpochCount: tuple.0,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for userAppchainFinalizedEpochCountCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "userAppchainFinalizedEpochCount(address,uint256)";
            const SELECTOR: [u8; 4] = [248u8, 158u8, 231u8, 141u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: userAppchainFinalizedEpochCountReturn = r.into();
                        r.finalizedEpochCount
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: userAppchainFinalizedEpochCountReturn = r.into();
                        r.finalizedEpochCount
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `userAppchainTotal(address,uint256)` and selector `0xa09d7a30`.
```solidity
function userAppchainTotal(address user, uint256 appchainId) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userAppchainTotalCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`userAppchainTotal(address,uint256)`](userAppchainTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userAppchainTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userAppchainTotalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: userAppchainTotalCall) -> Self {
                    (value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for userAppchainTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        user: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userAppchainTotalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: userAppchainTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for userAppchainTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for userAppchainTotalCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "userAppchainTotal(address,uint256)";
            const SELECTOR: [u8; 4] = [160u8, 157u8, 122u8, 48u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: userAppchainTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: userAppchainTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `userFinalizedEpochCount(address)` and selector `0x7c5dd5d9`.
```solidity
function userFinalizedEpochCount(address user) external view returns (uint256 finalizedEpochCount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userFinalizedEpochCountCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`userFinalizedEpochCount(address)`](userFinalizedEpochCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userFinalizedEpochCountReturn {
        #[allow(missing_docs)]
        pub finalizedEpochCount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userFinalizedEpochCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: userFinalizedEpochCountCall) -> Self {
                    (value.user,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for userFinalizedEpochCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { user: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userFinalizedEpochCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: userFinalizedEpochCountReturn) -> Self {
                    (value.finalizedEpochCount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for userFinalizedEpochCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        finalizedEpochCount: tuple.0,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for userFinalizedEpochCountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "userFinalizedEpochCount(address)";
            const SELECTOR: [u8; 4] = [124u8, 93u8, 213u8, 217u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: userFinalizedEpochCountReturn = r.into();
                        r.finalizedEpochCount
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: userFinalizedEpochCountReturn = r.into();
                        r.finalizedEpochCount
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `userTotal(address)` and selector `0xe601cf44`.
```solidity
function userTotal(address user) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userTotalCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`userTotal(address)`](userTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userTotalCall> for UnderlyingRustTuple<'_> {
                fn from(value: userTotalCall) -> Self {
                    (value.user,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for userTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { user: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userTotalReturn> for UnderlyingRustTuple<'_> {
                fn from(value: userTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for userTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for userTotalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "userTotal(address)";
            const SELECTOR: [u8; 4] = [230u8, 1u8, 207u8, 68u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: userTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: userTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `withdraw(uint256,address)` and selector `0x00f714ce`.
```solidity
function withdraw(uint256 epochIndex, address destination) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub destination: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`withdraw(uint256,address)`](withdrawCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawCall> for UnderlyingRustTuple<'_> {
                fn from(value: withdrawCall) -> Self {
                    (value.epochIndex, value.destination)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for withdrawCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        destination: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawReturn> for UnderlyingRustTuple<'_> {
                fn from(value: withdrawReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for withdrawReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl withdrawReturn {
            fn _tokenize(
                &self,
            ) -> <withdrawCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for withdrawCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = withdrawReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "withdraw(uint256,address)";
            const SELECTOR: [u8; 4] = [0u8, 247u8, 20u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.destination,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                withdrawReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `withdrawBulk(uint256[],address)` and selector `0x585a627a`.
```solidity
function withdrawBulk(uint256[] memory epochIndices, address destination) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawBulkCall {
        #[allow(missing_docs)]
        pub epochIndices: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
        #[allow(missing_docs)]
        pub destination: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`withdrawBulk(uint256[],address)`](withdrawBulkCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawBulkReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawBulkCall> for UnderlyingRustTuple<'_> {
                fn from(value: withdrawBulkCall) -> Self {
                    (value.epochIndices, value.destination)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for withdrawBulkCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndices: tuple.0,
                        destination: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawBulkReturn> for UnderlyingRustTuple<'_> {
                fn from(value: withdrawBulkReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for withdrawBulkReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl withdrawBulkReturn {
            fn _tokenize(
                &self,
            ) -> <withdrawBulkCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for withdrawBulkCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = withdrawBulkReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "withdrawBulk(uint256[],address)";
            const SELECTOR: [u8; 4] = [88u8, 90u8, 98u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndices),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.destination,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                withdrawBulkReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`SyndStaking`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum SyndStakingCalls {
        #[allow(missing_docs)]
        EPOCH_DURATION(EPOCH_DURATIONCall),
        #[allow(missing_docs)]
        START_TIMESTAMP(START_TIMESTAMPCall),
        #[allow(missing_docs)]
        appchainFinalizedEpochCount(appchainFinalizedEpochCountCall),
        #[allow(missing_docs)]
        appchainTotal(appchainTotalCall),
        #[allow(missing_docs)]
        claimAllRewards(claimAllRewardsCall),
        #[allow(missing_docs)]
        epochAdditions(epochAdditionsCall),
        #[allow(missing_docs)]
        epochAppchainAdditions(epochAppchainAdditionsCall),
        #[allow(missing_docs)]
        epochAppchainTotal(epochAppchainTotalCall),
        #[allow(missing_docs)]
        epochAppchainWithdrawals(epochAppchainWithdrawalsCall),
        #[allow(missing_docs)]
        epochStakeShare(epochStakeShareCall),
        #[allow(missing_docs)]
        epochTotal(epochTotalCall),
        #[allow(missing_docs)]
        epochUserAdditions(epochUserAdditionsCall),
        #[allow(missing_docs)]
        epochUserAppchainAdditions(epochUserAppchainAdditionsCall),
        #[allow(missing_docs)]
        epochUserAppchainTotal(epochUserAppchainTotalCall),
        #[allow(missing_docs)]
        epochUserAppchainWithdrawals(epochUserAppchainWithdrawalsCall),
        #[allow(missing_docs)]
        epochUserStakeShare(epochUserStakeShareCall),
        #[allow(missing_docs)]
        epochUserTotal(epochUserTotalCall),
        #[allow(missing_docs)]
        epochUserWithdrawals(epochUserWithdrawalsCall),
        #[allow(missing_docs)]
        epochWithdrawals(epochWithdrawalsCall),
        #[allow(missing_docs)]
        finalizeAppchainEpochs(finalizeAppchainEpochsCall),
        #[allow(missing_docs)]
        finalizeEpochs(finalizeEpochsCall),
        #[allow(missing_docs)]
        finalizeUserAppchainEpochs(finalizeUserAppchainEpochsCall),
        #[allow(missing_docs)]
        finalizeUserEpochs(finalizeUserEpochsCall),
        #[allow(missing_docs)]
        finalizedEpochCount(finalizedEpochCountCall),
        #[allow(missing_docs)]
        getAppchainStake(getAppchainStakeCall),
        #[allow(missing_docs)]
        getCurrentEpoch(getCurrentEpochCall),
        #[allow(missing_docs)]
        getEpochEnd(getEpochEndCall),
        #[allow(missing_docs)]
        getEpochStart(getEpochStartCall),
        #[allow(missing_docs)]
        getTotalStake(getTotalStakeCall),
        #[allow(missing_docs)]
        getTotalStakeShare(getTotalStakeShareCall),
        #[allow(missing_docs)]
        getUserAppchainStake(getUserAppchainStakeCall),
        #[allow(missing_docs)]
        getUserStake(getUserStakeCall),
        #[allow(missing_docs)]
        getUserStakeShare(getUserStakeShareCall),
        #[allow(missing_docs)]
        getWithdrawalAmount(getWithdrawalAmountCall),
        #[allow(missing_docs)]
        initializeWithdrawal_0(initializeWithdrawal_0Call),
        #[allow(missing_docs)]
        initializeWithdrawal_1(initializeWithdrawal_1Call),
        #[allow(missing_docs)]
        initializeWithdrawals_0(initializeWithdrawals_0Call),
        #[allow(missing_docs)]
        initializeWithdrawals_1(initializeWithdrawals_1Call),
        #[allow(missing_docs)]
        stageStakeTransfer(stageStakeTransferCall),
        #[allow(missing_docs)]
        stakeMultipleAppchains(stakeMultipleAppchainsCall),
        #[allow(missing_docs)]
        stakeSynd(stakeSyndCall),
        #[allow(missing_docs)]
        totalStake(totalStakeCall),
        #[allow(missing_docs)]
        userAppchainFinalizedEpochCount(userAppchainFinalizedEpochCountCall),
        #[allow(missing_docs)]
        userAppchainTotal(userAppchainTotalCall),
        #[allow(missing_docs)]
        userFinalizedEpochCount(userFinalizedEpochCountCall),
        #[allow(missing_docs)]
        userTotal(userTotalCall),
        #[allow(missing_docs)]
        withdraw(withdrawCall),
        #[allow(missing_docs)]
        withdrawBulk(withdrawBulkCall),
    }
    #[automatically_derived]
    impl SyndStakingCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 247u8, 20u8, 206u8],
            [1u8, 117u8, 226u8, 59u8],
            [4u8, 88u8, 41u8, 111u8],
            [5u8, 61u8, 205u8, 37u8],
            [11u8, 40u8, 27u8, 248u8],
            [16u8, 87u8, 233u8, 188u8],
            [18u8, 233u8, 115u8, 188u8],
            [26u8, 138u8, 115u8, 140u8],
            [27u8, 83u8, 59u8, 90u8],
            [30u8, 14u8, 132u8, 137u8],
            [59u8, 160u8, 15u8, 174u8],
            [64u8, 140u8, 50u8, 234u8],
            [65u8, 151u8, 164u8, 177u8],
            [69u8, 54u8, 127u8, 35u8],
            [88u8, 90u8, 98u8, 122u8],
            [89u8, 25u8, 63u8, 55u8],
            [93u8, 61u8, 140u8, 210u8],
            [98u8, 148u8, 84u8, 253u8],
            [104u8, 165u8, 85u8, 100u8],
            [105u8, 61u8, 11u8, 126u8],
            [120u8, 28u8, 217u8, 157u8],
            [123u8, 218u8, 28u8, 251u8],
            [124u8, 93u8, 213u8, 217u8],
            [124u8, 110u8, 170u8, 238u8],
            [126u8, 95u8, 92u8, 167u8],
            [133u8, 216u8, 18u8, 23u8],
            [139u8, 14u8, 159u8, 63u8],
            [140u8, 103u8, 144u8, 62u8],
            [150u8, 38u8, 162u8, 48u8],
            [157u8, 235u8, 102u8, 201u8],
            [160u8, 157u8, 122u8, 48u8],
            [167u8, 11u8, 159u8, 12u8],
            [185u8, 125u8, 217u8, 226u8],
            [195u8, 221u8, 179u8, 179u8],
            [206u8, 125u8, 142u8, 90u8],
            [213u8, 23u8, 109u8, 35u8],
            [229u8, 142u8, 83u8, 130u8],
            [230u8, 1u8, 207u8, 68u8],
            [237u8, 134u8, 186u8, 111u8],
            [238u8, 117u8, 20u8, 232u8],
            [240u8, 48u8, 33u8, 161u8],
            [241u8, 86u8, 224u8, 111u8],
            [248u8, 158u8, 231u8, 141u8],
            [249u8, 101u8, 101u8, 45u8],
            [249u8, 214u8, 99u8, 224u8],
            [250u8, 69u8, 123u8, 230u8],
            [250u8, 115u8, 206u8, 89u8],
            [254u8, 7u8, 187u8, 7u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndStakingCalls {
        const NAME: &'static str = "SyndStakingCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 48usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::EPOCH_DURATION(_) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::START_TIMESTAMP(_) => {
                    <START_TIMESTAMPCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::appchainFinalizedEpochCount(_) => {
                    <appchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::appchainTotal(_) => {
                    <appchainTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAllRewards(_) => {
                    <claimAllRewardsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochAdditions(_) => {
                    <epochAdditionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochAppchainAdditions(_) => {
                    <epochAppchainAdditionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochAppchainTotal(_) => {
                    <epochAppchainTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochAppchainWithdrawals(_) => {
                    <epochAppchainWithdrawalsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochStakeShare(_) => {
                    <epochStakeShareCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochTotal(_) => {
                    <epochTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserAdditions(_) => {
                    <epochUserAdditionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserAppchainAdditions(_) => {
                    <epochUserAppchainAdditionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserAppchainTotal(_) => {
                    <epochUserAppchainTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserAppchainWithdrawals(_) => {
                    <epochUserAppchainWithdrawalsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserStakeShare(_) => {
                    <epochUserStakeShareCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserTotal(_) => {
                    <epochUserTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserWithdrawals(_) => {
                    <epochUserWithdrawalsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochWithdrawals(_) => {
                    <epochWithdrawalsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::finalizeAppchainEpochs(_) => {
                    <finalizeAppchainEpochsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::finalizeEpochs(_) => {
                    <finalizeEpochsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::finalizeUserAppchainEpochs(_) => {
                    <finalizeUserAppchainEpochsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::finalizeUserEpochs(_) => {
                    <finalizeUserEpochsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::finalizedEpochCount(_) => {
                    <finalizedEpochCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAppchainStake(_) => {
                    <getAppchainStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCurrentEpoch(_) => {
                    <getCurrentEpochCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getEpochEnd(_) => {
                    <getEpochEndCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getEpochStart(_) => {
                    <getEpochStartCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getTotalStake(_) => {
                    <getTotalStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getTotalStakeShare(_) => {
                    <getTotalStakeShareCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getUserAppchainStake(_) => {
                    <getUserAppchainStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getUserStake(_) => {
                    <getUserStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getUserStakeShare(_) => {
                    <getUserStakeShareCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getWithdrawalAmount(_) => {
                    <getWithdrawalAmountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initializeWithdrawal_0(_) => {
                    <initializeWithdrawal_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initializeWithdrawal_1(_) => {
                    <initializeWithdrawal_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initializeWithdrawals_0(_) => {
                    <initializeWithdrawals_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initializeWithdrawals_1(_) => {
                    <initializeWithdrawals_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::stageStakeTransfer(_) => {
                    <stageStakeTransferCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::stakeMultipleAppchains(_) => {
                    <stakeMultipleAppchainsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::stakeSynd(_) => {
                    <stakeSyndCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::totalStake(_) => {
                    <totalStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::userAppchainFinalizedEpochCount(_) => {
                    <userAppchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::userAppchainTotal(_) => {
                    <userAppchainTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::userFinalizedEpochCount(_) => {
                    <userFinalizedEpochCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::userTotal(_) => {
                    <userTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::withdraw(_) => <withdrawCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::withdrawBulk(_) => {
                    <withdrawBulkCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SyndStakingCalls>] = &[
                {
                    fn withdraw(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <withdrawCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndStakingCalls::withdraw)
                    }
                    withdraw
                },
                {
                    fn getEpochStart(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getEpochStartCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getEpochStart)
                    }
                    getEpochStart
                },
                {
                    fn stakeSynd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <stakeSyndCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndStakingCalls::stakeSynd)
                    }
                    stakeSynd
                },
                {
                    fn epochUserTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserTotal)
                    }
                    epochUserTotal
                },
                {
                    fn epochAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochAdditions)
                    }
                    epochAdditions
                },
                {
                    fn appchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <appchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::appchainTotal)
                    }
                    appchainTotal
                },
                {
                    fn epochStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochStakeShare)
                    }
                    epochStakeShare
                },
                {
                    fn finalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::finalizedEpochCount)
                    }
                    finalizedEpochCount
                },
                {
                    fn epochUserAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAdditions)
                    }
                    epochUserAdditions
                },
                {
                    fn epochTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochTotal)
                    }
                    epochTotal
                },
                {
                    fn appchainFinalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <appchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::appchainFinalizedEpochCount)
                    }
                    appchainFinalizedEpochCount
                },
                {
                    fn getTotalStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getTotalStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getTotalStakeShare)
                    }
                    getTotalStakeShare
                },
                {
                    fn initializeWithdrawals_0(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <initializeWithdrawals_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::initializeWithdrawals_0)
                    }
                    initializeWithdrawals_0
                },
                {
                    fn getTotalStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getTotalStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getTotalStake)
                    }
                    getTotalStake
                },
                {
                    fn withdrawBulk(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <withdrawBulkCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::withdrawBulk)
                    }
                    withdrawBulk
                },
                {
                    fn getWithdrawalAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getWithdrawalAmountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getWithdrawalAmount)
                    }
                    getWithdrawalAmount
                },
                {
                    fn epochUserWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserWithdrawals)
                    }
                    epochUserWithdrawals
                },
                {
                    fn epochUserAppchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAppchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAppchainTotal)
                    }
                    epochUserAppchainTotal
                },
                {
                    fn initializeWithdrawal_0(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <initializeWithdrawal_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::initializeWithdrawal_0)
                    }
                    initializeWithdrawal_0
                },
                {
                    fn epochUserAppchainAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAppchainAdditions)
                    }
                    epochUserAppchainAdditions
                },
                {
                    fn START_TIMESTAMP(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <START_TIMESTAMPCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::START_TIMESTAMP)
                    }
                    START_TIMESTAMP
                },
                {
                    fn epochAppchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAppchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochAppchainTotal)
                    }
                    epochAppchainTotal
                },
                {
                    fn userFinalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::userFinalizedEpochCount)
                    }
                    userFinalizedEpochCount
                },
                {
                    fn epochAppchainAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochAppchainAdditions)
                    }
                    epochAppchainAdditions
                },
                {
                    fn finalizeUserAppchainEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeUserAppchainEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeUserAppchainEpochs)
                    }
                    finalizeUserAppchainEpochs
                },
                {
                    fn stakeMultipleAppchains(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <stakeMultipleAppchainsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::stakeMultipleAppchains)
                    }
                    stakeMultipleAppchains
                },
                {
                    fn totalStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <totalStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::totalStake)
                    }
                    totalStake
                },
                {
                    fn epochWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochWithdrawals)
                    }
                    epochWithdrawals
                },
                {
                    fn getUserStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getUserStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getUserStake)
                    }
                    getUserStake
                },
                {
                    fn finalizeUserEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeUserEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeUserEpochs)
                    }
                    finalizeUserEpochs
                },
                {
                    fn userAppchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userAppchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::userAppchainTotal)
                    }
                    userAppchainTotal
                },
                {
                    fn EPOCH_DURATION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::EPOCH_DURATION)
                    }
                    EPOCH_DURATION
                },
                {
                    fn getCurrentEpoch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getCurrentEpochCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getCurrentEpoch)
                    }
                    getCurrentEpoch
                },
                {
                    fn getUserAppchainStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getUserAppchainStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getUserAppchainStake)
                    }
                    getUserAppchainStake
                },
                {
                    fn initializeWithdrawals_1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <initializeWithdrawals_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::initializeWithdrawals_1)
                    }
                    initializeWithdrawals_1
                },
                {
                    fn getEpochEnd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getEpochEndCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getEpochEnd)
                    }
                    getEpochEnd
                },
                {
                    fn stageStakeTransfer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <stageStakeTransferCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::stageStakeTransfer)
                    }
                    stageStakeTransfer
                },
                {
                    fn userTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndStakingCalls::userTotal)
                    }
                    userTotal
                },
                {
                    fn initializeWithdrawal_1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <initializeWithdrawal_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::initializeWithdrawal_1)
                    }
                    initializeWithdrawal_1
                },
                {
                    fn epochUserStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserStakeShare)
                    }
                    epochUserStakeShare
                },
                {
                    fn finalizeAppchainEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeAppchainEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeAppchainEpochs)
                    }
                    finalizeAppchainEpochs
                },
                {
                    fn claimAllRewards(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <claimAllRewardsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::claimAllRewards)
                    }
                    claimAllRewards
                },
                {
                    fn userAppchainFinalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userAppchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::userAppchainFinalizedEpochCount)
                    }
                    userAppchainFinalizedEpochCount
                },
                {
                    fn epochAppchainWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochAppchainWithdrawals)
                    }
                    epochAppchainWithdrawals
                },
                {
                    fn getUserStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getUserStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getUserStakeShare)
                    }
                    getUserStakeShare
                },
                {
                    fn getAppchainStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getAppchainStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getAppchainStake)
                    }
                    getAppchainStake
                },
                {
                    fn epochUserAppchainWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAppchainWithdrawals)
                    }
                    epochUserAppchainWithdrawals
                },
                {
                    fn finalizeEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeEpochs)
                    }
                    finalizeEpochs
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SyndStakingCalls>] = &[
                {
                    fn withdraw(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <withdrawCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::withdraw)
                    }
                    withdraw
                },
                {
                    fn getEpochStart(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getEpochStartCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getEpochStart)
                    }
                    getEpochStart
                },
                {
                    fn stakeSynd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <stakeSyndCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::stakeSynd)
                    }
                    stakeSynd
                },
                {
                    fn epochUserTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserTotal)
                    }
                    epochUserTotal
                },
                {
                    fn epochAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochAdditions)
                    }
                    epochAdditions
                },
                {
                    fn appchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <appchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::appchainTotal)
                    }
                    appchainTotal
                },
                {
                    fn epochStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochStakeShare)
                    }
                    epochStakeShare
                },
                {
                    fn finalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::finalizedEpochCount)
                    }
                    finalizedEpochCount
                },
                {
                    fn epochUserAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAdditions)
                    }
                    epochUserAdditions
                },
                {
                    fn epochTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochTotal)
                    }
                    epochTotal
                },
                {
                    fn appchainFinalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <appchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::appchainFinalizedEpochCount)
                    }
                    appchainFinalizedEpochCount
                },
                {
                    fn getTotalStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getTotalStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getTotalStakeShare)
                    }
                    getTotalStakeShare
                },
                {
                    fn initializeWithdrawals_0(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <initializeWithdrawals_0Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::initializeWithdrawals_0)
                    }
                    initializeWithdrawals_0
                },
                {
                    fn getTotalStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getTotalStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getTotalStake)
                    }
                    getTotalStake
                },
                {
                    fn withdrawBulk(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <withdrawBulkCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::withdrawBulk)
                    }
                    withdrawBulk
                },
                {
                    fn getWithdrawalAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getWithdrawalAmountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getWithdrawalAmount)
                    }
                    getWithdrawalAmount
                },
                {
                    fn epochUserWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserWithdrawals)
                    }
                    epochUserWithdrawals
                },
                {
                    fn epochUserAppchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAppchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAppchainTotal)
                    }
                    epochUserAppchainTotal
                },
                {
                    fn initializeWithdrawal_0(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <initializeWithdrawal_0Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::initializeWithdrawal_0)
                    }
                    initializeWithdrawal_0
                },
                {
                    fn epochUserAppchainAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAppchainAdditions)
                    }
                    epochUserAppchainAdditions
                },
                {
                    fn START_TIMESTAMP(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <START_TIMESTAMPCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::START_TIMESTAMP)
                    }
                    START_TIMESTAMP
                },
                {
                    fn epochAppchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAppchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochAppchainTotal)
                    }
                    epochAppchainTotal
                },
                {
                    fn userFinalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::userFinalizedEpochCount)
                    }
                    userFinalizedEpochCount
                },
                {
                    fn epochAppchainAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochAppchainAdditions)
                    }
                    epochAppchainAdditions
                },
                {
                    fn finalizeUserAppchainEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeUserAppchainEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeUserAppchainEpochs)
                    }
                    finalizeUserAppchainEpochs
                },
                {
                    fn stakeMultipleAppchains(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <stakeMultipleAppchainsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::stakeMultipleAppchains)
                    }
                    stakeMultipleAppchains
                },
                {
                    fn totalStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <totalStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::totalStake)
                    }
                    totalStake
                },
                {
                    fn epochWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochWithdrawals)
                    }
                    epochWithdrawals
                },
                {
                    fn getUserStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getUserStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getUserStake)
                    }
                    getUserStake
                },
                {
                    fn finalizeUserEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeUserEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeUserEpochs)
                    }
                    finalizeUserEpochs
                },
                {
                    fn userAppchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userAppchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::userAppchainTotal)
                    }
                    userAppchainTotal
                },
                {
                    fn EPOCH_DURATION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::EPOCH_DURATION)
                    }
                    EPOCH_DURATION
                },
                {
                    fn getCurrentEpoch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getCurrentEpochCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getCurrentEpoch)
                    }
                    getCurrentEpoch
                },
                {
                    fn getUserAppchainStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getUserAppchainStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getUserAppchainStake)
                    }
                    getUserAppchainStake
                },
                {
                    fn initializeWithdrawals_1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <initializeWithdrawals_1Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::initializeWithdrawals_1)
                    }
                    initializeWithdrawals_1
                },
                {
                    fn getEpochEnd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getEpochEndCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getEpochEnd)
                    }
                    getEpochEnd
                },
                {
                    fn stageStakeTransfer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <stageStakeTransferCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::stageStakeTransfer)
                    }
                    stageStakeTransfer
                },
                {
                    fn userTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::userTotal)
                    }
                    userTotal
                },
                {
                    fn initializeWithdrawal_1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <initializeWithdrawal_1Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::initializeWithdrawal_1)
                    }
                    initializeWithdrawal_1
                },
                {
                    fn epochUserStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserStakeShare)
                    }
                    epochUserStakeShare
                },
                {
                    fn finalizeAppchainEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeAppchainEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeAppchainEpochs)
                    }
                    finalizeAppchainEpochs
                },
                {
                    fn claimAllRewards(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <claimAllRewardsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::claimAllRewards)
                    }
                    claimAllRewards
                },
                {
                    fn userAppchainFinalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userAppchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::userAppchainFinalizedEpochCount)
                    }
                    userAppchainFinalizedEpochCount
                },
                {
                    fn epochAppchainWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochAppchainWithdrawals)
                    }
                    epochAppchainWithdrawals
                },
                {
                    fn getUserStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getUserStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getUserStakeShare)
                    }
                    getUserStakeShare
                },
                {
                    fn getAppchainStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getAppchainStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getAppchainStake)
                    }
                    getAppchainStake
                },
                {
                    fn epochUserAppchainWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAppchainWithdrawals)
                    }
                    epochUserAppchainWithdrawals
                },
                {
                    fn finalizeEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeEpochs)
                    }
                    finalizeEpochs
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::EPOCH_DURATION(inner) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::START_TIMESTAMP(inner) => {
                    <START_TIMESTAMPCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::appchainFinalizedEpochCount(inner) => {
                    <appchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::appchainTotal(inner) => {
                    <appchainTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAllRewards(inner) => {
                    <claimAllRewardsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochAdditions(inner) => {
                    <epochAdditionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochAppchainAdditions(inner) => {
                    <epochAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochAppchainTotal(inner) => {
                    <epochAppchainTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochAppchainWithdrawals(inner) => {
                    <epochAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochStakeShare(inner) => {
                    <epochStakeShareCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochTotal(inner) => {
                    <epochTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::epochUserAdditions(inner) => {
                    <epochUserAdditionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochUserAppchainAdditions(inner) => {
                    <epochUserAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochUserAppchainTotal(inner) => {
                    <epochUserAppchainTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochUserAppchainWithdrawals(inner) => {
                    <epochUserAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochUserStakeShare(inner) => {
                    <epochUserStakeShareCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochUserTotal(inner) => {
                    <epochUserTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochUserWithdrawals(inner) => {
                    <epochUserWithdrawalsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochWithdrawals(inner) => {
                    <epochWithdrawalsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::finalizeAppchainEpochs(inner) => {
                    <finalizeAppchainEpochsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::finalizeEpochs(inner) => {
                    <finalizeEpochsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::finalizeUserAppchainEpochs(inner) => {
                    <finalizeUserAppchainEpochsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::finalizeUserEpochs(inner) => {
                    <finalizeUserEpochsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::finalizedEpochCount(inner) => {
                    <finalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAppchainStake(inner) => {
                    <getAppchainStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCurrentEpoch(inner) => {
                    <getCurrentEpochCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getEpochEnd(inner) => {
                    <getEpochEndCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getEpochStart(inner) => {
                    <getEpochStartCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getTotalStake(inner) => {
                    <getTotalStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getTotalStakeShare(inner) => {
                    <getTotalStakeShareCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getUserAppchainStake(inner) => {
                    <getUserAppchainStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getUserStake(inner) => {
                    <getUserStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getUserStakeShare(inner) => {
                    <getUserStakeShareCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getWithdrawalAmount(inner) => {
                    <getWithdrawalAmountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::initializeWithdrawal_0(inner) => {
                    <initializeWithdrawal_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::initializeWithdrawal_1(inner) => {
                    <initializeWithdrawal_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::initializeWithdrawals_0(inner) => {
                    <initializeWithdrawals_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::initializeWithdrawals_1(inner) => {
                    <initializeWithdrawals_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::stageStakeTransfer(inner) => {
                    <stageStakeTransferCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::stakeMultipleAppchains(inner) => {
                    <stakeMultipleAppchainsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::stakeSynd(inner) => {
                    <stakeSyndCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::totalStake(inner) => {
                    <totalStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::userAppchainFinalizedEpochCount(inner) => {
                    <userAppchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::userAppchainTotal(inner) => {
                    <userAppchainTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::userFinalizedEpochCount(inner) => {
                    <userFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::userTotal(inner) => {
                    <userTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::withdraw(inner) => {
                    <withdrawCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::withdrawBulk(inner) => {
                    <withdrawBulkCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::EPOCH_DURATION(inner) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::START_TIMESTAMP(inner) => {
                    <START_TIMESTAMPCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::appchainFinalizedEpochCount(inner) => {
                    <appchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::appchainTotal(inner) => {
                    <appchainTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAllRewards(inner) => {
                    <claimAllRewardsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochAdditions(inner) => {
                    <epochAdditionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochAppchainAdditions(inner) => {
                    <epochAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochAppchainTotal(inner) => {
                    <epochAppchainTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochAppchainWithdrawals(inner) => {
                    <epochAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochStakeShare(inner) => {
                    <epochStakeShareCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochTotal(inner) => {
                    <epochTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserAdditions(inner) => {
                    <epochUserAdditionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserAppchainAdditions(inner) => {
                    <epochUserAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserAppchainTotal(inner) => {
                    <epochUserAppchainTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserAppchainWithdrawals(inner) => {
                    <epochUserAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserStakeShare(inner) => {
                    <epochUserStakeShareCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserTotal(inner) => {
                    <epochUserTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserWithdrawals(inner) => {
                    <epochUserWithdrawalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochWithdrawals(inner) => {
                    <epochWithdrawalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::finalizeAppchainEpochs(inner) => {
                    <finalizeAppchainEpochsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::finalizeEpochs(inner) => {
                    <finalizeEpochsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::finalizeUserAppchainEpochs(inner) => {
                    <finalizeUserAppchainEpochsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::finalizeUserEpochs(inner) => {
                    <finalizeUserEpochsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::finalizedEpochCount(inner) => {
                    <finalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAppchainStake(inner) => {
                    <getAppchainStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCurrentEpoch(inner) => {
                    <getCurrentEpochCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getEpochEnd(inner) => {
                    <getEpochEndCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getEpochStart(inner) => {
                    <getEpochStartCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getTotalStake(inner) => {
                    <getTotalStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getTotalStakeShare(inner) => {
                    <getTotalStakeShareCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getUserAppchainStake(inner) => {
                    <getUserAppchainStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getUserStake(inner) => {
                    <getUserStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getUserStakeShare(inner) => {
                    <getUserStakeShareCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getWithdrawalAmount(inner) => {
                    <getWithdrawalAmountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initializeWithdrawal_0(inner) => {
                    <initializeWithdrawal_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initializeWithdrawal_1(inner) => {
                    <initializeWithdrawal_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initializeWithdrawals_0(inner) => {
                    <initializeWithdrawals_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initializeWithdrawals_1(inner) => {
                    <initializeWithdrawals_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::stageStakeTransfer(inner) => {
                    <stageStakeTransferCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::stakeMultipleAppchains(inner) => {
                    <stakeMultipleAppchainsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::stakeSynd(inner) => {
                    <stakeSyndCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::totalStake(inner) => {
                    <totalStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::userAppchainFinalizedEpochCount(inner) => {
                    <userAppchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::userAppchainTotal(inner) => {
                    <userAppchainTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::userFinalizedEpochCount(inner) => {
                    <userFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::userTotal(inner) => {
                    <userTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::withdraw(inner) => {
                    <withdrawCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::withdrawBulk(inner) => {
                    <withdrawBulkCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`SyndStaking`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum SyndStakingErrors {
        #[allow(missing_docs)]
        FailedCall(FailedCall),
        #[allow(missing_docs)]
        InsufficientBalance(InsufficientBalance),
        #[allow(missing_docs)]
        InsufficientStake(InsufficientStake),
        #[allow(missing_docs)]
        InvalidAmount(InvalidAmount),
        #[allow(missing_docs)]
        InvalidAppchainId(InvalidAppchainId),
        #[allow(missing_docs)]
        InvalidInput(InvalidInput),
        #[allow(missing_docs)]
        InvalidStakingAmount(InvalidStakingAmount),
        #[allow(missing_docs)]
        InvalidWithdrawal(InvalidWithdrawal),
        #[allow(missing_docs)]
        NoClaimsProvided(NoClaimsProvided),
        #[allow(missing_docs)]
        ReentrancyGuardReentrantCall(ReentrancyGuardReentrantCall),
        #[allow(missing_docs)]
        WithdrawalNotReady(WithdrawalNotReady),
        #[allow(missing_docs)]
        ZeroEpochIndex(ZeroEpochIndex),
    }
    #[automatically_derived]
    impl SyndStakingErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [15u8, 44u8, 166u8, 231u8],
            [44u8, 82u8, 17u8, 198u8],
            [62u8, 229u8, 174u8, 181u8],
            [162u8, 221u8, 32u8, 239u8],
            [180u8, 250u8, 63u8, 179u8],
            [187u8, 205u8, 63u8, 51u8],
            [201u8, 69u8, 36u8, 45u8],
            [207u8, 71u8, 145u8, 129u8],
            [214u8, 147u8, 104u8, 212u8],
            [214u8, 189u8, 162u8, 117u8],
            [241u8, 188u8, 148u8, 210u8],
            [246u8, 180u8, 19u8, 28u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndStakingErrors {
        const NAME: &'static str = "SyndStakingErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 12usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::FailedCall(_) => {
                    <FailedCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientBalance(_) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientStake(_) => {
                    <InsufficientStake as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidAmount(_) => {
                    <InvalidAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidAppchainId(_) => {
                    <InvalidAppchainId as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidInput(_) => {
                    <InvalidInput as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidStakingAmount(_) => {
                    <InvalidStakingAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidWithdrawal(_) => {
                    <InvalidWithdrawal as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NoClaimsProvided(_) => {
                    <NoClaimsProvided as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ReentrancyGuardReentrantCall(_) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::WithdrawalNotReady(_) => {
                    <WithdrawalNotReady as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroEpochIndex(_) => {
                    <ZeroEpochIndex as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SyndStakingErrors>] = &[
                {
                    fn WithdrawalNotReady(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <WithdrawalNotReady as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::WithdrawalNotReady)
                    }
                    WithdrawalNotReady
                },
                {
                    fn InvalidAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidAmount)
                    }
                    InvalidAmount
                },
                {
                    fn ReentrancyGuardReentrantCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::ReentrancyGuardReentrantCall)
                    }
                    ReentrancyGuardReentrantCall
                },
                {
                    fn InvalidStakingAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidStakingAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidStakingAmount)
                    }
                    InvalidStakingAmount
                },
                {
                    fn InvalidInput(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidInput as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(SyndStakingErrors::InvalidInput)
                    }
                    InvalidInput
                },
                {
                    fn NoClaimsProvided(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <NoClaimsProvided as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::NoClaimsProvided)
                    }
                    NoClaimsProvided
                },
                {
                    fn InvalidWithdrawal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidWithdrawal as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidWithdrawal)
                    }
                    InvalidWithdrawal
                },
                {
                    fn InsufficientBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::InsufficientBalance)
                    }
                    InsufficientBalance
                },
                {
                    fn ZeroEpochIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <ZeroEpochIndex as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::ZeroEpochIndex)
                    }
                    ZeroEpochIndex
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(SyndStakingErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn InsufficientStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InsufficientStake as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::InsufficientStake)
                    }
                    InsufficientStake
                },
                {
                    fn InvalidAppchainId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidAppchainId as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidAppchainId)
                    }
                    InvalidAppchainId
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SyndStakingErrors>] = &[
                {
                    fn WithdrawalNotReady(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <WithdrawalNotReady as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::WithdrawalNotReady)
                    }
                    WithdrawalNotReady
                },
                {
                    fn InvalidAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidAmount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidAmount)
                    }
                    InvalidAmount
                },
                {
                    fn ReentrancyGuardReentrantCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::ReentrancyGuardReentrantCall)
                    }
                    ReentrancyGuardReentrantCall
                },
                {
                    fn InvalidStakingAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidStakingAmount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidStakingAmount)
                    }
                    InvalidStakingAmount
                },
                {
                    fn InvalidInput(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidInput as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidInput)
                    }
                    InvalidInput
                },
                {
                    fn NoClaimsProvided(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <NoClaimsProvided as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::NoClaimsProvided)
                    }
                    NoClaimsProvided
                },
                {
                    fn InvalidWithdrawal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidWithdrawal as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidWithdrawal)
                    }
                    InvalidWithdrawal
                },
                {
                    fn InsufficientBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::InsufficientBalance)
                    }
                    InsufficientBalance
                },
                {
                    fn ZeroEpochIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <ZeroEpochIndex as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::ZeroEpochIndex)
                    }
                    ZeroEpochIndex
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn InsufficientStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InsufficientStake as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::InsufficientStake)
                    }
                    InsufficientStake
                },
                {
                    fn InvalidAppchainId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidAppchainId as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidAppchainId)
                    }
                    InvalidAppchainId
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InsufficientBalance(inner) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientStake(inner) => {
                    <InsufficientStake as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidAmount(inner) => {
                    <InvalidAmount as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidAppchainId(inner) => {
                    <InvalidAppchainId as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidInput(inner) => {
                    <InvalidInput as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidStakingAmount(inner) => {
                    <InvalidStakingAmount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidWithdrawal(inner) => {
                    <InvalidWithdrawal as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NoClaimsProvided(inner) => {
                    <NoClaimsProvided as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::WithdrawalNotReady(inner) => {
                    <WithdrawalNotReady as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroEpochIndex(inner) => {
                    <ZeroEpochIndex as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::InsufficientBalance(inner) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientStake(inner) => {
                    <InsufficientStake as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidAmount(inner) => {
                    <InvalidAmount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidAppchainId(inner) => {
                    <InvalidAppchainId as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidInput(inner) => {
                    <InvalidInput as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidStakingAmount(inner) => {
                    <InvalidStakingAmount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidWithdrawal(inner) => {
                    <InvalidWithdrawal as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NoClaimsProvided(inner) => {
                    <NoClaimsProvided as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::WithdrawalNotReady(inner) => {
                    <WithdrawalNotReady as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroEpochIndex(inner) => {
                    <ZeroEpochIndex as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`SyndStaking`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum SyndStakingEvents {
        #[allow(missing_docs)]
        Stake(Stake),
        #[allow(missing_docs)]
        StakeTransfer(StakeTransfer),
        #[allow(missing_docs)]
        WithdrawalCompleted(WithdrawalCompleted),
        #[allow(missing_docs)]
        WithdrawalInitialized(WithdrawalInitialized),
    }
    #[automatically_derived]
    impl SyndStakingEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                80u8, 122u8, 195u8, 158u8, 179u8, 54u8, 16u8, 25u8, 28u8, 216u8, 253u8,
                84u8, 40u8, 110u8, 145u8, 197u8, 204u8, 70u8, 76u8, 38u8, 40u8, 97u8,
                100u8, 59u8, 227u8, 151u8, 143u8, 90u8, 159u8, 24u8, 171u8, 2u8,
            ],
            [
                139u8, 212u8, 114u8, 142u8, 233u8, 202u8, 63u8, 153u8, 221u8, 207u8,
                250u8, 36u8, 235u8, 79u8, 21u8, 222u8, 1u8, 92u8, 218u8, 154u8, 39u8,
                204u8, 196u8, 39u8, 223u8, 218u8, 247u8, 17u8, 148u8, 62u8, 188u8, 160u8,
            ],
            [
                176u8, 3u8, 130u8, 32u8, 59u8, 70u8, 195u8, 182u8, 173u8, 10u8, 45u8,
                122u8, 240u8, 38u8, 142u8, 51u8, 75u8, 217u8, 64u8, 98u8, 86u8, 167u8,
                199u8, 186u8, 143u8, 127u8, 200u8, 188u8, 71u8, 248u8, 205u8, 233u8,
            ],
            [
                179u8, 18u8, 144u8, 60u8, 226u8, 7u8, 210u8, 30u8, 132u8, 229u8, 125u8,
                16u8, 5u8, 224u8, 170u8, 83u8, 133u8, 183u8, 131u8, 235u8, 39u8, 226u8,
                88u8, 129u8, 113u8, 116u8, 208u8, 12u8, 251u8, 188u8, 50u8, 120u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for SyndStakingEvents {
        const NAME: &'static str = "SyndStakingEvents";
        const COUNT: usize = 4usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Stake as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Stake as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Stake)
                }
                Some(<StakeTransfer as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <StakeTransfer as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::StakeTransfer)
                }
                Some(
                    <WithdrawalCompleted as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <WithdrawalCompleted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::WithdrawalCompleted)
                }
                Some(
                    <WithdrawalInitialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <WithdrawalInitialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::WithdrawalInitialized)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for SyndStakingEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Stake(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::StakeTransfer(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::WithdrawalCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::WithdrawalInitialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Stake(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::StakeTransfer(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::WithdrawalCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::WithdrawalInitialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`SyndStaking`](self) contract instance.

See the [wrapper's documentation](`SyndStakingInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> SyndStakingInstance<P, N> {
        SyndStakingInstance::<P, N>::new(address, __provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<SyndStakingInstance<P, N>>,
    > {
        SyndStakingInstance::<P, N>::deploy(__provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(__provider: P) -> alloy_contract::RawCallBuilder<P, N> {
        SyndStakingInstance::<P, N>::deploy_builder(__provider)
    }
    /**A [`SyndStaking`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`SyndStaking`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct SyndStakingInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for SyndStakingInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("SyndStakingInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SyndStakingInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`SyndStaking`](self) contract instance.

See the [wrapper's documentation](`SyndStakingInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            __provider: P,
        ) -> alloy_contract::Result<SyndStakingInstance<P, N>> {
            let call_builder = Self::deploy_builder(__provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(__provider: P) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                __provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> SyndStakingInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> SyndStakingInstance<P, N> {
            SyndStakingInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SyndStakingInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`EPOCH_DURATION`] function.
        pub fn EPOCH_DURATION(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, EPOCH_DURATIONCall, N> {
            self.call_builder(&EPOCH_DURATIONCall)
        }
        ///Creates a new call builder for the [`START_TIMESTAMP`] function.
        pub fn START_TIMESTAMP(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, START_TIMESTAMPCall, N> {
            self.call_builder(&START_TIMESTAMPCall)
        }
        ///Creates a new call builder for the [`appchainFinalizedEpochCount`] function.
        pub fn appchainFinalizedEpochCount(
            &self,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, appchainFinalizedEpochCountCall, N> {
            self.call_builder(
                &appchainFinalizedEpochCountCall {
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`appchainTotal`] function.
        pub fn appchainTotal(
            &self,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, appchainTotalCall, N> {
            self.call_builder(&appchainTotalCall { appchainId })
        }
        ///Creates a new call builder for the [`claimAllRewards`] function.
        pub fn claimAllRewards(
            &self,
            claims: alloy::sol_types::private::Vec<
                <ClaimRequest as alloy::sol_types::SolType>::RustType,
            >,
            destination: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, claimAllRewardsCall, N> {
            self.call_builder(
                &claimAllRewardsCall {
                    claims,
                    destination,
                },
            )
        }
        ///Creates a new call builder for the [`epochAdditions`] function.
        pub fn epochAdditions(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochAdditionsCall, N> {
            self.call_builder(&epochAdditionsCall { epochIndex })
        }
        ///Creates a new call builder for the [`epochAppchainAdditions`] function.
        pub fn epochAppchainAdditions(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochAppchainAdditionsCall, N> {
            self.call_builder(
                &epochAppchainAdditionsCall {
                    epochIndex,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochAppchainTotal`] function.
        pub fn epochAppchainTotal(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochAppchainTotalCall, N> {
            self.call_builder(
                &epochAppchainTotalCall {
                    epochIndex,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochAppchainWithdrawals`] function.
        pub fn epochAppchainWithdrawals(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochAppchainWithdrawalsCall, N> {
            self.call_builder(
                &epochAppchainWithdrawalsCall {
                    epochIndex,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochStakeShare`] function.
        pub fn epochStakeShare(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochStakeShareCall, N> {
            self.call_builder(&epochStakeShareCall { epochIndex })
        }
        ///Creates a new call builder for the [`epochTotal`] function.
        pub fn epochTotal(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochTotalCall, N> {
            self.call_builder(&epochTotalCall { epochIndex })
        }
        ///Creates a new call builder for the [`epochUserAdditions`] function.
        pub fn epochUserAdditions(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserAdditionsCall, N> {
            self.call_builder(
                &epochUserAdditionsCall {
                    epochIndex,
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`epochUserAppchainAdditions`] function.
        pub fn epochUserAppchainAdditions(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserAppchainAdditionsCall, N> {
            self.call_builder(
                &epochUserAppchainAdditionsCall {
                    epochIndex,
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochUserAppchainTotal`] function.
        pub fn epochUserAppchainTotal(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserAppchainTotalCall, N> {
            self.call_builder(
                &epochUserAppchainTotalCall {
                    epochIndex,
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochUserAppchainWithdrawals`] function.
        pub fn epochUserAppchainWithdrawals(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserAppchainWithdrawalsCall, N> {
            self.call_builder(
                &epochUserAppchainWithdrawalsCall {
                    epochIndex,
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochUserStakeShare`] function.
        pub fn epochUserStakeShare(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserStakeShareCall, N> {
            self.call_builder(
                &epochUserStakeShareCall {
                    epochIndex,
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`epochUserTotal`] function.
        pub fn epochUserTotal(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserTotalCall, N> {
            self.call_builder(
                &epochUserTotalCall {
                    epochIndex,
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`epochUserWithdrawals`] function.
        pub fn epochUserWithdrawals(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserWithdrawalsCall, N> {
            self.call_builder(
                &epochUserWithdrawalsCall {
                    epochIndex,
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`epochWithdrawals`] function.
        pub fn epochWithdrawals(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochWithdrawalsCall, N> {
            self.call_builder(&epochWithdrawalsCall { epochIndex })
        }
        ///Creates a new call builder for the [`finalizeAppchainEpochs`] function.
        pub fn finalizeAppchainEpochs(
            &self,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, finalizeAppchainEpochsCall, N> {
            self.call_builder(
                &finalizeAppchainEpochsCall {
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`finalizeEpochs`] function.
        pub fn finalizeEpochs(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, finalizeEpochsCall, N> {
            self.call_builder(&finalizeEpochsCall)
        }
        ///Creates a new call builder for the [`finalizeUserAppchainEpochs`] function.
        pub fn finalizeUserAppchainEpochs(
            &self,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, finalizeUserAppchainEpochsCall, N> {
            self.call_builder(
                &finalizeUserAppchainEpochsCall {
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`finalizeUserEpochs`] function.
        pub fn finalizeUserEpochs(
            &self,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, finalizeUserEpochsCall, N> {
            self.call_builder(&finalizeUserEpochsCall { user })
        }
        ///Creates a new call builder for the [`finalizedEpochCount`] function.
        pub fn finalizedEpochCount(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, finalizedEpochCountCall, N> {
            self.call_builder(&finalizedEpochCountCall)
        }
        ///Creates a new call builder for the [`getAppchainStake`] function.
        pub fn getAppchainStake(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getAppchainStakeCall, N> {
            self.call_builder(
                &getAppchainStakeCall {
                    epochIndex,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`getCurrentEpoch`] function.
        pub fn getCurrentEpoch(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getCurrentEpochCall, N> {
            self.call_builder(&getCurrentEpochCall)
        }
        ///Creates a new call builder for the [`getEpochEnd`] function.
        pub fn getEpochEnd(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getEpochEndCall, N> {
            self.call_builder(&getEpochEndCall { epochIndex })
        }
        ///Creates a new call builder for the [`getEpochStart`] function.
        pub fn getEpochStart(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getEpochStartCall, N> {
            self.call_builder(&getEpochStartCall { epochIndex })
        }
        ///Creates a new call builder for the [`getTotalStake`] function.
        pub fn getTotalStake(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getTotalStakeCall, N> {
            self.call_builder(&getTotalStakeCall { epochIndex })
        }
        ///Creates a new call builder for the [`getTotalStakeShare`] function.
        pub fn getTotalStakeShare(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getTotalStakeShareCall, N> {
            self.call_builder(
                &getTotalStakeShareCall {
                    epochIndex,
                },
            )
        }
        ///Creates a new call builder for the [`getUserAppchainStake`] function.
        pub fn getUserAppchainStake(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getUserAppchainStakeCall, N> {
            self.call_builder(
                &getUserAppchainStakeCall {
                    epochIndex,
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`getUserStake`] function.
        pub fn getUserStake(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getUserStakeCall, N> {
            self.call_builder(
                &getUserStakeCall {
                    epochIndex,
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`getUserStakeShare`] function.
        pub fn getUserStakeShare(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getUserStakeShareCall, N> {
            self.call_builder(
                &getUserStakeShareCall {
                    epochIndex,
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`getWithdrawalAmount`] function.
        pub fn getWithdrawalAmount(
            &self,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getWithdrawalAmountCall, N> {
            self.call_builder(
                &getWithdrawalAmountCall {
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`initializeWithdrawal_0`] function.
        pub fn initializeWithdrawal_0(
            &self,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, initializeWithdrawal_0Call, N> {
            self.call_builder(
                &initializeWithdrawal_0Call {
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`initializeWithdrawal_1`] function.
        pub fn initializeWithdrawal_1(
            &self,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, initializeWithdrawal_1Call, N> {
            self.call_builder(
                &initializeWithdrawal_1Call {
                    appchainId,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`initializeWithdrawals_0`] function.
        pub fn initializeWithdrawals_0(
            &self,
            appchainIds: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            amounts: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, initializeWithdrawals_0Call, N> {
            self.call_builder(
                &initializeWithdrawals_0Call {
                    appchainIds,
                    amounts,
                },
            )
        }
        ///Creates a new call builder for the [`initializeWithdrawals_1`] function.
        pub fn initializeWithdrawals_1(
            &self,
            appchainIds: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, initializeWithdrawals_1Call, N> {
            self.call_builder(
                &initializeWithdrawals_1Call {
                    appchainIds,
                },
            )
        }
        ///Creates a new call builder for the [`stageStakeTransfer`] function.
        pub fn stageStakeTransfer(
            &self,
            fromAppchainId: alloy::sol_types::private::primitives::aliases::U256,
            toAppchainId: alloy::sol_types::private::primitives::aliases::U256,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, stageStakeTransferCall, N> {
            self.call_builder(
                &stageStakeTransferCall {
                    fromAppchainId,
                    toAppchainId,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`stakeMultipleAppchains`] function.
        pub fn stakeMultipleAppchains(
            &self,
            appchainIds: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            amounts: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, stakeMultipleAppchainsCall, N> {
            self.call_builder(
                &stakeMultipleAppchainsCall {
                    appchainIds,
                    amounts,
                },
            )
        }
        ///Creates a new call builder for the [`stakeSynd`] function.
        pub fn stakeSynd(
            &self,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, stakeSyndCall, N> {
            self.call_builder(&stakeSyndCall { appchainId })
        }
        ///Creates a new call builder for the [`totalStake`] function.
        pub fn totalStake(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, totalStakeCall, N> {
            self.call_builder(&totalStakeCall)
        }
        ///Creates a new call builder for the [`userAppchainFinalizedEpochCount`] function.
        pub fn userAppchainFinalizedEpochCount(
            &self,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, userAppchainFinalizedEpochCountCall, N> {
            self.call_builder(
                &userAppchainFinalizedEpochCountCall {
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`userAppchainTotal`] function.
        pub fn userAppchainTotal(
            &self,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, userAppchainTotalCall, N> {
            self.call_builder(
                &userAppchainTotalCall {
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`userFinalizedEpochCount`] function.
        pub fn userFinalizedEpochCount(
            &self,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, userFinalizedEpochCountCall, N> {
            self.call_builder(
                &userFinalizedEpochCountCall {
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`userTotal`] function.
        pub fn userTotal(
            &self,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, userTotalCall, N> {
            self.call_builder(&userTotalCall { user })
        }
        ///Creates a new call builder for the [`withdraw`] function.
        pub fn withdraw(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            destination: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, withdrawCall, N> {
            self.call_builder(
                &withdrawCall {
                    epochIndex,
                    destination,
                },
            )
        }
        ///Creates a new call builder for the [`withdrawBulk`] function.
        pub fn withdrawBulk(
            &self,
            epochIndices: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            destination: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, withdrawBulkCall, N> {
            self.call_builder(
                &withdrawBulkCall {
                    epochIndices,
                    destination,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SyndStakingInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Stake`] event.
        pub fn Stake_filter(&self) -> alloy_contract::Event<&P, Stake, N> {
            self.event_filter::<Stake>()
        }
        ///Creates a new event filter for the [`StakeTransfer`] event.
        pub fn StakeTransfer_filter(
            &self,
        ) -> alloy_contract::Event<&P, StakeTransfer, N> {
            self.event_filter::<StakeTransfer>()
        }
        ///Creates a new event filter for the [`WithdrawalCompleted`] event.
        pub fn WithdrawalCompleted_filter(
            &self,
        ) -> alloy_contract::Event<&P, WithdrawalCompleted, N> {
            self.event_filter::<WithdrawalCompleted>()
        }
        ///Creates a new event filter for the [`WithdrawalInitialized`] event.
        pub fn WithdrawalInitialized_filter(
            &self,
        ) -> alloy_contract::Event<&P, WithdrawalInitialized, N> {
            self.event_filter::<WithdrawalInitialized>()
        }
    }
}
