/**

Generated by the following Solidity interface...
```solidity
interface SyndStaking {
    struct ClaimRequest {
        uint256 epochIndex;
        address poolAddress;
    }

    error EnforcedPause();
    error ExpectedPause();
    error FailedCall();
    error InsufficientBalance(uint256 balance, uint256 needed);
    error InsufficientStake();
    error InvalidAmount();
    error InvalidAppchainId();
    error InvalidInput();
    error InvalidStakingAmount(uint256 totalAmount, uint256 sentAmount);
    error InvalidWithdrawal();
    error NoClaimsProvided();
    error OwnableInvalidOwner(address owner);
    error OwnableUnauthorizedAccount(address account);
    error ReentrancyGuardReentrantCall();
    error WithdrawalNotReady();
    error ZeroEpochIndex();

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event Paused(address account);
    event Stake(uint256 epochIndex, address user, uint256 amount, uint256 appchainId);
    event StakeTransfer(uint256 epochIndex, address user, uint256 amount, uint256 fromAppchainId, uint256 toAppchainId);
    event Unpaused(address account);
    event WithdrawalCompleted(address user, address destination, uint256 amount);
    event WithdrawalInitialized(address user, uint256 appchainId, uint256 amount);

    constructor(address _defaultAdmin);

    function EPOCH_DURATION() external view returns (uint256);
    function START_TIMESTAMP() external view returns (uint256);
    function appchainFinalizedEpochCount(uint256 appchainId) external view returns (uint256 finalizedEpochCount);
    function appchainTotal(uint256 appchainId) external view returns (uint256 total);
    function claimAllRewards(ClaimRequest[] memory claims, address destination) external;
    function epochAdditions(uint256 epochIndex) external view returns (uint256 additions);
    function epochAppchainAdditions(uint256 epochIndex, uint256 appchainId) external view returns (uint256 additions);
    function epochAppchainTotal(uint256 epochIndex, uint256 appchainId) external view returns (uint256 total);
    function epochAppchainWithdrawals(uint256 epochIndex, uint256 appchainId) external view returns (uint256 withdrawals);
    function epochStakeShare(uint256 epochIndex) external view returns (uint256 stakeShare);
    function epochTotal(uint256 epochIndex) external view returns (uint256 total);
    function epochUserAdditions(uint256 epochIndex, address user) external view returns (uint256 additions);
    function epochUserAppchainAdditions(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256 additions);
    function epochUserAppchainTotal(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256 total);
    function epochUserAppchainWithdrawals(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256 withdrawals);
    function epochUserStakeShare(uint256 epochIndex, address user) external view returns (uint256 stakeShare);
    function epochUserTotal(uint256 epochIndex, address user) external view returns (uint256 total);
    function epochUserWithdrawals(uint256 epochIndex, address user) external view returns (uint256 withdrawals);
    function epochWithdrawals(uint256 epochIndex) external view returns (uint256 withdrawals);
    function finalizeAppchainEpochs(uint256 appchainId) external;
    function finalizeEpochs() external;
    function finalizeUserAppchainEpochs(address user, uint256 appchainId) external;
    function finalizeUserEpochs(address user) external;
    function finalizedEpochCount() external view returns (uint256);
    function getAppchainStake(uint256 epochIndex, uint256 appchainId) external view returns (uint256);
    function getCurrentEpoch() external view returns (uint256);
    function getEpochEnd(uint256 epochIndex) external pure returns (uint256);
    function getEpochStart(uint256 epochIndex) external pure returns (uint256);
    function getTotalStake(uint256 epochIndex) external view returns (uint256);
    function getTotalStakeShare(uint256 epochIndex) external view returns (uint256);
    function getUserAppchainStake(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256);
    function getUserStake(uint256 epochIndex, address user) external view returns (uint256);
    function getUserStakeShare(uint256 epochIndex, address user) external view returns (uint256);
    function getWithdrawalAmount(address user, uint256 appchainId) external view returns (uint256);
    function initializeWithdrawal(uint256 appchainId) external;
    function initializeWithdrawal(uint256 appchainId, uint256 amount) external;
    function initializeWithdrawals(uint256[] memory appchainIds, uint256[] memory amounts) external;
    function initializeWithdrawals(uint256[] memory appchainIds) external;
    function owner() external view returns (address);
    function pause() external;
    function paused() external view returns (bool);
    function renounceOwnership() external;
    function stageStakeTransfer(uint256 fromAppchainId, uint256 toAppchainId, uint256 amount) external payable;
    function stakeMultipleAppchains(uint256[] memory appchainIds, uint256[] memory amounts) external payable;
    function stakeSynd(uint256 appchainId) external payable;
    function totalStake() external view returns (uint256);
    function transferOwnership(address newOwner) external;
    function unpause() external;
    function userAppchainFinalizedEpochCount(address user, uint256 appchainId) external view returns (uint256 finalizedEpochCount);
    function userAppchainTotal(address user, uint256 appchainId) external view returns (uint256 total);
    function userFinalizedEpochCount(address user) external view returns (uint256 finalizedEpochCount);
    function userTotal(address user) external view returns (uint256 total);
    function withdraw(uint256 epochIndex, address destination) external;
    function withdrawBulk(uint256[] memory epochIndices, address destination) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_defaultAdmin",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "EPOCH_DURATION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "START_TIMESTAMP",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "appchainFinalizedEpochCount",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "finalizedEpochCount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "appchainTotal",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "claimAllRewards",
    "inputs": [
      {
        "name": "claims",
        "type": "tuple[]",
        "internalType": "struct SyndStaking.ClaimRequest[]",
        "components": [
          {
            "name": "epochIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "poolAddress",
            "type": "address",
            "internalType": "address"
          }
        ]
      },
      {
        "name": "destination",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "epochAdditions",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "additions",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochAppchainAdditions",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "additions",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochAppchainTotal",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochAppchainWithdrawals",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "withdrawals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochStakeShare",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "stakeShare",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochTotal",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserAdditions",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "additions",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserAppchainAdditions",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "additions",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserAppchainTotal",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserAppchainWithdrawals",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "withdrawals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserStakeShare",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "stakeShare",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserTotal",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserWithdrawals",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "withdrawals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochWithdrawals",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "withdrawals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "finalizeAppchainEpochs",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "finalizeEpochs",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "finalizeUserAppchainEpochs",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "finalizeUserEpochs",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "finalizedEpochCount",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAppchainStake",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCurrentEpoch",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getEpochEnd",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "getEpochStart",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "getTotalStake",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getTotalStakeShare",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getUserAppchainStake",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getUserStake",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getUserStakeShare",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getWithdrawalAmount",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initializeWithdrawal",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "initializeWithdrawal",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "initializeWithdrawals",
    "inputs": [
      {
        "name": "appchainIds",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "amounts",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "initializeWithdrawals",
    "inputs": [
      {
        "name": "appchainIds",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "paused",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "stageStakeTransfer",
    "inputs": [
      {
        "name": "fromAppchainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "toAppchainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "stakeMultipleAppchains",
    "inputs": [
      {
        "name": "appchainIds",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "amounts",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "stakeSynd",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "totalStake",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "unpause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "userAppchainFinalizedEpochCount",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "finalizedEpochCount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "userAppchainTotal",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "userFinalizedEpochCount",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "finalizedEpochCount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "userTotal",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "withdraw",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "destination",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "withdrawBulk",
    "inputs": [
      {
        "name": "epochIndices",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "destination",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Paused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Stake",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "StakeTransfer",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "fromAppchainId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "toAppchainId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Unpaused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "WithdrawalCompleted",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "destination",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "WithdrawalInitialized",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "EnforcedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExpectedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientBalance",
    "inputs": [
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientStake",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidAmount",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidAppchainId",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidInput",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidStakingAmount",
    "inputs": [
      {
        "name": "totalAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "sentAmount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidWithdrawal",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NoClaimsProvided",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OwnableInvalidOwner",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OwnableUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ReentrancyGuardReentrantCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "WithdrawalNotReady",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroEpochIndex",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod SyndStaking {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60803460c957601f61263338819003918201601f19168301916001600160401b0383118484101760cd5780849260209460405283398101031260c957516001600160a01b03811680820360c95760015f5560015491811560b6576001600160a81b03198316600891821b610100600160a81b03161760015560405192901c6001600160a01b03167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a361255190816100e28239f35b631e4fbdf760e01b5f525f60045260245ffd5b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60806040526004361015610011575f80fd5b5f3560e01c8062f714ce1461151c5780630175e23b146114505780630458296f14611430578063053dcd25146113de5780630b281bf8146113b45780631057e9bc1461138a57806312e973bc146113605780631a8a738c146113435780631b533b5a146112f15780631e0e8489146112c75780633ba00fae1461129d5780633f4ba83a14611200578063408c32ea146111cc5780634197a4b11461117557806345367f2314611157578063585a627a14610fdc57806359193f3714610ad05780635c975abb14610fba5780635d3d8cd214610f68578063629454fd14610f1957806368a5556414610ee5578063693d0b7e14610e96578063715018a614610e15578063781cd99d14610df75780637bda1cfb14610dc85780637c5dd5d914610d835780637c6eaaee14610d545780637e5f5ca714610d2f5780638456cb5914610cb957806385d8121714610be55780638b0e9f3f14610bc85780638c67903e14610b9e5780638da5cb5b14610b685780639626a23014610b425780639deb66c914610b21578063a09d7a3014610ad0578063a70b9f0c14610ab3578063b97dd9e214610a99578063c3ddb3b314610a80578063ce7d8e5a146109f7578063d5176d23146109d9578063e58e5382146106ff578063e601cf44146106ba578063ed86ba6f146106a3578063ee7514e814610651578063f03021a114610635578063f156e06f146104c4578063f2fde38b146103d4578063f89ee78d14610383578063f965652d14610354578063f9d663e0146102f8578063fa457be6146102d7578063fa73ce59146102885763fe07bb071461026a575f80fd5b34610284575f60031936011261028457610282612094565b005b5f80fd5b3461028457610296366116f9565b915f52601460205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f20905f52602052602060405f2054604051908152f35b346102845760206102f06102ea36611730565b90611ff9565b604051908152f35b346102845760406003193601126102845760206102f0600435610319611630565b6103238183611974565b915f526017845273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52835260405f205490611753565b346102845761036236611730565b905f52600f60205260405f20905f52602052602060405f2054604051908152f35b346102845760406003193601126102845773ffffffffffffffffffffffffffffffffffffffff6103b1611653565b165f52601560205260405f206024355f52602052602060405f2054604051908152f35b34610284576020600319360112610284576103ed611653565b6103f5612501565b73ffffffffffffffffffffffffffffffffffffffff81169081156104985773ffffffffffffffffffffffffffffffffffffffff9074ffffffffffffffffffffffffffffffffffffffff006001549160081b167fffffffffffffffffffffff0000000000000000000000000000000000000000ff82161760015560081c167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3005b7f1e4fbdf7000000000000000000000000000000000000000000000000000000005f525f60045260245ffd5b346102845760406003193601126102845760043567ffffffffffffffff8111610284573660238201121561028457806004013567ffffffffffffffff8111610284576024820191602436918360061b01011161028457610522611630565b9061052b61212f565b801561060d579073ffffffffffffffffffffffffffffffffffffffff165f5b8281106105575760015f55005b6020610564828587611f7b565b01359073ffffffffffffffffffffffffffffffffffffffff821680920361028457610590818587611f7b565b35823b15610284575f926064849260405195869384927f69bc274700000000000000000000000000000000000000000000000000000000845260048401523360248401528860448401525af1918215610602576001926105f2575b500161054a565b5f6105fc91611f8b565b856105eb565b6040513d5f823e3d90fd5b7fbbcd3f33000000000000000000000000000000000000000000000000000000005f5260045ffd5b3461028457602060031936011261028457610282600435611ea0565b346102845760406003193601126102845761066a611630565b6004355f52601760205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b34610284576102826106b436611730565b90611c76565b346102845760206003193601126102845773ffffffffffffffffffffffffffffffffffffffff6106e8611653565b165f526007602052602060405f2054604051908152f35b60606003193601126102845760243560043560443561071c61212f565b610724612259565b80156109b157811580156109a9575b61098157335f52601160205260405f20825f526020528060405f205410610959577fb312903ce207d21e84e57d1005e0aa5385b783eb27e258817174d00cfbbc32789260a092610781611b1a565b92335f52600b6020528360405f20541061094b575b815f5260106020528360405f20541061093d575b335f52601560205260405f20825f526020528360405f20541061092e575b835f52601260205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20825f5260205260405f20610809828254611753565b9055835f52600d60205260405f20825f5260205260405f2061082c828254611753565b9055335f52601160205260405f20825f5260205260405f2061084f828254611746565b9055815f52600c60205260405f20610868828254611746565b9055835f52601360205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20835f5260205260405f206108ab828254611753565b9055835f52600e60205260405f20835f5260205260405f206108ce828254611753565b9055335f52601160205260405f20835f5260205260405f206108f1828254611753565b9055825f52600c60205260405f2061090a828254611753565b9055604051938452336020850152604084015260608301526080820152a160015f55005b610938823361182b565b6107c8565b61094682611ea0565b6107aa565b61095433611a29565b610796565b7ff1bc94d2000000000000000000000000000000000000000000000000000000005f5260045ffd5b7ff6b4131c000000000000000000000000000000000000000000000000000000005f5260045ffd5b508215610733565b7f2c5211c6000000000000000000000000000000000000000000000000000000005f5260045ffd5b346102845760206003193601126102845760206102f0600435611c4a565b346102845760206003193601126102845760043567ffffffffffffffff811161028457610a28903690600401611676565b610a3061212f565b5f5b818110610a3f5760015f55005b80610a7a610a506001938587611760565b35610a5c838688611760565b35335f52601160205260405f20905f5260205260405f205490611c76565b01610a32565b346102845760206102f0610a93366116f9565b91611b58565b34610284575f6003193601126102845760206102f0611b1a565b34610284575f60031936011261028457602060405162278d008152f35b346102845760406003193601126102845773ffffffffffffffffffffffffffffffffffffffff610afe611653565b165f52601160205260405f206024355f52602052602060405f2054604051908152f35b3461028457602060031936011261028457610282610b3d611653565b611a29565b346102845760406003193601126102845760206102f0610b60611630565b600435611974565b34610284575f60031936011261028457602073ffffffffffffffffffffffffffffffffffffffff60015460081c16604051908152f35b34610284576020600319360112610284576004355f526005602052602060405f2054604051908152f35b34610284575f600319360112610284576020600254604051908152f35b610bee366116a7565b610bf9939293612259565b808403610c91579291905f935f935b808510610c485785348103610c1957005b7fa2dd20ef000000000000000000000000000000000000000000000000000000005f526004523460245260445ffd5b9091929394610c65600191610c5e888688611760565b3590611753565b95610c87610c74828589611760565b35610c80838789611760565b359061228d565b0193929190610c08565b7fb4fa3fb3000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610284575f60031936011261028457610cd1612501565b610cd9612259565b60017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00815416176001557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586020604051338152a1005b3461028457604060031936011261028457610282610d4b611653565b6024359061182b565b3461028457610d6236611730565b905f52600e60205260405f20905f52602052602060405f2054604051908152f35b346102845760206003193601126102845773ffffffffffffffffffffffffffffffffffffffff610db1611653565b165f52600b602052602060405f2054604051908152f35b3461028457610dd636611730565b905f52600d60205260405f20905f52602052602060405f2054604051908152f35b34610284575f60031936011261028457602060405163688d46f08152f35b34610284575f60031936011261028457610e2d612501565b5f73ffffffffffffffffffffffffffffffffffffffff6001547fffffffffffffffffffffff0000000000000000000000000000000000000000ff811660015560081c167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a3005b3461028457610ea4366116f9565b915f52601360205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f20905f52602052602060405f2054604051908152f35b3461028457602060031936011261028457610282600435335f52601160205260405f20815f5260205260405f205490611c76565b3461028457610f27366116f9565b915f52601260205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f20905f52602052602060405f2054604051908152f35b3461028457604060031936011261028457610f81611630565b6004355f52600a60205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b34610284575f60031936011261028457602060ff600154166040519015158152f35b346102845760406003193601126102845760043567ffffffffffffffff81116102845761100d903690600401611676565b611015611630565b5f91829033905b808310611097577fb00382203b46c3b6ad0a2d7af0268e334bd9406256a7c7ba8f7fc8bc47f8cde985856110668273ffffffffffffffffffffffffffffffffffffffff8316612166565b6040805133815273ffffffffffffffffffffffffffffffffffffffff929092166020830152810191909152606090a1005b9091936110a5858388611760565b356110ae611b1a565b81101561112f57805f52600a60205260405f20845f5260205260405f20548015611107576001926110fe926110e233611a29565b5f52600a60205260405f20865f526020525f6040812055611753565b9401919061101c565b7fc945242d000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f0f2ca6e7000000000000000000000000000000000000000000000000000000005f5260045ffd5b346102845760206003193601126102845760206102f060043561179d565b3461028457611183366116a7565b9061118c61212f565b818303611107575f5b8381106111a25760015f55005b806111c66111b36001938789611760565b356111bf838787611760565b3590611c76565b01611195565b346102845760206003193601126102845760206102f06004356111ee8161179d565b905f526016835260405f205490611753565b34610284575f60031936011261028457611218612501565b60015460ff811615611275577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00166001557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa6020604051338152a1005b7f8dfc202b000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610284576020600319360112610284576004355f526010602052602060405f2054604051908152f35b34610284576020600319360112610284576004355f526003602052602060405f2054604051908152f35b346102845760406003193601126102845761130a611630565b6004355f52600960205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b34610284575f600319360112610284576020600654604051908152f35b34610284576020600319360112610284576004355f526016602052602060405f2054604051908152f35b34610284576020600319360112610284576004355f52600c602052602060405f2054604051908152f35b34610284576020600319360112610284576004355f526004602052602060405f2054604051908152f35b34610284576040600319360112610284576113f7611630565b6004355f52600860205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b602060031936011261028457611444612259565b6102823460043561228d565b346102845760206003193601126102845760043580156114f4577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81019081116114c75762278d0081029080820462278d0014901517156114c75763688d46f0018063688d46f0116114c757602090604051908152f35b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b7fd69368d4000000000000000000000000000000000000000000000000000000005f5260045ffd5b3461028457604060031936011261028457600435611538611630565b61154061212f565b611548611b1a565b82101561112f57815f52600a60205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f2054908115611107577fb00382203b46c3b6ad0a2d7af0268e334bd9406256a7c7ba8f7fc8bc47f8cde9926115ae33611a29565b5f52600a60205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f526020525f60408120556115fb8273ffffffffffffffffffffffffffffffffffffffff8316612166565b6040805133815273ffffffffffffffffffffffffffffffffffffffff929092166020830152810191909152606090a160015f55005b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361028457565b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361028457565b9181601f840112156102845782359167ffffffffffffffff8311610284576020808501948460051b01011161028457565b60406003198201126102845760043567ffffffffffffffff811161028457816116d291600401611676565b929092916024359067ffffffffffffffff8211610284576116f591600401611676565b9091565b6003196060910112610284576004359060243573ffffffffffffffffffffffffffffffffffffffff81168103610284579060443590565b6003196040910112610284576004359060243590565b919082039182116114c757565b919082018092116114c757565b91908110156117705760051b0190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b60065481106117ef576117ec906117d96117c6600254835f52600360205260405f205490611753565b825f52600560205260405f205490611753565b905f52600460205260405f205490611746565b90565b5f52600360205260405f205490565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81146114c75760010190565b9073ffffffffffffffffffffffffffffffffffffffff611849611b1a565b9216805f52601560205260405f20825f5260205260405f2054925b80841061188457505f52601560205260405f20905f5260205260405f2055565b9261196e90825f52601160205260405f20845f5260205260405f2054815f52601260205260405f20845f5260205260405f20855f526020526118cb60405f20918254611753565b9055805f52601460205260405f20835f5260205260405f20845f5260205260405f2054815f52601260205260405f20845f5260205260405f20855f5260205261191960405f20918254611753565b9055805f52601360205260405f20835f5260205260405f20845f5260205260405f2054815f52601260205260405f20845f5260205260405f20855f5260205261196760405f20918254611746565b90556117fe565b92611864565b9073ffffffffffffffffffffffffffffffffffffffff1690815f52600b60205260405f20548110155f14611a1057816117ec925f5260076020526119f36119d660405f2054845f52600860205260405f20845f5260205260405f205490611753565b835f52600a60205260405f20835f5260205260405f205490611753565b915f52600960205260405f20905f5260205260405f205490611746565b5f52600860205260405f20905f5260205260405f205490565b73ffffffffffffffffffffffffffffffffffffffff611a46611b1a565b9116805f52600b60205260405f2054915b808310611a6d57505f52600b60205260405f2055565b91611b1490825f52600760205260405f2054815f52600860205260405f20845f52602052611aa060405f20918254611753565b9055805f52600a60205260405f20835f5260205260405f2054815f52600860205260405f20845f52602052611ada60405f20918254611753565b9055805f52600960205260405f20835f5260205260405f2054815f52600860205260405f20845f5260205261196760405f20918254611746565b91611a57565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff9772b91042014281116114c75762278d009004600181018091116114c75790565b9073ffffffffffffffffffffffffffffffffffffffff16805f52601560205260405f20835f5260205260405f20548210155f14611c265791826117ec935f52601160205260405f20825f52602052611bff611bd860405f2054855f52601260205260405f20845f5260205260405f20855f5260205260405f205490611753565b845f52601460205260405f20835f5260205260405f20845f5260205260405f205490611753565b925f52601360205260405f20905f5260205260405f20905f5260205260405f205490611746565b905f52601260205260405f20905f5260205260405f20905f5260205260405f205490565b80156114f45762278d00810290810462278d00036114c75763688d46f0018063688d46f0116114c75790565b9080156109b157811561098157335f52601160205260405f20825f5260205260405f205481118015611e8b575b610959577f8bd4728ee9ca3f99ddcffa24eb4f15de015cda9a27ccc427dfdaf711943ebca091606091611cd4611b1a565b8060065410611e7e575b335f52600b6020528060405f205410611e70575b825f5260106020528060405f205410611e62575b335f52601560205260405f20835f526020528060405f205410611e53575b805f52600560205260405f20611d3b838254611753565b9055805f52600a60205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20611d74838254611753565b9055805f52600f60205260405f20835f5260205260405f20611d97838254611753565b90555f52601460205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20825f5260205260405f20611dd9828254611753565b9055611de781600254611746565b600255335f52600760205260405f20611e01828254611746565b9055815f52600c60205260405f20611e1a828254611746565b9055335f52601160205260405f20825f5260205260405f20611e3d828254611746565b90556040519133835260208301526040820152a1565b611e5d833361182b565b611d24565b611e6b83611ea0565b611d06565b611e7933611a29565b611cf2565b611e86612094565b611cde565b50335f52600760205260405f20548111611ca3565b611ea8611b1a565b90805f52601060205260405f2054915b808310611ece57505f52601060205260405f2055565b91611f7590825f52600c60205260405f2054815f52600d60205260405f20845f52602052611f0160405f20918254611753565b9055805f52600f60205260405f20835f5260205260405f2054815f52600d60205260405f20845f52602052611f3b60405f20918254611753565b9055805f52600e60205260405f20835f5260205260405f2054815f52600d60205260405f20845f5260205261196760405f20918254611746565b91611eb8565b91908110156117705760061b0190565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117611fcc57604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b5f82815260106020526040902054811061207b57816117ec925f52600c60205261205e61204160405f2054845f52600d60205260405f20845f5260205260405f205490611753565b835f52600f60205260405f20835f5260205260405f205490611753565b915f52600e60205260405f20905f5260205260405f205490611746565b5f52600d60205260405f20905f5260205260405f205490565b61209c611b1a565b905b6006548281101561212a57600254905f5260036020526120c360405f20918254611753565b9055600654805f52600560205260405f2054905f5260036020526120ec60405f20918254611753565b9055600654805f52600460205260405f2054905f52600360205261211560405f20918254611746565b90556121226006546117fe565b60065561209e565b509050565b60025f541461213e5760025f55565b7f3ee5aeb5000000000000000000000000000000000000000000000000000000005f5260045ffd5b814710612229575f80809373ffffffffffffffffffffffffffffffffffffffff8294165af13d15612221573d9067ffffffffffffffff8211611fcc57604051916121d860207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8401160184611f8b565b82523d5f602084013e5b156121ea5750565b8051156121f957805190602001fd5b7fd6bda275000000000000000000000000000000000000000000000000000000005f5260045ffd5b6060906121e2565b50477fcf479181000000000000000000000000000000000000000000000000000000005f5260045260245260445ffd5b60ff6001541661226557565b7fd93c0665000000000000000000000000000000000000000000000000000000005f5260045ffd5b81156109b1578015610981576122a1611b1a565b80600654106124f4575b335f52600b6020528060405f2054106124e6575b815f5260106020528060405f2054106124d8575b335f52601560205260405f20825f526020528060405f2054106124c9575b61230b6123046122ff611b1a565b611c4a565b4290611746565b9182840292848404036114c7577f507ac39eb33610191cd8fd54286e91c5cc464c262861643be3978f5a9f18ab029362278d0060809404835f52601660205260405f20612359828254611753565b9055835f52601760205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205261239260405f20918254611753565b9055825f52600460205260405f206123ab828254611753565b90556123b981600254611753565b600255825f52600960205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f206123f3828254611753565b9055335f52600760205260405f2061240c828254611753565b9055825f52600e60205260405f20825f5260205260405f2061242f828254611753565b9055815f52600c60205260405f20612448828254611753565b9055825f52601360205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20825f5260205260405f2061248b828254611753565b9055335f52601160205260405f20825f5260205260405f206124ae828254611753565b905560405192835233602084015260408301526060820152a1565b6124d3823361182b565b6122f1565b6124e182611ea0565b6122d3565b6124ef33611a29565b6122bf565b6124fc612094565b6122ab565b73ffffffffffffffffffffffffffffffffffffffff60015460081c16330361252557565b7f118cdaa7000000000000000000000000000000000000000000000000000000005f523360045260245ffd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x804`\xC9W`\x1Fa&38\x81\x90\x03\x91\x82\x01`\x1F\x19\x16\x83\x01\x91`\x01`\x01`@\x1B\x03\x83\x11\x84\x84\x10\x17`\xCDW\x80\x84\x92` \x94`@R\x839\x81\x01\x03\x12`\xC9WQ`\x01`\x01`\xA0\x1B\x03\x81\x16\x80\x82\x03`\xC9W`\x01_U`\x01T\x91\x81\x15`\xB6W`\x01`\x01`\xA8\x1B\x03\x19\x83\x16`\x08\x91\x82\x1Ba\x01\0`\x01`\xA8\x1B\x03\x16\x17`\x01U`@Q\x92\x90\x1C`\x01`\x01`\xA0\x1B\x03\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0_\x80\xA3a%Q\x90\x81a\0\xE2\x829\xF3[c\x1EO\xBD\xF7`\xE0\x1B_R_`\x04R`$_\xFD[_\x80\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD\xFE`\x80`@R`\x046\x10\x15a\0\x11W_\x80\xFD[_5`\xE0\x1C\x80b\xF7\x14\xCE\x14a\x15\x1CW\x80c\x01u\xE2;\x14a\x14PW\x80c\x04X)o\x14a\x140W\x80c\x05=\xCD%\x14a\x13\xDEW\x80c\x0B(\x1B\xF8\x14a\x13\xB4W\x80c\x10W\xE9\xBC\x14a\x13\x8AW\x80c\x12\xE9s\xBC\x14a\x13`W\x80c\x1A\x8As\x8C\x14a\x13CW\x80c\x1BS;Z\x14a\x12\xF1W\x80c\x1E\x0E\x84\x89\x14a\x12\xC7W\x80c;\xA0\x0F\xAE\x14a\x12\x9DW\x80c?K\xA8:\x14a\x12\0W\x80c@\x8C2\xEA\x14a\x11\xCCW\x80cA\x97\xA4\xB1\x14a\x11uW\x80cE6\x7F#\x14a\x11WW\x80cXZbz\x14a\x0F\xDCW\x80cY\x19?7\x14a\n\xD0W\x80c\\\x97Z\xBB\x14a\x0F\xBAW\x80c]=\x8C\xD2\x14a\x0FhW\x80cb\x94T\xFD\x14a\x0F\x19W\x80ch\xA5Ud\x14a\x0E\xE5W\x80ci=\x0B~\x14a\x0E\x96W\x80cqP\x18\xA6\x14a\x0E\x15W\x80cx\x1C\xD9\x9D\x14a\r\xF7W\x80c{\xDA\x1C\xFB\x14a\r\xC8W\x80c|]\xD5\xD9\x14a\r\x83W\x80c|n\xAA\xEE\x14a\rTW\x80c~_\\\xA7\x14a\r/W\x80c\x84V\xCBY\x14a\x0C\xB9W\x80c\x85\xD8\x12\x17\x14a\x0B\xE5W\x80c\x8B\x0E\x9F?\x14a\x0B\xC8W\x80c\x8Cg\x90>\x14a\x0B\x9EW\x80c\x8D\xA5\xCB[\x14a\x0BhW\x80c\x96&\xA20\x14a\x0BBW\x80c\x9D\xEBf\xC9\x14a\x0B!W\x80c\xA0\x9Dz0\x14a\n\xD0W\x80c\xA7\x0B\x9F\x0C\x14a\n\xB3W\x80c\xB9}\xD9\xE2\x14a\n\x99W\x80c\xC3\xDD\xB3\xB3\x14a\n\x80W\x80c\xCE}\x8EZ\x14a\t\xF7W\x80c\xD5\x17m#\x14a\t\xD9W\x80c\xE5\x8ES\x82\x14a\x06\xFFW\x80c\xE6\x01\xCFD\x14a\x06\xBAW\x80c\xED\x86\xBAo\x14a\x06\xA3W\x80c\xEEu\x14\xE8\x14a\x06QW\x80c\xF00!\xA1\x14a\x065W\x80c\xF1V\xE0o\x14a\x04\xC4W\x80c\xF2\xFD\xE3\x8B\x14a\x03\xD4W\x80c\xF8\x9E\xE7\x8D\x14a\x03\x83W\x80c\xF9ee-\x14a\x03TW\x80c\xF9\xD6c\xE0\x14a\x02\xF8W\x80c\xFAE{\xE6\x14a\x02\xD7W\x80c\xFAs\xCEY\x14a\x02\x88Wc\xFE\x07\xBB\x07\x14a\x02jW_\x80\xFD[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84Wa\x02\x82a \x94V[\0[_\x80\xFD[4a\x02\x84Wa\x02\x966a\x16\xF9V[\x91_R`\x14` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W` a\x02\xF0a\x02\xEA6a\x170V[\x90a\x1F\xF9V[`@Q\x90\x81R\xF3[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84W` a\x02\xF0`\x045a\x03\x19a\x160V[a\x03#\x81\x83a\x19tV[\x91_R`\x17\x84Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R\x83R`@_ T\x90a\x17SV[4a\x02\x84Wa\x03b6a\x170V[\x90_R`\x0F` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x03\xB1a\x16SV[\x16_R`\x15` R`@_ `$5_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84Wa\x03\xEDa\x16SV[a\x03\xF5a%\x01V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x81\x15a\x04\x98Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90t\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0`\x01T\x91`\x08\x1B\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xFF\x82\x16\x17`\x01U`\x08\x1C\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0_\x80\xA3\0[\x7F\x1EO\xBD\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R_`\x04R`$_\xFD[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02\x84W6`#\x82\x01\x12\x15a\x02\x84W\x80`\x04\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02\x84W`$\x82\x01\x91`$6\x91\x83`\x06\x1B\x01\x01\x11a\x02\x84Wa\x05\"a\x160V[\x90a\x05+a!/V[\x80\x15a\x06\rW\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_[\x82\x81\x10a\x05WW`\x01_U\0[` a\x05d\x82\x85\x87a\x1F{V[\x015\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x80\x92\x03a\x02\x84Wa\x05\x90\x81\x85\x87a\x1F{V[5\x82;\x15a\x02\x84W_\x92`d\x84\x92`@Q\x95\x86\x93\x84\x92\x7Fi\xBC'G\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84R`\x04\x84\x01R3`$\x84\x01R\x88`D\x84\x01RZ\xF1\x91\x82\x15a\x06\x02W`\x01\x92a\x05\xF2W[P\x01a\x05JV[_a\x05\xFC\x91a\x1F\x8BV[\x85a\x05\xEBV[`@Q=_\x82>=\x90\xFD[\x7F\xBB\xCD?3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84Wa\x02\x82`\x045a\x1E\xA0V[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84Wa\x06ja\x160V[`\x045_R`\x17` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84Wa\x02\x82a\x06\xB46a\x170V[\x90a\x1CvV[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x06\xE8a\x16SV[\x16_R`\x07` R` `@_ T`@Q\x90\x81R\xF3[```\x03\x196\x01\x12a\x02\x84W`$5`\x045`D5a\x07\x1Ca!/V[a\x07$a\"YV[\x80\x15a\t\xB1W\x81\x15\x80\x15a\t\xA9W[a\t\x81W3_R`\x11` R`@_ \x82_R` R\x80`@_ T\x10a\tYW\x7F\xB3\x12\x90<\xE2\x07\xD2\x1E\x84\xE5}\x10\x05\xE0\xAAS\x85\xB7\x83\xEB'\xE2X\x81qt\xD0\x0C\xFB\xBC2x\x92`\xA0\x92a\x07\x81a\x1B\x1AV[\x923_R`\x0B` R\x83`@_ T\x10a\tKW[\x81_R`\x10` R\x83`@_ T\x10a\t=W[3_R`\x15` R`@_ \x82_R` R\x83`@_ T\x10a\t.W[\x83_R`\x12` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x82_R` R`@_ a\x08\t\x82\x82Ta\x17SV[\x90U\x83_R`\r` R`@_ \x82_R` R`@_ a\x08,\x82\x82Ta\x17SV[\x90U3_R`\x11` R`@_ \x82_R` R`@_ a\x08O\x82\x82Ta\x17FV[\x90U\x81_R`\x0C` R`@_ a\x08h\x82\x82Ta\x17FV[\x90U\x83_R`\x13` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x83_R` R`@_ a\x08\xAB\x82\x82Ta\x17SV[\x90U\x83_R`\x0E` R`@_ \x83_R` R`@_ a\x08\xCE\x82\x82Ta\x17SV[\x90U3_R`\x11` R`@_ \x83_R` R`@_ a\x08\xF1\x82\x82Ta\x17SV[\x90U\x82_R`\x0C` R`@_ a\t\n\x82\x82Ta\x17SV[\x90U`@Q\x93\x84R3` \x85\x01R`@\x84\x01R``\x83\x01R`\x80\x82\x01R\xA1`\x01_U\0[a\t8\x823a\x18+V[a\x07\xC8V[a\tF\x82a\x1E\xA0V[a\x07\xAAV[a\tT3a\x1A)V[a\x07\x96V[\x7F\xF1\xBC\x94\xD2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\xF6\xB4\x13\x1C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[P\x82\x15a\x073V[\x7F,R\x11\xC6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W` a\x02\xF0`\x045a\x1CJV[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02\x84Wa\n(\x906\x90`\x04\x01a\x16vV[a\n0a!/V[_[\x81\x81\x10a\n?W`\x01_U\0[\x80a\nza\nP`\x01\x93\x85\x87a\x17`V[5a\n\\\x83\x86\x88a\x17`V[53_R`\x11` R`@_ \x90_R` R`@_ T\x90a\x1CvV[\x01a\n2V[4a\x02\x84W` a\x02\xF0a\n\x936a\x16\xF9V[\x91a\x1BXV[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84W` a\x02\xF0a\x1B\x1AV[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84W` `@Qb'\x8D\0\x81R\xF3[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\n\xFEa\x16SV[\x16_R`\x11` R`@_ `$5_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84Wa\x02\x82a\x0B=a\x16SV[a\x1A)V[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84W` a\x02\xF0a\x0B`a\x160V[`\x045a\x19tV[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01T`\x08\x1C\x16`@Q\x90\x81R\xF3[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W`\x045_R`\x05` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84W` `\x02T`@Q\x90\x81R\xF3[a\x0B\xEE6a\x16\xA7V[a\x0B\xF9\x93\x92\x93a\"YV[\x80\x84\x03a\x0C\x91W\x92\x91\x90_\x93_\x93[\x80\x85\x10a\x0CHW\x854\x81\x03a\x0C\x19W\0[\x7F\xA2\xDD \xEF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R4`$R`D_\xFD[\x90\x91\x92\x93\x94a\x0Ce`\x01\x91a\x0C^\x88\x86\x88a\x17`V[5\x90a\x17SV[\x95a\x0C\x87a\x0Ct\x82\x85\x89a\x17`V[5a\x0C\x80\x83\x87\x89a\x17`V[5\x90a\"\x8DV[\x01\x93\x92\x91\x90a\x0C\x08V[\x7F\xB4\xFA?\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84Wa\x0C\xD1a%\x01V[a\x0C\xD9a\"YV[`\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x81T\x16\x17`\x01U\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X` `@Q3\x81R\xA1\0[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84Wa\x02\x82a\rKa\x16SV[`$5\x90a\x18+V[4a\x02\x84Wa\rb6a\x170V[\x90_R`\x0E` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\r\xB1a\x16SV[\x16_R`\x0B` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84Wa\r\xD66a\x170V[\x90_R`\r` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84W` `@Qch\x8DF\xF0\x81R\xF3[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84Wa\x0E-a%\x01V[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xFF\x81\x16`\x01U`\x08\x1C\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x82\x80\xA3\0[4a\x02\x84Wa\x0E\xA46a\x16\xF9V[\x91_R`\x13` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84Wa\x02\x82`\x0453_R`\x11` R`@_ \x81_R` R`@_ T\x90a\x1CvV[4a\x02\x84Wa\x0F'6a\x16\xF9V[\x91_R`\x12` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84Wa\x0F\x81a\x160V[`\x045_R`\n` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84W` `\xFF`\x01T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02\x84Wa\x10\r\x906\x90`\x04\x01a\x16vV[a\x10\x15a\x160V[_\x91\x82\x903\x90[\x80\x83\x10a\x10\x97W\x7F\xB0\x03\x82 ;F\xC3\xB6\xAD\n-z\xF0&\x8E3K\xD9@bV\xA7\xC7\xBA\x8F\x7F\xC8\xBCG\xF8\xCD\xE9\x85\x85a\x10f\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16a!fV[`@\x80Q3\x81Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x90\x92\x16` \x83\x01R\x81\x01\x91\x90\x91R``\x90\xA1\0[\x90\x91\x93a\x10\xA5\x85\x83\x88a\x17`V[5a\x10\xAEa\x1B\x1AV[\x81\x10\x15a\x11/W\x80_R`\n` R`@_ \x84_R` R`@_ T\x80\x15a\x11\x07W`\x01\x92a\x10\xFE\x92a\x10\xE23a\x1A)V[_R`\n` R`@_ \x86_R` R_`@\x81 Ua\x17SV[\x94\x01\x91\x90a\x10\x1CV[\x7F\xC9E$-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\x0F,\xA6\xE7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W` a\x02\xF0`\x045a\x17\x9DV[4a\x02\x84Wa\x11\x836a\x16\xA7V[\x90a\x11\x8Ca!/V[\x81\x83\x03a\x11\x07W_[\x83\x81\x10a\x11\xA2W`\x01_U\0[\x80a\x11\xC6a\x11\xB3`\x01\x93\x87\x89a\x17`V[5a\x11\xBF\x83\x87\x87a\x17`V[5\x90a\x1CvV[\x01a\x11\x95V[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W` a\x02\xF0`\x045a\x11\xEE\x81a\x17\x9DV[\x90_R`\x16\x83R`@_ T\x90a\x17SV[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84Wa\x12\x18a%\x01V[`\x01T`\xFF\x81\x16\x15a\x12uW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x16`\x01U\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA` `@Q3\x81R\xA1\0[\x7F\x8D\xFC +\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W`\x045_R`\x10` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W`\x045_R`\x03` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84Wa\x13\na\x160V[`\x045_R`\t` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84W` `\x06T`@Q\x90\x81R\xF3[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W`\x045_R`\x16` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W`\x045_R`\x0C` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W`\x045_R`\x04` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84Wa\x13\xF7a\x160V[`\x045_R`\x08` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[` `\x03\x196\x01\x12a\x02\x84Wa\x14Da\"YV[a\x02\x824`\x045a\"\x8DV[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W`\x045\x80\x15a\x14\xF4W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x01\x90\x81\x11a\x14\xC7Wb'\x8D\0\x81\x02\x90\x80\x82\x04b'\x8D\0\x14\x90\x15\x17\x15a\x14\xC7Wch\x8DF\xF0\x01\x80ch\x8DF\xF0\x11a\x14\xC7W` \x90`@Q\x90\x81R\xF3[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[\x7F\xD6\x93h\xD4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84W`\x045a\x158a\x160V[a\x15@a!/V[a\x15Ha\x1B\x1AV[\x82\x10\x15a\x11/W\x81_R`\n` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ T\x90\x81\x15a\x11\x07W\x7F\xB0\x03\x82 ;F\xC3\xB6\xAD\n-z\xF0&\x8E3K\xD9@bV\xA7\xC7\xBA\x8F\x7F\xC8\xBCG\xF8\xCD\xE9\x92a\x15\xAE3a\x1A)V[_R`\n` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R_`@\x81 Ua\x15\xFB\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16a!fV[`@\x80Q3\x81Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x90\x92\x16` \x83\x01R\x81\x01\x91\x90\x91R``\x90\xA1`\x01_U\0[`$5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x02\x84WV[`\x045\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x02\x84WV[\x91\x81`\x1F\x84\x01\x12\x15a\x02\x84W\x825\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x02\x84W` \x80\x85\x01\x94\x84`\x05\x1B\x01\x01\x11a\x02\x84WV[`@`\x03\x19\x82\x01\x12a\x02\x84W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02\x84W\x81a\x16\xD2\x91`\x04\x01a\x16vV[\x92\x90\x92\x91`$5\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x02\x84Wa\x16\xF5\x91`\x04\x01a\x16vV[\x90\x91V[`\x03\x19``\x91\x01\x12a\x02\x84W`\x045\x90`$5s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x02\x84W\x90`D5\x90V[`\x03\x19`@\x91\x01\x12a\x02\x84W`\x045\x90`$5\x90V[\x91\x90\x82\x03\x91\x82\x11a\x14\xC7WV[\x91\x90\x82\x01\x80\x92\x11a\x14\xC7WV[\x91\x90\x81\x10\x15a\x17pW`\x05\x1B\x01\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[`\x06T\x81\x10a\x17\xEFWa\x17\xEC\x90a\x17\xD9a\x17\xC6`\x02T\x83_R`\x03` R`@_ T\x90a\x17SV[\x82_R`\x05` R`@_ T\x90a\x17SV[\x90_R`\x04` R`@_ T\x90a\x17FV[\x90V[_R`\x03` R`@_ T\x90V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x14a\x14\xC7W`\x01\x01\x90V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x18Ia\x1B\x1AV[\x92\x16\x80_R`\x15` R`@_ \x82_R` R`@_ T\x92[\x80\x84\x10a\x18\x84WP_R`\x15` R`@_ \x90_R` R`@_ UV[\x92a\x19n\x90\x82_R`\x11` R`@_ \x84_R` R`@_ T\x81_R`\x12` R`@_ \x84_R` R`@_ \x85_R` Ra\x18\xCB`@_ \x91\x82Ta\x17SV[\x90U\x80_R`\x14` R`@_ \x83_R` R`@_ \x84_R` R`@_ T\x81_R`\x12` R`@_ \x84_R` R`@_ \x85_R` Ra\x19\x19`@_ \x91\x82Ta\x17SV[\x90U\x80_R`\x13` R`@_ \x83_R` R`@_ \x84_R` R`@_ T\x81_R`\x12` R`@_ \x84_R` R`@_ \x85_R` Ra\x19g`@_ \x91\x82Ta\x17FV[\x90Ua\x17\xFEV[\x92a\x18dV[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81_R`\x0B` R`@_ T\x81\x10\x15_\x14a\x1A\x10W\x81a\x17\xEC\x92_R`\x07` Ra\x19\xF3a\x19\xD6`@_ T\x84_R`\x08` R`@_ \x84_R` R`@_ T\x90a\x17SV[\x83_R`\n` R`@_ \x83_R` R`@_ T\x90a\x17SV[\x91_R`\t` R`@_ \x90_R` R`@_ T\x90a\x17FV[_R`\x08` R`@_ \x90_R` R`@_ T\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x1AFa\x1B\x1AV[\x91\x16\x80_R`\x0B` R`@_ T\x91[\x80\x83\x10a\x1AmWP_R`\x0B` R`@_ UV[\x91a\x1B\x14\x90\x82_R`\x07` R`@_ T\x81_R`\x08` R`@_ \x84_R` Ra\x1A\xA0`@_ \x91\x82Ta\x17SV[\x90U\x80_R`\n` R`@_ \x83_R` R`@_ T\x81_R`\x08` R`@_ \x84_R` Ra\x1A\xDA`@_ \x91\x82Ta\x17SV[\x90U\x80_R`\t` R`@_ \x83_R` R`@_ T\x81_R`\x08` R`@_ \x84_R` Ra\x19g`@_ \x91\x82Ta\x17FV[\x91a\x1AWV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x97r\xB9\x10B\x01B\x81\x11a\x14\xC7Wb'\x8D\0\x90\x04`\x01\x81\x01\x80\x91\x11a\x14\xC7W\x90V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80_R`\x15` R`@_ \x83_R` R`@_ T\x82\x10\x15_\x14a\x1C&W\x91\x82a\x17\xEC\x93_R`\x11` R`@_ \x82_R` Ra\x1B\xFFa\x1B\xD8`@_ T\x85_R`\x12` R`@_ \x84_R` R`@_ \x85_R` R`@_ T\x90a\x17SV[\x84_R`\x14` R`@_ \x83_R` R`@_ \x84_R` R`@_ T\x90a\x17SV[\x92_R`\x13` R`@_ \x90_R` R`@_ \x90_R` R`@_ T\x90a\x17FV[\x90_R`\x12` R`@_ \x90_R` R`@_ \x90_R` R`@_ T\x90V[\x80\x15a\x14\xF4Wb'\x8D\0\x81\x02\x90\x81\x04b'\x8D\0\x03a\x14\xC7Wch\x8DF\xF0\x01\x80ch\x8DF\xF0\x11a\x14\xC7W\x90V[\x90\x80\x15a\t\xB1W\x81\x15a\t\x81W3_R`\x11` R`@_ \x82_R` R`@_ T\x81\x11\x80\x15a\x1E\x8BW[a\tYW\x7F\x8B\xD4r\x8E\xE9\xCA?\x99\xDD\xCF\xFA$\xEBO\x15\xDE\x01\\\xDA\x9A'\xCC\xC4'\xDF\xDA\xF7\x11\x94>\xBC\xA0\x91``\x91a\x1C\xD4a\x1B\x1AV[\x80`\x06T\x10a\x1E~W[3_R`\x0B` R\x80`@_ T\x10a\x1EpW[\x82_R`\x10` R\x80`@_ T\x10a\x1EbW[3_R`\x15` R`@_ \x83_R` R\x80`@_ T\x10a\x1ESW[\x80_R`\x05` R`@_ a\x1D;\x83\x82Ta\x17SV[\x90U\x80_R`\n` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ a\x1Dt\x83\x82Ta\x17SV[\x90U\x80_R`\x0F` R`@_ \x83_R` R`@_ a\x1D\x97\x83\x82Ta\x17SV[\x90U_R`\x14` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x82_R` R`@_ a\x1D\xD9\x82\x82Ta\x17SV[\x90Ua\x1D\xE7\x81`\x02Ta\x17FV[`\x02U3_R`\x07` R`@_ a\x1E\x01\x82\x82Ta\x17FV[\x90U\x81_R`\x0C` R`@_ a\x1E\x1A\x82\x82Ta\x17FV[\x90U3_R`\x11` R`@_ \x82_R` R`@_ a\x1E=\x82\x82Ta\x17FV[\x90U`@Q\x913\x83R` \x83\x01R`@\x82\x01R\xA1V[a\x1E]\x833a\x18+V[a\x1D$V[a\x1Ek\x83a\x1E\xA0V[a\x1D\x06V[a\x1Ey3a\x1A)V[a\x1C\xF2V[a\x1E\x86a \x94V[a\x1C\xDEV[P3_R`\x07` R`@_ T\x81\x11a\x1C\xA3V[a\x1E\xA8a\x1B\x1AV[\x90\x80_R`\x10` R`@_ T\x91[\x80\x83\x10a\x1E\xCEWP_R`\x10` R`@_ UV[\x91a\x1Fu\x90\x82_R`\x0C` R`@_ T\x81_R`\r` R`@_ \x84_R` Ra\x1F\x01`@_ \x91\x82Ta\x17SV[\x90U\x80_R`\x0F` R`@_ \x83_R` R`@_ T\x81_R`\r` R`@_ \x84_R` Ra\x1F;`@_ \x91\x82Ta\x17SV[\x90U\x80_R`\x0E` R`@_ \x83_R` R`@_ T\x81_R`\r` R`@_ \x84_R` Ra\x19g`@_ \x91\x82Ta\x17FV[\x91a\x1E\xB8V[\x91\x90\x81\x10\x15a\x17pW`\x06\x1B\x01\x90V[\x90`\x1F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x1F\xCCW`@RV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[_\x82\x81R`\x10` R`@\x90 T\x81\x10a {W\x81a\x17\xEC\x92_R`\x0C` Ra ^a A`@_ T\x84_R`\r` R`@_ \x84_R` R`@_ T\x90a\x17SV[\x83_R`\x0F` R`@_ \x83_R` R`@_ T\x90a\x17SV[\x91_R`\x0E` R`@_ \x90_R` R`@_ T\x90a\x17FV[_R`\r` R`@_ \x90_R` R`@_ T\x90V[a \x9Ca\x1B\x1AV[\x90[`\x06T\x82\x81\x10\x15a!*W`\x02T\x90_R`\x03` Ra \xC3`@_ \x91\x82Ta\x17SV[\x90U`\x06T\x80_R`\x05` R`@_ T\x90_R`\x03` Ra \xEC`@_ \x91\x82Ta\x17SV[\x90U`\x06T\x80_R`\x04` R`@_ T\x90_R`\x03` Ra!\x15`@_ \x91\x82Ta\x17FV[\x90Ua!\"`\x06Ta\x17\xFEV[`\x06Ua \x9EV[P\x90PV[`\x02_T\x14a!>W`\x02_UV[\x7F>\xE5\xAE\xB5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x81G\x10a\")W_\x80\x80\x93s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x94\x16Z\xF1=\x15a\"!W=\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x1F\xCCW`@Q\x91a!\xD8` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x84\x01\x16\x01\x84a\x1F\x8BV[\x82R=_` \x84\x01>[\x15a!\xEAWPV[\x80Q\x15a!\xF9W\x80Q\x90` \x01\xFD[\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[``\x90a!\xE2V[PG\x7F\xCFG\x91\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$R`D_\xFD[`\xFF`\x01T\x16a\"eWV[\x7F\xD9<\x06e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x81\x15a\t\xB1W\x80\x15a\t\x81Wa\"\xA1a\x1B\x1AV[\x80`\x06T\x10a$\xF4W[3_R`\x0B` R\x80`@_ T\x10a$\xE6W[\x81_R`\x10` R\x80`@_ T\x10a$\xD8W[3_R`\x15` R`@_ \x82_R` R\x80`@_ T\x10a$\xC9W[a#\x0Ba#\x04a\"\xFFa\x1B\x1AV[a\x1CJV[B\x90a\x17FV[\x91\x82\x84\x02\x92\x84\x84\x04\x03a\x14\xC7W\x7FPz\xC3\x9E\xB36\x10\x19\x1C\xD8\xFDT(n\x91\xC5\xCCFL&(ad;\xE3\x97\x8FZ\x9F\x18\xAB\x02\x93b'\x8D\0`\x80\x94\x04\x83_R`\x16` R`@_ a#Y\x82\x82Ta\x17SV[\x90U\x83_R`\x17` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` Ra#\x92`@_ \x91\x82Ta\x17SV[\x90U\x82_R`\x04` R`@_ a#\xAB\x82\x82Ta\x17SV[\x90Ua#\xB9\x81`\x02Ta\x17SV[`\x02U\x82_R`\t` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ a#\xF3\x82\x82Ta\x17SV[\x90U3_R`\x07` R`@_ a$\x0C\x82\x82Ta\x17SV[\x90U\x82_R`\x0E` R`@_ \x82_R` R`@_ a$/\x82\x82Ta\x17SV[\x90U\x81_R`\x0C` R`@_ a$H\x82\x82Ta\x17SV[\x90U\x82_R`\x13` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x82_R` R`@_ a$\x8B\x82\x82Ta\x17SV[\x90U3_R`\x11` R`@_ \x82_R` R`@_ a$\xAE\x82\x82Ta\x17SV[\x90U`@Q\x92\x83R3` \x84\x01R`@\x83\x01R``\x82\x01R\xA1V[a$\xD3\x823a\x18+V[a\"\xF1V[a$\xE1\x82a\x1E\xA0V[a\"\xD3V[a$\xEF3a\x1A)V[a\"\xBFV[a$\xFCa \x94V[a\"\xABV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01T`\x08\x1C\x163\x03a%%WV[\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R3`\x04R`$_\xFD",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610011575f80fd5b5f3560e01c8062f714ce1461151c5780630175e23b146114505780630458296f14611430578063053dcd25146113de5780630b281bf8146113b45780631057e9bc1461138a57806312e973bc146113605780631a8a738c146113435780631b533b5a146112f15780631e0e8489146112c75780633ba00fae1461129d5780633f4ba83a14611200578063408c32ea146111cc5780634197a4b11461117557806345367f2314611157578063585a627a14610fdc57806359193f3714610ad05780635c975abb14610fba5780635d3d8cd214610f68578063629454fd14610f1957806368a5556414610ee5578063693d0b7e14610e96578063715018a614610e15578063781cd99d14610df75780637bda1cfb14610dc85780637c5dd5d914610d835780637c6eaaee14610d545780637e5f5ca714610d2f5780638456cb5914610cb957806385d8121714610be55780638b0e9f3f14610bc85780638c67903e14610b9e5780638da5cb5b14610b685780639626a23014610b425780639deb66c914610b21578063a09d7a3014610ad0578063a70b9f0c14610ab3578063b97dd9e214610a99578063c3ddb3b314610a80578063ce7d8e5a146109f7578063d5176d23146109d9578063e58e5382146106ff578063e601cf44146106ba578063ed86ba6f146106a3578063ee7514e814610651578063f03021a114610635578063f156e06f146104c4578063f2fde38b146103d4578063f89ee78d14610383578063f965652d14610354578063f9d663e0146102f8578063fa457be6146102d7578063fa73ce59146102885763fe07bb071461026a575f80fd5b34610284575f60031936011261028457610282612094565b005b5f80fd5b3461028457610296366116f9565b915f52601460205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f20905f52602052602060405f2054604051908152f35b346102845760206102f06102ea36611730565b90611ff9565b604051908152f35b346102845760406003193601126102845760206102f0600435610319611630565b6103238183611974565b915f526017845273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52835260405f205490611753565b346102845761036236611730565b905f52600f60205260405f20905f52602052602060405f2054604051908152f35b346102845760406003193601126102845773ffffffffffffffffffffffffffffffffffffffff6103b1611653565b165f52601560205260405f206024355f52602052602060405f2054604051908152f35b34610284576020600319360112610284576103ed611653565b6103f5612501565b73ffffffffffffffffffffffffffffffffffffffff81169081156104985773ffffffffffffffffffffffffffffffffffffffff9074ffffffffffffffffffffffffffffffffffffffff006001549160081b167fffffffffffffffffffffff0000000000000000000000000000000000000000ff82161760015560081c167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3005b7f1e4fbdf7000000000000000000000000000000000000000000000000000000005f525f60045260245ffd5b346102845760406003193601126102845760043567ffffffffffffffff8111610284573660238201121561028457806004013567ffffffffffffffff8111610284576024820191602436918360061b01011161028457610522611630565b9061052b61212f565b801561060d579073ffffffffffffffffffffffffffffffffffffffff165f5b8281106105575760015f55005b6020610564828587611f7b565b01359073ffffffffffffffffffffffffffffffffffffffff821680920361028457610590818587611f7b565b35823b15610284575f926064849260405195869384927f69bc274700000000000000000000000000000000000000000000000000000000845260048401523360248401528860448401525af1918215610602576001926105f2575b500161054a565b5f6105fc91611f8b565b856105eb565b6040513d5f823e3d90fd5b7fbbcd3f33000000000000000000000000000000000000000000000000000000005f5260045ffd5b3461028457602060031936011261028457610282600435611ea0565b346102845760406003193601126102845761066a611630565b6004355f52601760205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b34610284576102826106b436611730565b90611c76565b346102845760206003193601126102845773ffffffffffffffffffffffffffffffffffffffff6106e8611653565b165f526007602052602060405f2054604051908152f35b60606003193601126102845760243560043560443561071c61212f565b610724612259565b80156109b157811580156109a9575b61098157335f52601160205260405f20825f526020528060405f205410610959577fb312903ce207d21e84e57d1005e0aa5385b783eb27e258817174d00cfbbc32789260a092610781611b1a565b92335f52600b6020528360405f20541061094b575b815f5260106020528360405f20541061093d575b335f52601560205260405f20825f526020528360405f20541061092e575b835f52601260205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20825f5260205260405f20610809828254611753565b9055835f52600d60205260405f20825f5260205260405f2061082c828254611753565b9055335f52601160205260405f20825f5260205260405f2061084f828254611746565b9055815f52600c60205260405f20610868828254611746565b9055835f52601360205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20835f5260205260405f206108ab828254611753565b9055835f52600e60205260405f20835f5260205260405f206108ce828254611753565b9055335f52601160205260405f20835f5260205260405f206108f1828254611753565b9055825f52600c60205260405f2061090a828254611753565b9055604051938452336020850152604084015260608301526080820152a160015f55005b610938823361182b565b6107c8565b61094682611ea0565b6107aa565b61095433611a29565b610796565b7ff1bc94d2000000000000000000000000000000000000000000000000000000005f5260045ffd5b7ff6b4131c000000000000000000000000000000000000000000000000000000005f5260045ffd5b508215610733565b7f2c5211c6000000000000000000000000000000000000000000000000000000005f5260045ffd5b346102845760206003193601126102845760206102f0600435611c4a565b346102845760206003193601126102845760043567ffffffffffffffff811161028457610a28903690600401611676565b610a3061212f565b5f5b818110610a3f5760015f55005b80610a7a610a506001938587611760565b35610a5c838688611760565b35335f52601160205260405f20905f5260205260405f205490611c76565b01610a32565b346102845760206102f0610a93366116f9565b91611b58565b34610284575f6003193601126102845760206102f0611b1a565b34610284575f60031936011261028457602060405162278d008152f35b346102845760406003193601126102845773ffffffffffffffffffffffffffffffffffffffff610afe611653565b165f52601160205260405f206024355f52602052602060405f2054604051908152f35b3461028457602060031936011261028457610282610b3d611653565b611a29565b346102845760406003193601126102845760206102f0610b60611630565b600435611974565b34610284575f60031936011261028457602073ffffffffffffffffffffffffffffffffffffffff60015460081c16604051908152f35b34610284576020600319360112610284576004355f526005602052602060405f2054604051908152f35b34610284575f600319360112610284576020600254604051908152f35b610bee366116a7565b610bf9939293612259565b808403610c91579291905f935f935b808510610c485785348103610c1957005b7fa2dd20ef000000000000000000000000000000000000000000000000000000005f526004523460245260445ffd5b9091929394610c65600191610c5e888688611760565b3590611753565b95610c87610c74828589611760565b35610c80838789611760565b359061228d565b0193929190610c08565b7fb4fa3fb3000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610284575f60031936011261028457610cd1612501565b610cd9612259565b60017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00815416176001557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586020604051338152a1005b3461028457604060031936011261028457610282610d4b611653565b6024359061182b565b3461028457610d6236611730565b905f52600e60205260405f20905f52602052602060405f2054604051908152f35b346102845760206003193601126102845773ffffffffffffffffffffffffffffffffffffffff610db1611653565b165f52600b602052602060405f2054604051908152f35b3461028457610dd636611730565b905f52600d60205260405f20905f52602052602060405f2054604051908152f35b34610284575f60031936011261028457602060405163688d46f08152f35b34610284575f60031936011261028457610e2d612501565b5f73ffffffffffffffffffffffffffffffffffffffff6001547fffffffffffffffffffffff0000000000000000000000000000000000000000ff811660015560081c167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a3005b3461028457610ea4366116f9565b915f52601360205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f20905f52602052602060405f2054604051908152f35b3461028457602060031936011261028457610282600435335f52601160205260405f20815f5260205260405f205490611c76565b3461028457610f27366116f9565b915f52601260205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f20905f52602052602060405f2054604051908152f35b3461028457604060031936011261028457610f81611630565b6004355f52600a60205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b34610284575f60031936011261028457602060ff600154166040519015158152f35b346102845760406003193601126102845760043567ffffffffffffffff81116102845761100d903690600401611676565b611015611630565b5f91829033905b808310611097577fb00382203b46c3b6ad0a2d7af0268e334bd9406256a7c7ba8f7fc8bc47f8cde985856110668273ffffffffffffffffffffffffffffffffffffffff8316612166565b6040805133815273ffffffffffffffffffffffffffffffffffffffff929092166020830152810191909152606090a1005b9091936110a5858388611760565b356110ae611b1a565b81101561112f57805f52600a60205260405f20845f5260205260405f20548015611107576001926110fe926110e233611a29565b5f52600a60205260405f20865f526020525f6040812055611753565b9401919061101c565b7fc945242d000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f0f2ca6e7000000000000000000000000000000000000000000000000000000005f5260045ffd5b346102845760206003193601126102845760206102f060043561179d565b3461028457611183366116a7565b9061118c61212f565b818303611107575f5b8381106111a25760015f55005b806111c66111b36001938789611760565b356111bf838787611760565b3590611c76565b01611195565b346102845760206003193601126102845760206102f06004356111ee8161179d565b905f526016835260405f205490611753565b34610284575f60031936011261028457611218612501565b60015460ff811615611275577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00166001557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa6020604051338152a1005b7f8dfc202b000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610284576020600319360112610284576004355f526010602052602060405f2054604051908152f35b34610284576020600319360112610284576004355f526003602052602060405f2054604051908152f35b346102845760406003193601126102845761130a611630565b6004355f52600960205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b34610284575f600319360112610284576020600654604051908152f35b34610284576020600319360112610284576004355f526016602052602060405f2054604051908152f35b34610284576020600319360112610284576004355f52600c602052602060405f2054604051908152f35b34610284576020600319360112610284576004355f526004602052602060405f2054604051908152f35b34610284576040600319360112610284576113f7611630565b6004355f52600860205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b602060031936011261028457611444612259565b6102823460043561228d565b346102845760206003193601126102845760043580156114f4577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81019081116114c75762278d0081029080820462278d0014901517156114c75763688d46f0018063688d46f0116114c757602090604051908152f35b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b7fd69368d4000000000000000000000000000000000000000000000000000000005f5260045ffd5b3461028457604060031936011261028457600435611538611630565b61154061212f565b611548611b1a565b82101561112f57815f52600a60205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f2054908115611107577fb00382203b46c3b6ad0a2d7af0268e334bd9406256a7c7ba8f7fc8bc47f8cde9926115ae33611a29565b5f52600a60205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f526020525f60408120556115fb8273ffffffffffffffffffffffffffffffffffffffff8316612166565b6040805133815273ffffffffffffffffffffffffffffffffffffffff929092166020830152810191909152606090a160015f55005b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361028457565b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361028457565b9181601f840112156102845782359167ffffffffffffffff8311610284576020808501948460051b01011161028457565b60406003198201126102845760043567ffffffffffffffff811161028457816116d291600401611676565b929092916024359067ffffffffffffffff8211610284576116f591600401611676565b9091565b6003196060910112610284576004359060243573ffffffffffffffffffffffffffffffffffffffff81168103610284579060443590565b6003196040910112610284576004359060243590565b919082039182116114c757565b919082018092116114c757565b91908110156117705760051b0190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b60065481106117ef576117ec906117d96117c6600254835f52600360205260405f205490611753565b825f52600560205260405f205490611753565b905f52600460205260405f205490611746565b90565b5f52600360205260405f205490565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81146114c75760010190565b9073ffffffffffffffffffffffffffffffffffffffff611849611b1a565b9216805f52601560205260405f20825f5260205260405f2054925b80841061188457505f52601560205260405f20905f5260205260405f2055565b9261196e90825f52601160205260405f20845f5260205260405f2054815f52601260205260405f20845f5260205260405f20855f526020526118cb60405f20918254611753565b9055805f52601460205260405f20835f5260205260405f20845f5260205260405f2054815f52601260205260405f20845f5260205260405f20855f5260205261191960405f20918254611753565b9055805f52601360205260405f20835f5260205260405f20845f5260205260405f2054815f52601260205260405f20845f5260205260405f20855f5260205261196760405f20918254611746565b90556117fe565b92611864565b9073ffffffffffffffffffffffffffffffffffffffff1690815f52600b60205260405f20548110155f14611a1057816117ec925f5260076020526119f36119d660405f2054845f52600860205260405f20845f5260205260405f205490611753565b835f52600a60205260405f20835f5260205260405f205490611753565b915f52600960205260405f20905f5260205260405f205490611746565b5f52600860205260405f20905f5260205260405f205490565b73ffffffffffffffffffffffffffffffffffffffff611a46611b1a565b9116805f52600b60205260405f2054915b808310611a6d57505f52600b60205260405f2055565b91611b1490825f52600760205260405f2054815f52600860205260405f20845f52602052611aa060405f20918254611753565b9055805f52600a60205260405f20835f5260205260405f2054815f52600860205260405f20845f52602052611ada60405f20918254611753565b9055805f52600960205260405f20835f5260205260405f2054815f52600860205260405f20845f5260205261196760405f20918254611746565b91611a57565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff9772b91042014281116114c75762278d009004600181018091116114c75790565b9073ffffffffffffffffffffffffffffffffffffffff16805f52601560205260405f20835f5260205260405f20548210155f14611c265791826117ec935f52601160205260405f20825f52602052611bff611bd860405f2054855f52601260205260405f20845f5260205260405f20855f5260205260405f205490611753565b845f52601460205260405f20835f5260205260405f20845f5260205260405f205490611753565b925f52601360205260405f20905f5260205260405f20905f5260205260405f205490611746565b905f52601260205260405f20905f5260205260405f20905f5260205260405f205490565b80156114f45762278d00810290810462278d00036114c75763688d46f0018063688d46f0116114c75790565b9080156109b157811561098157335f52601160205260405f20825f5260205260405f205481118015611e8b575b610959577f8bd4728ee9ca3f99ddcffa24eb4f15de015cda9a27ccc427dfdaf711943ebca091606091611cd4611b1a565b8060065410611e7e575b335f52600b6020528060405f205410611e70575b825f5260106020528060405f205410611e62575b335f52601560205260405f20835f526020528060405f205410611e53575b805f52600560205260405f20611d3b838254611753565b9055805f52600a60205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20611d74838254611753565b9055805f52600f60205260405f20835f5260205260405f20611d97838254611753565b90555f52601460205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20825f5260205260405f20611dd9828254611753565b9055611de781600254611746565b600255335f52600760205260405f20611e01828254611746565b9055815f52600c60205260405f20611e1a828254611746565b9055335f52601160205260405f20825f5260205260405f20611e3d828254611746565b90556040519133835260208301526040820152a1565b611e5d833361182b565b611d24565b611e6b83611ea0565b611d06565b611e7933611a29565b611cf2565b611e86612094565b611cde565b50335f52600760205260405f20548111611ca3565b611ea8611b1a565b90805f52601060205260405f2054915b808310611ece57505f52601060205260405f2055565b91611f7590825f52600c60205260405f2054815f52600d60205260405f20845f52602052611f0160405f20918254611753565b9055805f52600f60205260405f20835f5260205260405f2054815f52600d60205260405f20845f52602052611f3b60405f20918254611753565b9055805f52600e60205260405f20835f5260205260405f2054815f52600d60205260405f20845f5260205261196760405f20918254611746565b91611eb8565b91908110156117705760061b0190565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117611fcc57604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b5f82815260106020526040902054811061207b57816117ec925f52600c60205261205e61204160405f2054845f52600d60205260405f20845f5260205260405f205490611753565b835f52600f60205260405f20835f5260205260405f205490611753565b915f52600e60205260405f20905f5260205260405f205490611746565b5f52600d60205260405f20905f5260205260405f205490565b61209c611b1a565b905b6006548281101561212a57600254905f5260036020526120c360405f20918254611753565b9055600654805f52600560205260405f2054905f5260036020526120ec60405f20918254611753565b9055600654805f52600460205260405f2054905f52600360205261211560405f20918254611746565b90556121226006546117fe565b60065561209e565b509050565b60025f541461213e5760025f55565b7f3ee5aeb5000000000000000000000000000000000000000000000000000000005f5260045ffd5b814710612229575f80809373ffffffffffffffffffffffffffffffffffffffff8294165af13d15612221573d9067ffffffffffffffff8211611fcc57604051916121d860207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8401160184611f8b565b82523d5f602084013e5b156121ea5750565b8051156121f957805190602001fd5b7fd6bda275000000000000000000000000000000000000000000000000000000005f5260045ffd5b6060906121e2565b50477fcf479181000000000000000000000000000000000000000000000000000000005f5260045260245260445ffd5b60ff6001541661226557565b7fd93c0665000000000000000000000000000000000000000000000000000000005f5260045ffd5b81156109b1578015610981576122a1611b1a565b80600654106124f4575b335f52600b6020528060405f2054106124e6575b815f5260106020528060405f2054106124d8575b335f52601560205260405f20825f526020528060405f2054106124c9575b61230b6123046122ff611b1a565b611c4a565b4290611746565b9182840292848404036114c7577f507ac39eb33610191cd8fd54286e91c5cc464c262861643be3978f5a9f18ab029362278d0060809404835f52601660205260405f20612359828254611753565b9055835f52601760205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205261239260405f20918254611753565b9055825f52600460205260405f206123ab828254611753565b90556123b981600254611753565b600255825f52600960205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f206123f3828254611753565b9055335f52600760205260405f2061240c828254611753565b9055825f52600e60205260405f20825f5260205260405f2061242f828254611753565b9055815f52600c60205260405f20612448828254611753565b9055825f52601360205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20825f5260205260405f2061248b828254611753565b9055335f52601160205260405f20825f5260205260405f206124ae828254611753565b905560405192835233602084015260408301526060820152a1565b6124d3823361182b565b6122f1565b6124e182611ea0565b6122d3565b6124ef33611a29565b6122bf565b6124fc612094565b6122ab565b73ffffffffffffffffffffffffffffffffffffffff60015460081c16330361252557565b7f118cdaa7000000000000000000000000000000000000000000000000000000005f523360045260245ffd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x11W_\x80\xFD[_5`\xE0\x1C\x80b\xF7\x14\xCE\x14a\x15\x1CW\x80c\x01u\xE2;\x14a\x14PW\x80c\x04X)o\x14a\x140W\x80c\x05=\xCD%\x14a\x13\xDEW\x80c\x0B(\x1B\xF8\x14a\x13\xB4W\x80c\x10W\xE9\xBC\x14a\x13\x8AW\x80c\x12\xE9s\xBC\x14a\x13`W\x80c\x1A\x8As\x8C\x14a\x13CW\x80c\x1BS;Z\x14a\x12\xF1W\x80c\x1E\x0E\x84\x89\x14a\x12\xC7W\x80c;\xA0\x0F\xAE\x14a\x12\x9DW\x80c?K\xA8:\x14a\x12\0W\x80c@\x8C2\xEA\x14a\x11\xCCW\x80cA\x97\xA4\xB1\x14a\x11uW\x80cE6\x7F#\x14a\x11WW\x80cXZbz\x14a\x0F\xDCW\x80cY\x19?7\x14a\n\xD0W\x80c\\\x97Z\xBB\x14a\x0F\xBAW\x80c]=\x8C\xD2\x14a\x0FhW\x80cb\x94T\xFD\x14a\x0F\x19W\x80ch\xA5Ud\x14a\x0E\xE5W\x80ci=\x0B~\x14a\x0E\x96W\x80cqP\x18\xA6\x14a\x0E\x15W\x80cx\x1C\xD9\x9D\x14a\r\xF7W\x80c{\xDA\x1C\xFB\x14a\r\xC8W\x80c|]\xD5\xD9\x14a\r\x83W\x80c|n\xAA\xEE\x14a\rTW\x80c~_\\\xA7\x14a\r/W\x80c\x84V\xCBY\x14a\x0C\xB9W\x80c\x85\xD8\x12\x17\x14a\x0B\xE5W\x80c\x8B\x0E\x9F?\x14a\x0B\xC8W\x80c\x8Cg\x90>\x14a\x0B\x9EW\x80c\x8D\xA5\xCB[\x14a\x0BhW\x80c\x96&\xA20\x14a\x0BBW\x80c\x9D\xEBf\xC9\x14a\x0B!W\x80c\xA0\x9Dz0\x14a\n\xD0W\x80c\xA7\x0B\x9F\x0C\x14a\n\xB3W\x80c\xB9}\xD9\xE2\x14a\n\x99W\x80c\xC3\xDD\xB3\xB3\x14a\n\x80W\x80c\xCE}\x8EZ\x14a\t\xF7W\x80c\xD5\x17m#\x14a\t\xD9W\x80c\xE5\x8ES\x82\x14a\x06\xFFW\x80c\xE6\x01\xCFD\x14a\x06\xBAW\x80c\xED\x86\xBAo\x14a\x06\xA3W\x80c\xEEu\x14\xE8\x14a\x06QW\x80c\xF00!\xA1\x14a\x065W\x80c\xF1V\xE0o\x14a\x04\xC4W\x80c\xF2\xFD\xE3\x8B\x14a\x03\xD4W\x80c\xF8\x9E\xE7\x8D\x14a\x03\x83W\x80c\xF9ee-\x14a\x03TW\x80c\xF9\xD6c\xE0\x14a\x02\xF8W\x80c\xFAE{\xE6\x14a\x02\xD7W\x80c\xFAs\xCEY\x14a\x02\x88Wc\xFE\x07\xBB\x07\x14a\x02jW_\x80\xFD[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84Wa\x02\x82a \x94V[\0[_\x80\xFD[4a\x02\x84Wa\x02\x966a\x16\xF9V[\x91_R`\x14` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W` a\x02\xF0a\x02\xEA6a\x170V[\x90a\x1F\xF9V[`@Q\x90\x81R\xF3[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84W` a\x02\xF0`\x045a\x03\x19a\x160V[a\x03#\x81\x83a\x19tV[\x91_R`\x17\x84Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R\x83R`@_ T\x90a\x17SV[4a\x02\x84Wa\x03b6a\x170V[\x90_R`\x0F` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x03\xB1a\x16SV[\x16_R`\x15` R`@_ `$5_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84Wa\x03\xEDa\x16SV[a\x03\xF5a%\x01V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x81\x15a\x04\x98Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90t\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0`\x01T\x91`\x08\x1B\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xFF\x82\x16\x17`\x01U`\x08\x1C\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0_\x80\xA3\0[\x7F\x1EO\xBD\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R_`\x04R`$_\xFD[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02\x84W6`#\x82\x01\x12\x15a\x02\x84W\x80`\x04\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02\x84W`$\x82\x01\x91`$6\x91\x83`\x06\x1B\x01\x01\x11a\x02\x84Wa\x05\"a\x160V[\x90a\x05+a!/V[\x80\x15a\x06\rW\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_[\x82\x81\x10a\x05WW`\x01_U\0[` a\x05d\x82\x85\x87a\x1F{V[\x015\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x80\x92\x03a\x02\x84Wa\x05\x90\x81\x85\x87a\x1F{V[5\x82;\x15a\x02\x84W_\x92`d\x84\x92`@Q\x95\x86\x93\x84\x92\x7Fi\xBC'G\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84R`\x04\x84\x01R3`$\x84\x01R\x88`D\x84\x01RZ\xF1\x91\x82\x15a\x06\x02W`\x01\x92a\x05\xF2W[P\x01a\x05JV[_a\x05\xFC\x91a\x1F\x8BV[\x85a\x05\xEBV[`@Q=_\x82>=\x90\xFD[\x7F\xBB\xCD?3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84Wa\x02\x82`\x045a\x1E\xA0V[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84Wa\x06ja\x160V[`\x045_R`\x17` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84Wa\x02\x82a\x06\xB46a\x170V[\x90a\x1CvV[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x06\xE8a\x16SV[\x16_R`\x07` R` `@_ T`@Q\x90\x81R\xF3[```\x03\x196\x01\x12a\x02\x84W`$5`\x045`D5a\x07\x1Ca!/V[a\x07$a\"YV[\x80\x15a\t\xB1W\x81\x15\x80\x15a\t\xA9W[a\t\x81W3_R`\x11` R`@_ \x82_R` R\x80`@_ T\x10a\tYW\x7F\xB3\x12\x90<\xE2\x07\xD2\x1E\x84\xE5}\x10\x05\xE0\xAAS\x85\xB7\x83\xEB'\xE2X\x81qt\xD0\x0C\xFB\xBC2x\x92`\xA0\x92a\x07\x81a\x1B\x1AV[\x923_R`\x0B` R\x83`@_ T\x10a\tKW[\x81_R`\x10` R\x83`@_ T\x10a\t=W[3_R`\x15` R`@_ \x82_R` R\x83`@_ T\x10a\t.W[\x83_R`\x12` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x82_R` R`@_ a\x08\t\x82\x82Ta\x17SV[\x90U\x83_R`\r` R`@_ \x82_R` R`@_ a\x08,\x82\x82Ta\x17SV[\x90U3_R`\x11` R`@_ \x82_R` R`@_ a\x08O\x82\x82Ta\x17FV[\x90U\x81_R`\x0C` R`@_ a\x08h\x82\x82Ta\x17FV[\x90U\x83_R`\x13` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x83_R` R`@_ a\x08\xAB\x82\x82Ta\x17SV[\x90U\x83_R`\x0E` R`@_ \x83_R` R`@_ a\x08\xCE\x82\x82Ta\x17SV[\x90U3_R`\x11` R`@_ \x83_R` R`@_ a\x08\xF1\x82\x82Ta\x17SV[\x90U\x82_R`\x0C` R`@_ a\t\n\x82\x82Ta\x17SV[\x90U`@Q\x93\x84R3` \x85\x01R`@\x84\x01R``\x83\x01R`\x80\x82\x01R\xA1`\x01_U\0[a\t8\x823a\x18+V[a\x07\xC8V[a\tF\x82a\x1E\xA0V[a\x07\xAAV[a\tT3a\x1A)V[a\x07\x96V[\x7F\xF1\xBC\x94\xD2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\xF6\xB4\x13\x1C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[P\x82\x15a\x073V[\x7F,R\x11\xC6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W` a\x02\xF0`\x045a\x1CJV[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02\x84Wa\n(\x906\x90`\x04\x01a\x16vV[a\n0a!/V[_[\x81\x81\x10a\n?W`\x01_U\0[\x80a\nza\nP`\x01\x93\x85\x87a\x17`V[5a\n\\\x83\x86\x88a\x17`V[53_R`\x11` R`@_ \x90_R` R`@_ T\x90a\x1CvV[\x01a\n2V[4a\x02\x84W` a\x02\xF0a\n\x936a\x16\xF9V[\x91a\x1BXV[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84W` a\x02\xF0a\x1B\x1AV[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84W` `@Qb'\x8D\0\x81R\xF3[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\n\xFEa\x16SV[\x16_R`\x11` R`@_ `$5_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84Wa\x02\x82a\x0B=a\x16SV[a\x1A)V[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84W` a\x02\xF0a\x0B`a\x160V[`\x045a\x19tV[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01T`\x08\x1C\x16`@Q\x90\x81R\xF3[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W`\x045_R`\x05` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84W` `\x02T`@Q\x90\x81R\xF3[a\x0B\xEE6a\x16\xA7V[a\x0B\xF9\x93\x92\x93a\"YV[\x80\x84\x03a\x0C\x91W\x92\x91\x90_\x93_\x93[\x80\x85\x10a\x0CHW\x854\x81\x03a\x0C\x19W\0[\x7F\xA2\xDD \xEF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R4`$R`D_\xFD[\x90\x91\x92\x93\x94a\x0Ce`\x01\x91a\x0C^\x88\x86\x88a\x17`V[5\x90a\x17SV[\x95a\x0C\x87a\x0Ct\x82\x85\x89a\x17`V[5a\x0C\x80\x83\x87\x89a\x17`V[5\x90a\"\x8DV[\x01\x93\x92\x91\x90a\x0C\x08V[\x7F\xB4\xFA?\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84Wa\x0C\xD1a%\x01V[a\x0C\xD9a\"YV[`\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x81T\x16\x17`\x01U\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X` `@Q3\x81R\xA1\0[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84Wa\x02\x82a\rKa\x16SV[`$5\x90a\x18+V[4a\x02\x84Wa\rb6a\x170V[\x90_R`\x0E` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\r\xB1a\x16SV[\x16_R`\x0B` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84Wa\r\xD66a\x170V[\x90_R`\r` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84W` `@Qch\x8DF\xF0\x81R\xF3[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84Wa\x0E-a%\x01V[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xFF\x81\x16`\x01U`\x08\x1C\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x82\x80\xA3\0[4a\x02\x84Wa\x0E\xA46a\x16\xF9V[\x91_R`\x13` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84Wa\x02\x82`\x0453_R`\x11` R`@_ \x81_R` R`@_ T\x90a\x1CvV[4a\x02\x84Wa\x0F'6a\x16\xF9V[\x91_R`\x12` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84Wa\x0F\x81a\x160V[`\x045_R`\n` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84W` `\xFF`\x01T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02\x84Wa\x10\r\x906\x90`\x04\x01a\x16vV[a\x10\x15a\x160V[_\x91\x82\x903\x90[\x80\x83\x10a\x10\x97W\x7F\xB0\x03\x82 ;F\xC3\xB6\xAD\n-z\xF0&\x8E3K\xD9@bV\xA7\xC7\xBA\x8F\x7F\xC8\xBCG\xF8\xCD\xE9\x85\x85a\x10f\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16a!fV[`@\x80Q3\x81Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x90\x92\x16` \x83\x01R\x81\x01\x91\x90\x91R``\x90\xA1\0[\x90\x91\x93a\x10\xA5\x85\x83\x88a\x17`V[5a\x10\xAEa\x1B\x1AV[\x81\x10\x15a\x11/W\x80_R`\n` R`@_ \x84_R` R`@_ T\x80\x15a\x11\x07W`\x01\x92a\x10\xFE\x92a\x10\xE23a\x1A)V[_R`\n` R`@_ \x86_R` R_`@\x81 Ua\x17SV[\x94\x01\x91\x90a\x10\x1CV[\x7F\xC9E$-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\x0F,\xA6\xE7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W` a\x02\xF0`\x045a\x17\x9DV[4a\x02\x84Wa\x11\x836a\x16\xA7V[\x90a\x11\x8Ca!/V[\x81\x83\x03a\x11\x07W_[\x83\x81\x10a\x11\xA2W`\x01_U\0[\x80a\x11\xC6a\x11\xB3`\x01\x93\x87\x89a\x17`V[5a\x11\xBF\x83\x87\x87a\x17`V[5\x90a\x1CvV[\x01a\x11\x95V[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W` a\x02\xF0`\x045a\x11\xEE\x81a\x17\x9DV[\x90_R`\x16\x83R`@_ T\x90a\x17SV[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84Wa\x12\x18a%\x01V[`\x01T`\xFF\x81\x16\x15a\x12uW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x16`\x01U\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA` `@Q3\x81R\xA1\0[\x7F\x8D\xFC +\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W`\x045_R`\x10` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W`\x045_R`\x03` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84Wa\x13\na\x160V[`\x045_R`\t` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W_`\x03\x196\x01\x12a\x02\x84W` `\x06T`@Q\x90\x81R\xF3[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W`\x045_R`\x16` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W`\x045_R`\x0C` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W`\x045_R`\x04` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84Wa\x13\xF7a\x160V[`\x045_R`\x08` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[` `\x03\x196\x01\x12a\x02\x84Wa\x14Da\"YV[a\x02\x824`\x045a\"\x8DV[4a\x02\x84W` `\x03\x196\x01\x12a\x02\x84W`\x045\x80\x15a\x14\xF4W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x01\x90\x81\x11a\x14\xC7Wb'\x8D\0\x81\x02\x90\x80\x82\x04b'\x8D\0\x14\x90\x15\x17\x15a\x14\xC7Wch\x8DF\xF0\x01\x80ch\x8DF\xF0\x11a\x14\xC7W` \x90`@Q\x90\x81R\xF3[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[\x7F\xD6\x93h\xD4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02\x84W`@`\x03\x196\x01\x12a\x02\x84W`\x045a\x158a\x160V[a\x15@a!/V[a\x15Ha\x1B\x1AV[\x82\x10\x15a\x11/W\x81_R`\n` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ T\x90\x81\x15a\x11\x07W\x7F\xB0\x03\x82 ;F\xC3\xB6\xAD\n-z\xF0&\x8E3K\xD9@bV\xA7\xC7\xBA\x8F\x7F\xC8\xBCG\xF8\xCD\xE9\x92a\x15\xAE3a\x1A)V[_R`\n` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R_`@\x81 Ua\x15\xFB\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16a!fV[`@\x80Q3\x81Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x90\x92\x16` \x83\x01R\x81\x01\x91\x90\x91R``\x90\xA1`\x01_U\0[`$5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x02\x84WV[`\x045\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x02\x84WV[\x91\x81`\x1F\x84\x01\x12\x15a\x02\x84W\x825\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x02\x84W` \x80\x85\x01\x94\x84`\x05\x1B\x01\x01\x11a\x02\x84WV[`@`\x03\x19\x82\x01\x12a\x02\x84W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02\x84W\x81a\x16\xD2\x91`\x04\x01a\x16vV[\x92\x90\x92\x91`$5\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x02\x84Wa\x16\xF5\x91`\x04\x01a\x16vV[\x90\x91V[`\x03\x19``\x91\x01\x12a\x02\x84W`\x045\x90`$5s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x02\x84W\x90`D5\x90V[`\x03\x19`@\x91\x01\x12a\x02\x84W`\x045\x90`$5\x90V[\x91\x90\x82\x03\x91\x82\x11a\x14\xC7WV[\x91\x90\x82\x01\x80\x92\x11a\x14\xC7WV[\x91\x90\x81\x10\x15a\x17pW`\x05\x1B\x01\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[`\x06T\x81\x10a\x17\xEFWa\x17\xEC\x90a\x17\xD9a\x17\xC6`\x02T\x83_R`\x03` R`@_ T\x90a\x17SV[\x82_R`\x05` R`@_ T\x90a\x17SV[\x90_R`\x04` R`@_ T\x90a\x17FV[\x90V[_R`\x03` R`@_ T\x90V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x14a\x14\xC7W`\x01\x01\x90V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x18Ia\x1B\x1AV[\x92\x16\x80_R`\x15` R`@_ \x82_R` R`@_ T\x92[\x80\x84\x10a\x18\x84WP_R`\x15` R`@_ \x90_R` R`@_ UV[\x92a\x19n\x90\x82_R`\x11` R`@_ \x84_R` R`@_ T\x81_R`\x12` R`@_ \x84_R` R`@_ \x85_R` Ra\x18\xCB`@_ \x91\x82Ta\x17SV[\x90U\x80_R`\x14` R`@_ \x83_R` R`@_ \x84_R` R`@_ T\x81_R`\x12` R`@_ \x84_R` R`@_ \x85_R` Ra\x19\x19`@_ \x91\x82Ta\x17SV[\x90U\x80_R`\x13` R`@_ \x83_R` R`@_ \x84_R` R`@_ T\x81_R`\x12` R`@_ \x84_R` R`@_ \x85_R` Ra\x19g`@_ \x91\x82Ta\x17FV[\x90Ua\x17\xFEV[\x92a\x18dV[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81_R`\x0B` R`@_ T\x81\x10\x15_\x14a\x1A\x10W\x81a\x17\xEC\x92_R`\x07` Ra\x19\xF3a\x19\xD6`@_ T\x84_R`\x08` R`@_ \x84_R` R`@_ T\x90a\x17SV[\x83_R`\n` R`@_ \x83_R` R`@_ T\x90a\x17SV[\x91_R`\t` R`@_ \x90_R` R`@_ T\x90a\x17FV[_R`\x08` R`@_ \x90_R` R`@_ T\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x1AFa\x1B\x1AV[\x91\x16\x80_R`\x0B` R`@_ T\x91[\x80\x83\x10a\x1AmWP_R`\x0B` R`@_ UV[\x91a\x1B\x14\x90\x82_R`\x07` R`@_ T\x81_R`\x08` R`@_ \x84_R` Ra\x1A\xA0`@_ \x91\x82Ta\x17SV[\x90U\x80_R`\n` R`@_ \x83_R` R`@_ T\x81_R`\x08` R`@_ \x84_R` Ra\x1A\xDA`@_ \x91\x82Ta\x17SV[\x90U\x80_R`\t` R`@_ \x83_R` R`@_ T\x81_R`\x08` R`@_ \x84_R` Ra\x19g`@_ \x91\x82Ta\x17FV[\x91a\x1AWV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x97r\xB9\x10B\x01B\x81\x11a\x14\xC7Wb'\x8D\0\x90\x04`\x01\x81\x01\x80\x91\x11a\x14\xC7W\x90V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80_R`\x15` R`@_ \x83_R` R`@_ T\x82\x10\x15_\x14a\x1C&W\x91\x82a\x17\xEC\x93_R`\x11` R`@_ \x82_R` Ra\x1B\xFFa\x1B\xD8`@_ T\x85_R`\x12` R`@_ \x84_R` R`@_ \x85_R` R`@_ T\x90a\x17SV[\x84_R`\x14` R`@_ \x83_R` R`@_ \x84_R` R`@_ T\x90a\x17SV[\x92_R`\x13` R`@_ \x90_R` R`@_ \x90_R` R`@_ T\x90a\x17FV[\x90_R`\x12` R`@_ \x90_R` R`@_ \x90_R` R`@_ T\x90V[\x80\x15a\x14\xF4Wb'\x8D\0\x81\x02\x90\x81\x04b'\x8D\0\x03a\x14\xC7Wch\x8DF\xF0\x01\x80ch\x8DF\xF0\x11a\x14\xC7W\x90V[\x90\x80\x15a\t\xB1W\x81\x15a\t\x81W3_R`\x11` R`@_ \x82_R` R`@_ T\x81\x11\x80\x15a\x1E\x8BW[a\tYW\x7F\x8B\xD4r\x8E\xE9\xCA?\x99\xDD\xCF\xFA$\xEBO\x15\xDE\x01\\\xDA\x9A'\xCC\xC4'\xDF\xDA\xF7\x11\x94>\xBC\xA0\x91``\x91a\x1C\xD4a\x1B\x1AV[\x80`\x06T\x10a\x1E~W[3_R`\x0B` R\x80`@_ T\x10a\x1EpW[\x82_R`\x10` R\x80`@_ T\x10a\x1EbW[3_R`\x15` R`@_ \x83_R` R\x80`@_ T\x10a\x1ESW[\x80_R`\x05` R`@_ a\x1D;\x83\x82Ta\x17SV[\x90U\x80_R`\n` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ a\x1Dt\x83\x82Ta\x17SV[\x90U\x80_R`\x0F` R`@_ \x83_R` R`@_ a\x1D\x97\x83\x82Ta\x17SV[\x90U_R`\x14` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x82_R` R`@_ a\x1D\xD9\x82\x82Ta\x17SV[\x90Ua\x1D\xE7\x81`\x02Ta\x17FV[`\x02U3_R`\x07` R`@_ a\x1E\x01\x82\x82Ta\x17FV[\x90U\x81_R`\x0C` R`@_ a\x1E\x1A\x82\x82Ta\x17FV[\x90U3_R`\x11` R`@_ \x82_R` R`@_ a\x1E=\x82\x82Ta\x17FV[\x90U`@Q\x913\x83R` \x83\x01R`@\x82\x01R\xA1V[a\x1E]\x833a\x18+V[a\x1D$V[a\x1Ek\x83a\x1E\xA0V[a\x1D\x06V[a\x1Ey3a\x1A)V[a\x1C\xF2V[a\x1E\x86a \x94V[a\x1C\xDEV[P3_R`\x07` R`@_ T\x81\x11a\x1C\xA3V[a\x1E\xA8a\x1B\x1AV[\x90\x80_R`\x10` R`@_ T\x91[\x80\x83\x10a\x1E\xCEWP_R`\x10` R`@_ UV[\x91a\x1Fu\x90\x82_R`\x0C` R`@_ T\x81_R`\r` R`@_ \x84_R` Ra\x1F\x01`@_ \x91\x82Ta\x17SV[\x90U\x80_R`\x0F` R`@_ \x83_R` R`@_ T\x81_R`\r` R`@_ \x84_R` Ra\x1F;`@_ \x91\x82Ta\x17SV[\x90U\x80_R`\x0E` R`@_ \x83_R` R`@_ T\x81_R`\r` R`@_ \x84_R` Ra\x19g`@_ \x91\x82Ta\x17FV[\x91a\x1E\xB8V[\x91\x90\x81\x10\x15a\x17pW`\x06\x1B\x01\x90V[\x90`\x1F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x1F\xCCW`@RV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[_\x82\x81R`\x10` R`@\x90 T\x81\x10a {W\x81a\x17\xEC\x92_R`\x0C` Ra ^a A`@_ T\x84_R`\r` R`@_ \x84_R` R`@_ T\x90a\x17SV[\x83_R`\x0F` R`@_ \x83_R` R`@_ T\x90a\x17SV[\x91_R`\x0E` R`@_ \x90_R` R`@_ T\x90a\x17FV[_R`\r` R`@_ \x90_R` R`@_ T\x90V[a \x9Ca\x1B\x1AV[\x90[`\x06T\x82\x81\x10\x15a!*W`\x02T\x90_R`\x03` Ra \xC3`@_ \x91\x82Ta\x17SV[\x90U`\x06T\x80_R`\x05` R`@_ T\x90_R`\x03` Ra \xEC`@_ \x91\x82Ta\x17SV[\x90U`\x06T\x80_R`\x04` R`@_ T\x90_R`\x03` Ra!\x15`@_ \x91\x82Ta\x17FV[\x90Ua!\"`\x06Ta\x17\xFEV[`\x06Ua \x9EV[P\x90PV[`\x02_T\x14a!>W`\x02_UV[\x7F>\xE5\xAE\xB5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x81G\x10a\")W_\x80\x80\x93s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x94\x16Z\xF1=\x15a\"!W=\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x1F\xCCW`@Q\x91a!\xD8` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x84\x01\x16\x01\x84a\x1F\x8BV[\x82R=_` \x84\x01>[\x15a!\xEAWPV[\x80Q\x15a!\xF9W\x80Q\x90` \x01\xFD[\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[``\x90a!\xE2V[PG\x7F\xCFG\x91\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$R`D_\xFD[`\xFF`\x01T\x16a\"eWV[\x7F\xD9<\x06e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x81\x15a\t\xB1W\x80\x15a\t\x81Wa\"\xA1a\x1B\x1AV[\x80`\x06T\x10a$\xF4W[3_R`\x0B` R\x80`@_ T\x10a$\xE6W[\x81_R`\x10` R\x80`@_ T\x10a$\xD8W[3_R`\x15` R`@_ \x82_R` R\x80`@_ T\x10a$\xC9W[a#\x0Ba#\x04a\"\xFFa\x1B\x1AV[a\x1CJV[B\x90a\x17FV[\x91\x82\x84\x02\x92\x84\x84\x04\x03a\x14\xC7W\x7FPz\xC3\x9E\xB36\x10\x19\x1C\xD8\xFDT(n\x91\xC5\xCCFL&(ad;\xE3\x97\x8FZ\x9F\x18\xAB\x02\x93b'\x8D\0`\x80\x94\x04\x83_R`\x16` R`@_ a#Y\x82\x82Ta\x17SV[\x90U\x83_R`\x17` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` Ra#\x92`@_ \x91\x82Ta\x17SV[\x90U\x82_R`\x04` R`@_ a#\xAB\x82\x82Ta\x17SV[\x90Ua#\xB9\x81`\x02Ta\x17SV[`\x02U\x82_R`\t` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ a#\xF3\x82\x82Ta\x17SV[\x90U3_R`\x07` R`@_ a$\x0C\x82\x82Ta\x17SV[\x90U\x82_R`\x0E` R`@_ \x82_R` R`@_ a$/\x82\x82Ta\x17SV[\x90U\x81_R`\x0C` R`@_ a$H\x82\x82Ta\x17SV[\x90U\x82_R`\x13` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x82_R` R`@_ a$\x8B\x82\x82Ta\x17SV[\x90U3_R`\x11` R`@_ \x82_R` R`@_ a$\xAE\x82\x82Ta\x17SV[\x90U`@Q\x92\x83R3` \x84\x01R`@\x83\x01R``\x82\x01R\xA1V[a$\xD3\x823a\x18+V[a\"\xF1V[a$\xE1\x82a\x1E\xA0V[a\"\xD3V[a$\xEF3a\x1A)V[a\"\xBFV[a$\xFCa \x94V[a\"\xABV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01T`\x08\x1C\x163\x03a%%WV[\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R3`\x04R`$_\xFD",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct ClaimRequest { uint256 epochIndex; address poolAddress; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ClaimRequest {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub poolAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ClaimRequest> for UnderlyingRustTuple<'_> {
            fn from(value: ClaimRequest) -> Self {
                (value.epochIndex, value.poolAddress)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ClaimRequest {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    epochIndex: tuple.0,
                    poolAddress: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ClaimRequest {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ClaimRequest {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.poolAddress,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ClaimRequest {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ClaimRequest {
            const NAME: &'static str = "ClaimRequest";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ClaimRequest(uint256 epochIndex,address poolAddress)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.epochIndex)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.poolAddress,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ClaimRequest {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.epochIndex,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.poolAddress,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.epochIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.poolAddress,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `EnforcedPause()` and selector `0xd93c0665`.
```solidity
error EnforcedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EnforcedPause;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EnforcedPause> for UnderlyingRustTuple<'_> {
            fn from(value: EnforcedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EnforcedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EnforcedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EnforcedPause()";
            const SELECTOR: [u8; 4] = [217u8, 60u8, 6u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ExpectedPause()` and selector `0x8dfc202b`.
```solidity
error ExpectedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExpectedPause;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExpectedPause> for UnderlyingRustTuple<'_> {
            fn from(value: ExpectedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExpectedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExpectedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExpectedPause()";
            const SELECTOR: [u8; 4] = [141u8, 252u8, 32u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedCall()` and selector `0xd6bda275`.
```solidity
error FailedCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedCall;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedCall()";
            const SELECTOR: [u8; 4] = [214u8, 189u8, 162u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientBalance(uint256,uint256)` and selector `0xcf479181`.
```solidity
error InsufficientBalance(uint256 balance, uint256 needed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientBalance {
        #[allow(missing_docs)]
        pub balance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientBalance> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientBalance) -> Self {
                (value.balance, value.needed)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    balance: tuple.0,
                    needed: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientBalance(uint256,uint256)";
            const SELECTOR: [u8; 4] = [207u8, 71u8, 145u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.needed),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientStake()` and selector `0xf1bc94d2`.
```solidity
error InsufficientStake();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientStake;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientStake> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientStake) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientStake {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientStake {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientStake()";
            const SELECTOR: [u8; 4] = [241u8, 188u8, 148u8, 210u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidAmount()` and selector `0x2c5211c6`.
```solidity
error InvalidAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidAmount;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidAmount> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidAmount()";
            const SELECTOR: [u8; 4] = [44u8, 82u8, 17u8, 198u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidAppchainId()` and selector `0xf6b4131c`.
```solidity
error InvalidAppchainId();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidAppchainId;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidAppchainId> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidAppchainId) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidAppchainId {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidAppchainId {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidAppchainId()";
            const SELECTOR: [u8; 4] = [246u8, 180u8, 19u8, 28u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidInput()` and selector `0xb4fa3fb3`.
```solidity
error InvalidInput();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidInput;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidInput> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidInput) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidInput {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidInput {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidInput()";
            const SELECTOR: [u8; 4] = [180u8, 250u8, 63u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidStakingAmount(uint256,uint256)` and selector `0xa2dd20ef`.
```solidity
error InvalidStakingAmount(uint256 totalAmount, uint256 sentAmount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidStakingAmount {
        #[allow(missing_docs)]
        pub totalAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub sentAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidStakingAmount> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidStakingAmount) -> Self {
                (value.totalAmount, value.sentAmount)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidStakingAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    totalAmount: tuple.0,
                    sentAmount: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidStakingAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidStakingAmount(uint256,uint256)";
            const SELECTOR: [u8; 4] = [162u8, 221u8, 32u8, 239u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalAmount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.sentAmount),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidWithdrawal()` and selector `0xc945242d`.
```solidity
error InvalidWithdrawal();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidWithdrawal;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidWithdrawal> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidWithdrawal) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidWithdrawal {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidWithdrawal {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidWithdrawal()";
            const SELECTOR: [u8; 4] = [201u8, 69u8, 36u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NoClaimsProvided()` and selector `0xbbcd3f33`.
```solidity
error NoClaimsProvided();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoClaimsProvided;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoClaimsProvided> for UnderlyingRustTuple<'_> {
            fn from(value: NoClaimsProvided) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NoClaimsProvided {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoClaimsProvided {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoClaimsProvided()";
            const SELECTOR: [u8; 4] = [187u8, 205u8, 63u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OwnableInvalidOwner(address)` and selector `0x1e4fbdf7`.
```solidity
error OwnableInvalidOwner(address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableInvalidOwner {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableInvalidOwner> for UnderlyingRustTuple<'_> {
            fn from(value: OwnableInvalidOwner) -> Self {
                (value.owner,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OwnableInvalidOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { owner: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableInvalidOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableInvalidOwner(address)";
            const SELECTOR: [u8; 4] = [30u8, 79u8, 189u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OwnableUnauthorizedAccount(address)` and selector `0x118cdaa7`.
```solidity
error OwnableUnauthorizedAccount(address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: OwnableUnauthorizedAccount) -> Self {
                (value.account,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OwnableUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { account: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableUnauthorizedAccount(address)";
            const SELECTOR: [u8; 4] = [17u8, 140u8, 218u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ReentrancyGuardReentrantCall()` and selector `0x3ee5aeb5`.
```solidity
error ReentrancyGuardReentrantCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ReentrancyGuardReentrantCall;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ReentrancyGuardReentrantCall>
        for UnderlyingRustTuple<'_> {
            fn from(value: ReentrancyGuardReentrantCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ReentrancyGuardReentrantCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ReentrancyGuardReentrantCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ReentrancyGuardReentrantCall()";
            const SELECTOR: [u8; 4] = [62u8, 229u8, 174u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `WithdrawalNotReady()` and selector `0x0f2ca6e7`.
```solidity
error WithdrawalNotReady();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct WithdrawalNotReady;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<WithdrawalNotReady> for UnderlyingRustTuple<'_> {
            fn from(value: WithdrawalNotReady) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for WithdrawalNotReady {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for WithdrawalNotReady {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "WithdrawalNotReady()";
            const SELECTOR: [u8; 4] = [15u8, 44u8, 166u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ZeroEpochIndex()` and selector `0xd69368d4`.
```solidity
error ZeroEpochIndex();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroEpochIndex;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroEpochIndex> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroEpochIndex) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroEpochIndex {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroEpochIndex {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroEpochIndex()";
            const SELECTOR: [u8; 4] = [214u8, 147u8, 104u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Paused(address)` and selector `0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258`.
```solidity
event Paused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Paused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Paused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Paused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                98u8, 231u8, 140u8, 234u8, 1u8, 190u8, 227u8, 32u8, 205u8, 78u8, 66u8,
                2u8, 112u8, 181u8, 234u8, 116u8, 0u8, 13u8, 17u8, 176u8, 201u8, 247u8,
                71u8, 84u8, 235u8, 219u8, 252u8, 84u8, 75u8, 5u8, 162u8, 88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Paused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Paused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Paused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Stake(uint256,address,uint256,uint256)` and selector `0x507ac39eb33610191cd8fd54286e91c5cc464c262861643be3978f5a9f18ab02`.
```solidity
event Stake(uint256 epochIndex, address user, uint256 amount, uint256 appchainId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Stake {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Stake {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Stake(uint256,address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                80u8, 122u8, 195u8, 158u8, 179u8, 54u8, 16u8, 25u8, 28u8, 216u8, 253u8,
                84u8, 40u8, 110u8, 145u8, 197u8, 204u8, 70u8, 76u8, 38u8, 40u8, 97u8,
                100u8, 59u8, 227u8, 151u8, 143u8, 90u8, 159u8, 24u8, 171u8, 2u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    epochIndex: data.0,
                    user: data.1,
                    amount: data.2,
                    appchainId: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Stake {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Stake> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Stake) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `StakeTransfer(uint256,address,uint256,uint256,uint256)` and selector `0xb312903ce207d21e84e57d1005e0aa5385b783eb27e258817174d00cfbbc3278`.
```solidity
event StakeTransfer(uint256 epochIndex, address user, uint256 amount, uint256 fromAppchainId, uint256 toAppchainId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct StakeTransfer {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub fromAppchainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub toAppchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for StakeTransfer {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "StakeTransfer(uint256,address,uint256,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                179u8, 18u8, 144u8, 60u8, 226u8, 7u8, 210u8, 30u8, 132u8, 229u8, 125u8,
                16u8, 5u8, 224u8, 170u8, 83u8, 133u8, 183u8, 131u8, 235u8, 39u8, 226u8,
                88u8, 129u8, 113u8, 116u8, 208u8, 12u8, 251u8, 188u8, 50u8, 120u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    epochIndex: data.0,
                    user: data.1,
                    amount: data.2,
                    fromAppchainId: data.3,
                    toAppchainId: data.4,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.fromAppchainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.toAppchainId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for StakeTransfer {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&StakeTransfer> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &StakeTransfer) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Unpaused(address)` and selector `0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa`.
```solidity
event Unpaused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Unpaused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Unpaused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Unpaused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8, 185u8, 238u8, 10u8, 73u8, 91u8, 242u8, 230u8, 255u8, 156u8, 145u8,
                167u8, 131u8, 76u8, 27u8, 164u8, 253u8, 210u8, 68u8, 165u8, 232u8, 170u8,
                78u8, 83u8, 123u8, 211u8, 138u8, 234u8, 228u8, 176u8, 115u8, 170u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Unpaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Unpaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Unpaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `WithdrawalCompleted(address,address,uint256)` and selector `0xb00382203b46c3b6ad0a2d7af0268e334bd9406256a7c7ba8f7fc8bc47f8cde9`.
```solidity
event WithdrawalCompleted(address user, address destination, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct WithdrawalCompleted {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub destination: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for WithdrawalCompleted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "WithdrawalCompleted(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                176u8, 3u8, 130u8, 32u8, 59u8, 70u8, 195u8, 182u8, 173u8, 10u8, 45u8,
                122u8, 240u8, 38u8, 142u8, 51u8, 75u8, 217u8, 64u8, 98u8, 86u8, 167u8,
                199u8, 186u8, 143u8, 127u8, 200u8, 188u8, 71u8, 248u8, 205u8, 233u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    user: data.0,
                    destination: data.1,
                    amount: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.destination,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for WithdrawalCompleted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&WithdrawalCompleted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &WithdrawalCompleted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `WithdrawalInitialized(address,uint256,uint256)` and selector `0x8bd4728ee9ca3f99ddcffa24eb4f15de015cda9a27ccc427dfdaf711943ebca0`.
```solidity
event WithdrawalInitialized(address user, uint256 appchainId, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct WithdrawalInitialized {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for WithdrawalInitialized {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "WithdrawalInitialized(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8, 212u8, 114u8, 142u8, 233u8, 202u8, 63u8, 153u8, 221u8, 207u8,
                250u8, 36u8, 235u8, 79u8, 21u8, 222u8, 1u8, 92u8, 218u8, 154u8, 39u8,
                204u8, 196u8, 39u8, 223u8, 218u8, 247u8, 17u8, 148u8, 62u8, 188u8, 160u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    user: data.0,
                    appchainId: data.1,
                    amount: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for WithdrawalInitialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&WithdrawalInitialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &WithdrawalInitialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address _defaultAdmin);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub _defaultAdmin: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value._defaultAdmin,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _defaultAdmin: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._defaultAdmin,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `EPOCH_DURATION()` and selector `0xa70b9f0c`.
```solidity
function EPOCH_DURATION() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EPOCH_DURATIONCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`EPOCH_DURATION()`](EPOCH_DURATIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EPOCH_DURATIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EPOCH_DURATIONCall> for UnderlyingRustTuple<'_> {
                fn from(value: EPOCH_DURATIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for EPOCH_DURATIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EPOCH_DURATIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EPOCH_DURATIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EPOCH_DURATIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EPOCH_DURATIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EPOCH_DURATION()";
            const SELECTOR: [u8; 4] = [167u8, 11u8, 159u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: EPOCH_DURATIONReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: EPOCH_DURATIONReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `START_TIMESTAMP()` and selector `0x781cd99d`.
```solidity
function START_TIMESTAMP() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct START_TIMESTAMPCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`START_TIMESTAMP()`](START_TIMESTAMPCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct START_TIMESTAMPReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<START_TIMESTAMPCall> for UnderlyingRustTuple<'_> {
                fn from(value: START_TIMESTAMPCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for START_TIMESTAMPCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<START_TIMESTAMPReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: START_TIMESTAMPReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for START_TIMESTAMPReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for START_TIMESTAMPCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "START_TIMESTAMP()";
            const SELECTOR: [u8; 4] = [120u8, 28u8, 217u8, 157u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: START_TIMESTAMPReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: START_TIMESTAMPReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `appchainFinalizedEpochCount(uint256)` and selector `0x3ba00fae`.
```solidity
function appchainFinalizedEpochCount(uint256 appchainId) external view returns (uint256 finalizedEpochCount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appchainFinalizedEpochCountCall {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`appchainFinalizedEpochCount(uint256)`](appchainFinalizedEpochCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appchainFinalizedEpochCountReturn {
        #[allow(missing_docs)]
        pub finalizedEpochCount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appchainFinalizedEpochCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: appchainFinalizedEpochCountCall) -> Self {
                    (value.appchainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for appchainFinalizedEpochCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { appchainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appchainFinalizedEpochCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: appchainFinalizedEpochCountReturn) -> Self {
                    (value.finalizedEpochCount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for appchainFinalizedEpochCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        finalizedEpochCount: tuple.0,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for appchainFinalizedEpochCountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "appchainFinalizedEpochCount(uint256)";
            const SELECTOR: [u8; 4] = [59u8, 160u8, 15u8, 174u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: appchainFinalizedEpochCountReturn = r.into();
                        r.finalizedEpochCount
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: appchainFinalizedEpochCountReturn = r.into();
                        r.finalizedEpochCount
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `appchainTotal(uint256)` and selector `0x1057e9bc`.
```solidity
function appchainTotal(uint256 appchainId) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appchainTotalCall {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`appchainTotal(uint256)`](appchainTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appchainTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appchainTotalCall> for UnderlyingRustTuple<'_> {
                fn from(value: appchainTotalCall) -> Self {
                    (value.appchainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for appchainTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { appchainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appchainTotalReturn> for UnderlyingRustTuple<'_> {
                fn from(value: appchainTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for appchainTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for appchainTotalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "appchainTotal(uint256)";
            const SELECTOR: [u8; 4] = [16u8, 87u8, 233u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: appchainTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: appchainTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `claimAllRewards((uint256,address)[],address)` and selector `0xf156e06f`.
```solidity
function claimAllRewards(ClaimRequest[] memory claims, address destination) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAllRewardsCall {
        #[allow(missing_docs)]
        pub claims: alloy::sol_types::private::Vec<
            <ClaimRequest as alloy::sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub destination: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`claimAllRewards((uint256,address)[],address)`](claimAllRewardsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAllRewardsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<ClaimRequest>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    <ClaimRequest as alloy::sol_types::SolType>::RustType,
                >,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAllRewardsCall> for UnderlyingRustTuple<'_> {
                fn from(value: claimAllRewardsCall) -> Self {
                    (value.claims, value.destination)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claimAllRewardsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        claims: tuple.0,
                        destination: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAllRewardsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAllRewardsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAllRewardsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl claimAllRewardsReturn {
            fn _tokenize(
                &self,
            ) -> <claimAllRewardsCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAllRewardsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<ClaimRequest>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAllRewardsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAllRewards((uint256,address)[],address)";
            const SELECTOR: [u8; 4] = [241u8, 86u8, 224u8, 111u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        ClaimRequest,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.destination,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                claimAllRewardsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochAdditions(uint256)` and selector `0x0b281bf8`.
```solidity
function epochAdditions(uint256 epochIndex) external view returns (uint256 additions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAdditionsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochAdditions(uint256)`](epochAdditionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAdditionsReturn {
        #[allow(missing_docs)]
        pub additions: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAdditionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: epochAdditionsCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for epochAdditionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAdditionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAdditionsReturn) -> Self {
                    (value.additions,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAdditionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { additions: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochAdditionsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochAdditions(uint256)";
            const SELECTOR: [u8; 4] = [11u8, 40u8, 27u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochAdditionsReturn = r.into();
                        r.additions
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochAdditionsReturn = r.into();
                        r.additions
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochAppchainAdditions(uint256,uint256)` and selector `0x7c6eaaee`.
```solidity
function epochAppchainAdditions(uint256 epochIndex, uint256 appchainId) external view returns (uint256 additions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainAdditionsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochAppchainAdditions(uint256,uint256)`](epochAppchainAdditionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainAdditionsReturn {
        #[allow(missing_docs)]
        pub additions: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainAdditionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainAdditionsCall) -> Self {
                    (value.epochIndex, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainAdditionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainAdditionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainAdditionsReturn) -> Self {
                    (value.additions,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainAdditionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { additions: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochAppchainAdditionsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochAppchainAdditions(uint256,uint256)";
            const SELECTOR: [u8; 4] = [124u8, 110u8, 170u8, 238u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochAppchainAdditionsReturn = r.into();
                        r.additions
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochAppchainAdditionsReturn = r.into();
                        r.additions
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochAppchainTotal(uint256,uint256)` and selector `0x7bda1cfb`.
```solidity
function epochAppchainTotal(uint256 epochIndex, uint256 appchainId) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainTotalCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochAppchainTotal(uint256,uint256)`](epochAppchainTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainTotalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainTotalCall) -> Self {
                    (value.epochIndex, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainTotalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochAppchainTotalCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochAppchainTotal(uint256,uint256)";
            const SELECTOR: [u8; 4] = [123u8, 218u8, 28u8, 251u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochAppchainTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochAppchainTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochAppchainWithdrawals(uint256,uint256)` and selector `0xf965652d`.
```solidity
function epochAppchainWithdrawals(uint256 epochIndex, uint256 appchainId) external view returns (uint256 withdrawals);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainWithdrawalsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochAppchainWithdrawals(uint256,uint256)`](epochAppchainWithdrawalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainWithdrawalsReturn {
        #[allow(missing_docs)]
        pub withdrawals: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainWithdrawalsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainWithdrawalsCall) -> Self {
                    (value.epochIndex, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainWithdrawalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainWithdrawalsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainWithdrawalsReturn) -> Self {
                    (value.withdrawals,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainWithdrawalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { withdrawals: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochAppchainWithdrawalsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochAppchainWithdrawals(uint256,uint256)";
            const SELECTOR: [u8; 4] = [249u8, 101u8, 101u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochAppchainWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochAppchainWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochStakeShare(uint256)` and selector `0x12e973bc`.
```solidity
function epochStakeShare(uint256 epochIndex) external view returns (uint256 stakeShare);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochStakeShareCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochStakeShare(uint256)`](epochStakeShareCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochStakeShareReturn {
        #[allow(missing_docs)]
        pub stakeShare: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochStakeShareCall> for UnderlyingRustTuple<'_> {
                fn from(value: epochStakeShareCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for epochStakeShareCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochStakeShareReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochStakeShareReturn) -> Self {
                    (value.stakeShare,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochStakeShareReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stakeShare: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochStakeShareCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochStakeShare(uint256)";
            const SELECTOR: [u8; 4] = [18u8, 233u8, 115u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochStakeShareReturn = r.into();
                        r.stakeShare
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochStakeShareReturn = r.into();
                        r.stakeShare
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochTotal(uint256)` and selector `0x1e0e8489`.
```solidity
function epochTotal(uint256 epochIndex) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochTotalCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochTotal(uint256)`](epochTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochTotalCall> for UnderlyingRustTuple<'_> {
                fn from(value: epochTotalCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for epochTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochTotalReturn> for UnderlyingRustTuple<'_> {
                fn from(value: epochTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for epochTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochTotalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochTotal(uint256)";
            const SELECTOR: [u8; 4] = [30u8, 14u8, 132u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserAdditions(uint256,address)` and selector `0x1b533b5a`.
```solidity
function epochUserAdditions(uint256 epochIndex, address user) external view returns (uint256 additions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAdditionsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserAdditions(uint256,address)`](epochUserAdditionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAdditionsReturn {
        #[allow(missing_docs)]
        pub additions: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAdditionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAdditionsCall) -> Self {
                    (value.epochIndex, value.user)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAdditionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAdditionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAdditionsReturn) -> Self {
                    (value.additions,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAdditionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { additions: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserAdditionsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserAdditions(uint256,address)";
            const SELECTOR: [u8; 4] = [27u8, 83u8, 59u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserAdditionsReturn = r.into();
                        r.additions
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserAdditionsReturn = r.into();
                        r.additions
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserAppchainAdditions(uint256,address,uint256)` and selector `0x693d0b7e`.
```solidity
function epochUserAppchainAdditions(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256 additions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAppchainAdditionsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserAppchainAdditions(uint256,address,uint256)`](epochUserAppchainAdditionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAppchainAdditionsReturn {
        #[allow(missing_docs)]
        pub additions: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAppchainAdditionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAppchainAdditionsCall) -> Self {
                    (value.epochIndex, value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAppchainAdditionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                        appchainId: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAppchainAdditionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAppchainAdditionsReturn) -> Self {
                    (value.additions,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAppchainAdditionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { additions: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserAppchainAdditionsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserAppchainAdditions(uint256,address,uint256)";
            const SELECTOR: [u8; 4] = [105u8, 61u8, 11u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserAppchainAdditionsReturn = r.into();
                        r.additions
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserAppchainAdditionsReturn = r.into();
                        r.additions
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserAppchainTotal(uint256,address,uint256)` and selector `0x629454fd`.
```solidity
function epochUserAppchainTotal(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAppchainTotalCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserAppchainTotal(uint256,address,uint256)`](epochUserAppchainTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAppchainTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAppchainTotalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAppchainTotalCall) -> Self {
                    (value.epochIndex, value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAppchainTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                        appchainId: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAppchainTotalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAppchainTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAppchainTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserAppchainTotalCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserAppchainTotal(uint256,address,uint256)";
            const SELECTOR: [u8; 4] = [98u8, 148u8, 84u8, 253u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserAppchainTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserAppchainTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserAppchainWithdrawals(uint256,address,uint256)` and selector `0xfa73ce59`.
```solidity
function epochUserAppchainWithdrawals(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256 withdrawals);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAppchainWithdrawalsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserAppchainWithdrawals(uint256,address,uint256)`](epochUserAppchainWithdrawalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAppchainWithdrawalsReturn {
        #[allow(missing_docs)]
        pub withdrawals: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAppchainWithdrawalsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAppchainWithdrawalsCall) -> Self {
                    (value.epochIndex, value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAppchainWithdrawalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                        appchainId: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAppchainWithdrawalsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAppchainWithdrawalsReturn) -> Self {
                    (value.withdrawals,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAppchainWithdrawalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { withdrawals: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserAppchainWithdrawalsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserAppchainWithdrawals(uint256,address,uint256)";
            const SELECTOR: [u8; 4] = [250u8, 115u8, 206u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserAppchainWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserAppchainWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserStakeShare(uint256,address)` and selector `0xee7514e8`.
```solidity
function epochUserStakeShare(uint256 epochIndex, address user) external view returns (uint256 stakeShare);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserStakeShareCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserStakeShare(uint256,address)`](epochUserStakeShareCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserStakeShareReturn {
        #[allow(missing_docs)]
        pub stakeShare: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserStakeShareCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserStakeShareCall) -> Self {
                    (value.epochIndex, value.user)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserStakeShareCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserStakeShareReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserStakeShareReturn) -> Self {
                    (value.stakeShare,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserStakeShareReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stakeShare: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserStakeShareCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserStakeShare(uint256,address)";
            const SELECTOR: [u8; 4] = [238u8, 117u8, 20u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserStakeShareReturn = r.into();
                        r.stakeShare
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserStakeShareReturn = r.into();
                        r.stakeShare
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserTotal(uint256,address)` and selector `0x053dcd25`.
```solidity
function epochUserTotal(uint256 epochIndex, address user) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserTotalCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserTotal(uint256,address)`](epochUserTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserTotalCall> for UnderlyingRustTuple<'_> {
                fn from(value: epochUserTotalCall) -> Self {
                    (value.epochIndex, value.user)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for epochUserTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserTotalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserTotalCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserTotal(uint256,address)";
            const SELECTOR: [u8; 4] = [5u8, 61u8, 205u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserWithdrawals(uint256,address)` and selector `0x5d3d8cd2`.
```solidity
function epochUserWithdrawals(uint256 epochIndex, address user) external view returns (uint256 withdrawals);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserWithdrawalsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserWithdrawals(uint256,address)`](epochUserWithdrawalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserWithdrawalsReturn {
        #[allow(missing_docs)]
        pub withdrawals: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserWithdrawalsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserWithdrawalsCall) -> Self {
                    (value.epochIndex, value.user)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserWithdrawalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserWithdrawalsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserWithdrawalsReturn) -> Self {
                    (value.withdrawals,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserWithdrawalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { withdrawals: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserWithdrawalsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserWithdrawals(uint256,address)";
            const SELECTOR: [u8; 4] = [93u8, 61u8, 140u8, 210u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochWithdrawals(uint256)` and selector `0x8c67903e`.
```solidity
function epochWithdrawals(uint256 epochIndex) external view returns (uint256 withdrawals);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochWithdrawalsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochWithdrawals(uint256)`](epochWithdrawalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochWithdrawalsReturn {
        #[allow(missing_docs)]
        pub withdrawals: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochWithdrawalsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochWithdrawalsCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochWithdrawalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochWithdrawalsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochWithdrawalsReturn) -> Self {
                    (value.withdrawals,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochWithdrawalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { withdrawals: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochWithdrawalsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochWithdrawals(uint256)";
            const SELECTOR: [u8; 4] = [140u8, 103u8, 144u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `finalizeAppchainEpochs(uint256)` and selector `0xf03021a1`.
```solidity
function finalizeAppchainEpochs(uint256 appchainId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeAppchainEpochsCall {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`finalizeAppchainEpochs(uint256)`](finalizeAppchainEpochsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeAppchainEpochsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeAppchainEpochsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeAppchainEpochsCall) -> Self {
                    (value.appchainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeAppchainEpochsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { appchainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeAppchainEpochsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeAppchainEpochsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeAppchainEpochsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl finalizeAppchainEpochsReturn {
            fn _tokenize(
                &self,
            ) -> <finalizeAppchainEpochsCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for finalizeAppchainEpochsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = finalizeAppchainEpochsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "finalizeAppchainEpochs(uint256)";
            const SELECTOR: [u8; 4] = [240u8, 48u8, 33u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                finalizeAppchainEpochsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `finalizeEpochs()` and selector `0xfe07bb07`.
```solidity
function finalizeEpochs() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeEpochsCall;
    ///Container type for the return parameters of the [`finalizeEpochs()`](finalizeEpochsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeEpochsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeEpochsCall> for UnderlyingRustTuple<'_> {
                fn from(value: finalizeEpochsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for finalizeEpochsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeEpochsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeEpochsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeEpochsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl finalizeEpochsReturn {
            fn _tokenize(
                &self,
            ) -> <finalizeEpochsCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for finalizeEpochsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = finalizeEpochsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "finalizeEpochs()";
            const SELECTOR: [u8; 4] = [254u8, 7u8, 187u8, 7u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                finalizeEpochsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `finalizeUserAppchainEpochs(address,uint256)` and selector `0x7e5f5ca7`.
```solidity
function finalizeUserAppchainEpochs(address user, uint256 appchainId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeUserAppchainEpochsCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`finalizeUserAppchainEpochs(address,uint256)`](finalizeUserAppchainEpochsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeUserAppchainEpochsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeUserAppchainEpochsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeUserAppchainEpochsCall) -> Self {
                    (value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeUserAppchainEpochsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        user: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeUserAppchainEpochsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeUserAppchainEpochsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeUserAppchainEpochsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl finalizeUserAppchainEpochsReturn {
            fn _tokenize(
                &self,
            ) -> <finalizeUserAppchainEpochsCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for finalizeUserAppchainEpochsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = finalizeUserAppchainEpochsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "finalizeUserAppchainEpochs(address,uint256)";
            const SELECTOR: [u8; 4] = [126u8, 95u8, 92u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                finalizeUserAppchainEpochsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `finalizeUserEpochs(address)` and selector `0x9deb66c9`.
```solidity
function finalizeUserEpochs(address user) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeUserEpochsCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`finalizeUserEpochs(address)`](finalizeUserEpochsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeUserEpochsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeUserEpochsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeUserEpochsCall) -> Self {
                    (value.user,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeUserEpochsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { user: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeUserEpochsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeUserEpochsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeUserEpochsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl finalizeUserEpochsReturn {
            fn _tokenize(
                &self,
            ) -> <finalizeUserEpochsCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for finalizeUserEpochsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = finalizeUserEpochsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "finalizeUserEpochs(address)";
            const SELECTOR: [u8; 4] = [157u8, 235u8, 102u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                finalizeUserEpochsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `finalizedEpochCount()` and selector `0x1a8a738c`.
```solidity
function finalizedEpochCount() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizedEpochCountCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`finalizedEpochCount()`](finalizedEpochCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizedEpochCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizedEpochCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizedEpochCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizedEpochCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizedEpochCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizedEpochCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizedEpochCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for finalizedEpochCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "finalizedEpochCount()";
            const SELECTOR: [u8; 4] = [26u8, 138u8, 115u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: finalizedEpochCountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: finalizedEpochCountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getAppchainStake(uint256,uint256)` and selector `0xfa457be6`.
```solidity
function getAppchainStake(uint256 epochIndex, uint256 appchainId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAppchainStakeCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getAppchainStake(uint256,uint256)`](getAppchainStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAppchainStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAppchainStakeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAppchainStakeCall) -> Self {
                    (value.epochIndex, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAppchainStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAppchainStakeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAppchainStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAppchainStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAppchainStakeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAppchainStake(uint256,uint256)";
            const SELECTOR: [u8; 4] = [250u8, 69u8, 123u8, 230u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getAppchainStakeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getAppchainStakeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getCurrentEpoch()` and selector `0xb97dd9e2`.
```solidity
function getCurrentEpoch() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getCurrentEpoch()`](getCurrentEpochCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochCall> for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getCurrentEpochCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentEpochReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentEpochCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentEpoch()";
            const SELECTOR: [u8; 4] = [185u8, 125u8, 217u8, 226u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getCurrentEpochReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getCurrentEpochReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getEpochEnd(uint256)` and selector `0xd5176d23`.
```solidity
function getEpochEnd(uint256 epochIndex) external pure returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEpochEndCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getEpochEnd(uint256)`](getEpochEndCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEpochEndReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEpochEndCall> for UnderlyingRustTuple<'_> {
                fn from(value: getEpochEndCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getEpochEndCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEpochEndReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getEpochEndReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getEpochEndReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getEpochEndCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getEpochEnd(uint256)";
            const SELECTOR: [u8; 4] = [213u8, 23u8, 109u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getEpochEndReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getEpochEndReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getEpochStart(uint256)` and selector `0x0175e23b`.
```solidity
function getEpochStart(uint256 epochIndex) external pure returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEpochStartCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getEpochStart(uint256)`](getEpochStartCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEpochStartReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEpochStartCall> for UnderlyingRustTuple<'_> {
                fn from(value: getEpochStartCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getEpochStartCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEpochStartReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getEpochStartReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getEpochStartReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getEpochStartCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getEpochStart(uint256)";
            const SELECTOR: [u8; 4] = [1u8, 117u8, 226u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getEpochStartReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getEpochStartReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getTotalStake(uint256)` and selector `0x45367f23`.
```solidity
function getTotalStake(uint256 epochIndex) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTotalStakeCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getTotalStake(uint256)`](getTotalStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTotalStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTotalStakeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getTotalStakeCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getTotalStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTotalStakeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getTotalStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getTotalStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getTotalStakeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getTotalStake(uint256)";
            const SELECTOR: [u8; 4] = [69u8, 54u8, 127u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getTotalStakeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getTotalStakeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getTotalStakeShare(uint256)` and selector `0x408c32ea`.
```solidity
function getTotalStakeShare(uint256 epochIndex) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTotalStakeShareCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getTotalStakeShare(uint256)`](getTotalStakeShareCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTotalStakeShareReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTotalStakeShareCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getTotalStakeShareCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getTotalStakeShareCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTotalStakeShareReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getTotalStakeShareReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getTotalStakeShareReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getTotalStakeShareCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getTotalStakeShare(uint256)";
            const SELECTOR: [u8; 4] = [64u8, 140u8, 50u8, 234u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getTotalStakeShareReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getTotalStakeShareReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getUserAppchainStake(uint256,address,uint256)` and selector `0xc3ddb3b3`.
```solidity
function getUserAppchainStake(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserAppchainStakeCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getUserAppchainStake(uint256,address,uint256)`](getUserAppchainStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserAppchainStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserAppchainStakeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getUserAppchainStakeCall) -> Self {
                    (value.epochIndex, value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getUserAppchainStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                        appchainId: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserAppchainStakeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getUserAppchainStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getUserAppchainStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getUserAppchainStakeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getUserAppchainStake(uint256,address,uint256)";
            const SELECTOR: [u8; 4] = [195u8, 221u8, 179u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getUserAppchainStakeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getUserAppchainStakeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getUserStake(uint256,address)` and selector `0x9626a230`.
```solidity
function getUserStake(uint256 epochIndex, address user) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserStakeCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getUserStake(uint256,address)`](getUserStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserStakeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getUserStakeCall) -> Self {
                    (value.epochIndex, value.user)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getUserStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserStakeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getUserStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getUserStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getUserStakeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getUserStake(uint256,address)";
            const SELECTOR: [u8; 4] = [150u8, 38u8, 162u8, 48u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getUserStakeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getUserStakeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getUserStakeShare(uint256,address)` and selector `0xf9d663e0`.
```solidity
function getUserStakeShare(uint256 epochIndex, address user) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserStakeShareCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getUserStakeShare(uint256,address)`](getUserStakeShareCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserStakeShareReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserStakeShareCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getUserStakeShareCall) -> Self {
                    (value.epochIndex, value.user)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getUserStakeShareCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserStakeShareReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getUserStakeShareReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getUserStakeShareReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getUserStakeShareCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getUserStakeShare(uint256,address)";
            const SELECTOR: [u8; 4] = [249u8, 214u8, 99u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getUserStakeShareReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getUserStakeShareReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getWithdrawalAmount(address,uint256)` and selector `0x59193f37`.
```solidity
function getWithdrawalAmount(address user, uint256 appchainId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getWithdrawalAmountCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getWithdrawalAmount(address,uint256)`](getWithdrawalAmountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getWithdrawalAmountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getWithdrawalAmountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getWithdrawalAmountCall) -> Self {
                    (value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getWithdrawalAmountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        user: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getWithdrawalAmountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getWithdrawalAmountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getWithdrawalAmountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getWithdrawalAmountCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getWithdrawalAmount(address,uint256)";
            const SELECTOR: [u8; 4] = [89u8, 25u8, 63u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getWithdrawalAmountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getWithdrawalAmountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initializeWithdrawal(uint256)` and selector `0x68a55564`.
```solidity
function initializeWithdrawal(uint256 appchainId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeWithdrawal_0Call {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`initializeWithdrawal(uint256)`](initializeWithdrawal_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeWithdrawal_0Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeWithdrawal_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeWithdrawal_0Call) -> Self {
                    (value.appchainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeWithdrawal_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { appchainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeWithdrawal_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeWithdrawal_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeWithdrawal_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeWithdrawal_0Return {
            fn _tokenize(
                &self,
            ) -> <initializeWithdrawal_0Call as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeWithdrawal_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeWithdrawal_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initializeWithdrawal(uint256)";
            const SELECTOR: [u8; 4] = [104u8, 165u8, 85u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeWithdrawal_0Return::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initializeWithdrawal(uint256,uint256)` and selector `0xed86ba6f`.
```solidity
function initializeWithdrawal(uint256 appchainId, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeWithdrawal_1Call {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`initializeWithdrawal(uint256,uint256)`](initializeWithdrawal_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeWithdrawal_1Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeWithdrawal_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeWithdrawal_1Call) -> Self {
                    (value.appchainId, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeWithdrawal_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        appchainId: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeWithdrawal_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeWithdrawal_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeWithdrawal_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeWithdrawal_1Return {
            fn _tokenize(
                &self,
            ) -> <initializeWithdrawal_1Call as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeWithdrawal_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeWithdrawal_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initializeWithdrawal(uint256,uint256)";
            const SELECTOR: [u8; 4] = [237u8, 134u8, 186u8, 111u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeWithdrawal_1Return::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initializeWithdrawals(uint256[],uint256[])` and selector `0x4197a4b1`.
```solidity
function initializeWithdrawals(uint256[] memory appchainIds, uint256[] memory amounts) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeWithdrawals_0Call {
        #[allow(missing_docs)]
        pub appchainIds: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
        #[allow(missing_docs)]
        pub amounts: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    ///Container type for the return parameters of the [`initializeWithdrawals(uint256[],uint256[])`](initializeWithdrawals_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeWithdrawals_0Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeWithdrawals_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeWithdrawals_0Call) -> Self {
                    (value.appchainIds, value.amounts)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeWithdrawals_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        appchainIds: tuple.0,
                        amounts: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeWithdrawals_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeWithdrawals_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeWithdrawals_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeWithdrawals_0Return {
            fn _tokenize(
                &self,
            ) -> <initializeWithdrawals_0Call as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeWithdrawals_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeWithdrawals_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initializeWithdrawals(uint256[],uint256[])";
            const SELECTOR: [u8; 4] = [65u8, 151u8, 164u8, 177u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainIds),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.amounts),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeWithdrawals_0Return::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initializeWithdrawals(uint256[])` and selector `0xce7d8e5a`.
```solidity
function initializeWithdrawals(uint256[] memory appchainIds) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeWithdrawals_1Call {
        #[allow(missing_docs)]
        pub appchainIds: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    ///Container type for the return parameters of the [`initializeWithdrawals(uint256[])`](initializeWithdrawals_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeWithdrawals_1Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeWithdrawals_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeWithdrawals_1Call) -> Self {
                    (value.appchainIds,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeWithdrawals_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { appchainIds: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeWithdrawals_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeWithdrawals_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeWithdrawals_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeWithdrawals_1Return {
            fn _tokenize(
                &self,
            ) -> <initializeWithdrawals_1Call as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeWithdrawals_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeWithdrawals_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initializeWithdrawals(uint256[])";
            const SELECTOR: [u8; 4] = [206u8, 125u8, 142u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainIds),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeWithdrawals_1Return::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: ownerReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: ownerReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `pause()` and selector `0x8456cb59`.
```solidity
function pause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseCall;
    ///Container type for the return parameters of the [`pause()`](pauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl pauseReturn {
            fn _tokenize(
                &self,
            ) -> <pauseCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause()";
            const SELECTOR: [u8; 4] = [132u8, 86u8, 203u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                pauseReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `paused()` and selector `0x5c975abb`.
```solidity
function paused() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`paused()`](pausedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedCall> for UnderlyingRustTuple<'_> {
                fn from(value: pausedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pausedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pausedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: pausedReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: pausedReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall;
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl renounceOwnershipReturn {
            fn _tokenize(
                &self,
            ) -> <renounceOwnershipCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                renounceOwnershipReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `stageStakeTransfer(uint256,uint256,uint256)` and selector `0xe58e5382`.
```solidity
function stageStakeTransfer(uint256 fromAppchainId, uint256 toAppchainId, uint256 amount) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stageStakeTransferCall {
        #[allow(missing_docs)]
        pub fromAppchainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub toAppchainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`stageStakeTransfer(uint256,uint256,uint256)`](stageStakeTransferCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stageStakeTransferReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stageStakeTransferCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: stageStakeTransferCall) -> Self {
                    (value.fromAppchainId, value.toAppchainId, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for stageStakeTransferCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        fromAppchainId: tuple.0,
                        toAppchainId: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stageStakeTransferReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: stageStakeTransferReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for stageStakeTransferReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl stageStakeTransferReturn {
            fn _tokenize(
                &self,
            ) -> <stageStakeTransferCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stageStakeTransferCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = stageStakeTransferReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stageStakeTransfer(uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [229u8, 142u8, 83u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.fromAppchainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.toAppchainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                stageStakeTransferReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `stakeMultipleAppchains(uint256[],uint256[])` and selector `0x85d81217`.
```solidity
function stakeMultipleAppchains(uint256[] memory appchainIds, uint256[] memory amounts) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stakeMultipleAppchainsCall {
        #[allow(missing_docs)]
        pub appchainIds: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
        #[allow(missing_docs)]
        pub amounts: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    ///Container type for the return parameters of the [`stakeMultipleAppchains(uint256[],uint256[])`](stakeMultipleAppchainsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stakeMultipleAppchainsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeMultipleAppchainsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: stakeMultipleAppchainsCall) -> Self {
                    (value.appchainIds, value.amounts)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for stakeMultipleAppchainsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        appchainIds: tuple.0,
                        amounts: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeMultipleAppchainsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: stakeMultipleAppchainsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for stakeMultipleAppchainsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl stakeMultipleAppchainsReturn {
            fn _tokenize(
                &self,
            ) -> <stakeMultipleAppchainsCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stakeMultipleAppchainsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = stakeMultipleAppchainsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stakeMultipleAppchains(uint256[],uint256[])";
            const SELECTOR: [u8; 4] = [133u8, 216u8, 18u8, 23u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainIds),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.amounts),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                stakeMultipleAppchainsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `stakeSynd(uint256)` and selector `0x0458296f`.
```solidity
function stakeSynd(uint256 appchainId) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stakeSyndCall {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`stakeSynd(uint256)`](stakeSyndCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stakeSyndReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeSyndCall> for UnderlyingRustTuple<'_> {
                fn from(value: stakeSyndCall) -> Self {
                    (value.appchainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stakeSyndCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { appchainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeSyndReturn> for UnderlyingRustTuple<'_> {
                fn from(value: stakeSyndReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stakeSyndReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl stakeSyndReturn {
            fn _tokenize(
                &self,
            ) -> <stakeSyndCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stakeSyndCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = stakeSyndReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stakeSynd(uint256)";
            const SELECTOR: [u8; 4] = [4u8, 88u8, 41u8, 111u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                stakeSyndReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `totalStake()` and selector `0x8b0e9f3f`.
```solidity
function totalStake() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalStakeCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`totalStake()`](totalStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalStakeCall> for UnderlyingRustTuple<'_> {
                fn from(value: totalStakeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalStakeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: totalStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalStakeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalStake()";
            const SELECTOR: [u8; 4] = [139u8, 14u8, 159u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: totalStakeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: totalStakeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl transferOwnershipReturn {
            fn _tokenize(
                &self,
            ) -> <transferOwnershipCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                transferOwnershipReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `unpause()` and selector `0x3f4ba83a`.
```solidity
function unpause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseCall;
    ///Container type for the return parameters of the [`unpause()`](unpauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl unpauseReturn {
            fn _tokenize(
                &self,
            ) -> <unpauseCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unpauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unpauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unpause()";
            const SELECTOR: [u8; 4] = [63u8, 75u8, 168u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                unpauseReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `userAppchainFinalizedEpochCount(address,uint256)` and selector `0xf89ee78d`.
```solidity
function userAppchainFinalizedEpochCount(address user, uint256 appchainId) external view returns (uint256 finalizedEpochCount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userAppchainFinalizedEpochCountCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`userAppchainFinalizedEpochCount(address,uint256)`](userAppchainFinalizedEpochCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userAppchainFinalizedEpochCountReturn {
        #[allow(missing_docs)]
        pub finalizedEpochCount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userAppchainFinalizedEpochCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: userAppchainFinalizedEpochCountCall) -> Self {
                    (value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for userAppchainFinalizedEpochCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        user: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userAppchainFinalizedEpochCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: userAppchainFinalizedEpochCountReturn) -> Self {
                    (value.finalizedEpochCount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for userAppchainFinalizedEpochCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        finalizedEpochCount: tuple.0,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for userAppchainFinalizedEpochCountCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "userAppchainFinalizedEpochCount(address,uint256)";
            const SELECTOR: [u8; 4] = [248u8, 158u8, 231u8, 141u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: userAppchainFinalizedEpochCountReturn = r.into();
                        r.finalizedEpochCount
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: userAppchainFinalizedEpochCountReturn = r.into();
                        r.finalizedEpochCount
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `userAppchainTotal(address,uint256)` and selector `0xa09d7a30`.
```solidity
function userAppchainTotal(address user, uint256 appchainId) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userAppchainTotalCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`userAppchainTotal(address,uint256)`](userAppchainTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userAppchainTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userAppchainTotalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: userAppchainTotalCall) -> Self {
                    (value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for userAppchainTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        user: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userAppchainTotalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: userAppchainTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for userAppchainTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for userAppchainTotalCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "userAppchainTotal(address,uint256)";
            const SELECTOR: [u8; 4] = [160u8, 157u8, 122u8, 48u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: userAppchainTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: userAppchainTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `userFinalizedEpochCount(address)` and selector `0x7c5dd5d9`.
```solidity
function userFinalizedEpochCount(address user) external view returns (uint256 finalizedEpochCount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userFinalizedEpochCountCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`userFinalizedEpochCount(address)`](userFinalizedEpochCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userFinalizedEpochCountReturn {
        #[allow(missing_docs)]
        pub finalizedEpochCount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userFinalizedEpochCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: userFinalizedEpochCountCall) -> Self {
                    (value.user,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for userFinalizedEpochCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { user: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userFinalizedEpochCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: userFinalizedEpochCountReturn) -> Self {
                    (value.finalizedEpochCount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for userFinalizedEpochCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        finalizedEpochCount: tuple.0,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for userFinalizedEpochCountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "userFinalizedEpochCount(address)";
            const SELECTOR: [u8; 4] = [124u8, 93u8, 213u8, 217u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: userFinalizedEpochCountReturn = r.into();
                        r.finalizedEpochCount
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: userFinalizedEpochCountReturn = r.into();
                        r.finalizedEpochCount
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `userTotal(address)` and selector `0xe601cf44`.
```solidity
function userTotal(address user) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userTotalCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`userTotal(address)`](userTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userTotalCall> for UnderlyingRustTuple<'_> {
                fn from(value: userTotalCall) -> Self {
                    (value.user,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for userTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { user: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userTotalReturn> for UnderlyingRustTuple<'_> {
                fn from(value: userTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for userTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for userTotalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "userTotal(address)";
            const SELECTOR: [u8; 4] = [230u8, 1u8, 207u8, 68u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: userTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: userTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `withdraw(uint256,address)` and selector `0x00f714ce`.
```solidity
function withdraw(uint256 epochIndex, address destination) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub destination: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`withdraw(uint256,address)`](withdrawCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawCall> for UnderlyingRustTuple<'_> {
                fn from(value: withdrawCall) -> Self {
                    (value.epochIndex, value.destination)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for withdrawCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        destination: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawReturn> for UnderlyingRustTuple<'_> {
                fn from(value: withdrawReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for withdrawReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl withdrawReturn {
            fn _tokenize(
                &self,
            ) -> <withdrawCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for withdrawCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = withdrawReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "withdraw(uint256,address)";
            const SELECTOR: [u8; 4] = [0u8, 247u8, 20u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.destination,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                withdrawReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `withdrawBulk(uint256[],address)` and selector `0x585a627a`.
```solidity
function withdrawBulk(uint256[] memory epochIndices, address destination) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawBulkCall {
        #[allow(missing_docs)]
        pub epochIndices: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
        #[allow(missing_docs)]
        pub destination: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`withdrawBulk(uint256[],address)`](withdrawBulkCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawBulkReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawBulkCall> for UnderlyingRustTuple<'_> {
                fn from(value: withdrawBulkCall) -> Self {
                    (value.epochIndices, value.destination)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for withdrawBulkCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndices: tuple.0,
                        destination: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawBulkReturn> for UnderlyingRustTuple<'_> {
                fn from(value: withdrawBulkReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for withdrawBulkReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl withdrawBulkReturn {
            fn _tokenize(
                &self,
            ) -> <withdrawBulkCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for withdrawBulkCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = withdrawBulkReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "withdrawBulk(uint256[],address)";
            const SELECTOR: [u8; 4] = [88u8, 90u8, 98u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndices),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.destination,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                withdrawBulkReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`SyndStaking`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum SyndStakingCalls {
        #[allow(missing_docs)]
        EPOCH_DURATION(EPOCH_DURATIONCall),
        #[allow(missing_docs)]
        START_TIMESTAMP(START_TIMESTAMPCall),
        #[allow(missing_docs)]
        appchainFinalizedEpochCount(appchainFinalizedEpochCountCall),
        #[allow(missing_docs)]
        appchainTotal(appchainTotalCall),
        #[allow(missing_docs)]
        claimAllRewards(claimAllRewardsCall),
        #[allow(missing_docs)]
        epochAdditions(epochAdditionsCall),
        #[allow(missing_docs)]
        epochAppchainAdditions(epochAppchainAdditionsCall),
        #[allow(missing_docs)]
        epochAppchainTotal(epochAppchainTotalCall),
        #[allow(missing_docs)]
        epochAppchainWithdrawals(epochAppchainWithdrawalsCall),
        #[allow(missing_docs)]
        epochStakeShare(epochStakeShareCall),
        #[allow(missing_docs)]
        epochTotal(epochTotalCall),
        #[allow(missing_docs)]
        epochUserAdditions(epochUserAdditionsCall),
        #[allow(missing_docs)]
        epochUserAppchainAdditions(epochUserAppchainAdditionsCall),
        #[allow(missing_docs)]
        epochUserAppchainTotal(epochUserAppchainTotalCall),
        #[allow(missing_docs)]
        epochUserAppchainWithdrawals(epochUserAppchainWithdrawalsCall),
        #[allow(missing_docs)]
        epochUserStakeShare(epochUserStakeShareCall),
        #[allow(missing_docs)]
        epochUserTotal(epochUserTotalCall),
        #[allow(missing_docs)]
        epochUserWithdrawals(epochUserWithdrawalsCall),
        #[allow(missing_docs)]
        epochWithdrawals(epochWithdrawalsCall),
        #[allow(missing_docs)]
        finalizeAppchainEpochs(finalizeAppchainEpochsCall),
        #[allow(missing_docs)]
        finalizeEpochs(finalizeEpochsCall),
        #[allow(missing_docs)]
        finalizeUserAppchainEpochs(finalizeUserAppchainEpochsCall),
        #[allow(missing_docs)]
        finalizeUserEpochs(finalizeUserEpochsCall),
        #[allow(missing_docs)]
        finalizedEpochCount(finalizedEpochCountCall),
        #[allow(missing_docs)]
        getAppchainStake(getAppchainStakeCall),
        #[allow(missing_docs)]
        getCurrentEpoch(getCurrentEpochCall),
        #[allow(missing_docs)]
        getEpochEnd(getEpochEndCall),
        #[allow(missing_docs)]
        getEpochStart(getEpochStartCall),
        #[allow(missing_docs)]
        getTotalStake(getTotalStakeCall),
        #[allow(missing_docs)]
        getTotalStakeShare(getTotalStakeShareCall),
        #[allow(missing_docs)]
        getUserAppchainStake(getUserAppchainStakeCall),
        #[allow(missing_docs)]
        getUserStake(getUserStakeCall),
        #[allow(missing_docs)]
        getUserStakeShare(getUserStakeShareCall),
        #[allow(missing_docs)]
        getWithdrawalAmount(getWithdrawalAmountCall),
        #[allow(missing_docs)]
        initializeWithdrawal_0(initializeWithdrawal_0Call),
        #[allow(missing_docs)]
        initializeWithdrawal_1(initializeWithdrawal_1Call),
        #[allow(missing_docs)]
        initializeWithdrawals_0(initializeWithdrawals_0Call),
        #[allow(missing_docs)]
        initializeWithdrawals_1(initializeWithdrawals_1Call),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        pause(pauseCall),
        #[allow(missing_docs)]
        paused(pausedCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        stageStakeTransfer(stageStakeTransferCall),
        #[allow(missing_docs)]
        stakeMultipleAppchains(stakeMultipleAppchainsCall),
        #[allow(missing_docs)]
        stakeSynd(stakeSyndCall),
        #[allow(missing_docs)]
        totalStake(totalStakeCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
        #[allow(missing_docs)]
        unpause(unpauseCall),
        #[allow(missing_docs)]
        userAppchainFinalizedEpochCount(userAppchainFinalizedEpochCountCall),
        #[allow(missing_docs)]
        userAppchainTotal(userAppchainTotalCall),
        #[allow(missing_docs)]
        userFinalizedEpochCount(userFinalizedEpochCountCall),
        #[allow(missing_docs)]
        userTotal(userTotalCall),
        #[allow(missing_docs)]
        withdraw(withdrawCall),
        #[allow(missing_docs)]
        withdrawBulk(withdrawBulkCall),
    }
    #[automatically_derived]
    impl SyndStakingCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 247u8, 20u8, 206u8],
            [1u8, 117u8, 226u8, 59u8],
            [4u8, 88u8, 41u8, 111u8],
            [5u8, 61u8, 205u8, 37u8],
            [11u8, 40u8, 27u8, 248u8],
            [16u8, 87u8, 233u8, 188u8],
            [18u8, 233u8, 115u8, 188u8],
            [26u8, 138u8, 115u8, 140u8],
            [27u8, 83u8, 59u8, 90u8],
            [30u8, 14u8, 132u8, 137u8],
            [59u8, 160u8, 15u8, 174u8],
            [63u8, 75u8, 168u8, 58u8],
            [64u8, 140u8, 50u8, 234u8],
            [65u8, 151u8, 164u8, 177u8],
            [69u8, 54u8, 127u8, 35u8],
            [88u8, 90u8, 98u8, 122u8],
            [89u8, 25u8, 63u8, 55u8],
            [92u8, 151u8, 90u8, 187u8],
            [93u8, 61u8, 140u8, 210u8],
            [98u8, 148u8, 84u8, 253u8],
            [104u8, 165u8, 85u8, 100u8],
            [105u8, 61u8, 11u8, 126u8],
            [113u8, 80u8, 24u8, 166u8],
            [120u8, 28u8, 217u8, 157u8],
            [123u8, 218u8, 28u8, 251u8],
            [124u8, 93u8, 213u8, 217u8],
            [124u8, 110u8, 170u8, 238u8],
            [126u8, 95u8, 92u8, 167u8],
            [132u8, 86u8, 203u8, 89u8],
            [133u8, 216u8, 18u8, 23u8],
            [139u8, 14u8, 159u8, 63u8],
            [140u8, 103u8, 144u8, 62u8],
            [141u8, 165u8, 203u8, 91u8],
            [150u8, 38u8, 162u8, 48u8],
            [157u8, 235u8, 102u8, 201u8],
            [160u8, 157u8, 122u8, 48u8],
            [167u8, 11u8, 159u8, 12u8],
            [185u8, 125u8, 217u8, 226u8],
            [195u8, 221u8, 179u8, 179u8],
            [206u8, 125u8, 142u8, 90u8],
            [213u8, 23u8, 109u8, 35u8],
            [229u8, 142u8, 83u8, 130u8],
            [230u8, 1u8, 207u8, 68u8],
            [237u8, 134u8, 186u8, 111u8],
            [238u8, 117u8, 20u8, 232u8],
            [240u8, 48u8, 33u8, 161u8],
            [241u8, 86u8, 224u8, 111u8],
            [242u8, 253u8, 227u8, 139u8],
            [248u8, 158u8, 231u8, 141u8],
            [249u8, 101u8, 101u8, 45u8],
            [249u8, 214u8, 99u8, 224u8],
            [250u8, 69u8, 123u8, 230u8],
            [250u8, 115u8, 206u8, 89u8],
            [254u8, 7u8, 187u8, 7u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndStakingCalls {
        const NAME: &'static str = "SyndStakingCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 54usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::EPOCH_DURATION(_) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::START_TIMESTAMP(_) => {
                    <START_TIMESTAMPCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::appchainFinalizedEpochCount(_) => {
                    <appchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::appchainTotal(_) => {
                    <appchainTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAllRewards(_) => {
                    <claimAllRewardsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochAdditions(_) => {
                    <epochAdditionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochAppchainAdditions(_) => {
                    <epochAppchainAdditionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochAppchainTotal(_) => {
                    <epochAppchainTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochAppchainWithdrawals(_) => {
                    <epochAppchainWithdrawalsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochStakeShare(_) => {
                    <epochStakeShareCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochTotal(_) => {
                    <epochTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserAdditions(_) => {
                    <epochUserAdditionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserAppchainAdditions(_) => {
                    <epochUserAppchainAdditionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserAppchainTotal(_) => {
                    <epochUserAppchainTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserAppchainWithdrawals(_) => {
                    <epochUserAppchainWithdrawalsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserStakeShare(_) => {
                    <epochUserStakeShareCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserTotal(_) => {
                    <epochUserTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserWithdrawals(_) => {
                    <epochUserWithdrawalsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochWithdrawals(_) => {
                    <epochWithdrawalsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::finalizeAppchainEpochs(_) => {
                    <finalizeAppchainEpochsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::finalizeEpochs(_) => {
                    <finalizeEpochsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::finalizeUserAppchainEpochs(_) => {
                    <finalizeUserAppchainEpochsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::finalizeUserEpochs(_) => {
                    <finalizeUserEpochsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::finalizedEpochCount(_) => {
                    <finalizedEpochCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAppchainStake(_) => {
                    <getAppchainStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCurrentEpoch(_) => {
                    <getCurrentEpochCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getEpochEnd(_) => {
                    <getEpochEndCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getEpochStart(_) => {
                    <getEpochStartCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getTotalStake(_) => {
                    <getTotalStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getTotalStakeShare(_) => {
                    <getTotalStakeShareCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getUserAppchainStake(_) => {
                    <getUserAppchainStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getUserStake(_) => {
                    <getUserStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getUserStakeShare(_) => {
                    <getUserStakeShareCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getWithdrawalAmount(_) => {
                    <getWithdrawalAmountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initializeWithdrawal_0(_) => {
                    <initializeWithdrawal_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initializeWithdrawal_1(_) => {
                    <initializeWithdrawal_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initializeWithdrawals_0(_) => {
                    <initializeWithdrawals_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initializeWithdrawals_1(_) => {
                    <initializeWithdrawals_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::paused(_) => <pausedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::stageStakeTransfer(_) => {
                    <stageStakeTransferCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::stakeMultipleAppchains(_) => {
                    <stakeMultipleAppchainsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::stakeSynd(_) => {
                    <stakeSyndCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::totalStake(_) => {
                    <totalStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unpause(_) => <unpauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::userAppchainFinalizedEpochCount(_) => {
                    <userAppchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::userAppchainTotal(_) => {
                    <userAppchainTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::userFinalizedEpochCount(_) => {
                    <userFinalizedEpochCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::userTotal(_) => {
                    <userTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::withdraw(_) => <withdrawCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::withdrawBulk(_) => {
                    <withdrawBulkCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SyndStakingCalls>] = &[
                {
                    fn withdraw(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <withdrawCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndStakingCalls::withdraw)
                    }
                    withdraw
                },
                {
                    fn getEpochStart(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getEpochStartCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getEpochStart)
                    }
                    getEpochStart
                },
                {
                    fn stakeSynd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <stakeSyndCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndStakingCalls::stakeSynd)
                    }
                    stakeSynd
                },
                {
                    fn epochUserTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserTotal)
                    }
                    epochUserTotal
                },
                {
                    fn epochAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochAdditions)
                    }
                    epochAdditions
                },
                {
                    fn appchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <appchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::appchainTotal)
                    }
                    appchainTotal
                },
                {
                    fn epochStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochStakeShare)
                    }
                    epochStakeShare
                },
                {
                    fn finalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::finalizedEpochCount)
                    }
                    finalizedEpochCount
                },
                {
                    fn epochUserAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAdditions)
                    }
                    epochUserAdditions
                },
                {
                    fn epochTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochTotal)
                    }
                    epochTotal
                },
                {
                    fn appchainFinalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <appchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::appchainFinalizedEpochCount)
                    }
                    appchainFinalizedEpochCount
                },
                {
                    fn unpause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndStakingCalls::unpause)
                    }
                    unpause
                },
                {
                    fn getTotalStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getTotalStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getTotalStakeShare)
                    }
                    getTotalStakeShare
                },
                {
                    fn initializeWithdrawals_0(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <initializeWithdrawals_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::initializeWithdrawals_0)
                    }
                    initializeWithdrawals_0
                },
                {
                    fn getTotalStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getTotalStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getTotalStake)
                    }
                    getTotalStake
                },
                {
                    fn withdrawBulk(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <withdrawBulkCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::withdrawBulk)
                    }
                    withdrawBulk
                },
                {
                    fn getWithdrawalAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getWithdrawalAmountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getWithdrawalAmount)
                    }
                    getWithdrawalAmount
                },
                {
                    fn paused(data: &[u8]) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndStakingCalls::paused)
                    }
                    paused
                },
                {
                    fn epochUserWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserWithdrawals)
                    }
                    epochUserWithdrawals
                },
                {
                    fn epochUserAppchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAppchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAppchainTotal)
                    }
                    epochUserAppchainTotal
                },
                {
                    fn initializeWithdrawal_0(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <initializeWithdrawal_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::initializeWithdrawal_0)
                    }
                    initializeWithdrawal_0
                },
                {
                    fn epochUserAppchainAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAppchainAdditions)
                    }
                    epochUserAppchainAdditions
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn START_TIMESTAMP(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <START_TIMESTAMPCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::START_TIMESTAMP)
                    }
                    START_TIMESTAMP
                },
                {
                    fn epochAppchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAppchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochAppchainTotal)
                    }
                    epochAppchainTotal
                },
                {
                    fn userFinalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::userFinalizedEpochCount)
                    }
                    userFinalizedEpochCount
                },
                {
                    fn epochAppchainAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochAppchainAdditions)
                    }
                    epochAppchainAdditions
                },
                {
                    fn finalizeUserAppchainEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeUserAppchainEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeUserAppchainEpochs)
                    }
                    finalizeUserAppchainEpochs
                },
                {
                    fn pause(data: &[u8]) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndStakingCalls::pause)
                    }
                    pause
                },
                {
                    fn stakeMultipleAppchains(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <stakeMultipleAppchainsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::stakeMultipleAppchains)
                    }
                    stakeMultipleAppchains
                },
                {
                    fn totalStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <totalStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::totalStake)
                    }
                    totalStake
                },
                {
                    fn epochWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochWithdrawals)
                    }
                    epochWithdrawals
                },
                {
                    fn owner(data: &[u8]) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndStakingCalls::owner)
                    }
                    owner
                },
                {
                    fn getUserStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getUserStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getUserStake)
                    }
                    getUserStake
                },
                {
                    fn finalizeUserEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeUserEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeUserEpochs)
                    }
                    finalizeUserEpochs
                },
                {
                    fn userAppchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userAppchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::userAppchainTotal)
                    }
                    userAppchainTotal
                },
                {
                    fn EPOCH_DURATION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::EPOCH_DURATION)
                    }
                    EPOCH_DURATION
                },
                {
                    fn getCurrentEpoch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getCurrentEpochCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getCurrentEpoch)
                    }
                    getCurrentEpoch
                },
                {
                    fn getUserAppchainStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getUserAppchainStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getUserAppchainStake)
                    }
                    getUserAppchainStake
                },
                {
                    fn initializeWithdrawals_1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <initializeWithdrawals_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::initializeWithdrawals_1)
                    }
                    initializeWithdrawals_1
                },
                {
                    fn getEpochEnd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getEpochEndCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getEpochEnd)
                    }
                    getEpochEnd
                },
                {
                    fn stageStakeTransfer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <stageStakeTransferCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::stageStakeTransfer)
                    }
                    stageStakeTransfer
                },
                {
                    fn userTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndStakingCalls::userTotal)
                    }
                    userTotal
                },
                {
                    fn initializeWithdrawal_1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <initializeWithdrawal_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::initializeWithdrawal_1)
                    }
                    initializeWithdrawal_1
                },
                {
                    fn epochUserStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserStakeShare)
                    }
                    epochUserStakeShare
                },
                {
                    fn finalizeAppchainEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeAppchainEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeAppchainEpochs)
                    }
                    finalizeAppchainEpochs
                },
                {
                    fn claimAllRewards(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <claimAllRewardsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::claimAllRewards)
                    }
                    claimAllRewards
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::transferOwnership)
                    }
                    transferOwnership
                },
                {
                    fn userAppchainFinalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userAppchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::userAppchainFinalizedEpochCount)
                    }
                    userAppchainFinalizedEpochCount
                },
                {
                    fn epochAppchainWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochAppchainWithdrawals)
                    }
                    epochAppchainWithdrawals
                },
                {
                    fn getUserStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getUserStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getUserStakeShare)
                    }
                    getUserStakeShare
                },
                {
                    fn getAppchainStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getAppchainStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getAppchainStake)
                    }
                    getAppchainStake
                },
                {
                    fn epochUserAppchainWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAppchainWithdrawals)
                    }
                    epochUserAppchainWithdrawals
                },
                {
                    fn finalizeEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeEpochs)
                    }
                    finalizeEpochs
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SyndStakingCalls>] = &[
                {
                    fn withdraw(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <withdrawCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::withdraw)
                    }
                    withdraw
                },
                {
                    fn getEpochStart(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getEpochStartCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getEpochStart)
                    }
                    getEpochStart
                },
                {
                    fn stakeSynd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <stakeSyndCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::stakeSynd)
                    }
                    stakeSynd
                },
                {
                    fn epochUserTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserTotal)
                    }
                    epochUserTotal
                },
                {
                    fn epochAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochAdditions)
                    }
                    epochAdditions
                },
                {
                    fn appchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <appchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::appchainTotal)
                    }
                    appchainTotal
                },
                {
                    fn epochStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochStakeShare)
                    }
                    epochStakeShare
                },
                {
                    fn finalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::finalizedEpochCount)
                    }
                    finalizedEpochCount
                },
                {
                    fn epochUserAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAdditions)
                    }
                    epochUserAdditions
                },
                {
                    fn epochTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochTotal)
                    }
                    epochTotal
                },
                {
                    fn appchainFinalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <appchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::appchainFinalizedEpochCount)
                    }
                    appchainFinalizedEpochCount
                },
                {
                    fn unpause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::unpause)
                    }
                    unpause
                },
                {
                    fn getTotalStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getTotalStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getTotalStakeShare)
                    }
                    getTotalStakeShare
                },
                {
                    fn initializeWithdrawals_0(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <initializeWithdrawals_0Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::initializeWithdrawals_0)
                    }
                    initializeWithdrawals_0
                },
                {
                    fn getTotalStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getTotalStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getTotalStake)
                    }
                    getTotalStake
                },
                {
                    fn withdrawBulk(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <withdrawBulkCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::withdrawBulk)
                    }
                    withdrawBulk
                },
                {
                    fn getWithdrawalAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getWithdrawalAmountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getWithdrawalAmount)
                    }
                    getWithdrawalAmount
                },
                {
                    fn paused(data: &[u8]) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::paused)
                    }
                    paused
                },
                {
                    fn epochUserWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserWithdrawals)
                    }
                    epochUserWithdrawals
                },
                {
                    fn epochUserAppchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAppchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAppchainTotal)
                    }
                    epochUserAppchainTotal
                },
                {
                    fn initializeWithdrawal_0(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <initializeWithdrawal_0Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::initializeWithdrawal_0)
                    }
                    initializeWithdrawal_0
                },
                {
                    fn epochUserAppchainAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAppchainAdditions)
                    }
                    epochUserAppchainAdditions
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn START_TIMESTAMP(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <START_TIMESTAMPCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::START_TIMESTAMP)
                    }
                    START_TIMESTAMP
                },
                {
                    fn epochAppchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAppchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochAppchainTotal)
                    }
                    epochAppchainTotal
                },
                {
                    fn userFinalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::userFinalizedEpochCount)
                    }
                    userFinalizedEpochCount
                },
                {
                    fn epochAppchainAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochAppchainAdditions)
                    }
                    epochAppchainAdditions
                },
                {
                    fn finalizeUserAppchainEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeUserAppchainEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeUserAppchainEpochs)
                    }
                    finalizeUserAppchainEpochs
                },
                {
                    fn pause(data: &[u8]) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::pause)
                    }
                    pause
                },
                {
                    fn stakeMultipleAppchains(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <stakeMultipleAppchainsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::stakeMultipleAppchains)
                    }
                    stakeMultipleAppchains
                },
                {
                    fn totalStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <totalStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::totalStake)
                    }
                    totalStake
                },
                {
                    fn epochWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochWithdrawals)
                    }
                    epochWithdrawals
                },
                {
                    fn owner(data: &[u8]) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::owner)
                    }
                    owner
                },
                {
                    fn getUserStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getUserStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getUserStake)
                    }
                    getUserStake
                },
                {
                    fn finalizeUserEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeUserEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeUserEpochs)
                    }
                    finalizeUserEpochs
                },
                {
                    fn userAppchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userAppchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::userAppchainTotal)
                    }
                    userAppchainTotal
                },
                {
                    fn EPOCH_DURATION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::EPOCH_DURATION)
                    }
                    EPOCH_DURATION
                },
                {
                    fn getCurrentEpoch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getCurrentEpochCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getCurrentEpoch)
                    }
                    getCurrentEpoch
                },
                {
                    fn getUserAppchainStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getUserAppchainStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getUserAppchainStake)
                    }
                    getUserAppchainStake
                },
                {
                    fn initializeWithdrawals_1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <initializeWithdrawals_1Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::initializeWithdrawals_1)
                    }
                    initializeWithdrawals_1
                },
                {
                    fn getEpochEnd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getEpochEndCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getEpochEnd)
                    }
                    getEpochEnd
                },
                {
                    fn stageStakeTransfer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <stageStakeTransferCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::stageStakeTransfer)
                    }
                    stageStakeTransfer
                },
                {
                    fn userTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::userTotal)
                    }
                    userTotal
                },
                {
                    fn initializeWithdrawal_1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <initializeWithdrawal_1Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::initializeWithdrawal_1)
                    }
                    initializeWithdrawal_1
                },
                {
                    fn epochUserStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserStakeShare)
                    }
                    epochUserStakeShare
                },
                {
                    fn finalizeAppchainEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeAppchainEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeAppchainEpochs)
                    }
                    finalizeAppchainEpochs
                },
                {
                    fn claimAllRewards(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <claimAllRewardsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::claimAllRewards)
                    }
                    claimAllRewards
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::transferOwnership)
                    }
                    transferOwnership
                },
                {
                    fn userAppchainFinalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userAppchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::userAppchainFinalizedEpochCount)
                    }
                    userAppchainFinalizedEpochCount
                },
                {
                    fn epochAppchainWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochAppchainWithdrawals)
                    }
                    epochAppchainWithdrawals
                },
                {
                    fn getUserStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getUserStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getUserStakeShare)
                    }
                    getUserStakeShare
                },
                {
                    fn getAppchainStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getAppchainStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getAppchainStake)
                    }
                    getAppchainStake
                },
                {
                    fn epochUserAppchainWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAppchainWithdrawals)
                    }
                    epochUserAppchainWithdrawals
                },
                {
                    fn finalizeEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeEpochs)
                    }
                    finalizeEpochs
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::EPOCH_DURATION(inner) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::START_TIMESTAMP(inner) => {
                    <START_TIMESTAMPCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::appchainFinalizedEpochCount(inner) => {
                    <appchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::appchainTotal(inner) => {
                    <appchainTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAllRewards(inner) => {
                    <claimAllRewardsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochAdditions(inner) => {
                    <epochAdditionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochAppchainAdditions(inner) => {
                    <epochAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochAppchainTotal(inner) => {
                    <epochAppchainTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochAppchainWithdrawals(inner) => {
                    <epochAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochStakeShare(inner) => {
                    <epochStakeShareCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochTotal(inner) => {
                    <epochTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::epochUserAdditions(inner) => {
                    <epochUserAdditionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochUserAppchainAdditions(inner) => {
                    <epochUserAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochUserAppchainTotal(inner) => {
                    <epochUserAppchainTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochUserAppchainWithdrawals(inner) => {
                    <epochUserAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochUserStakeShare(inner) => {
                    <epochUserStakeShareCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochUserTotal(inner) => {
                    <epochUserTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochUserWithdrawals(inner) => {
                    <epochUserWithdrawalsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochWithdrawals(inner) => {
                    <epochWithdrawalsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::finalizeAppchainEpochs(inner) => {
                    <finalizeAppchainEpochsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::finalizeEpochs(inner) => {
                    <finalizeEpochsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::finalizeUserAppchainEpochs(inner) => {
                    <finalizeUserAppchainEpochsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::finalizeUserEpochs(inner) => {
                    <finalizeUserEpochsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::finalizedEpochCount(inner) => {
                    <finalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAppchainStake(inner) => {
                    <getAppchainStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCurrentEpoch(inner) => {
                    <getCurrentEpochCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getEpochEnd(inner) => {
                    <getEpochEndCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getEpochStart(inner) => {
                    <getEpochStartCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getTotalStake(inner) => {
                    <getTotalStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getTotalStakeShare(inner) => {
                    <getTotalStakeShareCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getUserAppchainStake(inner) => {
                    <getUserAppchainStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getUserStake(inner) => {
                    <getUserStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getUserStakeShare(inner) => {
                    <getUserStakeShareCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getWithdrawalAmount(inner) => {
                    <getWithdrawalAmountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::initializeWithdrawal_0(inner) => {
                    <initializeWithdrawal_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::initializeWithdrawal_1(inner) => {
                    <initializeWithdrawal_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::initializeWithdrawals_0(inner) => {
                    <initializeWithdrawals_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::initializeWithdrawals_1(inner) => {
                    <initializeWithdrawals_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::stageStakeTransfer(inner) => {
                    <stageStakeTransferCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::stakeMultipleAppchains(inner) => {
                    <stakeMultipleAppchainsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::stakeSynd(inner) => {
                    <stakeSyndCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::totalStake(inner) => {
                    <totalStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::userAppchainFinalizedEpochCount(inner) => {
                    <userAppchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::userAppchainTotal(inner) => {
                    <userAppchainTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::userFinalizedEpochCount(inner) => {
                    <userFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::userTotal(inner) => {
                    <userTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::withdraw(inner) => {
                    <withdrawCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::withdrawBulk(inner) => {
                    <withdrawBulkCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::EPOCH_DURATION(inner) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::START_TIMESTAMP(inner) => {
                    <START_TIMESTAMPCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::appchainFinalizedEpochCount(inner) => {
                    <appchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::appchainTotal(inner) => {
                    <appchainTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAllRewards(inner) => {
                    <claimAllRewardsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochAdditions(inner) => {
                    <epochAdditionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochAppchainAdditions(inner) => {
                    <epochAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochAppchainTotal(inner) => {
                    <epochAppchainTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochAppchainWithdrawals(inner) => {
                    <epochAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochStakeShare(inner) => {
                    <epochStakeShareCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochTotal(inner) => {
                    <epochTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserAdditions(inner) => {
                    <epochUserAdditionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserAppchainAdditions(inner) => {
                    <epochUserAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserAppchainTotal(inner) => {
                    <epochUserAppchainTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserAppchainWithdrawals(inner) => {
                    <epochUserAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserStakeShare(inner) => {
                    <epochUserStakeShareCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserTotal(inner) => {
                    <epochUserTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserWithdrawals(inner) => {
                    <epochUserWithdrawalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochWithdrawals(inner) => {
                    <epochWithdrawalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::finalizeAppchainEpochs(inner) => {
                    <finalizeAppchainEpochsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::finalizeEpochs(inner) => {
                    <finalizeEpochsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::finalizeUserAppchainEpochs(inner) => {
                    <finalizeUserAppchainEpochsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::finalizeUserEpochs(inner) => {
                    <finalizeUserEpochsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::finalizedEpochCount(inner) => {
                    <finalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAppchainStake(inner) => {
                    <getAppchainStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCurrentEpoch(inner) => {
                    <getCurrentEpochCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getEpochEnd(inner) => {
                    <getEpochEndCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getEpochStart(inner) => {
                    <getEpochStartCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getTotalStake(inner) => {
                    <getTotalStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getTotalStakeShare(inner) => {
                    <getTotalStakeShareCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getUserAppchainStake(inner) => {
                    <getUserAppchainStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getUserStake(inner) => {
                    <getUserStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getUserStakeShare(inner) => {
                    <getUserStakeShareCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getWithdrawalAmount(inner) => {
                    <getWithdrawalAmountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initializeWithdrawal_0(inner) => {
                    <initializeWithdrawal_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initializeWithdrawal_1(inner) => {
                    <initializeWithdrawal_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initializeWithdrawals_0(inner) => {
                    <initializeWithdrawals_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initializeWithdrawals_1(inner) => {
                    <initializeWithdrawals_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::stageStakeTransfer(inner) => {
                    <stageStakeTransferCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::stakeMultipleAppchains(inner) => {
                    <stakeMultipleAppchainsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::stakeSynd(inner) => {
                    <stakeSyndCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::totalStake(inner) => {
                    <totalStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::userAppchainFinalizedEpochCount(inner) => {
                    <userAppchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::userAppchainTotal(inner) => {
                    <userAppchainTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::userFinalizedEpochCount(inner) => {
                    <userFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::userTotal(inner) => {
                    <userTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::withdraw(inner) => {
                    <withdrawCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::withdrawBulk(inner) => {
                    <withdrawBulkCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`SyndStaking`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum SyndStakingErrors {
        #[allow(missing_docs)]
        EnforcedPause(EnforcedPause),
        #[allow(missing_docs)]
        ExpectedPause(ExpectedPause),
        #[allow(missing_docs)]
        FailedCall(FailedCall),
        #[allow(missing_docs)]
        InsufficientBalance(InsufficientBalance),
        #[allow(missing_docs)]
        InsufficientStake(InsufficientStake),
        #[allow(missing_docs)]
        InvalidAmount(InvalidAmount),
        #[allow(missing_docs)]
        InvalidAppchainId(InvalidAppchainId),
        #[allow(missing_docs)]
        InvalidInput(InvalidInput),
        #[allow(missing_docs)]
        InvalidStakingAmount(InvalidStakingAmount),
        #[allow(missing_docs)]
        InvalidWithdrawal(InvalidWithdrawal),
        #[allow(missing_docs)]
        NoClaimsProvided(NoClaimsProvided),
        #[allow(missing_docs)]
        OwnableInvalidOwner(OwnableInvalidOwner),
        #[allow(missing_docs)]
        OwnableUnauthorizedAccount(OwnableUnauthorizedAccount),
        #[allow(missing_docs)]
        ReentrancyGuardReentrantCall(ReentrancyGuardReentrantCall),
        #[allow(missing_docs)]
        WithdrawalNotReady(WithdrawalNotReady),
        #[allow(missing_docs)]
        ZeroEpochIndex(ZeroEpochIndex),
    }
    #[automatically_derived]
    impl SyndStakingErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [15u8, 44u8, 166u8, 231u8],
            [17u8, 140u8, 218u8, 167u8],
            [30u8, 79u8, 189u8, 247u8],
            [44u8, 82u8, 17u8, 198u8],
            [62u8, 229u8, 174u8, 181u8],
            [141u8, 252u8, 32u8, 43u8],
            [162u8, 221u8, 32u8, 239u8],
            [180u8, 250u8, 63u8, 179u8],
            [187u8, 205u8, 63u8, 51u8],
            [201u8, 69u8, 36u8, 45u8],
            [207u8, 71u8, 145u8, 129u8],
            [214u8, 147u8, 104u8, 212u8],
            [214u8, 189u8, 162u8, 117u8],
            [217u8, 60u8, 6u8, 101u8],
            [241u8, 188u8, 148u8, 210u8],
            [246u8, 180u8, 19u8, 28u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndStakingErrors {
        const NAME: &'static str = "SyndStakingErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 16usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::EnforcedPause(_) => {
                    <EnforcedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExpectedPause(_) => {
                    <ExpectedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedCall(_) => {
                    <FailedCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientBalance(_) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientStake(_) => {
                    <InsufficientStake as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidAmount(_) => {
                    <InvalidAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidAppchainId(_) => {
                    <InvalidAppchainId as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidInput(_) => {
                    <InvalidInput as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidStakingAmount(_) => {
                    <InvalidStakingAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidWithdrawal(_) => {
                    <InvalidWithdrawal as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NoClaimsProvided(_) => {
                    <NoClaimsProvided as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableInvalidOwner(_) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableUnauthorizedAccount(_) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ReentrancyGuardReentrantCall(_) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::WithdrawalNotReady(_) => {
                    <WithdrawalNotReady as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroEpochIndex(_) => {
                    <ZeroEpochIndex as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SyndStakingErrors>] = &[
                {
                    fn WithdrawalNotReady(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <WithdrawalNotReady as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::WithdrawalNotReady)
                    }
                    WithdrawalNotReady
                },
                {
                    fn OwnableUnauthorizedAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::OwnableUnauthorizedAccount)
                    }
                    OwnableUnauthorizedAccount
                },
                {
                    fn OwnableInvalidOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::OwnableInvalidOwner)
                    }
                    OwnableInvalidOwner
                },
                {
                    fn InvalidAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidAmount)
                    }
                    InvalidAmount
                },
                {
                    fn ReentrancyGuardReentrantCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::ReentrancyGuardReentrantCall)
                    }
                    ReentrancyGuardReentrantCall
                },
                {
                    fn ExpectedPause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <ExpectedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::ExpectedPause)
                    }
                    ExpectedPause
                },
                {
                    fn InvalidStakingAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidStakingAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidStakingAmount)
                    }
                    InvalidStakingAmount
                },
                {
                    fn InvalidInput(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidInput as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(SyndStakingErrors::InvalidInput)
                    }
                    InvalidInput
                },
                {
                    fn NoClaimsProvided(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <NoClaimsProvided as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::NoClaimsProvided)
                    }
                    NoClaimsProvided
                },
                {
                    fn InvalidWithdrawal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidWithdrawal as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidWithdrawal)
                    }
                    InvalidWithdrawal
                },
                {
                    fn InsufficientBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::InsufficientBalance)
                    }
                    InsufficientBalance
                },
                {
                    fn ZeroEpochIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <ZeroEpochIndex as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::ZeroEpochIndex)
                    }
                    ZeroEpochIndex
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(SyndStakingErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn EnforcedPause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <EnforcedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::EnforcedPause)
                    }
                    EnforcedPause
                },
                {
                    fn InsufficientStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InsufficientStake as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::InsufficientStake)
                    }
                    InsufficientStake
                },
                {
                    fn InvalidAppchainId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidAppchainId as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidAppchainId)
                    }
                    InvalidAppchainId
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SyndStakingErrors>] = &[
                {
                    fn WithdrawalNotReady(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <WithdrawalNotReady as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::WithdrawalNotReady)
                    }
                    WithdrawalNotReady
                },
                {
                    fn OwnableUnauthorizedAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::OwnableUnauthorizedAccount)
                    }
                    OwnableUnauthorizedAccount
                },
                {
                    fn OwnableInvalidOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::OwnableInvalidOwner)
                    }
                    OwnableInvalidOwner
                },
                {
                    fn InvalidAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidAmount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidAmount)
                    }
                    InvalidAmount
                },
                {
                    fn ReentrancyGuardReentrantCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::ReentrancyGuardReentrantCall)
                    }
                    ReentrancyGuardReentrantCall
                },
                {
                    fn ExpectedPause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <ExpectedPause as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::ExpectedPause)
                    }
                    ExpectedPause
                },
                {
                    fn InvalidStakingAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidStakingAmount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidStakingAmount)
                    }
                    InvalidStakingAmount
                },
                {
                    fn InvalidInput(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidInput as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidInput)
                    }
                    InvalidInput
                },
                {
                    fn NoClaimsProvided(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <NoClaimsProvided as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::NoClaimsProvided)
                    }
                    NoClaimsProvided
                },
                {
                    fn InvalidWithdrawal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidWithdrawal as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidWithdrawal)
                    }
                    InvalidWithdrawal
                },
                {
                    fn InsufficientBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::InsufficientBalance)
                    }
                    InsufficientBalance
                },
                {
                    fn ZeroEpochIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <ZeroEpochIndex as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::ZeroEpochIndex)
                    }
                    ZeroEpochIndex
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn EnforcedPause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <EnforcedPause as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::EnforcedPause)
                    }
                    EnforcedPause
                },
                {
                    fn InsufficientStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InsufficientStake as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::InsufficientStake)
                    }
                    InsufficientStake
                },
                {
                    fn InvalidAppchainId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidAppchainId as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidAppchainId)
                    }
                    InvalidAppchainId
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InsufficientBalance(inner) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientStake(inner) => {
                    <InsufficientStake as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidAmount(inner) => {
                    <InvalidAmount as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidAppchainId(inner) => {
                    <InvalidAppchainId as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidInput(inner) => {
                    <InvalidInput as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidStakingAmount(inner) => {
                    <InvalidStakingAmount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidWithdrawal(inner) => {
                    <InvalidWithdrawal as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NoClaimsProvided(inner) => {
                    <NoClaimsProvided as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::WithdrawalNotReady(inner) => {
                    <WithdrawalNotReady as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroEpochIndex(inner) => {
                    <ZeroEpochIndex as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::InsufficientBalance(inner) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientStake(inner) => {
                    <InsufficientStake as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidAmount(inner) => {
                    <InvalidAmount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidAppchainId(inner) => {
                    <InvalidAppchainId as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidInput(inner) => {
                    <InvalidInput as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidStakingAmount(inner) => {
                    <InvalidStakingAmount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidWithdrawal(inner) => {
                    <InvalidWithdrawal as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NoClaimsProvided(inner) => {
                    <NoClaimsProvided as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::WithdrawalNotReady(inner) => {
                    <WithdrawalNotReady as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroEpochIndex(inner) => {
                    <ZeroEpochIndex as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`SyndStaking`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum SyndStakingEvents {
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
        #[allow(missing_docs)]
        Paused(Paused),
        #[allow(missing_docs)]
        Stake(Stake),
        #[allow(missing_docs)]
        StakeTransfer(StakeTransfer),
        #[allow(missing_docs)]
        Unpaused(Unpaused),
        #[allow(missing_docs)]
        WithdrawalCompleted(WithdrawalCompleted),
        #[allow(missing_docs)]
        WithdrawalInitialized(WithdrawalInitialized),
    }
    #[automatically_derived]
    impl SyndStakingEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                80u8, 122u8, 195u8, 158u8, 179u8, 54u8, 16u8, 25u8, 28u8, 216u8, 253u8,
                84u8, 40u8, 110u8, 145u8, 197u8, 204u8, 70u8, 76u8, 38u8, 40u8, 97u8,
                100u8, 59u8, 227u8, 151u8, 143u8, 90u8, 159u8, 24u8, 171u8, 2u8,
            ],
            [
                93u8, 185u8, 238u8, 10u8, 73u8, 91u8, 242u8, 230u8, 255u8, 156u8, 145u8,
                167u8, 131u8, 76u8, 27u8, 164u8, 253u8, 210u8, 68u8, 165u8, 232u8, 170u8,
                78u8, 83u8, 123u8, 211u8, 138u8, 234u8, 228u8, 176u8, 115u8, 170u8,
            ],
            [
                98u8, 231u8, 140u8, 234u8, 1u8, 190u8, 227u8, 32u8, 205u8, 78u8, 66u8,
                2u8, 112u8, 181u8, 234u8, 116u8, 0u8, 13u8, 17u8, 176u8, 201u8, 247u8,
                71u8, 84u8, 235u8, 219u8, 252u8, 84u8, 75u8, 5u8, 162u8, 88u8,
            ],
            [
                139u8, 212u8, 114u8, 142u8, 233u8, 202u8, 63u8, 153u8, 221u8, 207u8,
                250u8, 36u8, 235u8, 79u8, 21u8, 222u8, 1u8, 92u8, 218u8, 154u8, 39u8,
                204u8, 196u8, 39u8, 223u8, 218u8, 247u8, 17u8, 148u8, 62u8, 188u8, 160u8,
            ],
            [
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ],
            [
                176u8, 3u8, 130u8, 32u8, 59u8, 70u8, 195u8, 182u8, 173u8, 10u8, 45u8,
                122u8, 240u8, 38u8, 142u8, 51u8, 75u8, 217u8, 64u8, 98u8, 86u8, 167u8,
                199u8, 186u8, 143u8, 127u8, 200u8, 188u8, 71u8, 248u8, 205u8, 233u8,
            ],
            [
                179u8, 18u8, 144u8, 60u8, 226u8, 7u8, 210u8, 30u8, 132u8, 229u8, 125u8,
                16u8, 5u8, 224u8, 170u8, 83u8, 133u8, 183u8, 131u8, 235u8, 39u8, 226u8,
                88u8, 129u8, 113u8, 116u8, 208u8, 12u8, 251u8, 188u8, 50u8, 120u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for SyndStakingEvents {
        const NAME: &'static str = "SyndStakingEvents";
        const COUNT: usize = 7usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(<Paused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Paused as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Paused)
                }
                Some(<Stake as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Stake as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Stake)
                }
                Some(<StakeTransfer as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <StakeTransfer as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::StakeTransfer)
                }
                Some(<Unpaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Unpaused as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Unpaused)
                }
                Some(
                    <WithdrawalCompleted as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <WithdrawalCompleted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::WithdrawalCompleted)
                }
                Some(
                    <WithdrawalInitialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <WithdrawalInitialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::WithdrawalInitialized)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for SyndStakingEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Stake(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::StakeTransfer(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::WithdrawalCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::WithdrawalInitialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Stake(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::StakeTransfer(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::WithdrawalCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::WithdrawalInitialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`SyndStaking`](self) contract instance.

See the [wrapper's documentation](`SyndStakingInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> SyndStakingInstance<P, N> {
        SyndStakingInstance::<P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _defaultAdmin: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<SyndStakingInstance<P, N>>,
    > {
        SyndStakingInstance::<P, N>::deploy(provider, _defaultAdmin)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _defaultAdmin: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<P, N> {
        SyndStakingInstance::<P, N>::deploy_builder(provider, _defaultAdmin)
    }
    /**A [`SyndStaking`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`SyndStaking`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct SyndStakingInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for SyndStakingInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("SyndStakingInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SyndStakingInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`SyndStaking`](self) contract instance.

See the [wrapper's documentation](`SyndStakingInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            _defaultAdmin: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<SyndStakingInstance<P, N>> {
            let call_builder = Self::deploy_builder(provider, _defaultAdmin);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            _defaultAdmin: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall { _defaultAdmin },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> SyndStakingInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> SyndStakingInstance<P, N> {
            SyndStakingInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SyndStakingInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`EPOCH_DURATION`] function.
        pub fn EPOCH_DURATION(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, EPOCH_DURATIONCall, N> {
            self.call_builder(&EPOCH_DURATIONCall)
        }
        ///Creates a new call builder for the [`START_TIMESTAMP`] function.
        pub fn START_TIMESTAMP(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, START_TIMESTAMPCall, N> {
            self.call_builder(&START_TIMESTAMPCall)
        }
        ///Creates a new call builder for the [`appchainFinalizedEpochCount`] function.
        pub fn appchainFinalizedEpochCount(
            &self,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, appchainFinalizedEpochCountCall, N> {
            self.call_builder(
                &appchainFinalizedEpochCountCall {
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`appchainTotal`] function.
        pub fn appchainTotal(
            &self,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, appchainTotalCall, N> {
            self.call_builder(&appchainTotalCall { appchainId })
        }
        ///Creates a new call builder for the [`claimAllRewards`] function.
        pub fn claimAllRewards(
            &self,
            claims: alloy::sol_types::private::Vec<
                <ClaimRequest as alloy::sol_types::SolType>::RustType,
            >,
            destination: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, claimAllRewardsCall, N> {
            self.call_builder(
                &claimAllRewardsCall {
                    claims,
                    destination,
                },
            )
        }
        ///Creates a new call builder for the [`epochAdditions`] function.
        pub fn epochAdditions(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochAdditionsCall, N> {
            self.call_builder(&epochAdditionsCall { epochIndex })
        }
        ///Creates a new call builder for the [`epochAppchainAdditions`] function.
        pub fn epochAppchainAdditions(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochAppchainAdditionsCall, N> {
            self.call_builder(
                &epochAppchainAdditionsCall {
                    epochIndex,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochAppchainTotal`] function.
        pub fn epochAppchainTotal(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochAppchainTotalCall, N> {
            self.call_builder(
                &epochAppchainTotalCall {
                    epochIndex,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochAppchainWithdrawals`] function.
        pub fn epochAppchainWithdrawals(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochAppchainWithdrawalsCall, N> {
            self.call_builder(
                &epochAppchainWithdrawalsCall {
                    epochIndex,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochStakeShare`] function.
        pub fn epochStakeShare(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochStakeShareCall, N> {
            self.call_builder(&epochStakeShareCall { epochIndex })
        }
        ///Creates a new call builder for the [`epochTotal`] function.
        pub fn epochTotal(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochTotalCall, N> {
            self.call_builder(&epochTotalCall { epochIndex })
        }
        ///Creates a new call builder for the [`epochUserAdditions`] function.
        pub fn epochUserAdditions(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserAdditionsCall, N> {
            self.call_builder(
                &epochUserAdditionsCall {
                    epochIndex,
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`epochUserAppchainAdditions`] function.
        pub fn epochUserAppchainAdditions(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserAppchainAdditionsCall, N> {
            self.call_builder(
                &epochUserAppchainAdditionsCall {
                    epochIndex,
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochUserAppchainTotal`] function.
        pub fn epochUserAppchainTotal(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserAppchainTotalCall, N> {
            self.call_builder(
                &epochUserAppchainTotalCall {
                    epochIndex,
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochUserAppchainWithdrawals`] function.
        pub fn epochUserAppchainWithdrawals(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserAppchainWithdrawalsCall, N> {
            self.call_builder(
                &epochUserAppchainWithdrawalsCall {
                    epochIndex,
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochUserStakeShare`] function.
        pub fn epochUserStakeShare(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserStakeShareCall, N> {
            self.call_builder(
                &epochUserStakeShareCall {
                    epochIndex,
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`epochUserTotal`] function.
        pub fn epochUserTotal(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserTotalCall, N> {
            self.call_builder(
                &epochUserTotalCall {
                    epochIndex,
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`epochUserWithdrawals`] function.
        pub fn epochUserWithdrawals(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserWithdrawalsCall, N> {
            self.call_builder(
                &epochUserWithdrawalsCall {
                    epochIndex,
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`epochWithdrawals`] function.
        pub fn epochWithdrawals(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochWithdrawalsCall, N> {
            self.call_builder(&epochWithdrawalsCall { epochIndex })
        }
        ///Creates a new call builder for the [`finalizeAppchainEpochs`] function.
        pub fn finalizeAppchainEpochs(
            &self,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, finalizeAppchainEpochsCall, N> {
            self.call_builder(
                &finalizeAppchainEpochsCall {
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`finalizeEpochs`] function.
        pub fn finalizeEpochs(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, finalizeEpochsCall, N> {
            self.call_builder(&finalizeEpochsCall)
        }
        ///Creates a new call builder for the [`finalizeUserAppchainEpochs`] function.
        pub fn finalizeUserAppchainEpochs(
            &self,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, finalizeUserAppchainEpochsCall, N> {
            self.call_builder(
                &finalizeUserAppchainEpochsCall {
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`finalizeUserEpochs`] function.
        pub fn finalizeUserEpochs(
            &self,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, finalizeUserEpochsCall, N> {
            self.call_builder(&finalizeUserEpochsCall { user })
        }
        ///Creates a new call builder for the [`finalizedEpochCount`] function.
        pub fn finalizedEpochCount(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, finalizedEpochCountCall, N> {
            self.call_builder(&finalizedEpochCountCall)
        }
        ///Creates a new call builder for the [`getAppchainStake`] function.
        pub fn getAppchainStake(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getAppchainStakeCall, N> {
            self.call_builder(
                &getAppchainStakeCall {
                    epochIndex,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`getCurrentEpoch`] function.
        pub fn getCurrentEpoch(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getCurrentEpochCall, N> {
            self.call_builder(&getCurrentEpochCall)
        }
        ///Creates a new call builder for the [`getEpochEnd`] function.
        pub fn getEpochEnd(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getEpochEndCall, N> {
            self.call_builder(&getEpochEndCall { epochIndex })
        }
        ///Creates a new call builder for the [`getEpochStart`] function.
        pub fn getEpochStart(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getEpochStartCall, N> {
            self.call_builder(&getEpochStartCall { epochIndex })
        }
        ///Creates a new call builder for the [`getTotalStake`] function.
        pub fn getTotalStake(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getTotalStakeCall, N> {
            self.call_builder(&getTotalStakeCall { epochIndex })
        }
        ///Creates a new call builder for the [`getTotalStakeShare`] function.
        pub fn getTotalStakeShare(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getTotalStakeShareCall, N> {
            self.call_builder(
                &getTotalStakeShareCall {
                    epochIndex,
                },
            )
        }
        ///Creates a new call builder for the [`getUserAppchainStake`] function.
        pub fn getUserAppchainStake(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getUserAppchainStakeCall, N> {
            self.call_builder(
                &getUserAppchainStakeCall {
                    epochIndex,
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`getUserStake`] function.
        pub fn getUserStake(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getUserStakeCall, N> {
            self.call_builder(
                &getUserStakeCall {
                    epochIndex,
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`getUserStakeShare`] function.
        pub fn getUserStakeShare(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getUserStakeShareCall, N> {
            self.call_builder(
                &getUserStakeShareCall {
                    epochIndex,
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`getWithdrawalAmount`] function.
        pub fn getWithdrawalAmount(
            &self,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getWithdrawalAmountCall, N> {
            self.call_builder(
                &getWithdrawalAmountCall {
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`initializeWithdrawal_0`] function.
        pub fn initializeWithdrawal_0(
            &self,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, initializeWithdrawal_0Call, N> {
            self.call_builder(
                &initializeWithdrawal_0Call {
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`initializeWithdrawal_1`] function.
        pub fn initializeWithdrawal_1(
            &self,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, initializeWithdrawal_1Call, N> {
            self.call_builder(
                &initializeWithdrawal_1Call {
                    appchainId,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`initializeWithdrawals_0`] function.
        pub fn initializeWithdrawals_0(
            &self,
            appchainIds: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            amounts: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, initializeWithdrawals_0Call, N> {
            self.call_builder(
                &initializeWithdrawals_0Call {
                    appchainIds,
                    amounts,
                },
            )
        }
        ///Creates a new call builder for the [`initializeWithdrawals_1`] function.
        pub fn initializeWithdrawals_1(
            &self,
            appchainIds: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, initializeWithdrawals_1Call, N> {
            self.call_builder(
                &initializeWithdrawals_1Call {
                    appchainIds,
                },
            )
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<&P, ownerCall, N> {
            self.call_builder(&ownerCall)
        }
        ///Creates a new call builder for the [`pause`] function.
        pub fn pause(&self) -> alloy_contract::SolCallBuilder<&P, pauseCall, N> {
            self.call_builder(&pauseCall)
        }
        ///Creates a new call builder for the [`paused`] function.
        pub fn paused(&self) -> alloy_contract::SolCallBuilder<&P, pausedCall, N> {
            self.call_builder(&pausedCall)
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall)
        }
        ///Creates a new call builder for the [`stageStakeTransfer`] function.
        pub fn stageStakeTransfer(
            &self,
            fromAppchainId: alloy::sol_types::private::primitives::aliases::U256,
            toAppchainId: alloy::sol_types::private::primitives::aliases::U256,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, stageStakeTransferCall, N> {
            self.call_builder(
                &stageStakeTransferCall {
                    fromAppchainId,
                    toAppchainId,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`stakeMultipleAppchains`] function.
        pub fn stakeMultipleAppchains(
            &self,
            appchainIds: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            amounts: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, stakeMultipleAppchainsCall, N> {
            self.call_builder(
                &stakeMultipleAppchainsCall {
                    appchainIds,
                    amounts,
                },
            )
        }
        ///Creates a new call builder for the [`stakeSynd`] function.
        pub fn stakeSynd(
            &self,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, stakeSyndCall, N> {
            self.call_builder(&stakeSyndCall { appchainId })
        }
        ///Creates a new call builder for the [`totalStake`] function.
        pub fn totalStake(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, totalStakeCall, N> {
            self.call_builder(&totalStakeCall)
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        ///Creates a new call builder for the [`unpause`] function.
        pub fn unpause(&self) -> alloy_contract::SolCallBuilder<&P, unpauseCall, N> {
            self.call_builder(&unpauseCall)
        }
        ///Creates a new call builder for the [`userAppchainFinalizedEpochCount`] function.
        pub fn userAppchainFinalizedEpochCount(
            &self,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, userAppchainFinalizedEpochCountCall, N> {
            self.call_builder(
                &userAppchainFinalizedEpochCountCall {
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`userAppchainTotal`] function.
        pub fn userAppchainTotal(
            &self,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, userAppchainTotalCall, N> {
            self.call_builder(
                &userAppchainTotalCall {
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`userFinalizedEpochCount`] function.
        pub fn userFinalizedEpochCount(
            &self,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, userFinalizedEpochCountCall, N> {
            self.call_builder(
                &userFinalizedEpochCountCall {
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`userTotal`] function.
        pub fn userTotal(
            &self,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, userTotalCall, N> {
            self.call_builder(&userTotalCall { user })
        }
        ///Creates a new call builder for the [`withdraw`] function.
        pub fn withdraw(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            destination: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, withdrawCall, N> {
            self.call_builder(
                &withdrawCall {
                    epochIndex,
                    destination,
                },
            )
        }
        ///Creates a new call builder for the [`withdrawBulk`] function.
        pub fn withdrawBulk(
            &self,
            epochIndices: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            destination: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, withdrawBulkCall, N> {
            self.call_builder(
                &withdrawBulkCall {
                    epochIndices,
                    destination,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SyndStakingInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<&P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`Paused`] event.
        pub fn Paused_filter(&self) -> alloy_contract::Event<&P, Paused, N> {
            self.event_filter::<Paused>()
        }
        ///Creates a new event filter for the [`Stake`] event.
        pub fn Stake_filter(&self) -> alloy_contract::Event<&P, Stake, N> {
            self.event_filter::<Stake>()
        }
        ///Creates a new event filter for the [`StakeTransfer`] event.
        pub fn StakeTransfer_filter(
            &self,
        ) -> alloy_contract::Event<&P, StakeTransfer, N> {
            self.event_filter::<StakeTransfer>()
        }
        ///Creates a new event filter for the [`Unpaused`] event.
        pub fn Unpaused_filter(&self) -> alloy_contract::Event<&P, Unpaused, N> {
            self.event_filter::<Unpaused>()
        }
        ///Creates a new event filter for the [`WithdrawalCompleted`] event.
        pub fn WithdrawalCompleted_filter(
            &self,
        ) -> alloy_contract::Event<&P, WithdrawalCompleted, N> {
            self.event_filter::<WithdrawalCompleted>()
        }
        ///Creates a new event filter for the [`WithdrawalInitialized`] event.
        pub fn WithdrawalInitialized_filter(
            &self,
        ) -> alloy_contract::Event<&P, WithdrawalInitialized, N> {
            self.event_filter::<WithdrawalInitialized>()
        }
    }
}
