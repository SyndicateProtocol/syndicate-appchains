/**

Generated by the following Solidity interface...
```solidity
interface SyndStaking {
    error FailedCall();
    error InsufficientBalance(uint256 balance, uint256 needed);
    error InsufficientStake();
    error InvalidAmount();
    error InvalidAppchainId();
    error InvalidWithdrawal();
    error WithdrawalNotReady();

    event Stake(uint256 epochIndex, address user, uint256 amount, uint256 appchainId);
    event StakeTransfer(uint256 epochIndex, address user, uint256 amount, uint256 fromAppchainId, uint256 toAppchainId);
    event WithdrawalCompleted(address user, address destination, uint256 amount);
    event WithdrawalInitialized(address user, uint256 appchainId, uint256 amount);

    constructor(uint256 _startTimestamp);

    function EPOCH_DURATION() external view returns (uint256);
    function appchainFinalizedEpochCount(uint256 appchainId) external view returns (uint256 finalizedEpochCount);
    function appchainTotal(uint256 appchainId) external view returns (uint256 total);
    function epochAdditions(uint256 epochIndex) external view returns (uint256 additions);
    function epochAppchainAdditions(uint256 epochIndex, uint256 appchainId) external view returns (uint256 additions);
    function epochAppchainTotal(uint256 epochIndex, uint256 appchainId) external view returns (uint256 total);
    function epochAppchainWithdrawals(uint256 epochIndex, uint256 appchainId) external view returns (uint256 withdrawals);
    function epochStakeShare(uint256 epochIndex) external view returns (uint256 stakeShare);
    function epochTotal(uint256 epochIndex) external view returns (uint256 total);
    function epochUserAdditions(uint256 epochIndex, address user) external view returns (uint256 additions);
    function epochUserAppchainAdditions(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256 additions);
    function epochUserAppchainTotal(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256 total);
    function epochUserAppchainWithdrawals(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256 withdrawals);
    function epochUserStakeShare(uint256 epochIndex, address user) external view returns (uint256 stakeShare);
    function epochUserTotal(uint256 epochIndex, address user) external view returns (uint256 total);
    function epochUserWithdrawals(uint256 epochIndex, address user) external view returns (uint256 withdrawals);
    function epochWithdrawals(uint256 epochIndex) external view returns (uint256 withdrawals);
    function finalizeAppchainEpochs(uint256 appchainId) external;
    function finalizeEpochs() external;
    function finalizeUserAppchainEpochs(address user, uint256 appchainId) external;
    function finalizeUserEpochs(address user) external;
    function finalizedEpochCount() external view returns (uint256);
    function getAppchainStake(uint256 epochIndex, uint256 appchainId) external view returns (uint256);
    function getCurrentEpoch() external view returns (uint256);
    function getEpochEnd(uint256 epochIndex) external view returns (uint256);
    function getEpochStart(uint256 epochIndex) external view returns (uint256);
    function getTotalStake(uint256 epochIndex) external view returns (uint256);
    function getTotalStakeShare(uint256 epochIndex) external view returns (uint256);
    function getUserAppchainStake(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256);
    function getUserStake(uint256 epochIndex, address user) external view returns (uint256);
    function getUserStakeShare(uint256 epochIndex, address user) external view returns (uint256);
    function getWithdrawalAmount(address user, uint256 appchainId) external view returns (uint256);
    function initializeWithdrawal(uint256 appchainId) external;
    function initializeWithdrawal(uint256 appchainId, uint256 amount) external;
    function stageStakeTransfer(uint256 fromAppchainId, uint256 toAppchainId, uint256 amount) external payable;
    function stakeSynd(uint256 appchainId) external payable;
    function startTimestamp() external view returns (uint256);
    function totalStake() external view returns (uint256);
    function userAppchainFinalizedEpochCount(address user, uint256 appchainId) external view returns (uint256 finalizedEpochCount);
    function userAppchainTotal(address user, uint256 appchainId) external view returns (uint256 total);
    function userFinalizedEpochCount(address user) external view returns (uint256 finalizedEpochCount);
    function userTotal(address user) external view returns (uint256 total);
    function withdraw(uint256 epochIndex, address destination) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_startTimestamp",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "EPOCH_DURATION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "appchainFinalizedEpochCount",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "finalizedEpochCount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "appchainTotal",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochAdditions",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "additions",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochAppchainAdditions",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "additions",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochAppchainTotal",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochAppchainWithdrawals",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "withdrawals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochStakeShare",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "stakeShare",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochTotal",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserAdditions",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "additions",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserAppchainAdditions",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "additions",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserAppchainTotal",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserAppchainWithdrawals",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "withdrawals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserStakeShare",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "stakeShare",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserTotal",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochUserWithdrawals",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "withdrawals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochWithdrawals",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "withdrawals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "finalizeAppchainEpochs",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "finalizeEpochs",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "finalizeUserAppchainEpochs",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "finalizeUserEpochs",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "finalizedEpochCount",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAppchainStake",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCurrentEpoch",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getEpochEnd",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getEpochStart",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getTotalStake",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getTotalStakeShare",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getUserAppchainStake",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getUserStake",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getUserStakeShare",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getWithdrawalAmount",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initializeWithdrawal",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "initializeWithdrawal",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "stageStakeTransfer",
    "inputs": [
      {
        "name": "fromAppchainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "toAppchainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "stakeSynd",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "startTimestamp",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "totalStake",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "userAppchainFinalizedEpochCount",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "finalizedEpochCount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "userAppchainTotal",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "userFinalizedEpochCount",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "finalizedEpochCount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "userTotal",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "withdraw",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "destination",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Stake",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "StakeTransfer",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "user",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "fromAppchainId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "toAppchainId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "WithdrawalCompleted",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "destination",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "WithdrawalInitialized",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "FailedCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientBalance",
    "inputs": [
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientStake",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidAmount",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidAppchainId",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidWithdrawal",
    "inputs": []
  },
  {
    "type": "error",
    "name": "WithdrawalNotReady",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod SyndStaking {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a03461006f57601f611be938819003918201601f19168301916001600160401b038311848410176100735780849260209460405283398101031261006f5751608052604051611b61908161008882396080518181816103f701528181610f4e015281816116e40152611b2d0152f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60806040526004361015610011575f80fd5b5f3560e01c8062f714ce14610f725780630175e23b14610ef15780630458296f14610c42578063053dcd2514610bf05780630b281bf814610bc65780631057e9bc14610b9c57806312e973bc14610b725780631a8a738c14610b555780631b533b5a14610b035780631e0e848914610ad95780633ba00fae14610aaf578063408c32ea14610a7b57806345367f2314610a5d57806359193f37146107935780635d3d8cd214610a0b578063629454fd146109bc57806368a5556414610988578063693d0b7e146109395780637bda1cfb1461090a5780637c5dd5d9146108c55780637c6eaaee146108965780637e5f5ca7146108715780638b0e9f3f146108555780638c67903e1461082b5780639626a230146108055780639deb66c9146107e4578063a09d7a3014610793578063a70b9f0c14610776578063b97dd9e21461075c578063c3ddb3b314610743578063d5176d2314610725578063e58e53821461045f578063e601cf441461041a578063e6fd48bc146103e0578063ed86ba6f146103c9578063ee7514e814610377578063f03021a11461035b578063f89ee78d1461030a578063f965652d146102db578063f9d663e01461027f578063fa457be61461025e578063fa73ce591461020f5763fe07bb07146101f1575f80fd5b3461020b575f60031936011261020b57610209611a8a565b005b5f80fd5b3461020b5761021d366111f2565b915f52601260205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f20905f52602052602060405f2054604051908152f35b3461020b57602061027761027136611229565b906119ef565b604051908152f35b3461020b57604060031936011261020b5760206102776004356102a06111ac565b6102aa818361142f565b915f526015845273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52835260405f20549061124c565b3461020b576102e936611229565b905f52600d60205260405f20905f52602052602060405f2054604051908152f35b3461020b57604060031936011261020b5773ffffffffffffffffffffffffffffffffffffffff6103386111cf565b165f52601360205260405f206024355f52602052602060405f2054604051908152f35b3461020b57602060031936011261020b57610209600435611914565b3461020b57604060031936011261020b576103906111ac565b6004355f52601560205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b3461020b576102096103da36611229565b90611708565b3461020b575f60031936011261020b5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461020b57602060031936011261020b5773ffffffffffffffffffffffffffffffffffffffff6104486111cf565b165f526005602052602060405f2054604051908152f35b606060031936011261020b5760243560043560443580156106fd57811580156106f5575b6106cd57335f52600f60205260405f20825f526020528060405f2054106106a5577fb312903ce207d21e84e57d1005e0aa5385b783eb27e258817174d00cfbbc32789260a0926104d1611b24565b92335f5260096020528360405f205410610697575b815f52600e6020528360405f205410610689575b335f52601360205260405f20825f526020528360405f20541061067a575b835f52601060205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20825f5260205260405f2061055982825461124c565b9055835f52600b60205260405f20825f5260205260405f2061057c82825461124c565b9055335f52600f60205260405f20825f5260205260405f2061059f82825461123f565b9055815f52600a60205260405f206105b882825461123f565b9055835f52601160205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20835f5260205260405f206105fb82825461124c565b9055835f52600c60205260405f20835f5260205260405f2061061e82825461124c565b9055335f52600f60205260405f20835f5260205260405f2061064182825461124c565b9055825f52600a60205260405f2061065a82825461124c565b9055604051938452336020850152604084015260608301526080820152a1005b61068482336112e6565b610518565b61069282611914565b6104fa565b6106a0336114e4565b6104e6565b7ff1bc94d2000000000000000000000000000000000000000000000000000000005f5260045ffd5b7ff6b4131c000000000000000000000000000000000000000000000000000000005f5260045ffd5b508215610483565b7f2c5211c6000000000000000000000000000000000000000000000000000000005f5260045ffd5b3461020b57602060031936011261020b5760206102776004356116c7565b3461020b576020610277610756366111f2565b916115d5565b3461020b575f60031936011261020b576020610277611b24565b3461020b575f60031936011261020b57602060405162278d008152f35b3461020b57604060031936011261020b5773ffffffffffffffffffffffffffffffffffffffff6107c16111cf565b165f52600f60205260405f206024355f52602052602060405f2054604051908152f35b3461020b57602060031936011261020b576102096108006111cf565b6114e4565b3461020b57604060031936011261020b5760206102776108236111ac565b60043561142f565b3461020b57602060031936011261020b576004355f526003602052602060405f2054604051908152f35b3461020b575f60031936011261020b5760205f54604051908152f35b3461020b57604060031936011261020b5761020961088d6111cf565b602435906112e6565b3461020b576108a436611229565b905f52600c60205260405f20905f52602052602060405f2054604051908152f35b3461020b57602060031936011261020b5773ffffffffffffffffffffffffffffffffffffffff6108f36111cf565b165f526009602052602060405f2054604051908152f35b3461020b5761091836611229565b905f52600b60205260405f20905f52602052602060405f2054604051908152f35b3461020b57610947366111f2565b915f52601160205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f20905f52602052602060405f2054604051908152f35b3461020b57602060031936011261020b57610209600435335f52600f60205260405f20815f5260205260405f205490611708565b3461020b576109ca366111f2565b915f52601060205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f20905f52602052602060405f2054604051908152f35b3461020b57604060031936011261020b57610a246111ac565b6004355f52600860205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b3461020b57602060031936011261020b576020610277600435611259565b3461020b57602060031936011261020b576020610277600435610a9d81611259565b905f526014835260405f20549061124c565b3461020b57602060031936011261020b576004355f52600e602052602060405f2054604051908152f35b3461020b57602060031936011261020b576004355f526001602052602060405f2054604051908152f35b3461020b57604060031936011261020b57610b1c6111ac565b6004355f52600760205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b3461020b575f60031936011261020b576020600454604051908152f35b3461020b57602060031936011261020b576004355f526014602052602060405f2054604051908152f35b3461020b57602060031936011261020b576004355f52600a602052602060405f2054604051908152f35b3461020b57602060031936011261020b576004355f526002602052602060405f2054604051908152f35b3461020b57604060031936011261020b57610c096111ac565b6004355f52600660205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b602060031936011261020b5760043534156106fd5780156106cd57610c65611b24565b8060045410610ee4575b335f5260096020528060405f205410610ed6575b815f52600e6020528060405f205410610ec8575b335f52601360205260405f20825f526020528060405f205410610eb9575b610ccf610cc8610cc3611b24565b6116c7565b429061123f565b908134029134830403610e8c577f507ac39eb33610191cd8fd54286e91c5cc464c262861643be3978f5a9f18ab029262278d0060809304825f52601460205260405f20610d1d82825461124c565b9055825f52601560205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f52602052610d5660405f2091825461124c565b9055815f52600260205260405f20610d6f34825461124c565b9055610d7c345f5461124c565b5f55815f52600760205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20610db534825461124c565b9055335f52600560205260405f20610dce34825461124c565b9055815f52600c60205260405f20815f5260205260405f20610df134825461124c565b9055805f52600a60205260405f20610e0a34825461124c565b9055815f52601160205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20815f5260205260405f20610e4d34825461124c565b9055335f52600f60205260405f20815f5260205260405f20610e7034825461124c565b90556040519182523360208301523460408301526060820152a1005b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b610ec382336112e6565b610cb5565b610ed182611914565b610c97565b610edf336114e4565b610c83565b610eec611a8a565b610c6f565b3461020b57602060031936011261020b576004357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8101908111610e8c5762278d0081029080820462278d001490151715610e8c576102776020917f000000000000000000000000000000000000000000000000000000000000000061124c565b3461020b57604060031936011261020b57600435610f8e6111ac565b90610f97611b24565b81101561118457805f52600860205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f205491821561115c5773ffffffffffffffffffffffffffffffffffffffff91610ff1336114e4565b5f52600860205260405f208233165f526020525f6040812055169080471061112d575f80808084865af13d15611125573d9067ffffffffffffffff82116110f857604051917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f81601f8401160116830183811067ffffffffffffffff8211176110f85760405282523d5f602084013e5b156110c1577fb00382203b46c3b6ad0a2d7af0268e334bd9406256a7c7ba8f7fc8bc47f8cde9606084846040519133835260208301526040820152a1005b8051156110d057805190602001fd5b7fd6bda275000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b606090611083565b477fcf479181000000000000000000000000000000000000000000000000000000005f5260045260245260445ffd5b7fc945242d000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f0f2ca6e7000000000000000000000000000000000000000000000000000000005f5260045ffd5b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361020b57565b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361020b57565b600319606091011261020b576004359060243573ffffffffffffffffffffffffffffffffffffffff8116810361020b579060443590565b600319604091011261020b576004359060243590565b91908203918211610e8c57565b91908201809211610e8c57565b60045481106112aa576112a7906112946112815f54835f52600160205260405f20549061124c565b825f52600360205260405f20549061124c565b905f52600260205260405f20549061123f565b90565b5f52600160205260405f205490565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8114610e8c5760010190565b9073ffffffffffffffffffffffffffffffffffffffff611304611b24565b9216805f52601360205260405f20825f5260205260405f2054925b80841061133f57505f52601360205260405f20905f5260205260405f2055565b9261142990825f52600f60205260405f20845f5260205260405f2054815f52601060205260405f20845f5260205260405f20855f5260205261138660405f2091825461124c565b9055805f52601260205260405f20835f5260205260405f20845f5260205260405f2054815f52601060205260405f20845f5260205260405f20855f526020526113d460405f2091825461124c565b9055805f52601160205260405f20835f5260205260405f20845f5260205260405f2054815f52601060205260405f20845f5260205260405f20855f5260205261142260405f2091825461123f565b90556112b9565b9261131f565b9073ffffffffffffffffffffffffffffffffffffffff1690815f52600960205260405f20548110155f146114cb57816112a7925f5260056020526114ae61149160405f2054845f52600660205260405f20845f5260205260405f20549061124c565b835f52600860205260405f20835f5260205260405f20549061124c565b915f52600760205260405f20905f5260205260405f20549061123f565b5f52600660205260405f20905f5260205260405f205490565b73ffffffffffffffffffffffffffffffffffffffff611501611b24565b9116805f52600960205260405f2054915b80831061152857505f52600960205260405f2055565b916115cf90825f52600560205260405f2054815f52600660205260405f20845f5260205261155b60405f2091825461124c565b9055805f52600860205260405f20835f5260205260405f2054815f52600660205260405f20845f5260205261159560405f2091825461124c565b9055805f52600760205260405f20835f5260205260405f2054815f52600660205260405f20845f5260205261142260405f2091825461123f565b91611512565b9073ffffffffffffffffffffffffffffffffffffffff16805f52601360205260405f20835f5260205260405f20548210155f146116a35791826112a7935f52600f60205260405f20825f5260205261167c61165560405f2054855f52601060205260405f20845f5260205260405f20855f5260205260405f20549061124c565b845f52601260205260405f20835f5260205260405f20845f5260205260405f20549061124c565b925f52601160205260405f20905f5260205260405f20905f5260205260405f20549061123f565b905f52601060205260405f20905f5260205260405f20905f5260205260405f205490565b62278d0081029080820462278d001490151715610e8c576112a7907f000000000000000000000000000000000000000000000000000000000000000061124c565b9080156106fd5781156106cd57335f52600f60205260405f20825f526020528060405f2054106106a5577f8bd4728ee9ca3f99ddcffa24eb4f15de015cda9a27ccc427dfdaf711943ebca09160609161175f611b24565b8060045410611907575b335f5260096020528060405f2054106118f9575b825f52600e6020528060405f2054106118eb575b335f52601360205260405f20835f526020528060405f2054106118dc575b805f52600360205260405f206117c683825461124c565b9055805f52600860205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f206117ff83825461124c565b9055805f52600d60205260405f20835f5260205260405f2061182283825461124c565b90555f52601260205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20825f5260205260405f2061186482825461124c565b9055611871815f5461123f565b5f55335f52600560205260405f2061188a82825461123f565b9055815f52600a60205260405f206118a382825461123f565b9055335f52600f60205260405f20825f5260205260405f206118c682825461123f565b90556040519133835260208301526040820152a1565b6118e683336112e6565b6117af565b6118f483611914565b611791565b611902336114e4565b61177d565b61190f611a8a565b611769565b61191c611b24565b90805f52600e60205260405f2054915b80831061194257505f52600e60205260405f2055565b916119e990825f52600a60205260405f2054815f52600b60205260405f20845f5260205261197560405f2091825461124c565b9055805f52600d60205260405f20835f5260205260405f2054815f52600b60205260405f20845f526020526119af60405f2091825461124c565b9055805f52600c60205260405f20835f5260205260405f2054815f52600b60205260405f20845f5260205261142260405f2091825461123f565b9161192c565b5f828152600e60205260409020548110611a7157816112a7925f52600a602052611a54611a3760405f2054845f52600b60205260405f20845f5260205260405f20549061124c565b835f52600d60205260405f20835f5260205260405f20549061124c565b915f52600c60205260405f20905f5260205260405f20549061123f565b5f52600b60205260405f20905f5260205260405f205490565b611a92611b24565b905b60045482811015611b1f575f54905f526001602052611ab860405f2091825461124c565b9055600454805f52600360205260405f2054905f526001602052611ae160405f2091825461124c565b9055600454805f52600260205260405f2054905f526001602052611b0a60405f2091825461123f565b9055611b176004546112b9565b600455611a94565b509050565b62278d00611b527f00000000000000000000000000000000000000000000000000000000000000004261123f565b0460018101809111610e8c579056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA04a\0oW`\x1Fa\x1B\xE98\x81\x90\x03\x91\x82\x01`\x1F\x19\x16\x83\x01\x91`\x01`\x01`@\x1B\x03\x83\x11\x84\x84\x10\x17a\0sW\x80\x84\x92` \x94`@R\x839\x81\x01\x03\x12a\0oWQ`\x80R`@Qa\x1Ba\x90\x81a\0\x88\x829`\x80Q\x81\x81\x81a\x03\xF7\x01R\x81\x81a\x0FN\x01R\x81\x81a\x16\xE4\x01Ra\x1B-\x01R\xF3[_\x80\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD\xFE`\x80`@R`\x046\x10\x15a\0\x11W_\x80\xFD[_5`\xE0\x1C\x80b\xF7\x14\xCE\x14a\x0FrW\x80c\x01u\xE2;\x14a\x0E\xF1W\x80c\x04X)o\x14a\x0CBW\x80c\x05=\xCD%\x14a\x0B\xF0W\x80c\x0B(\x1B\xF8\x14a\x0B\xC6W\x80c\x10W\xE9\xBC\x14a\x0B\x9CW\x80c\x12\xE9s\xBC\x14a\x0BrW\x80c\x1A\x8As\x8C\x14a\x0BUW\x80c\x1BS;Z\x14a\x0B\x03W\x80c\x1E\x0E\x84\x89\x14a\n\xD9W\x80c;\xA0\x0F\xAE\x14a\n\xAFW\x80c@\x8C2\xEA\x14a\n{W\x80cE6\x7F#\x14a\n]W\x80cY\x19?7\x14a\x07\x93W\x80c]=\x8C\xD2\x14a\n\x0BW\x80cb\x94T\xFD\x14a\t\xBCW\x80ch\xA5Ud\x14a\t\x88W\x80ci=\x0B~\x14a\t9W\x80c{\xDA\x1C\xFB\x14a\t\nW\x80c|]\xD5\xD9\x14a\x08\xC5W\x80c|n\xAA\xEE\x14a\x08\x96W\x80c~_\\\xA7\x14a\x08qW\x80c\x8B\x0E\x9F?\x14a\x08UW\x80c\x8Cg\x90>\x14a\x08+W\x80c\x96&\xA20\x14a\x08\x05W\x80c\x9D\xEBf\xC9\x14a\x07\xE4W\x80c\xA0\x9Dz0\x14a\x07\x93W\x80c\xA7\x0B\x9F\x0C\x14a\x07vW\x80c\xB9}\xD9\xE2\x14a\x07\\W\x80c\xC3\xDD\xB3\xB3\x14a\x07CW\x80c\xD5\x17m#\x14a\x07%W\x80c\xE5\x8ES\x82\x14a\x04_W\x80c\xE6\x01\xCFD\x14a\x04\x1AW\x80c\xE6\xFDH\xBC\x14a\x03\xE0W\x80c\xED\x86\xBAo\x14a\x03\xC9W\x80c\xEEu\x14\xE8\x14a\x03wW\x80c\xF00!\xA1\x14a\x03[W\x80c\xF8\x9E\xE7\x8D\x14a\x03\nW\x80c\xF9ee-\x14a\x02\xDBW\x80c\xF9\xD6c\xE0\x14a\x02\x7FW\x80c\xFAE{\xE6\x14a\x02^W\x80c\xFAs\xCEY\x14a\x02\x0FWc\xFE\x07\xBB\x07\x14a\x01\xF1W_\x80\xFD[4a\x02\x0BW_`\x03\x196\x01\x12a\x02\x0BWa\x02\ta\x1A\x8AV[\0[_\x80\xFD[4a\x02\x0BWa\x02\x1D6a\x11\xF2V[\x91_R`\x12` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW` a\x02wa\x02q6a\x12)V[\x90a\x19\xEFV[`@Q\x90\x81R\xF3[4a\x02\x0BW`@`\x03\x196\x01\x12a\x02\x0BW` a\x02w`\x045a\x02\xA0a\x11\xACV[a\x02\xAA\x81\x83a\x14/V[\x91_R`\x15\x84Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R\x83R`@_ T\x90a\x12LV[4a\x02\x0BWa\x02\xE96a\x12)V[\x90_R`\r` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW`@`\x03\x196\x01\x12a\x02\x0BWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x038a\x11\xCFV[\x16_R`\x13` R`@_ `$5_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BWa\x02\t`\x045a\x19\x14V[4a\x02\x0BW`@`\x03\x196\x01\x12a\x02\x0BWa\x03\x90a\x11\xACV[`\x045_R`\x15` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BWa\x02\ta\x03\xDA6a\x12)V[\x90a\x17\x08V[4a\x02\x0BW_`\x03\x196\x01\x12a\x02\x0BW` `@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xF3[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x04Ha\x11\xCFV[\x16_R`\x05` R` `@_ T`@Q\x90\x81R\xF3[```\x03\x196\x01\x12a\x02\x0BW`$5`\x045`D5\x80\x15a\x06\xFDW\x81\x15\x80\x15a\x06\xF5W[a\x06\xCDW3_R`\x0F` R`@_ \x82_R` R\x80`@_ T\x10a\x06\xA5W\x7F\xB3\x12\x90<\xE2\x07\xD2\x1E\x84\xE5}\x10\x05\xE0\xAAS\x85\xB7\x83\xEB'\xE2X\x81qt\xD0\x0C\xFB\xBC2x\x92`\xA0\x92a\x04\xD1a\x1B$V[\x923_R`\t` R\x83`@_ T\x10a\x06\x97W[\x81_R`\x0E` R\x83`@_ T\x10a\x06\x89W[3_R`\x13` R`@_ \x82_R` R\x83`@_ T\x10a\x06zW[\x83_R`\x10` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x82_R` R`@_ a\x05Y\x82\x82Ta\x12LV[\x90U\x83_R`\x0B` R`@_ \x82_R` R`@_ a\x05|\x82\x82Ta\x12LV[\x90U3_R`\x0F` R`@_ \x82_R` R`@_ a\x05\x9F\x82\x82Ta\x12?V[\x90U\x81_R`\n` R`@_ a\x05\xB8\x82\x82Ta\x12?V[\x90U\x83_R`\x11` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x83_R` R`@_ a\x05\xFB\x82\x82Ta\x12LV[\x90U\x83_R`\x0C` R`@_ \x83_R` R`@_ a\x06\x1E\x82\x82Ta\x12LV[\x90U3_R`\x0F` R`@_ \x83_R` R`@_ a\x06A\x82\x82Ta\x12LV[\x90U\x82_R`\n` R`@_ a\x06Z\x82\x82Ta\x12LV[\x90U`@Q\x93\x84R3` \x85\x01R`@\x84\x01R``\x83\x01R`\x80\x82\x01R\xA1\0[a\x06\x84\x823a\x12\xE6V[a\x05\x18V[a\x06\x92\x82a\x19\x14V[a\x04\xFAV[a\x06\xA03a\x14\xE4V[a\x04\xE6V[\x7F\xF1\xBC\x94\xD2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\xF6\xB4\x13\x1C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[P\x82\x15a\x04\x83V[\x7F,R\x11\xC6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BW` a\x02w`\x045a\x16\xC7V[4a\x02\x0BW` a\x02wa\x07V6a\x11\xF2V[\x91a\x15\xD5V[4a\x02\x0BW_`\x03\x196\x01\x12a\x02\x0BW` a\x02wa\x1B$V[4a\x02\x0BW_`\x03\x196\x01\x12a\x02\x0BW` `@Qb'\x8D\0\x81R\xF3[4a\x02\x0BW`@`\x03\x196\x01\x12a\x02\x0BWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x07\xC1a\x11\xCFV[\x16_R`\x0F` R`@_ `$5_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BWa\x02\ta\x08\0a\x11\xCFV[a\x14\xE4V[4a\x02\x0BW`@`\x03\x196\x01\x12a\x02\x0BW` a\x02wa\x08#a\x11\xACV[`\x045a\x14/V[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BW`\x045_R`\x03` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW_`\x03\x196\x01\x12a\x02\x0BW` _T`@Q\x90\x81R\xF3[4a\x02\x0BW`@`\x03\x196\x01\x12a\x02\x0BWa\x02\ta\x08\x8Da\x11\xCFV[`$5\x90a\x12\xE6V[4a\x02\x0BWa\x08\xA46a\x12)V[\x90_R`\x0C` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x08\xF3a\x11\xCFV[\x16_R`\t` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BWa\t\x186a\x12)V[\x90_R`\x0B` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BWa\tG6a\x11\xF2V[\x91_R`\x11` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BWa\x02\t`\x0453_R`\x0F` R`@_ \x81_R` R`@_ T\x90a\x17\x08V[4a\x02\x0BWa\t\xCA6a\x11\xF2V[\x91_R`\x10` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW`@`\x03\x196\x01\x12a\x02\x0BWa\n$a\x11\xACV[`\x045_R`\x08` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BW` a\x02w`\x045a\x12YV[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BW` a\x02w`\x045a\n\x9D\x81a\x12YV[\x90_R`\x14\x83R`@_ T\x90a\x12LV[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BW`\x045_R`\x0E` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BW`\x045_R`\x01` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW`@`\x03\x196\x01\x12a\x02\x0BWa\x0B\x1Ca\x11\xACV[`\x045_R`\x07` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW_`\x03\x196\x01\x12a\x02\x0BW` `\x04T`@Q\x90\x81R\xF3[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BW`\x045_R`\x14` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BW`\x045_R`\n` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BW`\x045_R`\x02` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW`@`\x03\x196\x01\x12a\x02\x0BWa\x0C\ta\x11\xACV[`\x045_R`\x06` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[` `\x03\x196\x01\x12a\x02\x0BW`\x0454\x15a\x06\xFDW\x80\x15a\x06\xCDWa\x0Cea\x1B$V[\x80`\x04T\x10a\x0E\xE4W[3_R`\t` R\x80`@_ T\x10a\x0E\xD6W[\x81_R`\x0E` R\x80`@_ T\x10a\x0E\xC8W[3_R`\x13` R`@_ \x82_R` R\x80`@_ T\x10a\x0E\xB9W[a\x0C\xCFa\x0C\xC8a\x0C\xC3a\x1B$V[a\x16\xC7V[B\x90a\x12?V[\x90\x814\x02\x914\x83\x04\x03a\x0E\x8CW\x7FPz\xC3\x9E\xB36\x10\x19\x1C\xD8\xFDT(n\x91\xC5\xCCFL&(ad;\xE3\x97\x8FZ\x9F\x18\xAB\x02\x92b'\x8D\0`\x80\x93\x04\x82_R`\x14` R`@_ a\r\x1D\x82\x82Ta\x12LV[\x90U\x82_R`\x15` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` Ra\rV`@_ \x91\x82Ta\x12LV[\x90U\x81_R`\x02` R`@_ a\ro4\x82Ta\x12LV[\x90Ua\r|4_Ta\x12LV[_U\x81_R`\x07` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ a\r\xB54\x82Ta\x12LV[\x90U3_R`\x05` R`@_ a\r\xCE4\x82Ta\x12LV[\x90U\x81_R`\x0C` R`@_ \x81_R` R`@_ a\r\xF14\x82Ta\x12LV[\x90U\x80_R`\n` R`@_ a\x0E\n4\x82Ta\x12LV[\x90U\x81_R`\x11` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x81_R` R`@_ a\x0EM4\x82Ta\x12LV[\x90U3_R`\x0F` R`@_ \x81_R` R`@_ a\x0Ep4\x82Ta\x12LV[\x90U`@Q\x91\x82R3` \x83\x01R4`@\x83\x01R``\x82\x01R\xA1\0[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[a\x0E\xC3\x823a\x12\xE6V[a\x0C\xB5V[a\x0E\xD1\x82a\x19\x14V[a\x0C\x97V[a\x0E\xDF3a\x14\xE4V[a\x0C\x83V[a\x0E\xECa\x1A\x8AV[a\x0CoV[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BW`\x045\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x01\x90\x81\x11a\x0E\x8CWb'\x8D\0\x81\x02\x90\x80\x82\x04b'\x8D\0\x14\x90\x15\x17\x15a\x0E\x8CWa\x02w` \x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x12LV[4a\x02\x0BW`@`\x03\x196\x01\x12a\x02\x0BW`\x045a\x0F\x8Ea\x11\xACV[\x90a\x0F\x97a\x1B$V[\x81\x10\x15a\x11\x84W\x80_R`\x08` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ T\x91\x82\x15a\x11\\Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x0F\xF13a\x14\xE4V[_R`\x08` R`@_ \x823\x16_R` R_`@\x81 U\x16\x90\x80G\x10a\x11-W_\x80\x80\x80\x84\x86Z\xF1=\x15a\x11%W=\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x10\xF8W`@Q\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`?\x81`\x1F\x84\x01\x16\x01\x16\x83\x01\x83\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x10\xF8W`@R\x82R=_` \x84\x01>[\x15a\x10\xC1W\x7F\xB0\x03\x82 ;F\xC3\xB6\xAD\n-z\xF0&\x8E3K\xD9@bV\xA7\xC7\xBA\x8F\x7F\xC8\xBCG\xF8\xCD\xE9``\x84\x84`@Q\x913\x83R` \x83\x01R`@\x82\x01R\xA1\0[\x80Q\x15a\x10\xD0W\x80Q\x90` \x01\xFD[\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[``\x90a\x10\x83V[G\x7F\xCFG\x91\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$R`D_\xFD[\x7F\xC9E$-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\x0F,\xA6\xE7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[`$5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x02\x0BWV[`\x045\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x02\x0BWV[`\x03\x19``\x91\x01\x12a\x02\x0BW`\x045\x90`$5s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x02\x0BW\x90`D5\x90V[`\x03\x19`@\x91\x01\x12a\x02\x0BW`\x045\x90`$5\x90V[\x91\x90\x82\x03\x91\x82\x11a\x0E\x8CWV[\x91\x90\x82\x01\x80\x92\x11a\x0E\x8CWV[`\x04T\x81\x10a\x12\xAAWa\x12\xA7\x90a\x12\x94a\x12\x81_T\x83_R`\x01` R`@_ T\x90a\x12LV[\x82_R`\x03` R`@_ T\x90a\x12LV[\x90_R`\x02` R`@_ T\x90a\x12?V[\x90V[_R`\x01` R`@_ T\x90V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x14a\x0E\x8CW`\x01\x01\x90V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x13\x04a\x1B$V[\x92\x16\x80_R`\x13` R`@_ \x82_R` R`@_ T\x92[\x80\x84\x10a\x13?WP_R`\x13` R`@_ \x90_R` R`@_ UV[\x92a\x14)\x90\x82_R`\x0F` R`@_ \x84_R` R`@_ T\x81_R`\x10` R`@_ \x84_R` R`@_ \x85_R` Ra\x13\x86`@_ \x91\x82Ta\x12LV[\x90U\x80_R`\x12` R`@_ \x83_R` R`@_ \x84_R` R`@_ T\x81_R`\x10` R`@_ \x84_R` R`@_ \x85_R` Ra\x13\xD4`@_ \x91\x82Ta\x12LV[\x90U\x80_R`\x11` R`@_ \x83_R` R`@_ \x84_R` R`@_ T\x81_R`\x10` R`@_ \x84_R` R`@_ \x85_R` Ra\x14\"`@_ \x91\x82Ta\x12?V[\x90Ua\x12\xB9V[\x92a\x13\x1FV[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81_R`\t` R`@_ T\x81\x10\x15_\x14a\x14\xCBW\x81a\x12\xA7\x92_R`\x05` Ra\x14\xAEa\x14\x91`@_ T\x84_R`\x06` R`@_ \x84_R` R`@_ T\x90a\x12LV[\x83_R`\x08` R`@_ \x83_R` R`@_ T\x90a\x12LV[\x91_R`\x07` R`@_ \x90_R` R`@_ T\x90a\x12?V[_R`\x06` R`@_ \x90_R` R`@_ T\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x15\x01a\x1B$V[\x91\x16\x80_R`\t` R`@_ T\x91[\x80\x83\x10a\x15(WP_R`\t` R`@_ UV[\x91a\x15\xCF\x90\x82_R`\x05` R`@_ T\x81_R`\x06` R`@_ \x84_R` Ra\x15[`@_ \x91\x82Ta\x12LV[\x90U\x80_R`\x08` R`@_ \x83_R` R`@_ T\x81_R`\x06` R`@_ \x84_R` Ra\x15\x95`@_ \x91\x82Ta\x12LV[\x90U\x80_R`\x07` R`@_ \x83_R` R`@_ T\x81_R`\x06` R`@_ \x84_R` Ra\x14\"`@_ \x91\x82Ta\x12?V[\x91a\x15\x12V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80_R`\x13` R`@_ \x83_R` R`@_ T\x82\x10\x15_\x14a\x16\xA3W\x91\x82a\x12\xA7\x93_R`\x0F` R`@_ \x82_R` Ra\x16|a\x16U`@_ T\x85_R`\x10` R`@_ \x84_R` R`@_ \x85_R` R`@_ T\x90a\x12LV[\x84_R`\x12` R`@_ \x83_R` R`@_ \x84_R` R`@_ T\x90a\x12LV[\x92_R`\x11` R`@_ \x90_R` R`@_ \x90_R` R`@_ T\x90a\x12?V[\x90_R`\x10` R`@_ \x90_R` R`@_ \x90_R` R`@_ T\x90V[b'\x8D\0\x81\x02\x90\x80\x82\x04b'\x8D\0\x14\x90\x15\x17\x15a\x0E\x8CWa\x12\xA7\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x12LV[\x90\x80\x15a\x06\xFDW\x81\x15a\x06\xCDW3_R`\x0F` R`@_ \x82_R` R\x80`@_ T\x10a\x06\xA5W\x7F\x8B\xD4r\x8E\xE9\xCA?\x99\xDD\xCF\xFA$\xEBO\x15\xDE\x01\\\xDA\x9A'\xCC\xC4'\xDF\xDA\xF7\x11\x94>\xBC\xA0\x91``\x91a\x17_a\x1B$V[\x80`\x04T\x10a\x19\x07W[3_R`\t` R\x80`@_ T\x10a\x18\xF9W[\x82_R`\x0E` R\x80`@_ T\x10a\x18\xEBW[3_R`\x13` R`@_ \x83_R` R\x80`@_ T\x10a\x18\xDCW[\x80_R`\x03` R`@_ a\x17\xC6\x83\x82Ta\x12LV[\x90U\x80_R`\x08` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ a\x17\xFF\x83\x82Ta\x12LV[\x90U\x80_R`\r` R`@_ \x83_R` R`@_ a\x18\"\x83\x82Ta\x12LV[\x90U_R`\x12` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x82_R` R`@_ a\x18d\x82\x82Ta\x12LV[\x90Ua\x18q\x81_Ta\x12?V[_U3_R`\x05` R`@_ a\x18\x8A\x82\x82Ta\x12?V[\x90U\x81_R`\n` R`@_ a\x18\xA3\x82\x82Ta\x12?V[\x90U3_R`\x0F` R`@_ \x82_R` R`@_ a\x18\xC6\x82\x82Ta\x12?V[\x90U`@Q\x913\x83R` \x83\x01R`@\x82\x01R\xA1V[a\x18\xE6\x833a\x12\xE6V[a\x17\xAFV[a\x18\xF4\x83a\x19\x14V[a\x17\x91V[a\x19\x023a\x14\xE4V[a\x17}V[a\x19\x0Fa\x1A\x8AV[a\x17iV[a\x19\x1Ca\x1B$V[\x90\x80_R`\x0E` R`@_ T\x91[\x80\x83\x10a\x19BWP_R`\x0E` R`@_ UV[\x91a\x19\xE9\x90\x82_R`\n` R`@_ T\x81_R`\x0B` R`@_ \x84_R` Ra\x19u`@_ \x91\x82Ta\x12LV[\x90U\x80_R`\r` R`@_ \x83_R` R`@_ T\x81_R`\x0B` R`@_ \x84_R` Ra\x19\xAF`@_ \x91\x82Ta\x12LV[\x90U\x80_R`\x0C` R`@_ \x83_R` R`@_ T\x81_R`\x0B` R`@_ \x84_R` Ra\x14\"`@_ \x91\x82Ta\x12?V[\x91a\x19,V[_\x82\x81R`\x0E` R`@\x90 T\x81\x10a\x1AqW\x81a\x12\xA7\x92_R`\n` Ra\x1ATa\x1A7`@_ T\x84_R`\x0B` R`@_ \x84_R` R`@_ T\x90a\x12LV[\x83_R`\r` R`@_ \x83_R` R`@_ T\x90a\x12LV[\x91_R`\x0C` R`@_ \x90_R` R`@_ T\x90a\x12?V[_R`\x0B` R`@_ \x90_R` R`@_ T\x90V[a\x1A\x92a\x1B$V[\x90[`\x04T\x82\x81\x10\x15a\x1B\x1FW_T\x90_R`\x01` Ra\x1A\xB8`@_ \x91\x82Ta\x12LV[\x90U`\x04T\x80_R`\x03` R`@_ T\x90_R`\x01` Ra\x1A\xE1`@_ \x91\x82Ta\x12LV[\x90U`\x04T\x80_R`\x02` R`@_ T\x90_R`\x01` Ra\x1B\n`@_ \x91\x82Ta\x12?V[\x90Ua\x1B\x17`\x04Ta\x12\xB9V[`\x04Ua\x1A\x94V[P\x90PV[b'\x8D\0a\x1BR\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Ba\x12?V[\x04`\x01\x81\x01\x80\x91\x11a\x0E\x8CW\x90V",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610011575f80fd5b5f3560e01c8062f714ce14610f725780630175e23b14610ef15780630458296f14610c42578063053dcd2514610bf05780630b281bf814610bc65780631057e9bc14610b9c57806312e973bc14610b725780631a8a738c14610b555780631b533b5a14610b035780631e0e848914610ad95780633ba00fae14610aaf578063408c32ea14610a7b57806345367f2314610a5d57806359193f37146107935780635d3d8cd214610a0b578063629454fd146109bc57806368a5556414610988578063693d0b7e146109395780637bda1cfb1461090a5780637c5dd5d9146108c55780637c6eaaee146108965780637e5f5ca7146108715780638b0e9f3f146108555780638c67903e1461082b5780639626a230146108055780639deb66c9146107e4578063a09d7a3014610793578063a70b9f0c14610776578063b97dd9e21461075c578063c3ddb3b314610743578063d5176d2314610725578063e58e53821461045f578063e601cf441461041a578063e6fd48bc146103e0578063ed86ba6f146103c9578063ee7514e814610377578063f03021a11461035b578063f89ee78d1461030a578063f965652d146102db578063f9d663e01461027f578063fa457be61461025e578063fa73ce591461020f5763fe07bb07146101f1575f80fd5b3461020b575f60031936011261020b57610209611a8a565b005b5f80fd5b3461020b5761021d366111f2565b915f52601260205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f20905f52602052602060405f2054604051908152f35b3461020b57602061027761027136611229565b906119ef565b604051908152f35b3461020b57604060031936011261020b5760206102776004356102a06111ac565b6102aa818361142f565b915f526015845273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52835260405f20549061124c565b3461020b576102e936611229565b905f52600d60205260405f20905f52602052602060405f2054604051908152f35b3461020b57604060031936011261020b5773ffffffffffffffffffffffffffffffffffffffff6103386111cf565b165f52601360205260405f206024355f52602052602060405f2054604051908152f35b3461020b57602060031936011261020b57610209600435611914565b3461020b57604060031936011261020b576103906111ac565b6004355f52601560205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b3461020b576102096103da36611229565b90611708565b3461020b575f60031936011261020b5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461020b57602060031936011261020b5773ffffffffffffffffffffffffffffffffffffffff6104486111cf565b165f526005602052602060405f2054604051908152f35b606060031936011261020b5760243560043560443580156106fd57811580156106f5575b6106cd57335f52600f60205260405f20825f526020528060405f2054106106a5577fb312903ce207d21e84e57d1005e0aa5385b783eb27e258817174d00cfbbc32789260a0926104d1611b24565b92335f5260096020528360405f205410610697575b815f52600e6020528360405f205410610689575b335f52601360205260405f20825f526020528360405f20541061067a575b835f52601060205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20825f5260205260405f2061055982825461124c565b9055835f52600b60205260405f20825f5260205260405f2061057c82825461124c565b9055335f52600f60205260405f20825f5260205260405f2061059f82825461123f565b9055815f52600a60205260405f206105b882825461123f565b9055835f52601160205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20835f5260205260405f206105fb82825461124c565b9055835f52600c60205260405f20835f5260205260405f2061061e82825461124c565b9055335f52600f60205260405f20835f5260205260405f2061064182825461124c565b9055825f52600a60205260405f2061065a82825461124c565b9055604051938452336020850152604084015260608301526080820152a1005b61068482336112e6565b610518565b61069282611914565b6104fa565b6106a0336114e4565b6104e6565b7ff1bc94d2000000000000000000000000000000000000000000000000000000005f5260045ffd5b7ff6b4131c000000000000000000000000000000000000000000000000000000005f5260045ffd5b508215610483565b7f2c5211c6000000000000000000000000000000000000000000000000000000005f5260045ffd5b3461020b57602060031936011261020b5760206102776004356116c7565b3461020b576020610277610756366111f2565b916115d5565b3461020b575f60031936011261020b576020610277611b24565b3461020b575f60031936011261020b57602060405162278d008152f35b3461020b57604060031936011261020b5773ffffffffffffffffffffffffffffffffffffffff6107c16111cf565b165f52600f60205260405f206024355f52602052602060405f2054604051908152f35b3461020b57602060031936011261020b576102096108006111cf565b6114e4565b3461020b57604060031936011261020b5760206102776108236111ac565b60043561142f565b3461020b57602060031936011261020b576004355f526003602052602060405f2054604051908152f35b3461020b575f60031936011261020b5760205f54604051908152f35b3461020b57604060031936011261020b5761020961088d6111cf565b602435906112e6565b3461020b576108a436611229565b905f52600c60205260405f20905f52602052602060405f2054604051908152f35b3461020b57602060031936011261020b5773ffffffffffffffffffffffffffffffffffffffff6108f36111cf565b165f526009602052602060405f2054604051908152f35b3461020b5761091836611229565b905f52600b60205260405f20905f52602052602060405f2054604051908152f35b3461020b57610947366111f2565b915f52601160205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f20905f52602052602060405f2054604051908152f35b3461020b57602060031936011261020b57610209600435335f52600f60205260405f20815f5260205260405f205490611708565b3461020b576109ca366111f2565b915f52601060205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f20905f52602052602060405f2054604051908152f35b3461020b57604060031936011261020b57610a246111ac565b6004355f52600860205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b3461020b57602060031936011261020b576020610277600435611259565b3461020b57602060031936011261020b576020610277600435610a9d81611259565b905f526014835260405f20549061124c565b3461020b57602060031936011261020b576004355f52600e602052602060405f2054604051908152f35b3461020b57602060031936011261020b576004355f526001602052602060405f2054604051908152f35b3461020b57604060031936011261020b57610b1c6111ac565b6004355f52600760205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b3461020b575f60031936011261020b576020600454604051908152f35b3461020b57602060031936011261020b576004355f526014602052602060405f2054604051908152f35b3461020b57602060031936011261020b576004355f52600a602052602060405f2054604051908152f35b3461020b57602060031936011261020b576004355f526002602052602060405f2054604051908152f35b3461020b57604060031936011261020b57610c096111ac565b6004355f52600660205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060405f2054604051908152f35b602060031936011261020b5760043534156106fd5780156106cd57610c65611b24565b8060045410610ee4575b335f5260096020528060405f205410610ed6575b815f52600e6020528060405f205410610ec8575b335f52601360205260405f20825f526020528060405f205410610eb9575b610ccf610cc8610cc3611b24565b6116c7565b429061123f565b908134029134830403610e8c577f507ac39eb33610191cd8fd54286e91c5cc464c262861643be3978f5a9f18ab029262278d0060809304825f52601460205260405f20610d1d82825461124c565b9055825f52601560205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f52602052610d5660405f2091825461124c565b9055815f52600260205260405f20610d6f34825461124c565b9055610d7c345f5461124c565b5f55815f52600760205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20610db534825461124c565b9055335f52600560205260405f20610dce34825461124c565b9055815f52600c60205260405f20815f5260205260405f20610df134825461124c565b9055805f52600a60205260405f20610e0a34825461124c565b9055815f52601160205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20815f5260205260405f20610e4d34825461124c565b9055335f52600f60205260405f20815f5260205260405f20610e7034825461124c565b90556040519182523360208301523460408301526060820152a1005b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b610ec382336112e6565b610cb5565b610ed182611914565b610c97565b610edf336114e4565b610c83565b610eec611a8a565b610c6f565b3461020b57602060031936011261020b576004357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8101908111610e8c5762278d0081029080820462278d001490151715610e8c576102776020917f000000000000000000000000000000000000000000000000000000000000000061124c565b3461020b57604060031936011261020b57600435610f8e6111ac565b90610f97611b24565b81101561118457805f52600860205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f205491821561115c5773ffffffffffffffffffffffffffffffffffffffff91610ff1336114e4565b5f52600860205260405f208233165f526020525f6040812055169080471061112d575f80808084865af13d15611125573d9067ffffffffffffffff82116110f857604051917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f81601f8401160116830183811067ffffffffffffffff8211176110f85760405282523d5f602084013e5b156110c1577fb00382203b46c3b6ad0a2d7af0268e334bd9406256a7c7ba8f7fc8bc47f8cde9606084846040519133835260208301526040820152a1005b8051156110d057805190602001fd5b7fd6bda275000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b606090611083565b477fcf479181000000000000000000000000000000000000000000000000000000005f5260045260245260445ffd5b7fc945242d000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f0f2ca6e7000000000000000000000000000000000000000000000000000000005f5260045ffd5b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361020b57565b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361020b57565b600319606091011261020b576004359060243573ffffffffffffffffffffffffffffffffffffffff8116810361020b579060443590565b600319604091011261020b576004359060243590565b91908203918211610e8c57565b91908201809211610e8c57565b60045481106112aa576112a7906112946112815f54835f52600160205260405f20549061124c565b825f52600360205260405f20549061124c565b905f52600260205260405f20549061123f565b90565b5f52600160205260405f205490565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8114610e8c5760010190565b9073ffffffffffffffffffffffffffffffffffffffff611304611b24565b9216805f52601360205260405f20825f5260205260405f2054925b80841061133f57505f52601360205260405f20905f5260205260405f2055565b9261142990825f52600f60205260405f20845f5260205260405f2054815f52601060205260405f20845f5260205260405f20855f5260205261138660405f2091825461124c565b9055805f52601260205260405f20835f5260205260405f20845f5260205260405f2054815f52601060205260405f20845f5260205260405f20855f526020526113d460405f2091825461124c565b9055805f52601160205260405f20835f5260205260405f20845f5260205260405f2054815f52601060205260405f20845f5260205260405f20855f5260205261142260405f2091825461123f565b90556112b9565b9261131f565b9073ffffffffffffffffffffffffffffffffffffffff1690815f52600960205260405f20548110155f146114cb57816112a7925f5260056020526114ae61149160405f2054845f52600660205260405f20845f5260205260405f20549061124c565b835f52600860205260405f20835f5260205260405f20549061124c565b915f52600760205260405f20905f5260205260405f20549061123f565b5f52600660205260405f20905f5260205260405f205490565b73ffffffffffffffffffffffffffffffffffffffff611501611b24565b9116805f52600960205260405f2054915b80831061152857505f52600960205260405f2055565b916115cf90825f52600560205260405f2054815f52600660205260405f20845f5260205261155b60405f2091825461124c565b9055805f52600860205260405f20835f5260205260405f2054815f52600660205260405f20845f5260205261159560405f2091825461124c565b9055805f52600760205260405f20835f5260205260405f2054815f52600660205260405f20845f5260205261142260405f2091825461123f565b91611512565b9073ffffffffffffffffffffffffffffffffffffffff16805f52601360205260405f20835f5260205260405f20548210155f146116a35791826112a7935f52600f60205260405f20825f5260205261167c61165560405f2054855f52601060205260405f20845f5260205260405f20855f5260205260405f20549061124c565b845f52601260205260405f20835f5260205260405f20845f5260205260405f20549061124c565b925f52601160205260405f20905f5260205260405f20905f5260205260405f20549061123f565b905f52601060205260405f20905f5260205260405f20905f5260205260405f205490565b62278d0081029080820462278d001490151715610e8c576112a7907f000000000000000000000000000000000000000000000000000000000000000061124c565b9080156106fd5781156106cd57335f52600f60205260405f20825f526020528060405f2054106106a5577f8bd4728ee9ca3f99ddcffa24eb4f15de015cda9a27ccc427dfdaf711943ebca09160609161175f611b24565b8060045410611907575b335f5260096020528060405f2054106118f9575b825f52600e6020528060405f2054106118eb575b335f52601360205260405f20835f526020528060405f2054106118dc575b805f52600360205260405f206117c683825461124c565b9055805f52600860205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f206117ff83825461124c565b9055805f52600d60205260405f20835f5260205260405f2061182283825461124c565b90555f52601260205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260405f20825f5260205260405f2061186482825461124c565b9055611871815f5461123f565b5f55335f52600560205260405f2061188a82825461123f565b9055815f52600a60205260405f206118a382825461123f565b9055335f52600f60205260405f20825f5260205260405f206118c682825461123f565b90556040519133835260208301526040820152a1565b6118e683336112e6565b6117af565b6118f483611914565b611791565b611902336114e4565b61177d565b61190f611a8a565b611769565b61191c611b24565b90805f52600e60205260405f2054915b80831061194257505f52600e60205260405f2055565b916119e990825f52600a60205260405f2054815f52600b60205260405f20845f5260205261197560405f2091825461124c565b9055805f52600d60205260405f20835f5260205260405f2054815f52600b60205260405f20845f526020526119af60405f2091825461124c565b9055805f52600c60205260405f20835f5260205260405f2054815f52600b60205260405f20845f5260205261142260405f2091825461123f565b9161192c565b5f828152600e60205260409020548110611a7157816112a7925f52600a602052611a54611a3760405f2054845f52600b60205260405f20845f5260205260405f20549061124c565b835f52600d60205260405f20835f5260205260405f20549061124c565b915f52600c60205260405f20905f5260205260405f20549061123f565b5f52600b60205260405f20905f5260205260405f205490565b611a92611b24565b905b60045482811015611b1f575f54905f526001602052611ab860405f2091825461124c565b9055600454805f52600360205260405f2054905f526001602052611ae160405f2091825461124c565b9055600454805f52600260205260405f2054905f526001602052611b0a60405f2091825461123f565b9055611b176004546112b9565b600455611a94565b509050565b62278d00611b527f00000000000000000000000000000000000000000000000000000000000000004261123f565b0460018101809111610e8c579056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x11W_\x80\xFD[_5`\xE0\x1C\x80b\xF7\x14\xCE\x14a\x0FrW\x80c\x01u\xE2;\x14a\x0E\xF1W\x80c\x04X)o\x14a\x0CBW\x80c\x05=\xCD%\x14a\x0B\xF0W\x80c\x0B(\x1B\xF8\x14a\x0B\xC6W\x80c\x10W\xE9\xBC\x14a\x0B\x9CW\x80c\x12\xE9s\xBC\x14a\x0BrW\x80c\x1A\x8As\x8C\x14a\x0BUW\x80c\x1BS;Z\x14a\x0B\x03W\x80c\x1E\x0E\x84\x89\x14a\n\xD9W\x80c;\xA0\x0F\xAE\x14a\n\xAFW\x80c@\x8C2\xEA\x14a\n{W\x80cE6\x7F#\x14a\n]W\x80cY\x19?7\x14a\x07\x93W\x80c]=\x8C\xD2\x14a\n\x0BW\x80cb\x94T\xFD\x14a\t\xBCW\x80ch\xA5Ud\x14a\t\x88W\x80ci=\x0B~\x14a\t9W\x80c{\xDA\x1C\xFB\x14a\t\nW\x80c|]\xD5\xD9\x14a\x08\xC5W\x80c|n\xAA\xEE\x14a\x08\x96W\x80c~_\\\xA7\x14a\x08qW\x80c\x8B\x0E\x9F?\x14a\x08UW\x80c\x8Cg\x90>\x14a\x08+W\x80c\x96&\xA20\x14a\x08\x05W\x80c\x9D\xEBf\xC9\x14a\x07\xE4W\x80c\xA0\x9Dz0\x14a\x07\x93W\x80c\xA7\x0B\x9F\x0C\x14a\x07vW\x80c\xB9}\xD9\xE2\x14a\x07\\W\x80c\xC3\xDD\xB3\xB3\x14a\x07CW\x80c\xD5\x17m#\x14a\x07%W\x80c\xE5\x8ES\x82\x14a\x04_W\x80c\xE6\x01\xCFD\x14a\x04\x1AW\x80c\xE6\xFDH\xBC\x14a\x03\xE0W\x80c\xED\x86\xBAo\x14a\x03\xC9W\x80c\xEEu\x14\xE8\x14a\x03wW\x80c\xF00!\xA1\x14a\x03[W\x80c\xF8\x9E\xE7\x8D\x14a\x03\nW\x80c\xF9ee-\x14a\x02\xDBW\x80c\xF9\xD6c\xE0\x14a\x02\x7FW\x80c\xFAE{\xE6\x14a\x02^W\x80c\xFAs\xCEY\x14a\x02\x0FWc\xFE\x07\xBB\x07\x14a\x01\xF1W_\x80\xFD[4a\x02\x0BW_`\x03\x196\x01\x12a\x02\x0BWa\x02\ta\x1A\x8AV[\0[_\x80\xFD[4a\x02\x0BWa\x02\x1D6a\x11\xF2V[\x91_R`\x12` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW` a\x02wa\x02q6a\x12)V[\x90a\x19\xEFV[`@Q\x90\x81R\xF3[4a\x02\x0BW`@`\x03\x196\x01\x12a\x02\x0BW` a\x02w`\x045a\x02\xA0a\x11\xACV[a\x02\xAA\x81\x83a\x14/V[\x91_R`\x15\x84Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R\x83R`@_ T\x90a\x12LV[4a\x02\x0BWa\x02\xE96a\x12)V[\x90_R`\r` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW`@`\x03\x196\x01\x12a\x02\x0BWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x038a\x11\xCFV[\x16_R`\x13` R`@_ `$5_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BWa\x02\t`\x045a\x19\x14V[4a\x02\x0BW`@`\x03\x196\x01\x12a\x02\x0BWa\x03\x90a\x11\xACV[`\x045_R`\x15` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BWa\x02\ta\x03\xDA6a\x12)V[\x90a\x17\x08V[4a\x02\x0BW_`\x03\x196\x01\x12a\x02\x0BW` `@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xF3[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x04Ha\x11\xCFV[\x16_R`\x05` R` `@_ T`@Q\x90\x81R\xF3[```\x03\x196\x01\x12a\x02\x0BW`$5`\x045`D5\x80\x15a\x06\xFDW\x81\x15\x80\x15a\x06\xF5W[a\x06\xCDW3_R`\x0F` R`@_ \x82_R` R\x80`@_ T\x10a\x06\xA5W\x7F\xB3\x12\x90<\xE2\x07\xD2\x1E\x84\xE5}\x10\x05\xE0\xAAS\x85\xB7\x83\xEB'\xE2X\x81qt\xD0\x0C\xFB\xBC2x\x92`\xA0\x92a\x04\xD1a\x1B$V[\x923_R`\t` R\x83`@_ T\x10a\x06\x97W[\x81_R`\x0E` R\x83`@_ T\x10a\x06\x89W[3_R`\x13` R`@_ \x82_R` R\x83`@_ T\x10a\x06zW[\x83_R`\x10` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x82_R` R`@_ a\x05Y\x82\x82Ta\x12LV[\x90U\x83_R`\x0B` R`@_ \x82_R` R`@_ a\x05|\x82\x82Ta\x12LV[\x90U3_R`\x0F` R`@_ \x82_R` R`@_ a\x05\x9F\x82\x82Ta\x12?V[\x90U\x81_R`\n` R`@_ a\x05\xB8\x82\x82Ta\x12?V[\x90U\x83_R`\x11` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x83_R` R`@_ a\x05\xFB\x82\x82Ta\x12LV[\x90U\x83_R`\x0C` R`@_ \x83_R` R`@_ a\x06\x1E\x82\x82Ta\x12LV[\x90U3_R`\x0F` R`@_ \x83_R` R`@_ a\x06A\x82\x82Ta\x12LV[\x90U\x82_R`\n` R`@_ a\x06Z\x82\x82Ta\x12LV[\x90U`@Q\x93\x84R3` \x85\x01R`@\x84\x01R``\x83\x01R`\x80\x82\x01R\xA1\0[a\x06\x84\x823a\x12\xE6V[a\x05\x18V[a\x06\x92\x82a\x19\x14V[a\x04\xFAV[a\x06\xA03a\x14\xE4V[a\x04\xE6V[\x7F\xF1\xBC\x94\xD2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\xF6\xB4\x13\x1C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[P\x82\x15a\x04\x83V[\x7F,R\x11\xC6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BW` a\x02w`\x045a\x16\xC7V[4a\x02\x0BW` a\x02wa\x07V6a\x11\xF2V[\x91a\x15\xD5V[4a\x02\x0BW_`\x03\x196\x01\x12a\x02\x0BW` a\x02wa\x1B$V[4a\x02\x0BW_`\x03\x196\x01\x12a\x02\x0BW` `@Qb'\x8D\0\x81R\xF3[4a\x02\x0BW`@`\x03\x196\x01\x12a\x02\x0BWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x07\xC1a\x11\xCFV[\x16_R`\x0F` R`@_ `$5_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BWa\x02\ta\x08\0a\x11\xCFV[a\x14\xE4V[4a\x02\x0BW`@`\x03\x196\x01\x12a\x02\x0BW` a\x02wa\x08#a\x11\xACV[`\x045a\x14/V[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BW`\x045_R`\x03` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW_`\x03\x196\x01\x12a\x02\x0BW` _T`@Q\x90\x81R\xF3[4a\x02\x0BW`@`\x03\x196\x01\x12a\x02\x0BWa\x02\ta\x08\x8Da\x11\xCFV[`$5\x90a\x12\xE6V[4a\x02\x0BWa\x08\xA46a\x12)V[\x90_R`\x0C` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x08\xF3a\x11\xCFV[\x16_R`\t` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BWa\t\x186a\x12)V[\x90_R`\x0B` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BWa\tG6a\x11\xF2V[\x91_R`\x11` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BWa\x02\t`\x0453_R`\x0F` R`@_ \x81_R` R`@_ T\x90a\x17\x08V[4a\x02\x0BWa\t\xCA6a\x11\xF2V[\x91_R`\x10` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW`@`\x03\x196\x01\x12a\x02\x0BWa\n$a\x11\xACV[`\x045_R`\x08` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BW` a\x02w`\x045a\x12YV[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BW` a\x02w`\x045a\n\x9D\x81a\x12YV[\x90_R`\x14\x83R`@_ T\x90a\x12LV[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BW`\x045_R`\x0E` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BW`\x045_R`\x01` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW`@`\x03\x196\x01\x12a\x02\x0BWa\x0B\x1Ca\x11\xACV[`\x045_R`\x07` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW_`\x03\x196\x01\x12a\x02\x0BW` `\x04T`@Q\x90\x81R\xF3[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BW`\x045_R`\x14` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BW`\x045_R`\n` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BW`\x045_R`\x02` R` `@_ T`@Q\x90\x81R\xF3[4a\x02\x0BW`@`\x03\x196\x01\x12a\x02\x0BWa\x0C\ta\x11\xACV[`\x045_R`\x06` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `@_ T`@Q\x90\x81R\xF3[` `\x03\x196\x01\x12a\x02\x0BW`\x0454\x15a\x06\xFDW\x80\x15a\x06\xCDWa\x0Cea\x1B$V[\x80`\x04T\x10a\x0E\xE4W[3_R`\t` R\x80`@_ T\x10a\x0E\xD6W[\x81_R`\x0E` R\x80`@_ T\x10a\x0E\xC8W[3_R`\x13` R`@_ \x82_R` R\x80`@_ T\x10a\x0E\xB9W[a\x0C\xCFa\x0C\xC8a\x0C\xC3a\x1B$V[a\x16\xC7V[B\x90a\x12?V[\x90\x814\x02\x914\x83\x04\x03a\x0E\x8CW\x7FPz\xC3\x9E\xB36\x10\x19\x1C\xD8\xFDT(n\x91\xC5\xCCFL&(ad;\xE3\x97\x8FZ\x9F\x18\xAB\x02\x92b'\x8D\0`\x80\x93\x04\x82_R`\x14` R`@_ a\r\x1D\x82\x82Ta\x12LV[\x90U\x82_R`\x15` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` Ra\rV`@_ \x91\x82Ta\x12LV[\x90U\x81_R`\x02` R`@_ a\ro4\x82Ta\x12LV[\x90Ua\r|4_Ta\x12LV[_U\x81_R`\x07` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ a\r\xB54\x82Ta\x12LV[\x90U3_R`\x05` R`@_ a\r\xCE4\x82Ta\x12LV[\x90U\x81_R`\x0C` R`@_ \x81_R` R`@_ a\r\xF14\x82Ta\x12LV[\x90U\x80_R`\n` R`@_ a\x0E\n4\x82Ta\x12LV[\x90U\x81_R`\x11` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x81_R` R`@_ a\x0EM4\x82Ta\x12LV[\x90U3_R`\x0F` R`@_ \x81_R` R`@_ a\x0Ep4\x82Ta\x12LV[\x90U`@Q\x91\x82R3` \x83\x01R4`@\x83\x01R``\x82\x01R\xA1\0[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[a\x0E\xC3\x823a\x12\xE6V[a\x0C\xB5V[a\x0E\xD1\x82a\x19\x14V[a\x0C\x97V[a\x0E\xDF3a\x14\xE4V[a\x0C\x83V[a\x0E\xECa\x1A\x8AV[a\x0CoV[4a\x02\x0BW` `\x03\x196\x01\x12a\x02\x0BW`\x045\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x01\x90\x81\x11a\x0E\x8CWb'\x8D\0\x81\x02\x90\x80\x82\x04b'\x8D\0\x14\x90\x15\x17\x15a\x0E\x8CWa\x02w` \x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x12LV[4a\x02\x0BW`@`\x03\x196\x01\x12a\x02\x0BW`\x045a\x0F\x8Ea\x11\xACV[\x90a\x0F\x97a\x1B$V[\x81\x10\x15a\x11\x84W\x80_R`\x08` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ T\x91\x82\x15a\x11\\Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x0F\xF13a\x14\xE4V[_R`\x08` R`@_ \x823\x16_R` R_`@\x81 U\x16\x90\x80G\x10a\x11-W_\x80\x80\x80\x84\x86Z\xF1=\x15a\x11%W=\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x10\xF8W`@Q\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`?\x81`\x1F\x84\x01\x16\x01\x16\x83\x01\x83\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x10\xF8W`@R\x82R=_` \x84\x01>[\x15a\x10\xC1W\x7F\xB0\x03\x82 ;F\xC3\xB6\xAD\n-z\xF0&\x8E3K\xD9@bV\xA7\xC7\xBA\x8F\x7F\xC8\xBCG\xF8\xCD\xE9``\x84\x84`@Q\x913\x83R` \x83\x01R`@\x82\x01R\xA1\0[\x80Q\x15a\x10\xD0W\x80Q\x90` \x01\xFD[\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[``\x90a\x10\x83V[G\x7F\xCFG\x91\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$R`D_\xFD[\x7F\xC9E$-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\x0F,\xA6\xE7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[`$5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x02\x0BWV[`\x045\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x02\x0BWV[`\x03\x19``\x91\x01\x12a\x02\x0BW`\x045\x90`$5s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x02\x0BW\x90`D5\x90V[`\x03\x19`@\x91\x01\x12a\x02\x0BW`\x045\x90`$5\x90V[\x91\x90\x82\x03\x91\x82\x11a\x0E\x8CWV[\x91\x90\x82\x01\x80\x92\x11a\x0E\x8CWV[`\x04T\x81\x10a\x12\xAAWa\x12\xA7\x90a\x12\x94a\x12\x81_T\x83_R`\x01` R`@_ T\x90a\x12LV[\x82_R`\x03` R`@_ T\x90a\x12LV[\x90_R`\x02` R`@_ T\x90a\x12?V[\x90V[_R`\x01` R`@_ T\x90V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x14a\x0E\x8CW`\x01\x01\x90V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x13\x04a\x1B$V[\x92\x16\x80_R`\x13` R`@_ \x82_R` R`@_ T\x92[\x80\x84\x10a\x13?WP_R`\x13` R`@_ \x90_R` R`@_ UV[\x92a\x14)\x90\x82_R`\x0F` R`@_ \x84_R` R`@_ T\x81_R`\x10` R`@_ \x84_R` R`@_ \x85_R` Ra\x13\x86`@_ \x91\x82Ta\x12LV[\x90U\x80_R`\x12` R`@_ \x83_R` R`@_ \x84_R` R`@_ T\x81_R`\x10` R`@_ \x84_R` R`@_ \x85_R` Ra\x13\xD4`@_ \x91\x82Ta\x12LV[\x90U\x80_R`\x11` R`@_ \x83_R` R`@_ \x84_R` R`@_ T\x81_R`\x10` R`@_ \x84_R` R`@_ \x85_R` Ra\x14\"`@_ \x91\x82Ta\x12?V[\x90Ua\x12\xB9V[\x92a\x13\x1FV[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81_R`\t` R`@_ T\x81\x10\x15_\x14a\x14\xCBW\x81a\x12\xA7\x92_R`\x05` Ra\x14\xAEa\x14\x91`@_ T\x84_R`\x06` R`@_ \x84_R` R`@_ T\x90a\x12LV[\x83_R`\x08` R`@_ \x83_R` R`@_ T\x90a\x12LV[\x91_R`\x07` R`@_ \x90_R` R`@_ T\x90a\x12?V[_R`\x06` R`@_ \x90_R` R`@_ T\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x15\x01a\x1B$V[\x91\x16\x80_R`\t` R`@_ T\x91[\x80\x83\x10a\x15(WP_R`\t` R`@_ UV[\x91a\x15\xCF\x90\x82_R`\x05` R`@_ T\x81_R`\x06` R`@_ \x84_R` Ra\x15[`@_ \x91\x82Ta\x12LV[\x90U\x80_R`\x08` R`@_ \x83_R` R`@_ T\x81_R`\x06` R`@_ \x84_R` Ra\x15\x95`@_ \x91\x82Ta\x12LV[\x90U\x80_R`\x07` R`@_ \x83_R` R`@_ T\x81_R`\x06` R`@_ \x84_R` Ra\x14\"`@_ \x91\x82Ta\x12?V[\x91a\x15\x12V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80_R`\x13` R`@_ \x83_R` R`@_ T\x82\x10\x15_\x14a\x16\xA3W\x91\x82a\x12\xA7\x93_R`\x0F` R`@_ \x82_R` Ra\x16|a\x16U`@_ T\x85_R`\x10` R`@_ \x84_R` R`@_ \x85_R` R`@_ T\x90a\x12LV[\x84_R`\x12` R`@_ \x83_R` R`@_ \x84_R` R`@_ T\x90a\x12LV[\x92_R`\x11` R`@_ \x90_R` R`@_ \x90_R` R`@_ T\x90a\x12?V[\x90_R`\x10` R`@_ \x90_R` R`@_ \x90_R` R`@_ T\x90V[b'\x8D\0\x81\x02\x90\x80\x82\x04b'\x8D\0\x14\x90\x15\x17\x15a\x0E\x8CWa\x12\xA7\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x12LV[\x90\x80\x15a\x06\xFDW\x81\x15a\x06\xCDW3_R`\x0F` R`@_ \x82_R` R\x80`@_ T\x10a\x06\xA5W\x7F\x8B\xD4r\x8E\xE9\xCA?\x99\xDD\xCF\xFA$\xEBO\x15\xDE\x01\\\xDA\x9A'\xCC\xC4'\xDF\xDA\xF7\x11\x94>\xBC\xA0\x91``\x91a\x17_a\x1B$V[\x80`\x04T\x10a\x19\x07W[3_R`\t` R\x80`@_ T\x10a\x18\xF9W[\x82_R`\x0E` R\x80`@_ T\x10a\x18\xEBW[3_R`\x13` R`@_ \x83_R` R\x80`@_ T\x10a\x18\xDCW[\x80_R`\x03` R`@_ a\x17\xC6\x83\x82Ta\x12LV[\x90U\x80_R`\x08` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ a\x17\xFF\x83\x82Ta\x12LV[\x90U\x80_R`\r` R`@_ \x83_R` R`@_ a\x18\"\x83\x82Ta\x12LV[\x90U_R`\x12` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`@_ \x82_R` R`@_ a\x18d\x82\x82Ta\x12LV[\x90Ua\x18q\x81_Ta\x12?V[_U3_R`\x05` R`@_ a\x18\x8A\x82\x82Ta\x12?V[\x90U\x81_R`\n` R`@_ a\x18\xA3\x82\x82Ta\x12?V[\x90U3_R`\x0F` R`@_ \x82_R` R`@_ a\x18\xC6\x82\x82Ta\x12?V[\x90U`@Q\x913\x83R` \x83\x01R`@\x82\x01R\xA1V[a\x18\xE6\x833a\x12\xE6V[a\x17\xAFV[a\x18\xF4\x83a\x19\x14V[a\x17\x91V[a\x19\x023a\x14\xE4V[a\x17}V[a\x19\x0Fa\x1A\x8AV[a\x17iV[a\x19\x1Ca\x1B$V[\x90\x80_R`\x0E` R`@_ T\x91[\x80\x83\x10a\x19BWP_R`\x0E` R`@_ UV[\x91a\x19\xE9\x90\x82_R`\n` R`@_ T\x81_R`\x0B` R`@_ \x84_R` Ra\x19u`@_ \x91\x82Ta\x12LV[\x90U\x80_R`\r` R`@_ \x83_R` R`@_ T\x81_R`\x0B` R`@_ \x84_R` Ra\x19\xAF`@_ \x91\x82Ta\x12LV[\x90U\x80_R`\x0C` R`@_ \x83_R` R`@_ T\x81_R`\x0B` R`@_ \x84_R` Ra\x14\"`@_ \x91\x82Ta\x12?V[\x91a\x19,V[_\x82\x81R`\x0E` R`@\x90 T\x81\x10a\x1AqW\x81a\x12\xA7\x92_R`\n` Ra\x1ATa\x1A7`@_ T\x84_R`\x0B` R`@_ \x84_R` R`@_ T\x90a\x12LV[\x83_R`\r` R`@_ \x83_R` R`@_ T\x90a\x12LV[\x91_R`\x0C` R`@_ \x90_R` R`@_ T\x90a\x12?V[_R`\x0B` R`@_ \x90_R` R`@_ T\x90V[a\x1A\x92a\x1B$V[\x90[`\x04T\x82\x81\x10\x15a\x1B\x1FW_T\x90_R`\x01` Ra\x1A\xB8`@_ \x91\x82Ta\x12LV[\x90U`\x04T\x80_R`\x03` R`@_ T\x90_R`\x01` Ra\x1A\xE1`@_ \x91\x82Ta\x12LV[\x90U`\x04T\x80_R`\x02` R`@_ T\x90_R`\x01` Ra\x1B\n`@_ \x91\x82Ta\x12?V[\x90Ua\x1B\x17`\x04Ta\x12\xB9V[`\x04Ua\x1A\x94V[P\x90PV[b'\x8D\0a\x1BR\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Ba\x12?V[\x04`\x01\x81\x01\x80\x91\x11a\x0E\x8CW\x90V",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedCall()` and selector `0xd6bda275`.
```solidity
error FailedCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedCall;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedCall()";
            const SELECTOR: [u8; 4] = [214u8, 189u8, 162u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientBalance(uint256,uint256)` and selector `0xcf479181`.
```solidity
error InsufficientBalance(uint256 balance, uint256 needed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientBalance {
        #[allow(missing_docs)]
        pub balance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientBalance> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientBalance) -> Self {
                (value.balance, value.needed)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    balance: tuple.0,
                    needed: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientBalance(uint256,uint256)";
            const SELECTOR: [u8; 4] = [207u8, 71u8, 145u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.needed),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientStake()` and selector `0xf1bc94d2`.
```solidity
error InsufficientStake();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientStake;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientStake> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientStake) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientStake {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientStake {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientStake()";
            const SELECTOR: [u8; 4] = [241u8, 188u8, 148u8, 210u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidAmount()` and selector `0x2c5211c6`.
```solidity
error InvalidAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidAmount;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidAmount> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidAmount()";
            const SELECTOR: [u8; 4] = [44u8, 82u8, 17u8, 198u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidAppchainId()` and selector `0xf6b4131c`.
```solidity
error InvalidAppchainId();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidAppchainId;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidAppchainId> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidAppchainId) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidAppchainId {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidAppchainId {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidAppchainId()";
            const SELECTOR: [u8; 4] = [246u8, 180u8, 19u8, 28u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidWithdrawal()` and selector `0xc945242d`.
```solidity
error InvalidWithdrawal();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidWithdrawal;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidWithdrawal> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidWithdrawal) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidWithdrawal {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidWithdrawal {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidWithdrawal()";
            const SELECTOR: [u8; 4] = [201u8, 69u8, 36u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `WithdrawalNotReady()` and selector `0x0f2ca6e7`.
```solidity
error WithdrawalNotReady();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct WithdrawalNotReady;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<WithdrawalNotReady> for UnderlyingRustTuple<'_> {
            fn from(value: WithdrawalNotReady) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for WithdrawalNotReady {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for WithdrawalNotReady {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "WithdrawalNotReady()";
            const SELECTOR: [u8; 4] = [15u8, 44u8, 166u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Stake(uint256,address,uint256,uint256)` and selector `0x507ac39eb33610191cd8fd54286e91c5cc464c262861643be3978f5a9f18ab02`.
```solidity
event Stake(uint256 epochIndex, address user, uint256 amount, uint256 appchainId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Stake {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Stake {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Stake(uint256,address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                80u8, 122u8, 195u8, 158u8, 179u8, 54u8, 16u8, 25u8, 28u8, 216u8, 253u8,
                84u8, 40u8, 110u8, 145u8, 197u8, 204u8, 70u8, 76u8, 38u8, 40u8, 97u8,
                100u8, 59u8, 227u8, 151u8, 143u8, 90u8, 159u8, 24u8, 171u8, 2u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    epochIndex: data.0,
                    user: data.1,
                    amount: data.2,
                    appchainId: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Stake {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Stake> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Stake) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `StakeTransfer(uint256,address,uint256,uint256,uint256)` and selector `0xb312903ce207d21e84e57d1005e0aa5385b783eb27e258817174d00cfbbc3278`.
```solidity
event StakeTransfer(uint256 epochIndex, address user, uint256 amount, uint256 fromAppchainId, uint256 toAppchainId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct StakeTransfer {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub fromAppchainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub toAppchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for StakeTransfer {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "StakeTransfer(uint256,address,uint256,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                179u8, 18u8, 144u8, 60u8, 226u8, 7u8, 210u8, 30u8, 132u8, 229u8, 125u8,
                16u8, 5u8, 224u8, 170u8, 83u8, 133u8, 183u8, 131u8, 235u8, 39u8, 226u8,
                88u8, 129u8, 113u8, 116u8, 208u8, 12u8, 251u8, 188u8, 50u8, 120u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    epochIndex: data.0,
                    user: data.1,
                    amount: data.2,
                    fromAppchainId: data.3,
                    toAppchainId: data.4,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.fromAppchainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.toAppchainId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for StakeTransfer {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&StakeTransfer> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &StakeTransfer) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `WithdrawalCompleted(address,address,uint256)` and selector `0xb00382203b46c3b6ad0a2d7af0268e334bd9406256a7c7ba8f7fc8bc47f8cde9`.
```solidity
event WithdrawalCompleted(address user, address destination, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct WithdrawalCompleted {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub destination: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for WithdrawalCompleted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "WithdrawalCompleted(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                176u8, 3u8, 130u8, 32u8, 59u8, 70u8, 195u8, 182u8, 173u8, 10u8, 45u8,
                122u8, 240u8, 38u8, 142u8, 51u8, 75u8, 217u8, 64u8, 98u8, 86u8, 167u8,
                199u8, 186u8, 143u8, 127u8, 200u8, 188u8, 71u8, 248u8, 205u8, 233u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    user: data.0,
                    destination: data.1,
                    amount: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.destination,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for WithdrawalCompleted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&WithdrawalCompleted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &WithdrawalCompleted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `WithdrawalInitialized(address,uint256,uint256)` and selector `0x8bd4728ee9ca3f99ddcffa24eb4f15de015cda9a27ccc427dfdaf711943ebca0`.
```solidity
event WithdrawalInitialized(address user, uint256 appchainId, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct WithdrawalInitialized {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for WithdrawalInitialized {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "WithdrawalInitialized(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8, 212u8, 114u8, 142u8, 233u8, 202u8, 63u8, 153u8, 221u8, 207u8,
                250u8, 36u8, 235u8, 79u8, 21u8, 222u8, 1u8, 92u8, 218u8, 154u8, 39u8,
                204u8, 196u8, 39u8, 223u8, 218u8, 247u8, 17u8, 148u8, 62u8, 188u8, 160u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    user: data.0,
                    appchainId: data.1,
                    amount: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for WithdrawalInitialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&WithdrawalInitialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &WithdrawalInitialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(uint256 _startTimestamp);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub _startTimestamp: alloy::sol_types::private::primitives::aliases::U256,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value._startTimestamp,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _startTimestamp: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._startTimestamp),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `EPOCH_DURATION()` and selector `0xa70b9f0c`.
```solidity
function EPOCH_DURATION() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EPOCH_DURATIONCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`EPOCH_DURATION()`](EPOCH_DURATIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EPOCH_DURATIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EPOCH_DURATIONCall> for UnderlyingRustTuple<'_> {
                fn from(value: EPOCH_DURATIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for EPOCH_DURATIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EPOCH_DURATIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EPOCH_DURATIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EPOCH_DURATIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EPOCH_DURATIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EPOCH_DURATION()";
            const SELECTOR: [u8; 4] = [167u8, 11u8, 159u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: EPOCH_DURATIONReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: EPOCH_DURATIONReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `appchainFinalizedEpochCount(uint256)` and selector `0x3ba00fae`.
```solidity
function appchainFinalizedEpochCount(uint256 appchainId) external view returns (uint256 finalizedEpochCount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appchainFinalizedEpochCountCall {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`appchainFinalizedEpochCount(uint256)`](appchainFinalizedEpochCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appchainFinalizedEpochCountReturn {
        #[allow(missing_docs)]
        pub finalizedEpochCount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appchainFinalizedEpochCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: appchainFinalizedEpochCountCall) -> Self {
                    (value.appchainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for appchainFinalizedEpochCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { appchainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appchainFinalizedEpochCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: appchainFinalizedEpochCountReturn) -> Self {
                    (value.finalizedEpochCount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for appchainFinalizedEpochCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        finalizedEpochCount: tuple.0,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for appchainFinalizedEpochCountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "appchainFinalizedEpochCount(uint256)";
            const SELECTOR: [u8; 4] = [59u8, 160u8, 15u8, 174u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: appchainFinalizedEpochCountReturn = r.into();
                        r.finalizedEpochCount
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: appchainFinalizedEpochCountReturn = r.into();
                        r.finalizedEpochCount
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `appchainTotal(uint256)` and selector `0x1057e9bc`.
```solidity
function appchainTotal(uint256 appchainId) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appchainTotalCall {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`appchainTotal(uint256)`](appchainTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appchainTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appchainTotalCall> for UnderlyingRustTuple<'_> {
                fn from(value: appchainTotalCall) -> Self {
                    (value.appchainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for appchainTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { appchainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appchainTotalReturn> for UnderlyingRustTuple<'_> {
                fn from(value: appchainTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for appchainTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for appchainTotalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "appchainTotal(uint256)";
            const SELECTOR: [u8; 4] = [16u8, 87u8, 233u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: appchainTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: appchainTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochAdditions(uint256)` and selector `0x0b281bf8`.
```solidity
function epochAdditions(uint256 epochIndex) external view returns (uint256 additions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAdditionsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochAdditions(uint256)`](epochAdditionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAdditionsReturn {
        #[allow(missing_docs)]
        pub additions: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAdditionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: epochAdditionsCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for epochAdditionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAdditionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAdditionsReturn) -> Self {
                    (value.additions,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAdditionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { additions: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochAdditionsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochAdditions(uint256)";
            const SELECTOR: [u8; 4] = [11u8, 40u8, 27u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochAdditionsReturn = r.into();
                        r.additions
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochAdditionsReturn = r.into();
                        r.additions
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochAppchainAdditions(uint256,uint256)` and selector `0x7c6eaaee`.
```solidity
function epochAppchainAdditions(uint256 epochIndex, uint256 appchainId) external view returns (uint256 additions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainAdditionsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochAppchainAdditions(uint256,uint256)`](epochAppchainAdditionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainAdditionsReturn {
        #[allow(missing_docs)]
        pub additions: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainAdditionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainAdditionsCall) -> Self {
                    (value.epochIndex, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainAdditionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainAdditionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainAdditionsReturn) -> Self {
                    (value.additions,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainAdditionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { additions: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochAppchainAdditionsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochAppchainAdditions(uint256,uint256)";
            const SELECTOR: [u8; 4] = [124u8, 110u8, 170u8, 238u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochAppchainAdditionsReturn = r.into();
                        r.additions
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochAppchainAdditionsReturn = r.into();
                        r.additions
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochAppchainTotal(uint256,uint256)` and selector `0x7bda1cfb`.
```solidity
function epochAppchainTotal(uint256 epochIndex, uint256 appchainId) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainTotalCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochAppchainTotal(uint256,uint256)`](epochAppchainTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainTotalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainTotalCall) -> Self {
                    (value.epochIndex, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainTotalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochAppchainTotalCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochAppchainTotal(uint256,uint256)";
            const SELECTOR: [u8; 4] = [123u8, 218u8, 28u8, 251u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochAppchainTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochAppchainTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochAppchainWithdrawals(uint256,uint256)` and selector `0xf965652d`.
```solidity
function epochAppchainWithdrawals(uint256 epochIndex, uint256 appchainId) external view returns (uint256 withdrawals);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainWithdrawalsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochAppchainWithdrawals(uint256,uint256)`](epochAppchainWithdrawalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainWithdrawalsReturn {
        #[allow(missing_docs)]
        pub withdrawals: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainWithdrawalsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainWithdrawalsCall) -> Self {
                    (value.epochIndex, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainWithdrawalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainWithdrawalsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainWithdrawalsReturn) -> Self {
                    (value.withdrawals,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainWithdrawalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { withdrawals: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochAppchainWithdrawalsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochAppchainWithdrawals(uint256,uint256)";
            const SELECTOR: [u8; 4] = [249u8, 101u8, 101u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochAppchainWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochAppchainWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochStakeShare(uint256)` and selector `0x12e973bc`.
```solidity
function epochStakeShare(uint256 epochIndex) external view returns (uint256 stakeShare);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochStakeShareCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochStakeShare(uint256)`](epochStakeShareCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochStakeShareReturn {
        #[allow(missing_docs)]
        pub stakeShare: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochStakeShareCall> for UnderlyingRustTuple<'_> {
                fn from(value: epochStakeShareCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for epochStakeShareCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochStakeShareReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochStakeShareReturn) -> Self {
                    (value.stakeShare,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochStakeShareReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stakeShare: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochStakeShareCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochStakeShare(uint256)";
            const SELECTOR: [u8; 4] = [18u8, 233u8, 115u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochStakeShareReturn = r.into();
                        r.stakeShare
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochStakeShareReturn = r.into();
                        r.stakeShare
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochTotal(uint256)` and selector `0x1e0e8489`.
```solidity
function epochTotal(uint256 epochIndex) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochTotalCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochTotal(uint256)`](epochTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochTotalCall> for UnderlyingRustTuple<'_> {
                fn from(value: epochTotalCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for epochTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochTotalReturn> for UnderlyingRustTuple<'_> {
                fn from(value: epochTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for epochTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochTotalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochTotal(uint256)";
            const SELECTOR: [u8; 4] = [30u8, 14u8, 132u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserAdditions(uint256,address)` and selector `0x1b533b5a`.
```solidity
function epochUserAdditions(uint256 epochIndex, address user) external view returns (uint256 additions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAdditionsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserAdditions(uint256,address)`](epochUserAdditionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAdditionsReturn {
        #[allow(missing_docs)]
        pub additions: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAdditionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAdditionsCall) -> Self {
                    (value.epochIndex, value.user)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAdditionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAdditionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAdditionsReturn) -> Self {
                    (value.additions,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAdditionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { additions: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserAdditionsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserAdditions(uint256,address)";
            const SELECTOR: [u8; 4] = [27u8, 83u8, 59u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserAdditionsReturn = r.into();
                        r.additions
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserAdditionsReturn = r.into();
                        r.additions
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserAppchainAdditions(uint256,address,uint256)` and selector `0x693d0b7e`.
```solidity
function epochUserAppchainAdditions(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256 additions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAppchainAdditionsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserAppchainAdditions(uint256,address,uint256)`](epochUserAppchainAdditionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAppchainAdditionsReturn {
        #[allow(missing_docs)]
        pub additions: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAppchainAdditionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAppchainAdditionsCall) -> Self {
                    (value.epochIndex, value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAppchainAdditionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                        appchainId: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAppchainAdditionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAppchainAdditionsReturn) -> Self {
                    (value.additions,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAppchainAdditionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { additions: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserAppchainAdditionsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserAppchainAdditions(uint256,address,uint256)";
            const SELECTOR: [u8; 4] = [105u8, 61u8, 11u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserAppchainAdditionsReturn = r.into();
                        r.additions
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserAppchainAdditionsReturn = r.into();
                        r.additions
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserAppchainTotal(uint256,address,uint256)` and selector `0x629454fd`.
```solidity
function epochUserAppchainTotal(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAppchainTotalCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserAppchainTotal(uint256,address,uint256)`](epochUserAppchainTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAppchainTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAppchainTotalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAppchainTotalCall) -> Self {
                    (value.epochIndex, value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAppchainTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                        appchainId: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAppchainTotalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAppchainTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAppchainTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserAppchainTotalCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserAppchainTotal(uint256,address,uint256)";
            const SELECTOR: [u8; 4] = [98u8, 148u8, 84u8, 253u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserAppchainTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserAppchainTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserAppchainWithdrawals(uint256,address,uint256)` and selector `0xfa73ce59`.
```solidity
function epochUserAppchainWithdrawals(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256 withdrawals);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAppchainWithdrawalsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserAppchainWithdrawals(uint256,address,uint256)`](epochUserAppchainWithdrawalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserAppchainWithdrawalsReturn {
        #[allow(missing_docs)]
        pub withdrawals: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAppchainWithdrawalsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAppchainWithdrawalsCall) -> Self {
                    (value.epochIndex, value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAppchainWithdrawalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                        appchainId: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserAppchainWithdrawalsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserAppchainWithdrawalsReturn) -> Self {
                    (value.withdrawals,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserAppchainWithdrawalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { withdrawals: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserAppchainWithdrawalsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserAppchainWithdrawals(uint256,address,uint256)";
            const SELECTOR: [u8; 4] = [250u8, 115u8, 206u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserAppchainWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserAppchainWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserStakeShare(uint256,address)` and selector `0xee7514e8`.
```solidity
function epochUserStakeShare(uint256 epochIndex, address user) external view returns (uint256 stakeShare);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserStakeShareCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserStakeShare(uint256,address)`](epochUserStakeShareCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserStakeShareReturn {
        #[allow(missing_docs)]
        pub stakeShare: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserStakeShareCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserStakeShareCall) -> Self {
                    (value.epochIndex, value.user)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserStakeShareCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserStakeShareReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserStakeShareReturn) -> Self {
                    (value.stakeShare,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserStakeShareReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stakeShare: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserStakeShareCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserStakeShare(uint256,address)";
            const SELECTOR: [u8; 4] = [238u8, 117u8, 20u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserStakeShareReturn = r.into();
                        r.stakeShare
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserStakeShareReturn = r.into();
                        r.stakeShare
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserTotal(uint256,address)` and selector `0x053dcd25`.
```solidity
function epochUserTotal(uint256 epochIndex, address user) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserTotalCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserTotal(uint256,address)`](epochUserTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserTotalCall> for UnderlyingRustTuple<'_> {
                fn from(value: epochUserTotalCall) -> Self {
                    (value.epochIndex, value.user)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for epochUserTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserTotalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserTotalCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserTotal(uint256,address)";
            const SELECTOR: [u8; 4] = [5u8, 61u8, 205u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochUserWithdrawals(uint256,address)` and selector `0x5d3d8cd2`.
```solidity
function epochUserWithdrawals(uint256 epochIndex, address user) external view returns (uint256 withdrawals);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserWithdrawalsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochUserWithdrawals(uint256,address)`](epochUserWithdrawalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochUserWithdrawalsReturn {
        #[allow(missing_docs)]
        pub withdrawals: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserWithdrawalsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserWithdrawalsCall) -> Self {
                    (value.epochIndex, value.user)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserWithdrawalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochUserWithdrawalsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochUserWithdrawalsReturn) -> Self {
                    (value.withdrawals,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochUserWithdrawalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { withdrawals: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochUserWithdrawalsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochUserWithdrawals(uint256,address)";
            const SELECTOR: [u8; 4] = [93u8, 61u8, 140u8, 210u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochUserWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochUserWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochWithdrawals(uint256)` and selector `0x8c67903e`.
```solidity
function epochWithdrawals(uint256 epochIndex) external view returns (uint256 withdrawals);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochWithdrawalsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochWithdrawals(uint256)`](epochWithdrawalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochWithdrawalsReturn {
        #[allow(missing_docs)]
        pub withdrawals: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochWithdrawalsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochWithdrawalsCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochWithdrawalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochWithdrawalsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochWithdrawalsReturn) -> Self {
                    (value.withdrawals,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochWithdrawalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { withdrawals: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochWithdrawalsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochWithdrawals(uint256)";
            const SELECTOR: [u8; 4] = [140u8, 103u8, 144u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochWithdrawalsReturn = r.into();
                        r.withdrawals
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `finalizeAppchainEpochs(uint256)` and selector `0xf03021a1`.
```solidity
function finalizeAppchainEpochs(uint256 appchainId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeAppchainEpochsCall {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`finalizeAppchainEpochs(uint256)`](finalizeAppchainEpochsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeAppchainEpochsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeAppchainEpochsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeAppchainEpochsCall) -> Self {
                    (value.appchainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeAppchainEpochsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { appchainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeAppchainEpochsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeAppchainEpochsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeAppchainEpochsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl finalizeAppchainEpochsReturn {
            fn _tokenize(
                &self,
            ) -> <finalizeAppchainEpochsCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for finalizeAppchainEpochsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = finalizeAppchainEpochsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "finalizeAppchainEpochs(uint256)";
            const SELECTOR: [u8; 4] = [240u8, 48u8, 33u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                finalizeAppchainEpochsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `finalizeEpochs()` and selector `0xfe07bb07`.
```solidity
function finalizeEpochs() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeEpochsCall;
    ///Container type for the return parameters of the [`finalizeEpochs()`](finalizeEpochsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeEpochsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeEpochsCall> for UnderlyingRustTuple<'_> {
                fn from(value: finalizeEpochsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for finalizeEpochsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeEpochsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeEpochsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeEpochsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl finalizeEpochsReturn {
            fn _tokenize(
                &self,
            ) -> <finalizeEpochsCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for finalizeEpochsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = finalizeEpochsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "finalizeEpochs()";
            const SELECTOR: [u8; 4] = [254u8, 7u8, 187u8, 7u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                finalizeEpochsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `finalizeUserAppchainEpochs(address,uint256)` and selector `0x7e5f5ca7`.
```solidity
function finalizeUserAppchainEpochs(address user, uint256 appchainId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeUserAppchainEpochsCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`finalizeUserAppchainEpochs(address,uint256)`](finalizeUserAppchainEpochsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeUserAppchainEpochsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeUserAppchainEpochsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeUserAppchainEpochsCall) -> Self {
                    (value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeUserAppchainEpochsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        user: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeUserAppchainEpochsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeUserAppchainEpochsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeUserAppchainEpochsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl finalizeUserAppchainEpochsReturn {
            fn _tokenize(
                &self,
            ) -> <finalizeUserAppchainEpochsCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for finalizeUserAppchainEpochsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = finalizeUserAppchainEpochsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "finalizeUserAppchainEpochs(address,uint256)";
            const SELECTOR: [u8; 4] = [126u8, 95u8, 92u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                finalizeUserAppchainEpochsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `finalizeUserEpochs(address)` and selector `0x9deb66c9`.
```solidity
function finalizeUserEpochs(address user) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeUserEpochsCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`finalizeUserEpochs(address)`](finalizeUserEpochsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeUserEpochsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeUserEpochsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeUserEpochsCall) -> Self {
                    (value.user,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeUserEpochsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { user: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeUserEpochsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeUserEpochsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeUserEpochsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl finalizeUserEpochsReturn {
            fn _tokenize(
                &self,
            ) -> <finalizeUserEpochsCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for finalizeUserEpochsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = finalizeUserEpochsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "finalizeUserEpochs(address)";
            const SELECTOR: [u8; 4] = [157u8, 235u8, 102u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                finalizeUserEpochsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `finalizedEpochCount()` and selector `0x1a8a738c`.
```solidity
function finalizedEpochCount() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizedEpochCountCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`finalizedEpochCount()`](finalizedEpochCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizedEpochCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizedEpochCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizedEpochCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizedEpochCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizedEpochCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizedEpochCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizedEpochCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for finalizedEpochCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "finalizedEpochCount()";
            const SELECTOR: [u8; 4] = [26u8, 138u8, 115u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: finalizedEpochCountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: finalizedEpochCountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getAppchainStake(uint256,uint256)` and selector `0xfa457be6`.
```solidity
function getAppchainStake(uint256 epochIndex, uint256 appchainId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAppchainStakeCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getAppchainStake(uint256,uint256)`](getAppchainStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAppchainStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAppchainStakeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAppchainStakeCall) -> Self {
                    (value.epochIndex, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAppchainStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAppchainStakeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAppchainStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAppchainStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAppchainStakeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAppchainStake(uint256,uint256)";
            const SELECTOR: [u8; 4] = [250u8, 69u8, 123u8, 230u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getAppchainStakeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getAppchainStakeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getCurrentEpoch()` and selector `0xb97dd9e2`.
```solidity
function getCurrentEpoch() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getCurrentEpoch()`](getCurrentEpochCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochCall> for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getCurrentEpochCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentEpochReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentEpochCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentEpoch()";
            const SELECTOR: [u8; 4] = [185u8, 125u8, 217u8, 226u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getCurrentEpochReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getCurrentEpochReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getEpochEnd(uint256)` and selector `0xd5176d23`.
```solidity
function getEpochEnd(uint256 epochIndex) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEpochEndCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getEpochEnd(uint256)`](getEpochEndCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEpochEndReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEpochEndCall> for UnderlyingRustTuple<'_> {
                fn from(value: getEpochEndCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getEpochEndCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEpochEndReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getEpochEndReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getEpochEndReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getEpochEndCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getEpochEnd(uint256)";
            const SELECTOR: [u8; 4] = [213u8, 23u8, 109u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getEpochEndReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getEpochEndReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getEpochStart(uint256)` and selector `0x0175e23b`.
```solidity
function getEpochStart(uint256 epochIndex) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEpochStartCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getEpochStart(uint256)`](getEpochStartCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEpochStartReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEpochStartCall> for UnderlyingRustTuple<'_> {
                fn from(value: getEpochStartCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getEpochStartCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEpochStartReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getEpochStartReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getEpochStartReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getEpochStartCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getEpochStart(uint256)";
            const SELECTOR: [u8; 4] = [1u8, 117u8, 226u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getEpochStartReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getEpochStartReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getTotalStake(uint256)` and selector `0x45367f23`.
```solidity
function getTotalStake(uint256 epochIndex) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTotalStakeCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getTotalStake(uint256)`](getTotalStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTotalStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTotalStakeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getTotalStakeCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getTotalStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTotalStakeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getTotalStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getTotalStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getTotalStakeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getTotalStake(uint256)";
            const SELECTOR: [u8; 4] = [69u8, 54u8, 127u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getTotalStakeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getTotalStakeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getTotalStakeShare(uint256)` and selector `0x408c32ea`.
```solidity
function getTotalStakeShare(uint256 epochIndex) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTotalStakeShareCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getTotalStakeShare(uint256)`](getTotalStakeShareCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTotalStakeShareReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTotalStakeShareCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getTotalStakeShareCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getTotalStakeShareCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTotalStakeShareReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getTotalStakeShareReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getTotalStakeShareReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getTotalStakeShareCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getTotalStakeShare(uint256)";
            const SELECTOR: [u8; 4] = [64u8, 140u8, 50u8, 234u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getTotalStakeShareReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getTotalStakeShareReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getUserAppchainStake(uint256,address,uint256)` and selector `0xc3ddb3b3`.
```solidity
function getUserAppchainStake(uint256 epochIndex, address user, uint256 appchainId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserAppchainStakeCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getUserAppchainStake(uint256,address,uint256)`](getUserAppchainStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserAppchainStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserAppchainStakeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getUserAppchainStakeCall) -> Self {
                    (value.epochIndex, value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getUserAppchainStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                        appchainId: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserAppchainStakeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getUserAppchainStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getUserAppchainStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getUserAppchainStakeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getUserAppchainStake(uint256,address,uint256)";
            const SELECTOR: [u8; 4] = [195u8, 221u8, 179u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getUserAppchainStakeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getUserAppchainStakeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getUserStake(uint256,address)` and selector `0x9626a230`.
```solidity
function getUserStake(uint256 epochIndex, address user) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserStakeCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getUserStake(uint256,address)`](getUserStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserStakeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getUserStakeCall) -> Self {
                    (value.epochIndex, value.user)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getUserStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserStakeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getUserStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getUserStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getUserStakeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getUserStake(uint256,address)";
            const SELECTOR: [u8; 4] = [150u8, 38u8, 162u8, 48u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getUserStakeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getUserStakeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getUserStakeShare(uint256,address)` and selector `0xf9d663e0`.
```solidity
function getUserStakeShare(uint256 epochIndex, address user) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserStakeShareCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getUserStakeShare(uint256,address)`](getUserStakeShareCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserStakeShareReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserStakeShareCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getUserStakeShareCall) -> Self {
                    (value.epochIndex, value.user)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getUserStakeShareCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        user: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserStakeShareReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getUserStakeShareReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getUserStakeShareReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getUserStakeShareCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getUserStakeShare(uint256,address)";
            const SELECTOR: [u8; 4] = [249u8, 214u8, 99u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getUserStakeShareReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getUserStakeShareReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getWithdrawalAmount(address,uint256)` and selector `0x59193f37`.
```solidity
function getWithdrawalAmount(address user, uint256 appchainId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getWithdrawalAmountCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getWithdrawalAmount(address,uint256)`](getWithdrawalAmountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getWithdrawalAmountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getWithdrawalAmountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getWithdrawalAmountCall) -> Self {
                    (value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getWithdrawalAmountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        user: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getWithdrawalAmountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getWithdrawalAmountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getWithdrawalAmountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getWithdrawalAmountCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getWithdrawalAmount(address,uint256)";
            const SELECTOR: [u8; 4] = [89u8, 25u8, 63u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getWithdrawalAmountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getWithdrawalAmountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initializeWithdrawal(uint256)` and selector `0x68a55564`.
```solidity
function initializeWithdrawal(uint256 appchainId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeWithdrawal_0Call {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`initializeWithdrawal(uint256)`](initializeWithdrawal_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeWithdrawal_0Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeWithdrawal_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeWithdrawal_0Call) -> Self {
                    (value.appchainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeWithdrawal_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { appchainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeWithdrawal_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeWithdrawal_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeWithdrawal_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeWithdrawal_0Return {
            fn _tokenize(
                &self,
            ) -> <initializeWithdrawal_0Call as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeWithdrawal_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeWithdrawal_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initializeWithdrawal(uint256)";
            const SELECTOR: [u8; 4] = [104u8, 165u8, 85u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeWithdrawal_0Return::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initializeWithdrawal(uint256,uint256)` and selector `0xed86ba6f`.
```solidity
function initializeWithdrawal(uint256 appchainId, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeWithdrawal_1Call {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`initializeWithdrawal(uint256,uint256)`](initializeWithdrawal_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeWithdrawal_1Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeWithdrawal_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeWithdrawal_1Call) -> Self {
                    (value.appchainId, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeWithdrawal_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        appchainId: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeWithdrawal_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeWithdrawal_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeWithdrawal_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeWithdrawal_1Return {
            fn _tokenize(
                &self,
            ) -> <initializeWithdrawal_1Call as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeWithdrawal_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeWithdrawal_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initializeWithdrawal(uint256,uint256)";
            const SELECTOR: [u8; 4] = [237u8, 134u8, 186u8, 111u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeWithdrawal_1Return::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `stageStakeTransfer(uint256,uint256,uint256)` and selector `0xe58e5382`.
```solidity
function stageStakeTransfer(uint256 fromAppchainId, uint256 toAppchainId, uint256 amount) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stageStakeTransferCall {
        #[allow(missing_docs)]
        pub fromAppchainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub toAppchainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`stageStakeTransfer(uint256,uint256,uint256)`](stageStakeTransferCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stageStakeTransferReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stageStakeTransferCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: stageStakeTransferCall) -> Self {
                    (value.fromAppchainId, value.toAppchainId, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for stageStakeTransferCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        fromAppchainId: tuple.0,
                        toAppchainId: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stageStakeTransferReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: stageStakeTransferReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for stageStakeTransferReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl stageStakeTransferReturn {
            fn _tokenize(
                &self,
            ) -> <stageStakeTransferCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stageStakeTransferCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = stageStakeTransferReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stageStakeTransfer(uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [229u8, 142u8, 83u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.fromAppchainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.toAppchainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                stageStakeTransferReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `stakeSynd(uint256)` and selector `0x0458296f`.
```solidity
function stakeSynd(uint256 appchainId) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stakeSyndCall {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`stakeSynd(uint256)`](stakeSyndCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stakeSyndReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeSyndCall> for UnderlyingRustTuple<'_> {
                fn from(value: stakeSyndCall) -> Self {
                    (value.appchainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stakeSyndCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { appchainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeSyndReturn> for UnderlyingRustTuple<'_> {
                fn from(value: stakeSyndReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stakeSyndReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl stakeSyndReturn {
            fn _tokenize(
                &self,
            ) -> <stakeSyndCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stakeSyndCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = stakeSyndReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stakeSynd(uint256)";
            const SELECTOR: [u8; 4] = [4u8, 88u8, 41u8, 111u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                stakeSyndReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `startTimestamp()` and selector `0xe6fd48bc`.
```solidity
function startTimestamp() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startTimestampCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`startTimestamp()`](startTimestampCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startTimestampReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startTimestampCall> for UnderlyingRustTuple<'_> {
                fn from(value: startTimestampCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startTimestampCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startTimestampReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: startTimestampReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for startTimestampReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for startTimestampCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "startTimestamp()";
            const SELECTOR: [u8; 4] = [230u8, 253u8, 72u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: startTimestampReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: startTimestampReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `totalStake()` and selector `0x8b0e9f3f`.
```solidity
function totalStake() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalStakeCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`totalStake()`](totalStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalStakeCall> for UnderlyingRustTuple<'_> {
                fn from(value: totalStakeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalStakeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: totalStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalStakeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalStake()";
            const SELECTOR: [u8; 4] = [139u8, 14u8, 159u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: totalStakeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: totalStakeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `userAppchainFinalizedEpochCount(address,uint256)` and selector `0xf89ee78d`.
```solidity
function userAppchainFinalizedEpochCount(address user, uint256 appchainId) external view returns (uint256 finalizedEpochCount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userAppchainFinalizedEpochCountCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`userAppchainFinalizedEpochCount(address,uint256)`](userAppchainFinalizedEpochCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userAppchainFinalizedEpochCountReturn {
        #[allow(missing_docs)]
        pub finalizedEpochCount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userAppchainFinalizedEpochCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: userAppchainFinalizedEpochCountCall) -> Self {
                    (value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for userAppchainFinalizedEpochCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        user: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userAppchainFinalizedEpochCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: userAppchainFinalizedEpochCountReturn) -> Self {
                    (value.finalizedEpochCount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for userAppchainFinalizedEpochCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        finalizedEpochCount: tuple.0,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for userAppchainFinalizedEpochCountCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "userAppchainFinalizedEpochCount(address,uint256)";
            const SELECTOR: [u8; 4] = [248u8, 158u8, 231u8, 141u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: userAppchainFinalizedEpochCountReturn = r.into();
                        r.finalizedEpochCount
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: userAppchainFinalizedEpochCountReturn = r.into();
                        r.finalizedEpochCount
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `userAppchainTotal(address,uint256)` and selector `0xa09d7a30`.
```solidity
function userAppchainTotal(address user, uint256 appchainId) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userAppchainTotalCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`userAppchainTotal(address,uint256)`](userAppchainTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userAppchainTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userAppchainTotalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: userAppchainTotalCall) -> Self {
                    (value.user, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for userAppchainTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        user: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userAppchainTotalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: userAppchainTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for userAppchainTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for userAppchainTotalCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "userAppchainTotal(address,uint256)";
            const SELECTOR: [u8; 4] = [160u8, 157u8, 122u8, 48u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: userAppchainTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: userAppchainTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `userFinalizedEpochCount(address)` and selector `0x7c5dd5d9`.
```solidity
function userFinalizedEpochCount(address user) external view returns (uint256 finalizedEpochCount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userFinalizedEpochCountCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`userFinalizedEpochCount(address)`](userFinalizedEpochCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userFinalizedEpochCountReturn {
        #[allow(missing_docs)]
        pub finalizedEpochCount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userFinalizedEpochCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: userFinalizedEpochCountCall) -> Self {
                    (value.user,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for userFinalizedEpochCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { user: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userFinalizedEpochCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: userFinalizedEpochCountReturn) -> Self {
                    (value.finalizedEpochCount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for userFinalizedEpochCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        finalizedEpochCount: tuple.0,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for userFinalizedEpochCountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "userFinalizedEpochCount(address)";
            const SELECTOR: [u8; 4] = [124u8, 93u8, 213u8, 217u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: userFinalizedEpochCountReturn = r.into();
                        r.finalizedEpochCount
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: userFinalizedEpochCountReturn = r.into();
                        r.finalizedEpochCount
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `userTotal(address)` and selector `0xe601cf44`.
```solidity
function userTotal(address user) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userTotalCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`userTotal(address)`](userTotalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct userTotalReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userTotalCall> for UnderlyingRustTuple<'_> {
                fn from(value: userTotalCall) -> Self {
                    (value.user,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for userTotalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { user: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<userTotalReturn> for UnderlyingRustTuple<'_> {
                fn from(value: userTotalReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for userTotalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for userTotalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "userTotal(address)";
            const SELECTOR: [u8; 4] = [230u8, 1u8, 207u8, 68u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.user,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: userTotalReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: userTotalReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `withdraw(uint256,address)` and selector `0x00f714ce`.
```solidity
function withdraw(uint256 epochIndex, address destination) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub destination: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`withdraw(uint256,address)`](withdrawCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawCall> for UnderlyingRustTuple<'_> {
                fn from(value: withdrawCall) -> Self {
                    (value.epochIndex, value.destination)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for withdrawCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        destination: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawReturn> for UnderlyingRustTuple<'_> {
                fn from(value: withdrawReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for withdrawReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl withdrawReturn {
            fn _tokenize(
                &self,
            ) -> <withdrawCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for withdrawCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = withdrawReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "withdraw(uint256,address)";
            const SELECTOR: [u8; 4] = [0u8, 247u8, 20u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.destination,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                withdrawReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`SyndStaking`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum SyndStakingCalls {
        #[allow(missing_docs)]
        EPOCH_DURATION(EPOCH_DURATIONCall),
        #[allow(missing_docs)]
        appchainFinalizedEpochCount(appchainFinalizedEpochCountCall),
        #[allow(missing_docs)]
        appchainTotal(appchainTotalCall),
        #[allow(missing_docs)]
        epochAdditions(epochAdditionsCall),
        #[allow(missing_docs)]
        epochAppchainAdditions(epochAppchainAdditionsCall),
        #[allow(missing_docs)]
        epochAppchainTotal(epochAppchainTotalCall),
        #[allow(missing_docs)]
        epochAppchainWithdrawals(epochAppchainWithdrawalsCall),
        #[allow(missing_docs)]
        epochStakeShare(epochStakeShareCall),
        #[allow(missing_docs)]
        epochTotal(epochTotalCall),
        #[allow(missing_docs)]
        epochUserAdditions(epochUserAdditionsCall),
        #[allow(missing_docs)]
        epochUserAppchainAdditions(epochUserAppchainAdditionsCall),
        #[allow(missing_docs)]
        epochUserAppchainTotal(epochUserAppchainTotalCall),
        #[allow(missing_docs)]
        epochUserAppchainWithdrawals(epochUserAppchainWithdrawalsCall),
        #[allow(missing_docs)]
        epochUserStakeShare(epochUserStakeShareCall),
        #[allow(missing_docs)]
        epochUserTotal(epochUserTotalCall),
        #[allow(missing_docs)]
        epochUserWithdrawals(epochUserWithdrawalsCall),
        #[allow(missing_docs)]
        epochWithdrawals(epochWithdrawalsCall),
        #[allow(missing_docs)]
        finalizeAppchainEpochs(finalizeAppchainEpochsCall),
        #[allow(missing_docs)]
        finalizeEpochs(finalizeEpochsCall),
        #[allow(missing_docs)]
        finalizeUserAppchainEpochs(finalizeUserAppchainEpochsCall),
        #[allow(missing_docs)]
        finalizeUserEpochs(finalizeUserEpochsCall),
        #[allow(missing_docs)]
        finalizedEpochCount(finalizedEpochCountCall),
        #[allow(missing_docs)]
        getAppchainStake(getAppchainStakeCall),
        #[allow(missing_docs)]
        getCurrentEpoch(getCurrentEpochCall),
        #[allow(missing_docs)]
        getEpochEnd(getEpochEndCall),
        #[allow(missing_docs)]
        getEpochStart(getEpochStartCall),
        #[allow(missing_docs)]
        getTotalStake(getTotalStakeCall),
        #[allow(missing_docs)]
        getTotalStakeShare(getTotalStakeShareCall),
        #[allow(missing_docs)]
        getUserAppchainStake(getUserAppchainStakeCall),
        #[allow(missing_docs)]
        getUserStake(getUserStakeCall),
        #[allow(missing_docs)]
        getUserStakeShare(getUserStakeShareCall),
        #[allow(missing_docs)]
        getWithdrawalAmount(getWithdrawalAmountCall),
        #[allow(missing_docs)]
        initializeWithdrawal_0(initializeWithdrawal_0Call),
        #[allow(missing_docs)]
        initializeWithdrawal_1(initializeWithdrawal_1Call),
        #[allow(missing_docs)]
        stageStakeTransfer(stageStakeTransferCall),
        #[allow(missing_docs)]
        stakeSynd(stakeSyndCall),
        #[allow(missing_docs)]
        startTimestamp(startTimestampCall),
        #[allow(missing_docs)]
        totalStake(totalStakeCall),
        #[allow(missing_docs)]
        userAppchainFinalizedEpochCount(userAppchainFinalizedEpochCountCall),
        #[allow(missing_docs)]
        userAppchainTotal(userAppchainTotalCall),
        #[allow(missing_docs)]
        userFinalizedEpochCount(userFinalizedEpochCountCall),
        #[allow(missing_docs)]
        userTotal(userTotalCall),
        #[allow(missing_docs)]
        withdraw(withdrawCall),
    }
    #[automatically_derived]
    impl SyndStakingCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 247u8, 20u8, 206u8],
            [1u8, 117u8, 226u8, 59u8],
            [4u8, 88u8, 41u8, 111u8],
            [5u8, 61u8, 205u8, 37u8],
            [11u8, 40u8, 27u8, 248u8],
            [16u8, 87u8, 233u8, 188u8],
            [18u8, 233u8, 115u8, 188u8],
            [26u8, 138u8, 115u8, 140u8],
            [27u8, 83u8, 59u8, 90u8],
            [30u8, 14u8, 132u8, 137u8],
            [59u8, 160u8, 15u8, 174u8],
            [64u8, 140u8, 50u8, 234u8],
            [69u8, 54u8, 127u8, 35u8],
            [89u8, 25u8, 63u8, 55u8],
            [93u8, 61u8, 140u8, 210u8],
            [98u8, 148u8, 84u8, 253u8],
            [104u8, 165u8, 85u8, 100u8],
            [105u8, 61u8, 11u8, 126u8],
            [123u8, 218u8, 28u8, 251u8],
            [124u8, 93u8, 213u8, 217u8],
            [124u8, 110u8, 170u8, 238u8],
            [126u8, 95u8, 92u8, 167u8],
            [139u8, 14u8, 159u8, 63u8],
            [140u8, 103u8, 144u8, 62u8],
            [150u8, 38u8, 162u8, 48u8],
            [157u8, 235u8, 102u8, 201u8],
            [160u8, 157u8, 122u8, 48u8],
            [167u8, 11u8, 159u8, 12u8],
            [185u8, 125u8, 217u8, 226u8],
            [195u8, 221u8, 179u8, 179u8],
            [213u8, 23u8, 109u8, 35u8],
            [229u8, 142u8, 83u8, 130u8],
            [230u8, 1u8, 207u8, 68u8],
            [230u8, 253u8, 72u8, 188u8],
            [237u8, 134u8, 186u8, 111u8],
            [238u8, 117u8, 20u8, 232u8],
            [240u8, 48u8, 33u8, 161u8],
            [248u8, 158u8, 231u8, 141u8],
            [249u8, 101u8, 101u8, 45u8],
            [249u8, 214u8, 99u8, 224u8],
            [250u8, 69u8, 123u8, 230u8],
            [250u8, 115u8, 206u8, 89u8],
            [254u8, 7u8, 187u8, 7u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndStakingCalls {
        const NAME: &'static str = "SyndStakingCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 43usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::EPOCH_DURATION(_) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::appchainFinalizedEpochCount(_) => {
                    <appchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::appchainTotal(_) => {
                    <appchainTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochAdditions(_) => {
                    <epochAdditionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochAppchainAdditions(_) => {
                    <epochAppchainAdditionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochAppchainTotal(_) => {
                    <epochAppchainTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochAppchainWithdrawals(_) => {
                    <epochAppchainWithdrawalsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochStakeShare(_) => {
                    <epochStakeShareCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochTotal(_) => {
                    <epochTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserAdditions(_) => {
                    <epochUserAdditionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserAppchainAdditions(_) => {
                    <epochUserAppchainAdditionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserAppchainTotal(_) => {
                    <epochUserAppchainTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserAppchainWithdrawals(_) => {
                    <epochUserAppchainWithdrawalsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserStakeShare(_) => {
                    <epochUserStakeShareCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserTotal(_) => {
                    <epochUserTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochUserWithdrawals(_) => {
                    <epochUserWithdrawalsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochWithdrawals(_) => {
                    <epochWithdrawalsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::finalizeAppchainEpochs(_) => {
                    <finalizeAppchainEpochsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::finalizeEpochs(_) => {
                    <finalizeEpochsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::finalizeUserAppchainEpochs(_) => {
                    <finalizeUserAppchainEpochsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::finalizeUserEpochs(_) => {
                    <finalizeUserEpochsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::finalizedEpochCount(_) => {
                    <finalizedEpochCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAppchainStake(_) => {
                    <getAppchainStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCurrentEpoch(_) => {
                    <getCurrentEpochCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getEpochEnd(_) => {
                    <getEpochEndCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getEpochStart(_) => {
                    <getEpochStartCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getTotalStake(_) => {
                    <getTotalStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getTotalStakeShare(_) => {
                    <getTotalStakeShareCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getUserAppchainStake(_) => {
                    <getUserAppchainStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getUserStake(_) => {
                    <getUserStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getUserStakeShare(_) => {
                    <getUserStakeShareCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getWithdrawalAmount(_) => {
                    <getWithdrawalAmountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initializeWithdrawal_0(_) => {
                    <initializeWithdrawal_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initializeWithdrawal_1(_) => {
                    <initializeWithdrawal_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::stageStakeTransfer(_) => {
                    <stageStakeTransferCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::stakeSynd(_) => {
                    <stakeSyndCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::startTimestamp(_) => {
                    <startTimestampCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::totalStake(_) => {
                    <totalStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::userAppchainFinalizedEpochCount(_) => {
                    <userAppchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::userAppchainTotal(_) => {
                    <userAppchainTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::userFinalizedEpochCount(_) => {
                    <userFinalizedEpochCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::userTotal(_) => {
                    <userTotalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::withdraw(_) => <withdrawCall as alloy_sol_types::SolCall>::SELECTOR,
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SyndStakingCalls>] = &[
                {
                    fn withdraw(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <withdrawCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndStakingCalls::withdraw)
                    }
                    withdraw
                },
                {
                    fn getEpochStart(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getEpochStartCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getEpochStart)
                    }
                    getEpochStart
                },
                {
                    fn stakeSynd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <stakeSyndCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndStakingCalls::stakeSynd)
                    }
                    stakeSynd
                },
                {
                    fn epochUserTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserTotal)
                    }
                    epochUserTotal
                },
                {
                    fn epochAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochAdditions)
                    }
                    epochAdditions
                },
                {
                    fn appchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <appchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::appchainTotal)
                    }
                    appchainTotal
                },
                {
                    fn epochStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochStakeShare)
                    }
                    epochStakeShare
                },
                {
                    fn finalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::finalizedEpochCount)
                    }
                    finalizedEpochCount
                },
                {
                    fn epochUserAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAdditions)
                    }
                    epochUserAdditions
                },
                {
                    fn epochTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochTotal)
                    }
                    epochTotal
                },
                {
                    fn appchainFinalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <appchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::appchainFinalizedEpochCount)
                    }
                    appchainFinalizedEpochCount
                },
                {
                    fn getTotalStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getTotalStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getTotalStakeShare)
                    }
                    getTotalStakeShare
                },
                {
                    fn getTotalStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getTotalStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getTotalStake)
                    }
                    getTotalStake
                },
                {
                    fn getWithdrawalAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getWithdrawalAmountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getWithdrawalAmount)
                    }
                    getWithdrawalAmount
                },
                {
                    fn epochUserWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserWithdrawals)
                    }
                    epochUserWithdrawals
                },
                {
                    fn epochUserAppchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAppchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAppchainTotal)
                    }
                    epochUserAppchainTotal
                },
                {
                    fn initializeWithdrawal_0(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <initializeWithdrawal_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::initializeWithdrawal_0)
                    }
                    initializeWithdrawal_0
                },
                {
                    fn epochUserAppchainAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAppchainAdditions)
                    }
                    epochUserAppchainAdditions
                },
                {
                    fn epochAppchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAppchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochAppchainTotal)
                    }
                    epochAppchainTotal
                },
                {
                    fn userFinalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::userFinalizedEpochCount)
                    }
                    userFinalizedEpochCount
                },
                {
                    fn epochAppchainAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochAppchainAdditions)
                    }
                    epochAppchainAdditions
                },
                {
                    fn finalizeUserAppchainEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeUserAppchainEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeUserAppchainEpochs)
                    }
                    finalizeUserAppchainEpochs
                },
                {
                    fn totalStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <totalStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::totalStake)
                    }
                    totalStake
                },
                {
                    fn epochWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochWithdrawals)
                    }
                    epochWithdrawals
                },
                {
                    fn getUserStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getUserStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getUserStake)
                    }
                    getUserStake
                },
                {
                    fn finalizeUserEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeUserEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeUserEpochs)
                    }
                    finalizeUserEpochs
                },
                {
                    fn userAppchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userAppchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::userAppchainTotal)
                    }
                    userAppchainTotal
                },
                {
                    fn EPOCH_DURATION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::EPOCH_DURATION)
                    }
                    EPOCH_DURATION
                },
                {
                    fn getCurrentEpoch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getCurrentEpochCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getCurrentEpoch)
                    }
                    getCurrentEpoch
                },
                {
                    fn getUserAppchainStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getUserAppchainStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getUserAppchainStake)
                    }
                    getUserAppchainStake
                },
                {
                    fn getEpochEnd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getEpochEndCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getEpochEnd)
                    }
                    getEpochEnd
                },
                {
                    fn stageStakeTransfer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <stageStakeTransferCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::stageStakeTransfer)
                    }
                    stageStakeTransfer
                },
                {
                    fn userTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userTotalCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndStakingCalls::userTotal)
                    }
                    userTotal
                },
                {
                    fn startTimestamp(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <startTimestampCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::startTimestamp)
                    }
                    startTimestamp
                },
                {
                    fn initializeWithdrawal_1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <initializeWithdrawal_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::initializeWithdrawal_1)
                    }
                    initializeWithdrawal_1
                },
                {
                    fn epochUserStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserStakeShare)
                    }
                    epochUserStakeShare
                },
                {
                    fn finalizeAppchainEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeAppchainEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeAppchainEpochs)
                    }
                    finalizeAppchainEpochs
                },
                {
                    fn userAppchainFinalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userAppchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::userAppchainFinalizedEpochCount)
                    }
                    userAppchainFinalizedEpochCount
                },
                {
                    fn epochAppchainWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochAppchainWithdrawals)
                    }
                    epochAppchainWithdrawals
                },
                {
                    fn getUserStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getUserStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getUserStakeShare)
                    }
                    getUserStakeShare
                },
                {
                    fn getAppchainStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getAppchainStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::getAppchainStake)
                    }
                    getAppchainStake
                },
                {
                    fn epochUserAppchainWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAppchainWithdrawals)
                    }
                    epochUserAppchainWithdrawals
                },
                {
                    fn finalizeEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeEpochs)
                    }
                    finalizeEpochs
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SyndStakingCalls>] = &[
                {
                    fn withdraw(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <withdrawCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::withdraw)
                    }
                    withdraw
                },
                {
                    fn getEpochStart(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getEpochStartCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getEpochStart)
                    }
                    getEpochStart
                },
                {
                    fn stakeSynd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <stakeSyndCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::stakeSynd)
                    }
                    stakeSynd
                },
                {
                    fn epochUserTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserTotal)
                    }
                    epochUserTotal
                },
                {
                    fn epochAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochAdditions)
                    }
                    epochAdditions
                },
                {
                    fn appchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <appchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::appchainTotal)
                    }
                    appchainTotal
                },
                {
                    fn epochStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochStakeShare)
                    }
                    epochStakeShare
                },
                {
                    fn finalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::finalizedEpochCount)
                    }
                    finalizedEpochCount
                },
                {
                    fn epochUserAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAdditions)
                    }
                    epochUserAdditions
                },
                {
                    fn epochTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochTotal)
                    }
                    epochTotal
                },
                {
                    fn appchainFinalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <appchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::appchainFinalizedEpochCount)
                    }
                    appchainFinalizedEpochCount
                },
                {
                    fn getTotalStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getTotalStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getTotalStakeShare)
                    }
                    getTotalStakeShare
                },
                {
                    fn getTotalStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getTotalStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getTotalStake)
                    }
                    getTotalStake
                },
                {
                    fn getWithdrawalAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getWithdrawalAmountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getWithdrawalAmount)
                    }
                    getWithdrawalAmount
                },
                {
                    fn epochUserWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserWithdrawals)
                    }
                    epochUserWithdrawals
                },
                {
                    fn epochUserAppchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAppchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAppchainTotal)
                    }
                    epochUserAppchainTotal
                },
                {
                    fn initializeWithdrawal_0(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <initializeWithdrawal_0Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::initializeWithdrawal_0)
                    }
                    initializeWithdrawal_0
                },
                {
                    fn epochUserAppchainAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAppchainAdditions)
                    }
                    epochUserAppchainAdditions
                },
                {
                    fn epochAppchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAppchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochAppchainTotal)
                    }
                    epochAppchainTotal
                },
                {
                    fn userFinalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::userFinalizedEpochCount)
                    }
                    userFinalizedEpochCount
                },
                {
                    fn epochAppchainAdditions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochAppchainAdditions)
                    }
                    epochAppchainAdditions
                },
                {
                    fn finalizeUserAppchainEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeUserAppchainEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeUserAppchainEpochs)
                    }
                    finalizeUserAppchainEpochs
                },
                {
                    fn totalStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <totalStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::totalStake)
                    }
                    totalStake
                },
                {
                    fn epochWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochWithdrawals)
                    }
                    epochWithdrawals
                },
                {
                    fn getUserStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getUserStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getUserStake)
                    }
                    getUserStake
                },
                {
                    fn finalizeUserEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeUserEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeUserEpochs)
                    }
                    finalizeUserEpochs
                },
                {
                    fn userAppchainTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userAppchainTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::userAppchainTotal)
                    }
                    userAppchainTotal
                },
                {
                    fn EPOCH_DURATION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::EPOCH_DURATION)
                    }
                    EPOCH_DURATION
                },
                {
                    fn getCurrentEpoch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getCurrentEpochCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getCurrentEpoch)
                    }
                    getCurrentEpoch
                },
                {
                    fn getUserAppchainStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getUserAppchainStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getUserAppchainStake)
                    }
                    getUserAppchainStake
                },
                {
                    fn getEpochEnd(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getEpochEndCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getEpochEnd)
                    }
                    getEpochEnd
                },
                {
                    fn stageStakeTransfer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <stageStakeTransferCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::stageStakeTransfer)
                    }
                    stageStakeTransfer
                },
                {
                    fn userTotal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userTotalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::userTotal)
                    }
                    userTotal
                },
                {
                    fn startTimestamp(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <startTimestampCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::startTimestamp)
                    }
                    startTimestamp
                },
                {
                    fn initializeWithdrawal_1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <initializeWithdrawal_1Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::initializeWithdrawal_1)
                    }
                    initializeWithdrawal_1
                },
                {
                    fn epochUserStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserStakeShare)
                    }
                    epochUserStakeShare
                },
                {
                    fn finalizeAppchainEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeAppchainEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeAppchainEpochs)
                    }
                    finalizeAppchainEpochs
                },
                {
                    fn userAppchainFinalizedEpochCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <userAppchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::userAppchainFinalizedEpochCount)
                    }
                    userAppchainFinalizedEpochCount
                },
                {
                    fn epochAppchainWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochAppchainWithdrawals)
                    }
                    epochAppchainWithdrawals
                },
                {
                    fn getUserStakeShare(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getUserStakeShareCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getUserStakeShare)
                    }
                    getUserStakeShare
                },
                {
                    fn getAppchainStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <getAppchainStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::getAppchainStake)
                    }
                    getAppchainStake
                },
                {
                    fn epochUserAppchainWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <epochUserAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::epochUserAppchainWithdrawals)
                    }
                    epochUserAppchainWithdrawals
                },
                {
                    fn finalizeEpochs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingCalls> {
                        <finalizeEpochsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingCalls::finalizeEpochs)
                    }
                    finalizeEpochs
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::EPOCH_DURATION(inner) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::appchainFinalizedEpochCount(inner) => {
                    <appchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::appchainTotal(inner) => {
                    <appchainTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochAdditions(inner) => {
                    <epochAdditionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochAppchainAdditions(inner) => {
                    <epochAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochAppchainTotal(inner) => {
                    <epochAppchainTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochAppchainWithdrawals(inner) => {
                    <epochAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochStakeShare(inner) => {
                    <epochStakeShareCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochTotal(inner) => {
                    <epochTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::epochUserAdditions(inner) => {
                    <epochUserAdditionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochUserAppchainAdditions(inner) => {
                    <epochUserAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochUserAppchainTotal(inner) => {
                    <epochUserAppchainTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochUserAppchainWithdrawals(inner) => {
                    <epochUserAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochUserStakeShare(inner) => {
                    <epochUserStakeShareCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochUserTotal(inner) => {
                    <epochUserTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochUserWithdrawals(inner) => {
                    <epochUserWithdrawalsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochWithdrawals(inner) => {
                    <epochWithdrawalsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::finalizeAppchainEpochs(inner) => {
                    <finalizeAppchainEpochsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::finalizeEpochs(inner) => {
                    <finalizeEpochsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::finalizeUserAppchainEpochs(inner) => {
                    <finalizeUserAppchainEpochsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::finalizeUserEpochs(inner) => {
                    <finalizeUserEpochsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::finalizedEpochCount(inner) => {
                    <finalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAppchainStake(inner) => {
                    <getAppchainStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCurrentEpoch(inner) => {
                    <getCurrentEpochCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getEpochEnd(inner) => {
                    <getEpochEndCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getEpochStart(inner) => {
                    <getEpochStartCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getTotalStake(inner) => {
                    <getTotalStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getTotalStakeShare(inner) => {
                    <getTotalStakeShareCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getUserAppchainStake(inner) => {
                    <getUserAppchainStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getUserStake(inner) => {
                    <getUserStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getUserStakeShare(inner) => {
                    <getUserStakeShareCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getWithdrawalAmount(inner) => {
                    <getWithdrawalAmountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::initializeWithdrawal_0(inner) => {
                    <initializeWithdrawal_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::initializeWithdrawal_1(inner) => {
                    <initializeWithdrawal_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::stageStakeTransfer(inner) => {
                    <stageStakeTransferCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::stakeSynd(inner) => {
                    <stakeSyndCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::startTimestamp(inner) => {
                    <startTimestampCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::totalStake(inner) => {
                    <totalStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::userAppchainFinalizedEpochCount(inner) => {
                    <userAppchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::userAppchainTotal(inner) => {
                    <userAppchainTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::userFinalizedEpochCount(inner) => {
                    <userFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::userTotal(inner) => {
                    <userTotalCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::withdraw(inner) => {
                    <withdrawCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::EPOCH_DURATION(inner) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::appchainFinalizedEpochCount(inner) => {
                    <appchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::appchainTotal(inner) => {
                    <appchainTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochAdditions(inner) => {
                    <epochAdditionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochAppchainAdditions(inner) => {
                    <epochAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochAppchainTotal(inner) => {
                    <epochAppchainTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochAppchainWithdrawals(inner) => {
                    <epochAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochStakeShare(inner) => {
                    <epochStakeShareCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochTotal(inner) => {
                    <epochTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserAdditions(inner) => {
                    <epochUserAdditionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserAppchainAdditions(inner) => {
                    <epochUserAppchainAdditionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserAppchainTotal(inner) => {
                    <epochUserAppchainTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserAppchainWithdrawals(inner) => {
                    <epochUserAppchainWithdrawalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserStakeShare(inner) => {
                    <epochUserStakeShareCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserTotal(inner) => {
                    <epochUserTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochUserWithdrawals(inner) => {
                    <epochUserWithdrawalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochWithdrawals(inner) => {
                    <epochWithdrawalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::finalizeAppchainEpochs(inner) => {
                    <finalizeAppchainEpochsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::finalizeEpochs(inner) => {
                    <finalizeEpochsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::finalizeUserAppchainEpochs(inner) => {
                    <finalizeUserAppchainEpochsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::finalizeUserEpochs(inner) => {
                    <finalizeUserEpochsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::finalizedEpochCount(inner) => {
                    <finalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAppchainStake(inner) => {
                    <getAppchainStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCurrentEpoch(inner) => {
                    <getCurrentEpochCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getEpochEnd(inner) => {
                    <getEpochEndCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getEpochStart(inner) => {
                    <getEpochStartCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getTotalStake(inner) => {
                    <getTotalStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getTotalStakeShare(inner) => {
                    <getTotalStakeShareCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getUserAppchainStake(inner) => {
                    <getUserAppchainStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getUserStake(inner) => {
                    <getUserStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getUserStakeShare(inner) => {
                    <getUserStakeShareCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getWithdrawalAmount(inner) => {
                    <getWithdrawalAmountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initializeWithdrawal_0(inner) => {
                    <initializeWithdrawal_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initializeWithdrawal_1(inner) => {
                    <initializeWithdrawal_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::stageStakeTransfer(inner) => {
                    <stageStakeTransferCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::stakeSynd(inner) => {
                    <stakeSyndCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::startTimestamp(inner) => {
                    <startTimestampCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::totalStake(inner) => {
                    <totalStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::userAppchainFinalizedEpochCount(inner) => {
                    <userAppchainFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::userAppchainTotal(inner) => {
                    <userAppchainTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::userFinalizedEpochCount(inner) => {
                    <userFinalizedEpochCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::userTotal(inner) => {
                    <userTotalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::withdraw(inner) => {
                    <withdrawCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`SyndStaking`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum SyndStakingErrors {
        #[allow(missing_docs)]
        FailedCall(FailedCall),
        #[allow(missing_docs)]
        InsufficientBalance(InsufficientBalance),
        #[allow(missing_docs)]
        InsufficientStake(InsufficientStake),
        #[allow(missing_docs)]
        InvalidAmount(InvalidAmount),
        #[allow(missing_docs)]
        InvalidAppchainId(InvalidAppchainId),
        #[allow(missing_docs)]
        InvalidWithdrawal(InvalidWithdrawal),
        #[allow(missing_docs)]
        WithdrawalNotReady(WithdrawalNotReady),
    }
    #[automatically_derived]
    impl SyndStakingErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [15u8, 44u8, 166u8, 231u8],
            [44u8, 82u8, 17u8, 198u8],
            [201u8, 69u8, 36u8, 45u8],
            [207u8, 71u8, 145u8, 129u8],
            [214u8, 189u8, 162u8, 117u8],
            [241u8, 188u8, 148u8, 210u8],
            [246u8, 180u8, 19u8, 28u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndStakingErrors {
        const NAME: &'static str = "SyndStakingErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 7usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::FailedCall(_) => {
                    <FailedCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientBalance(_) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientStake(_) => {
                    <InsufficientStake as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidAmount(_) => {
                    <InvalidAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidAppchainId(_) => {
                    <InvalidAppchainId as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidWithdrawal(_) => {
                    <InvalidWithdrawal as alloy_sol_types::SolError>::SELECTOR
                }
                Self::WithdrawalNotReady(_) => {
                    <WithdrawalNotReady as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SyndStakingErrors>] = &[
                {
                    fn WithdrawalNotReady(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <WithdrawalNotReady as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::WithdrawalNotReady)
                    }
                    WithdrawalNotReady
                },
                {
                    fn InvalidAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidAmount)
                    }
                    InvalidAmount
                },
                {
                    fn InvalidWithdrawal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidWithdrawal as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidWithdrawal)
                    }
                    InvalidWithdrawal
                },
                {
                    fn InsufficientBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::InsufficientBalance)
                    }
                    InsufficientBalance
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(SyndStakingErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn InsufficientStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InsufficientStake as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::InsufficientStake)
                    }
                    InsufficientStake
                },
                {
                    fn InvalidAppchainId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidAppchainId as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidAppchainId)
                    }
                    InvalidAppchainId
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SyndStakingErrors>] = &[
                {
                    fn WithdrawalNotReady(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <WithdrawalNotReady as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::WithdrawalNotReady)
                    }
                    WithdrawalNotReady
                },
                {
                    fn InvalidAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidAmount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidAmount)
                    }
                    InvalidAmount
                },
                {
                    fn InvalidWithdrawal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidWithdrawal as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidWithdrawal)
                    }
                    InvalidWithdrawal
                },
                {
                    fn InsufficientBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::InsufficientBalance)
                    }
                    InsufficientBalance
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn InsufficientStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InsufficientStake as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::InsufficientStake)
                    }
                    InsufficientStake
                },
                {
                    fn InvalidAppchainId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndStakingErrors> {
                        <InvalidAppchainId as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndStakingErrors::InvalidAppchainId)
                    }
                    InvalidAppchainId
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InsufficientBalance(inner) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientStake(inner) => {
                    <InsufficientStake as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidAmount(inner) => {
                    <InvalidAmount as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidAppchainId(inner) => {
                    <InvalidAppchainId as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidWithdrawal(inner) => {
                    <InvalidWithdrawal as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::WithdrawalNotReady(inner) => {
                    <WithdrawalNotReady as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::InsufficientBalance(inner) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientStake(inner) => {
                    <InsufficientStake as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidAmount(inner) => {
                    <InvalidAmount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidAppchainId(inner) => {
                    <InvalidAppchainId as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidWithdrawal(inner) => {
                    <InvalidWithdrawal as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::WithdrawalNotReady(inner) => {
                    <WithdrawalNotReady as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`SyndStaking`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum SyndStakingEvents {
        #[allow(missing_docs)]
        Stake(Stake),
        #[allow(missing_docs)]
        StakeTransfer(StakeTransfer),
        #[allow(missing_docs)]
        WithdrawalCompleted(WithdrawalCompleted),
        #[allow(missing_docs)]
        WithdrawalInitialized(WithdrawalInitialized),
    }
    #[automatically_derived]
    impl SyndStakingEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                80u8, 122u8, 195u8, 158u8, 179u8, 54u8, 16u8, 25u8, 28u8, 216u8, 253u8,
                84u8, 40u8, 110u8, 145u8, 197u8, 204u8, 70u8, 76u8, 38u8, 40u8, 97u8,
                100u8, 59u8, 227u8, 151u8, 143u8, 90u8, 159u8, 24u8, 171u8, 2u8,
            ],
            [
                139u8, 212u8, 114u8, 142u8, 233u8, 202u8, 63u8, 153u8, 221u8, 207u8,
                250u8, 36u8, 235u8, 79u8, 21u8, 222u8, 1u8, 92u8, 218u8, 154u8, 39u8,
                204u8, 196u8, 39u8, 223u8, 218u8, 247u8, 17u8, 148u8, 62u8, 188u8, 160u8,
            ],
            [
                176u8, 3u8, 130u8, 32u8, 59u8, 70u8, 195u8, 182u8, 173u8, 10u8, 45u8,
                122u8, 240u8, 38u8, 142u8, 51u8, 75u8, 217u8, 64u8, 98u8, 86u8, 167u8,
                199u8, 186u8, 143u8, 127u8, 200u8, 188u8, 71u8, 248u8, 205u8, 233u8,
            ],
            [
                179u8, 18u8, 144u8, 60u8, 226u8, 7u8, 210u8, 30u8, 132u8, 229u8, 125u8,
                16u8, 5u8, 224u8, 170u8, 83u8, 133u8, 183u8, 131u8, 235u8, 39u8, 226u8,
                88u8, 129u8, 113u8, 116u8, 208u8, 12u8, 251u8, 188u8, 50u8, 120u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for SyndStakingEvents {
        const NAME: &'static str = "SyndStakingEvents";
        const COUNT: usize = 4usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Stake as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Stake as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Stake)
                }
                Some(<StakeTransfer as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <StakeTransfer as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::StakeTransfer)
                }
                Some(
                    <WithdrawalCompleted as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <WithdrawalCompleted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::WithdrawalCompleted)
                }
                Some(
                    <WithdrawalInitialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <WithdrawalInitialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::WithdrawalInitialized)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for SyndStakingEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Stake(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::StakeTransfer(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::WithdrawalCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::WithdrawalInitialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Stake(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::StakeTransfer(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::WithdrawalCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::WithdrawalInitialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`SyndStaking`](self) contract instance.

See the [wrapper's documentation](`SyndStakingInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> SyndStakingInstance<P, N> {
        SyndStakingInstance::<P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _startTimestamp: alloy::sol_types::private::primitives::aliases::U256,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<SyndStakingInstance<P, N>>,
    > {
        SyndStakingInstance::<P, N>::deploy(provider, _startTimestamp)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _startTimestamp: alloy::sol_types::private::primitives::aliases::U256,
    ) -> alloy_contract::RawCallBuilder<P, N> {
        SyndStakingInstance::<P, N>::deploy_builder(provider, _startTimestamp)
    }
    /**A [`SyndStaking`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`SyndStaking`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct SyndStakingInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for SyndStakingInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("SyndStakingInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SyndStakingInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`SyndStaking`](self) contract instance.

See the [wrapper's documentation](`SyndStakingInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            _startTimestamp: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::Result<SyndStakingInstance<P, N>> {
            let call_builder = Self::deploy_builder(provider, _startTimestamp);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            _startTimestamp: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall { _startTimestamp },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> SyndStakingInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> SyndStakingInstance<P, N> {
            SyndStakingInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SyndStakingInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`EPOCH_DURATION`] function.
        pub fn EPOCH_DURATION(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, EPOCH_DURATIONCall, N> {
            self.call_builder(&EPOCH_DURATIONCall)
        }
        ///Creates a new call builder for the [`appchainFinalizedEpochCount`] function.
        pub fn appchainFinalizedEpochCount(
            &self,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, appchainFinalizedEpochCountCall, N> {
            self.call_builder(
                &appchainFinalizedEpochCountCall {
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`appchainTotal`] function.
        pub fn appchainTotal(
            &self,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, appchainTotalCall, N> {
            self.call_builder(&appchainTotalCall { appchainId })
        }
        ///Creates a new call builder for the [`epochAdditions`] function.
        pub fn epochAdditions(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochAdditionsCall, N> {
            self.call_builder(&epochAdditionsCall { epochIndex })
        }
        ///Creates a new call builder for the [`epochAppchainAdditions`] function.
        pub fn epochAppchainAdditions(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochAppchainAdditionsCall, N> {
            self.call_builder(
                &epochAppchainAdditionsCall {
                    epochIndex,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochAppchainTotal`] function.
        pub fn epochAppchainTotal(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochAppchainTotalCall, N> {
            self.call_builder(
                &epochAppchainTotalCall {
                    epochIndex,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochAppchainWithdrawals`] function.
        pub fn epochAppchainWithdrawals(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochAppchainWithdrawalsCall, N> {
            self.call_builder(
                &epochAppchainWithdrawalsCall {
                    epochIndex,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochStakeShare`] function.
        pub fn epochStakeShare(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochStakeShareCall, N> {
            self.call_builder(&epochStakeShareCall { epochIndex })
        }
        ///Creates a new call builder for the [`epochTotal`] function.
        pub fn epochTotal(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochTotalCall, N> {
            self.call_builder(&epochTotalCall { epochIndex })
        }
        ///Creates a new call builder for the [`epochUserAdditions`] function.
        pub fn epochUserAdditions(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserAdditionsCall, N> {
            self.call_builder(
                &epochUserAdditionsCall {
                    epochIndex,
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`epochUserAppchainAdditions`] function.
        pub fn epochUserAppchainAdditions(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserAppchainAdditionsCall, N> {
            self.call_builder(
                &epochUserAppchainAdditionsCall {
                    epochIndex,
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochUserAppchainTotal`] function.
        pub fn epochUserAppchainTotal(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserAppchainTotalCall, N> {
            self.call_builder(
                &epochUserAppchainTotalCall {
                    epochIndex,
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochUserAppchainWithdrawals`] function.
        pub fn epochUserAppchainWithdrawals(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserAppchainWithdrawalsCall, N> {
            self.call_builder(
                &epochUserAppchainWithdrawalsCall {
                    epochIndex,
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochUserStakeShare`] function.
        pub fn epochUserStakeShare(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserStakeShareCall, N> {
            self.call_builder(
                &epochUserStakeShareCall {
                    epochIndex,
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`epochUserTotal`] function.
        pub fn epochUserTotal(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserTotalCall, N> {
            self.call_builder(
                &epochUserTotalCall {
                    epochIndex,
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`epochUserWithdrawals`] function.
        pub fn epochUserWithdrawals(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, epochUserWithdrawalsCall, N> {
            self.call_builder(
                &epochUserWithdrawalsCall {
                    epochIndex,
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`epochWithdrawals`] function.
        pub fn epochWithdrawals(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochWithdrawalsCall, N> {
            self.call_builder(&epochWithdrawalsCall { epochIndex })
        }
        ///Creates a new call builder for the [`finalizeAppchainEpochs`] function.
        pub fn finalizeAppchainEpochs(
            &self,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, finalizeAppchainEpochsCall, N> {
            self.call_builder(
                &finalizeAppchainEpochsCall {
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`finalizeEpochs`] function.
        pub fn finalizeEpochs(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, finalizeEpochsCall, N> {
            self.call_builder(&finalizeEpochsCall)
        }
        ///Creates a new call builder for the [`finalizeUserAppchainEpochs`] function.
        pub fn finalizeUserAppchainEpochs(
            &self,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, finalizeUserAppchainEpochsCall, N> {
            self.call_builder(
                &finalizeUserAppchainEpochsCall {
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`finalizeUserEpochs`] function.
        pub fn finalizeUserEpochs(
            &self,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, finalizeUserEpochsCall, N> {
            self.call_builder(&finalizeUserEpochsCall { user })
        }
        ///Creates a new call builder for the [`finalizedEpochCount`] function.
        pub fn finalizedEpochCount(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, finalizedEpochCountCall, N> {
            self.call_builder(&finalizedEpochCountCall)
        }
        ///Creates a new call builder for the [`getAppchainStake`] function.
        pub fn getAppchainStake(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getAppchainStakeCall, N> {
            self.call_builder(
                &getAppchainStakeCall {
                    epochIndex,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`getCurrentEpoch`] function.
        pub fn getCurrentEpoch(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getCurrentEpochCall, N> {
            self.call_builder(&getCurrentEpochCall)
        }
        ///Creates a new call builder for the [`getEpochEnd`] function.
        pub fn getEpochEnd(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getEpochEndCall, N> {
            self.call_builder(&getEpochEndCall { epochIndex })
        }
        ///Creates a new call builder for the [`getEpochStart`] function.
        pub fn getEpochStart(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getEpochStartCall, N> {
            self.call_builder(&getEpochStartCall { epochIndex })
        }
        ///Creates a new call builder for the [`getTotalStake`] function.
        pub fn getTotalStake(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getTotalStakeCall, N> {
            self.call_builder(&getTotalStakeCall { epochIndex })
        }
        ///Creates a new call builder for the [`getTotalStakeShare`] function.
        pub fn getTotalStakeShare(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getTotalStakeShareCall, N> {
            self.call_builder(
                &getTotalStakeShareCall {
                    epochIndex,
                },
            )
        }
        ///Creates a new call builder for the [`getUserAppchainStake`] function.
        pub fn getUserAppchainStake(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getUserAppchainStakeCall, N> {
            self.call_builder(
                &getUserAppchainStakeCall {
                    epochIndex,
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`getUserStake`] function.
        pub fn getUserStake(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getUserStakeCall, N> {
            self.call_builder(
                &getUserStakeCall {
                    epochIndex,
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`getUserStakeShare`] function.
        pub fn getUserStakeShare(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getUserStakeShareCall, N> {
            self.call_builder(
                &getUserStakeShareCall {
                    epochIndex,
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`getWithdrawalAmount`] function.
        pub fn getWithdrawalAmount(
            &self,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getWithdrawalAmountCall, N> {
            self.call_builder(
                &getWithdrawalAmountCall {
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`initializeWithdrawal_0`] function.
        pub fn initializeWithdrawal_0(
            &self,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, initializeWithdrawal_0Call, N> {
            self.call_builder(
                &initializeWithdrawal_0Call {
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`initializeWithdrawal_1`] function.
        pub fn initializeWithdrawal_1(
            &self,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, initializeWithdrawal_1Call, N> {
            self.call_builder(
                &initializeWithdrawal_1Call {
                    appchainId,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`stageStakeTransfer`] function.
        pub fn stageStakeTransfer(
            &self,
            fromAppchainId: alloy::sol_types::private::primitives::aliases::U256,
            toAppchainId: alloy::sol_types::private::primitives::aliases::U256,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, stageStakeTransferCall, N> {
            self.call_builder(
                &stageStakeTransferCall {
                    fromAppchainId,
                    toAppchainId,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`stakeSynd`] function.
        pub fn stakeSynd(
            &self,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, stakeSyndCall, N> {
            self.call_builder(&stakeSyndCall { appchainId })
        }
        ///Creates a new call builder for the [`startTimestamp`] function.
        pub fn startTimestamp(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, startTimestampCall, N> {
            self.call_builder(&startTimestampCall)
        }
        ///Creates a new call builder for the [`totalStake`] function.
        pub fn totalStake(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, totalStakeCall, N> {
            self.call_builder(&totalStakeCall)
        }
        ///Creates a new call builder for the [`userAppchainFinalizedEpochCount`] function.
        pub fn userAppchainFinalizedEpochCount(
            &self,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, userAppchainFinalizedEpochCountCall, N> {
            self.call_builder(
                &userAppchainFinalizedEpochCountCall {
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`userAppchainTotal`] function.
        pub fn userAppchainTotal(
            &self,
            user: alloy::sol_types::private::Address,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, userAppchainTotalCall, N> {
            self.call_builder(
                &userAppchainTotalCall {
                    user,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`userFinalizedEpochCount`] function.
        pub fn userFinalizedEpochCount(
            &self,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, userFinalizedEpochCountCall, N> {
            self.call_builder(
                &userFinalizedEpochCountCall {
                    user,
                },
            )
        }
        ///Creates a new call builder for the [`userTotal`] function.
        pub fn userTotal(
            &self,
            user: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, userTotalCall, N> {
            self.call_builder(&userTotalCall { user })
        }
        ///Creates a new call builder for the [`withdraw`] function.
        pub fn withdraw(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            destination: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, withdrawCall, N> {
            self.call_builder(
                &withdrawCall {
                    epochIndex,
                    destination,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SyndStakingInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Stake`] event.
        pub fn Stake_filter(&self) -> alloy_contract::Event<&P, Stake, N> {
            self.event_filter::<Stake>()
        }
        ///Creates a new event filter for the [`StakeTransfer`] event.
        pub fn StakeTransfer_filter(
            &self,
        ) -> alloy_contract::Event<&P, StakeTransfer, N> {
            self.event_filter::<StakeTransfer>()
        }
        ///Creates a new event filter for the [`WithdrawalCompleted`] event.
        pub fn WithdrawalCompleted_filter(
            &self,
        ) -> alloy_contract::Event<&P, WithdrawalCompleted, N> {
            self.event_filter::<WithdrawalCompleted>()
        }
        ///Creates a new event filter for the [`WithdrawalInitialized`] event.
        pub fn WithdrawalInitialized_filter(
            &self,
        ) -> alloy_contract::Event<&P, WithdrawalInitialized, N> {
            self.event_filter::<WithdrawalInitialized>()
        }
    }
}
