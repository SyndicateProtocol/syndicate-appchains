/**

Generated by the following Solidity interface...
```solidity
interface MockRollup {
    type MachineStatus is uint8;
    struct Assertion {
        ExecutionState beforeState;
        ExecutionState afterState;
        uint64 numBlocks;
    }
    struct AssertionInputs {
        BeforeStateData beforeStateData;
        AssertionState beforeState;
        AssertionState afterState;
    }
    struct AssertionState {
        GlobalState globalState;
        MachineStatus machineStatus;
        bytes32 endHistoryRoot;
    }
    struct BeforeStateData {
        bytes32 prevPrevAssertionHash;
        bytes32 sequencerBatchAcc;
        ConfigData configData;
    }
    struct ConfigData {
        bytes32 wasmModuleRoot;
        uint256 requiredStake;
        address challengeManager;
        uint64 confirmPeriodBlocks;
        uint64 nextInboxPosition;
    }
    struct ExecutionState {
        GlobalState globalState;
        MachineStatus machineStatus;
    }
    struct GlobalState {
        bytes32[2] bytes32Vals;
        uint64[2] u64Vals;
    }

    event AnyTrustFastConfirmerSet(address confimer);
    event FastConfirmNewAssertionCalled(bytes32 expectedAssertionHash);
    event ForceConfirmNodeCalled(uint64 nodeNum, bytes32 blockHash, bytes32 sendRoot);
    event ForceCreateNodeCalled(uint64 prevNode, uint256 prevNodeInboxMaxCount, bytes32 expectedNodeHash);
    event RolePaused();
    event ValidatorAfkBlocksSet(uint64 blocks);
    event ValidatorsSet(address[] validators, bool[] values);

    constructor();

    function baseStake() external view returns (uint256);
    function bridge() external view returns (address);
    function challengeManager() external view returns (address);
    function computeAssertionHash(bytes32, AssertionState memory, bytes32) external view returns (bytes32);
    function confirmPeriodBlocks() external view returns (uint64);
    function fastConfirmNewAssertion(AssertionInputs memory, bytes32 expectedAssertionHash) external;
    function forceConfirmNode(uint64 nodeNum, bytes32 blockHash, bytes32 sendRoot) external;
    function forceCreateNode(uint64 prevNode, uint256 prevNodeInboxMaxCount, Assertion memory, bytes32 expectedNodeHash) external;
    function genesisAssertionHash() external view returns (bytes32);
    function getValidators() external view returns (address[] memory);
    function owner() external view returns (address);
    function pause() external;
    function paused() external pure returns (bool);
    function sequencerInbox() external view returns (address);
    function setAnyTrustFastConfirmer(address confimer) external;
    function setBaseStake(uint256 stake) external;
    function setComputedAssertionHash(bytes32 hash) external;
    function setConfirmPeriodBlocks(uint64 blocks) external;
    function setGenesisAssertionHash(bytes32 hash) external;
    function setLegacyMode(bool mode) external;
    function setOwner(address newOwner) external;
    function setSequencerInboxAcc(uint256 index, bytes32 acc) external;
    function setSequencerMessageCount(uint256 count) external;
    function setValidator(address[] memory validators, bool[] memory values) external;
    function setValidatorAfkBlocks(uint64 blocks) external;
    function setValidators(address[] memory validators) external;
    function setWasmModuleRoot(bytes32 root) external;
    function wasmModuleRoot() external view returns (bytes32);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "baseStake",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridge",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract MockBridge"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "challengeManager",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "computeAssertionHash",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct AssertionState",
        "components": [
          {
            "name": "globalState",
            "type": "tuple",
            "internalType": "struct GlobalState",
            "components": [
              {
                "name": "bytes32Vals",
                "type": "bytes32[2]",
                "internalType": "bytes32[2]"
              },
              {
                "name": "u64Vals",
                "type": "uint64[2]",
                "internalType": "uint64[2]"
              }
            ]
          },
          {
            "name": "machineStatus",
            "type": "uint8",
            "internalType": "enum MachineStatus"
          },
          {
            "name": "endHistoryRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      },
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "confirmPeriodBlocks",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "fastConfirmNewAssertion",
    "inputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct AssertionInputs",
        "components": [
          {
            "name": "beforeStateData",
            "type": "tuple",
            "internalType": "struct BeforeStateData",
            "components": [
              {
                "name": "prevPrevAssertionHash",
                "type": "bytes32",
                "internalType": "bytes32"
              },
              {
                "name": "sequencerBatchAcc",
                "type": "bytes32",
                "internalType": "bytes32"
              },
              {
                "name": "configData",
                "type": "tuple",
                "internalType": "struct ConfigData",
                "components": [
                  {
                    "name": "wasmModuleRoot",
                    "type": "bytes32",
                    "internalType": "bytes32"
                  },
                  {
                    "name": "requiredStake",
                    "type": "uint256",
                    "internalType": "uint256"
                  },
                  {
                    "name": "challengeManager",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "confirmPeriodBlocks",
                    "type": "uint64",
                    "internalType": "uint64"
                  },
                  {
                    "name": "nextInboxPosition",
                    "type": "uint64",
                    "internalType": "uint64"
                  }
                ]
              }
            ]
          },
          {
            "name": "beforeState",
            "type": "tuple",
            "internalType": "struct AssertionState",
            "components": [
              {
                "name": "globalState",
                "type": "tuple",
                "internalType": "struct GlobalState",
                "components": [
                  {
                    "name": "bytes32Vals",
                    "type": "bytes32[2]",
                    "internalType": "bytes32[2]"
                  },
                  {
                    "name": "u64Vals",
                    "type": "uint64[2]",
                    "internalType": "uint64[2]"
                  }
                ]
              },
              {
                "name": "machineStatus",
                "type": "uint8",
                "internalType": "enum MachineStatus"
              },
              {
                "name": "endHistoryRoot",
                "type": "bytes32",
                "internalType": "bytes32"
              }
            ]
          },
          {
            "name": "afterState",
            "type": "tuple",
            "internalType": "struct AssertionState",
            "components": [
              {
                "name": "globalState",
                "type": "tuple",
                "internalType": "struct GlobalState",
                "components": [
                  {
                    "name": "bytes32Vals",
                    "type": "bytes32[2]",
                    "internalType": "bytes32[2]"
                  },
                  {
                    "name": "u64Vals",
                    "type": "uint64[2]",
                    "internalType": "uint64[2]"
                  }
                ]
              },
              {
                "name": "machineStatus",
                "type": "uint8",
                "internalType": "enum MachineStatus"
              },
              {
                "name": "endHistoryRoot",
                "type": "bytes32",
                "internalType": "bytes32"
              }
            ]
          }
        ]
      },
      {
        "name": "expectedAssertionHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "forceConfirmNode",
    "inputs": [
      {
        "name": "nodeNum",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "blockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "sendRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "forceCreateNode",
    "inputs": [
      {
        "name": "prevNode",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "prevNodeInboxMaxCount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Assertion",
        "components": [
          {
            "name": "beforeState",
            "type": "tuple",
            "internalType": "struct ExecutionState",
            "components": [
              {
                "name": "globalState",
                "type": "tuple",
                "internalType": "struct GlobalState",
                "components": [
                  {
                    "name": "bytes32Vals",
                    "type": "bytes32[2]",
                    "internalType": "bytes32[2]"
                  },
                  {
                    "name": "u64Vals",
                    "type": "uint64[2]",
                    "internalType": "uint64[2]"
                  }
                ]
              },
              {
                "name": "machineStatus",
                "type": "uint8",
                "internalType": "enum MachineStatus"
              }
            ]
          },
          {
            "name": "afterState",
            "type": "tuple",
            "internalType": "struct ExecutionState",
            "components": [
              {
                "name": "globalState",
                "type": "tuple",
                "internalType": "struct GlobalState",
                "components": [
                  {
                    "name": "bytes32Vals",
                    "type": "bytes32[2]",
                    "internalType": "bytes32[2]"
                  },
                  {
                    "name": "u64Vals",
                    "type": "uint64[2]",
                    "internalType": "uint64[2]"
                  }
                ]
              },
              {
                "name": "machineStatus",
                "type": "uint8",
                "internalType": "enum MachineStatus"
              }
            ]
          },
          {
            "name": "numBlocks",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      },
      {
        "name": "expectedNodeHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "genesisAssertionHash",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getValidators",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "paused",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "sequencerInbox",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract MockSequencerInbox"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setAnyTrustFastConfirmer",
    "inputs": [
      {
        "name": "confimer",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBaseStake",
    "inputs": [
      {
        "name": "stake",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setComputedAssertionHash",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setConfirmPeriodBlocks",
    "inputs": [
      {
        "name": "blocks",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setGenesisAssertionHash",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setLegacyMode",
    "inputs": [
      {
        "name": "mode",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setOwner",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setSequencerInboxAcc",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "acc",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setSequencerMessageCount",
    "inputs": [
      {
        "name": "count",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setValidator",
    "inputs": [
      {
        "name": "validators",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "values",
        "type": "bool[]",
        "internalType": "bool[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setValidatorAfkBlocks",
    "inputs": [
      {
        "name": "blocks",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setValidators",
    "inputs": [
      {
        "name": "validators",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setWasmModuleRoot",
    "inputs": [
      {
        "name": "root",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "wasmModuleRoot",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "AnyTrustFastConfirmerSet",
    "inputs": [
      {
        "name": "confimer",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FastConfirmNewAssertionCalled",
    "inputs": [
      {
        "name": "expectedAssertionHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ForceConfirmNodeCalled",
    "inputs": [
      {
        "name": "nodeNum",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      },
      {
        "name": "blockHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "sendRoot",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ForceCreateNodeCalled",
    "inputs": [
      {
        "name": "prevNode",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      },
      {
        "name": "prevNodeInboxMaxCount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "expectedNodeHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RolePaused",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ValidatorAfkBlocksSet",
    "inputs": [
      {
        "name": "blocks",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ValidatorsSet",
    "inputs": [
      {
        "name": "validators",
        "type": "address[]",
        "indexed": false,
        "internalType": "address[]"
      },
      {
        "name": "values",
        "type": "bool[]",
        "indexed": false,
        "internalType": "bool[]"
      }
    ],
    "anonymous": false
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod MockRollup {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x608060405234610027576100116102cb565b61001961002c565b611c996103b98239611c9990f35b610032565b60405190565b5f80fd5b5f1b90565b9061004760ff91610036565b9181191691161790565b151590565b61005f90610051565b90565b90565b9061007a61007561008192610056565b610062565b825461003b565b9055565b90565b60018060a01b031690565b90565b6100aa6100a56100af92610085565b610093565b610088565b90565b6100bb90610096565b90565b906100cf60018060a01b0391610036565b9181191691161790565b6100ed6100e86100f292610088565b610093565b610088565b90565b6100fe906100d9565b90565b61010a906100f5565b90565b90565b9061012561012061012c92610101565b61010d565b82546100be565b9055565b90565b61014761014261014c92610130565b610093565b610088565b90565b61015890610133565b90565b60a01b90565b90610176600160a01b600160e01b039161015b565b9181191691161790565b90565b60018060401b031690565b6101a261019d6101a792610180565b610093565b610183565b90565b90565b906101c26101bd6101c99261018e565b6101aa565b8254610161565b9055565b634e487b7160e01b5f52604160045260245ffd5b5f0190565b6101ee61002c565b3d5f823e3d90fd5b6101ff906100d9565b90565b61020b906101f6565b90565b90565b9061022661022161022d92610202565b61020e565b82546100be565b9055565b5f1c90565b60018060a01b031690565b61024d61025291610231565b610236565b90565b61025f9054610241565b90565b61026b906100f5565b90565b61027790610262565b9052565b919061028e905f6020850194019061026e565b565b610299906100d9565b90565b6102a590610290565b90565b90565b906102c06102bb6102c79261029c565b6102a8565b82546100be565b9055565b6102d55f5f610065565b6102ea6102e36109996100b2565b6007610110565b6102ff6102f861099861014f565b6008610110565b61030c61271060086101ad565b61031461002c565b6103b4810181811060018060401b038211176103b35761033c82916103b461205284396101e1565b03905ff080156103ae57610351906009610211565b61035b6009610255565b61036361002c565b906107e6820182811060018060401b038211176103a957829161038d916107e6612406853961027b565b03905ff080156103a4576103a290600a6102ab565b565b6101e6565b6101cd565b6101e6565b6101cd56fe60806040526004361015610013575b611071565b61001d5f356101dc565b8063023a96fe146101d757806306ae5851146101d25780630d561b37146101cd57806313af4035146101c85780631d39e389146101c35780632c24eccd146101be5780632e7acfa6146101b95780632f7968e8146101b457806333635fc2146101af578063353325e0146101aa578063468eff50146101a5578063470dce4e146101a05780635c975abb1461019b5780636420fb9f1461019657806376e7e23b146101915780638456cb591461018c57806389384960146101875780638da5cb5b146101825780638ee1a1261461017d5780639300c92614610178578063a3ffb77214610173578063b7ab4db51461016e578063ce66d05c14610169578063d202deaa14610164578063e78cea921461015f578063ee35f3271461015a578063f112cea3146101555763f3ef4b360361000e5761103e565b61100b565b610fd6565b610f73565b610ee7565b610eb4565b610e61565b610d8e565b610c67565b610b66565b610b31565b610afe565b610acb565b610a96565b610a40565b6109c8565b61096f565b610685565b610623565b6105ed565b610545565b6104b3565b610451565b6103da565b610361565b61032e565b6102ba565b610238565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f9103126101fa57565b6101ec565b60018060a01b031690565b610213906101ff565b90565b61021f9061020a565b9052565b9190610236905f60208501940190610216565b565b34610268576102483660046101f0565b6102646102536110aa565b61025b6101e2565b91829182610223565b0390f35b6101e8565b5f80fd5b90565b61027d81610271565b0361028457565b5f80fd5b9050359061029582610274565b565b906020828203126102b0576102ad915f01610288565b90565b6101ec565b5f0190565b346102e8576102d26102cd366004610297565b61111a565b6102da6101e2565b806102e4816102b5565b0390f35b6101e8565b6102f68161020a565b036102fd57565b5f80fd5b9050359061030e826102ed565b565b9060208282031261032957610326915f01610301565b90565b6101ec565b3461035c57610346610341366004610310565b611127565b61034e6101e2565b80610358816102b5565b0390f35b6101e8565b3461038f57610379610374366004610310565b6111ac565b6103816101e2565b8061038b816102b5565b0390f35b6101e8565b151590565b6103a281610394565b036103a957565b5f80fd5b905035906103ba82610399565b565b906020828203126103d5576103d2915f016103ad565b90565b6101ec565b34610408576103f26103ed3660046103bc565b6111fe565b6103fa6101e2565b80610404816102b5565b0390f35b6101e8565b90565b6104198161040d565b0361042057565b5f80fd5b9050359061043182610410565b565b9060208282031261044c57610449915f01610424565b90565b6101ec565b3461047f57610469610464366004610433565b611242565b6104716101e2565b8061047b816102b5565b0390f35b6101e8565b67ffffffffffffffff1690565b61049a90610484565b9052565b91906104b1905f60208501940190610491565b565b346104e3576104c33660046101f0565b6104df6104ce611281565b6104d66101e2565b9182918261049e565b0390f35b6101e8565b6104f181610484565b036104f857565b5f80fd5b90503590610509826104e8565b565b90916060828403126105405761053d610526845f85016104fc565b936105348160208601610424565b93604001610424565b90565b6101ec565b346105745761055e61055836600461050b565b916112c9565b6105666101e2565b80610570816102b5565b0390f35b6101e8565b5f80fd5b908160c091031261058b5790565b610579565b9091610100828403126105c6576105c36105ac845f8501610424565b936105ba816020860161057d565b9360e001610424565b90565b6101ec565b6105d49061040d565b9052565b91906105eb905f602085019401906105cb565b565b3461061e5761061a610609610603366004610590565b9161132c565b6106116101e2565b918291826105d8565b0390f35b6101e8565b34610653576106333660046101f0565b61064f61063e61141d565b6106466101e2565b918291826105d8565b0390f35b6101e8565b9190604083820312610680578061067461067d925f8601610288565b93602001610424565b90565b6101ec565b346106b45761069e610698366004610658565b906114c5565b6106a66101e2565b806106b0816102b5565b0390f35b6101e8565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906106e5906106bd565b810190811067ffffffffffffffff8211176106ff57604052565b6106c7565b906107176107106101e2565b92836106db565b565b5f80fd5b67ffffffffffffffff81116107325760200290565b6106c7565b5f80fd5b9092919261075061074b8261071d565b610704565b93602085920283019281841161078857915b83831061076f5750505050565b6020809161077d8486610424565b815201920191610762565b610737565b9080601f830112156107a8576107a59160029061073b565b90565b610719565b67ffffffffffffffff81116107c25760200290565b6106c7565b909291926107dc6107d7826107ad565b610704565b93602085920283019281841161081457915b8383106107fb5750505050565b6020809161080984866104fc565b8152019201916107ee565b610737565b9080601f8301121561083457610831916002906107c7565b90565b610719565b91906080838203126108735761086c906108536040610704565b93610860825f830161078d565b5f860152604001610819565b6020830152565b6106b9565b6004111561088257565b5f80fd5b9050359061089382610878565b565b919060a0838203126108cf576108c8906108af6040610704565b936108bc825f8301610839565b5f860152608001610886565b6020830152565b6106b9565b9190610160838203126109225761091b906108ef6060610704565b936108fc825f8301610895565b5f86015261090d8260a08301610895565b6020860152610140016104fc565b6040830152565b6106b9565b6101c08183031261096a5761093e825f83016104fc565b9261096761094f8460208501610288565b9361095d81604086016108d4565b936101a001610424565b90565b6101ec565b346109a15761098b610982366004610927565b92919091611589565b6109936101e2565b8061099d816102b5565b0390f35b6101e8565b6109af90610394565b9052565b91906109c6905f602085019401906109a6565b565b346109f8576109d83660046101f0565b6109f46109e36115cf565b6109eb6101e2565b918291826109b3565b0390f35b6101e8565b9081610260910312610a0c5790565b610579565b919061028083820312610a3b5780610a2e610a38925f86016109fd565b9361026001610424565b90565b6101ec565b34610a6f57610a59610a53366004610a11565b906115dc565b610a616101e2565b80610a6b816102b5565b0390f35b6101e8565b610a7d90610271565b9052565b9190610a94905f60208501940190610a74565b565b34610ac657610aa63660046101f0565b610ac2610ab1611640565b610ab96101e2565b91829182610a81565b0390f35b6101e8565b34610af957610adb3660046101f0565b610ae3611656565b610aeb6101e2565b80610af5816102b5565b0390f35b6101e8565b34610b2c57610b16610b11366004610433565b61168e565b610b1e6101e2565b80610b28816102b5565b0390f35b6101e8565b34610b6157610b413660046101f0565b610b5d610b4c61169b565b610b546101e2565b91829182610223565b0390f35b6101e8565b34610b9657610b763660046101f0565b610b92610b816116b1565b610b896101e2565b918291826105d8565b0390f35b6101e8565b67ffffffffffffffff8111610bb35760208091020190565b6106c7565b90929192610bcd610bc882610b9b565b610704565b9381855260208086019202830192818411610c0a57915b838310610bf15750505050565b60208091610bff8486610301565b815201920191610be4565b610737565b9080601f83011215610c2d57816020610c2a93359101610bb8565b90565b610719565b90602082820312610c62575f82013567ffffffffffffffff8111610c5d57610c5a9201610c0f565b90565b61026d565b6101ec565b34610c9557610c7f610c7a366004610c32565b61194a565b610c876101e2565b80610c91816102b5565b0390f35b6101e8565b67ffffffffffffffff8111610cb25760208091020190565b6106c7565b90929192610ccc610cc782610c9a565b610704565b9381855260208086019202830192818411610d0957915b838310610cf05750505050565b60208091610cfe84866103ad565b815201920191610ce3565b610737565b9080601f83011215610d2c57816020610d2993359101610cb7565b90565b610719565b919091604081840312610d89575f81013567ffffffffffffffff8111610d845783610d5d918301610c0f565b92602082013567ffffffffffffffff8111610d7f57610d7c9201610d0e565b90565b61026d565b61026d565b6101ec565b34610dbd57610da7610da1366004610d31565b906119a1565b610daf6101e2565b80610db9816102b5565b0390f35b6101e8565b5190565b60209181520190565b60200190565b610dde9061020a565b9052565b90610def81602093610dd5565b0190565b60200190565b90610e16610e10610e0984610dc2565b8093610dc6565b92610dcf565b905f5b818110610e265750505090565b909192610e3f610e396001928651610de2565b94610df3565b9101919091610e19565b610e5e9160208201915f818403910152610df9565b90565b34610e9157610e713660046101f0565b610e8d610e7c611a90565b610e846101e2565b91829182610e49565b0390f35b6101e8565b90602082820312610eaf57610eac915f016104fc565b90565b6101ec565b34610ee257610ecc610ec7366004610e96565b611b02565b610ed46101e2565b80610ede816102b5565b0390f35b6101e8565b34610f1557610eff610efa366004610297565b611b0f565b610f076101e2565b80610f11816102b5565b0390f35b6101e8565b90565b610f31610f2c610f36926101ff565b610f1a565b6101ff565b90565b610f4290610f1d565b90565b610f4e90610f39565b90565b610f5a90610f45565b9052565b9190610f71905f60208501940190610f51565b565b34610fa357610f833660046101f0565b610f9f610f8e611ba4565b610f966101e2565b91829182610f5e565b0390f35b6101e8565b610fb190610f39565b90565b610fbd90610fa8565b9052565b9190610fd4905f60208501940190610fb4565b565b3461100657610fe63660046101f0565b611002610ff1611bea565b610ff96101e2565b91829182610fc1565b0390f35b6101e8565b346110395761102361101e366004610e96565b611c46565b61102b6101e2565b80611035816102b5565b0390f35b6101e8565b3461106c57611056611051366004610433565b611c8c565b61105e6101e2565b80611068816102b5565b0390f35b6101e8565b5f80fd5b5f90565b5f1c90565b60018060a01b031690565b61109561109a91611079565b61107e565b90565b6110a79054611089565b90565b6110b2611075565b506110bd600861109d565b90565b5f1b90565b906110d15f19916110c0565b9181191691161790565b6110ef6110ea6110f492610271565b610f1a565b610271565b90565b90565b9061110f61110a611116926110db565b6110f7565b82546110c5565b9055565b6111259060036110fa565b565b61115d7fd3ab4cbe1b6f519eb43f09ded17a12e81b811e297063ada2d65dddef5b612c7c916111546101e2565b91829182610223565b0390a1565b9061117360018060a01b03916110c0565b9181191691161790565b61118690610f39565b90565b90565b906111a161119c6111a89261117d565b611189565b8254611162565b9055565b6111b790600761118c565b565b906111c560ff916110c0565b9181191691161790565b6111d890610394565b90565b90565b906111f36111ee6111fa926111cf565b6111db565b82546111b9565b9055565b611208905f6111de565b565b6112139061040d565b90565b61121f90611079565b90565b9061123761123261123e9261120a565b611216565b82546110c5565b9055565b61124d906005611222565b565b5f90565b67ffffffffffffffff1690565b61126c61127191611079565b611253565b90565b61127e9054611260565b90565b61128961124f565b506112946004611274565b90565b6040906112c06112c794969593966112b660608401985f850190610491565b60208301906105cb565b01906105cb565b565b6112ff7f8c8b7859bbc969bec99ac564f37f8128e2de9f85d340086139ad98a88598951b936112f66101e2565b93849384611297565b0390a1565b5f90565b90565b61131761131c91611079565b611308565b90565b611329905461130b565b90565b505050611337611304565b50611342600561131f565b90565b60ff1690565b61135761135c91611079565b611345565b90565b611369905461134b565b90565b60209181520190565b60207f6e20686173680000000000000000000000000000000000000000000000000000917f4c6567616379206d6f64653a206e6f2067656e6573697320617373657274696f5f8201520152565b6113cf602660409261136c565b6113d881611375565b0190565b6113f19060208101905f8183039101526113c2565b90565b156113fb57565b6114036101e2565b62461bcd60e51b815280611419600482016113dc565b0390fd5b611425611304565b5061144061143b6114355f61135f565b15610394565b6113f4565b61144a600161131f565b90565b60018060a01b031690565b61146461146991611079565b61144d565b90565b6114769054611458565b90565b5f80fd5b60e01b90565b5f91031261148d57565b6101ec565b9160206114b39294936114ac60408201965f830190610a74565b01906105cb565b565b6114bd6101e2565b3d5f823e3d90fd5b6114d76114d2600961146c565b610f45565b9163468eff50919092803b15611552576115045f809461150f6114f86101e2565b9788968795869461147d565b845260048401611492565b03925af1801561154d57611521575b50565b611540905f3d8111611546575b61153881836106db565b810190611483565b5f61151e565b503d61152e565b6114b5565b611479565b604090611580611587949695939661157660608401985f850190610491565b6020830190610a74565b01906105cb565b565b909291509190916115c67f486a73d38b9adfb3ec83a2013b18f5771a948f666b038e1b5b03f8588a62cdd7936115bd6101e2565b93849384611557565b0390a1565b5f90565b6115d76115cb565b505f90565b506116137f36d6096d658662ba82ae29e76de7daab22d6c3b2361a8294460766a28cf505d59161160a6101e2565b918291826105d8565b0390a1565b5f90565b90565b61162b61163091611079565b61161c565b90565b61163d905461161f565b90565b611648611618565b506116536003611633565b90565b7fa69b977e9474b454c0be019138b26cd46d25e4e2fbccf823202a0b6d7bbd3a2461167f6101e2565b80611689816102b5565b0390a1565b611699906002611222565b565b6116a3611075565b506116ae600761109d565b90565b6116b9611304565b506116c4600261131f565b90565b5490565b600190818003010490565b5f5260205f2090565b1b90565b919060086116fe9102916116f85f19846116df565b926116df565b9181191691161790565b919061171e611719611726936110db565b6110f7565b9083546116e3565b9055565b61173c91611736611618565b91611708565b565b5b81811061174a575050565b806117575f60019361172a565b0161173f565b909182811061176c575b505050565b61178a61178461177e611795956116cb565b926116cb565b926116d6565b91820191019061173e565b5f8080611767565b906801000000000000000081116117c657816117bb6117c4936116c7565b9082815561175d565b565b6106c7565b6117d5905161020a565b90565b6117e182610dc2565b9167ffffffffffffffff83116118445761180f611809600192611804868661179d565b610dcf565b926116d6565b9204915f5b8381106118215750505050565b6001906020611837611832866117cb565b611189565b9401938184015501611814565b6106c7565b90611853916117d8565b565b9061186761186283610c9a565b610704565b918252565b369037565b9061189661187e83611855565b9260208061188c8693610c9a565b920191039061186c565b565b5190565b60209181520190565b60200190565b6118b490610394565b9052565b906118c5816020936118ab565b0190565b60200190565b906118ec6118e66118df84611898565b809361189c565b926118a5565b905f5b8181106118fc5750505090565b90919261191561190f60019286516118b8565b946118c9565b91019190916118ef565b90916119396119479360408401908482035f860152610df9565b9160208184039101526118cf565b90565b611955816006611849565b61196661196182610dc2565b611871565b7f0d9690f97165f35991ae60d2a97e04aff472c08729722a9236ff1bc8b9ba90c09161199c6119936101e2565b9283928361191f565b0390a1565b907f0d9690f97165f35991ae60d2a97e04aff472c08729722a9236ff1bc8b9ba90c0916119d86119cf6101e2565b9283928361191f565b0390a1565b606090565b60209181520190565b6119f59054611089565b90565b60010190565b90611a1b611a15611a0e846116c7565b80936119e2565b926116d6565b905f5b818110611a2b5750505090565b909192611a4b611a45600192611a40876119eb565b610de2565b946119f8565b9101919091611a1e565b90611a5f916119fe565b90565b90611a82611a7b92611a726101e2565b93848092611a55565b03836106db565b565b611a8d90611a62565b90565b611a986119dd565b50611aa36006611a84565b90565b90611ab967ffffffffffffffff916110c0565b9181191691161790565b611ad7611ad2611adc92610484565b610f1a565b610484565b90565b90565b90611af7611af2611afe92611ac3565b611adf565b8254611aa6565b9055565b611b0d906004611ae2565b565b611b21611b1c600961146c565b610f45565b9063d202deaa90823b15611b9b57611b5892611b4d5f8094611b416101e2565b9687958694859361147d565b835260048301610a81565b03925af18015611b9657611b6a575b50565b611b89905f3d8111611b8f575b611b8181836106db565b810190611483565b5f611b67565b503d611b77565b6114b5565b611479565b5f90565b611bac611ba0565b50611bb7600961146c565b90565b5f90565b60018060a01b031690565b611bd5611bda91611079565b611bbe565b90565b611be79054611bc9565b90565b611bf2611bba565b50611bfd600a611bdd565b90565b60a01b90565b90611c1c67ffffffffffffffff60a01b91611c00565b9181191691161790565b90611c3b611c36611c4292611ac3565b611adf565b8254611c06565b9055565b611c51816008611c26565b611c877f77bb7cc2722114e0171bcbd5e787510981490d0764c5fc10b97c49b0b82f24d691611c7e6101e2565b9182918261049e565b0390a1565b611c97906001611222565b56608060405234601c57600e6020565b61038961002b823961038990f35b6026565b60405190565b5f80fdfe60806040526004361015610013575b61022f565b61001d5f3561005b565b806284120c1461005657806316bf557914610051578063468eff501461004c5763d202deaa0361000e576101fc565b6101c8565b61013e565b6100a3565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f91031261007957565b61006b565b90565b61008a9061007e565b9052565b91906100a1905f60208501940190610081565b565b346100d3576100b336600461006f565b6100cf6100be610260565b6100c6610061565b9182918261008e565b0390f35b610067565b6100e18161007e565b036100e857565b5f80fd5b905035906100f9826100d8565b565b9060208282031261011457610111915f016100ec565b90565b61006b565b90565b61012590610119565b9052565b919061013c905f6020850194019061011c565b565b3461016e5761016a6101596101543660046100fb565b6102d2565b610161610061565b91829182610129565b0390f35b610067565b61017c81610119565b0361018357565b5f80fd5b9050359061019482610173565b565b91906040838203126101be57806101b26101bb925f86016100ec565b93602001610187565b90565b61006b565b5f0190565b346101f7576101e16101db366004610196565b90610344565b6101e9610061565b806101f3816101c3565b0390f35b610067565b3461022a5761021461020f3660046100fb565b61037d565b61021c610061565b80610226816101c3565b0390f35b610067565b5f80fd5b5f90565b5f1c90565b90565b61024b61025091610237565b61023c565b90565b61025d905461023f565b90565b610268610233565b506102725f610253565b90565b5f90565b90565b61029061028b6102959261007e565b610279565b61007e565b90565b906102a29061027c565b5f5260205260405f2090565b90565b6102bd6102c291610237565b6102ae565b90565b6102cf90546102b1565b90565b6102e96102ee916102e1610275565b506001610298565b6102c5565b90565b5f1b90565b906103025f19916102f1565b9181191691161790565b61031590610119565b90565b61032190610237565b90565b906103396103346103409261030c565b610318565b82546102f6565b9055565b61035361035892916001610298565b610324565b565b90565b9061037261036d6103799261027c565b61035a565b82546102f6565b9055565b610387905f61035d565b5660806040523461002f57610019610014610100565b61019b565b610021610034565b61063d6101a9823961063d90f35b61003a565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906100669061003e565b810190811060018060401b0382111761007e57604052565b610048565b9061009661008f610034565b928361005c565b565b5f80fd5b60018060a01b031690565b6100b09061009c565b90565b6100bc906100a7565b90565b6100c8816100b3565b036100cf57565b5f80fd5b905051906100e0826100bf565b565b906020828203126100fb576100f8915f016100d3565b90565b610098565b61011e6107e68038038061011381610083565b9283398101906100e2565b90565b5f1b90565b9061013760018060a01b0391610121565b9181191691161790565b90565b61015861015361015d9261009c565b610141565b61009c565b90565b61016990610144565b90565b61017590610160565b90565b90565b9061019061018b6101979261016c565b610178565b8254610126565b9055565b6101a690600161017b565b56fe60806040526004361015610013575b6102f8565b61001d5f3561004c565b80636e7df3e71461004757806371c3e6fe146100425763e0bc97290361000e576102be565b61016c565b6100f8565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b60018060a01b031690565b61007890610064565b90565b6100848161006f565b0361008b57565b5f80fd5b9050359061009c8261007b565b565b151590565b6100ac8161009e565b036100b357565b5f80fd5b905035906100c4826100a3565b565b91906040838203126100ee57806100e26100eb925f860161008f565b936020016100b7565b90565b61005c565b5f0190565b346101275761011161010b3660046100c6565b906103c3565b610119610052565b80610123816100f3565b0390f35b610058565b9060208282031261014557610142915f0161008f565b90565b61005c565b6101539061009e565b9052565b919061016a905f6020850194019061014a565b565b3461019c5761019861018761018236600461012c565b610443565b61018f610052565b91829182610157565b0390f35b610058565b90565b6101ad816101a1565b036101b457565b5f80fd5b905035906101c5826101a4565b565b5f80fd5b5f80fd5b5f80fd5b909182601f8301121561020d5781359167ffffffffffffffff831161020857602001926001830284011161020357565b6101cf565b6101cb565b6101c7565b61021b9061006f565b90565b61022781610212565b0361022e57565b5f80fd5b9050359061023f8261021e565b565b9060c0828203126102b957610258815f84016101b8565b92602083013567ffffffffffffffff81116102b457826102799185016101d3565b92909361028982604083016101b8565b926102b161029a8460608501610232565b936102a881608086016101b8565b9360a0016101b8565b90565b610060565b61005c565b346102f3576102dd6102d1366004610241565b9594909493919361056c565b6102e5610052565b806102ef816100f3565b0390f35b610058565b5f80fd5b90565b61031361030e61031892610064565b6102fc565b610064565b90565b610324906102ff565b90565b6103309061031b565b90565b9061033d90610327565b5f5260205260405f2090565b5f1b90565b9061035a60ff91610349565b9181191691161790565b61036d9061009e565b90565b90565b9061038861038361038f92610364565b610370565b825461034e565b9055565b61039c9061006f565b9052565b9160206103c19294936103ba60408201965f830190610393565b019061014a565b565b6103d7826103d25f8490610333565b610373565b907f28bcc5626d357efe966b4b0876aa1ee8ab99e26da4f131f6a2623f1800701c219161040e610405610052565b928392836103a0565b0390a1565b5f90565b5f1c90565b60ff1690565b61042e61043391610417565b61041c565b90565b6104409054610422565b90565b61045961045e91610452610413565b505f610333565b610436565b90565b60018060a01b031690565b61047861047d91610417565b610461565b90565b61048a905461046c565b90565b6104969061031b565b90565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906104c59061049d565b810190811067ffffffffffffffff8211176104df57604052565b6104a7565b60e01b90565b5f9103126104f457565b61005c565b90565b61051061050b610515926104f9565b6102fc565b6101a1565b90565b610521906104fc565b9052565b9190610538905f60208501940190610518565b565b610542610052565b3d5f823e3d90fd5b610553906101a1565b9052565b919061056a905f6020850194019061054a565b565b955050505050506105856105806001610480565b61048d565b63d202deaa6002823b15610638576105bc926105b15f80946105a5610052565b968795869485936104e4565b835260048301610525565b03925af1801561063357610607575b506106027f1eb13a7f15212b56ad60574a2b0ad542f125db9cf126374b72e84c8b9d953ec3916105f9610052565b91829182610557565b0390a1565b610626905f3d811161062c575b61061e81836104bb565b8101906104ea565b5f6105cb565b503d610614565b61053a565b61049956
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4a\0'Wa\0\x11a\x02\xCBV[a\0\x19a\0,V[a\x1C\x99a\x03\xB9\x829a\x1C\x99\x90\xF3[a\x002V[`@Q\x90V[_\x80\xFD[_\x1B\x90V[\x90a\0G`\xFF\x91a\x006V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x15\x15\x90V[a\0_\x90a\0QV[\x90V[\x90V[\x90a\0za\0ua\0\x81\x92a\0VV[a\0bV[\x82Ta\0;V[\x90UV[\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[\x90V[a\0\xAAa\0\xA5a\0\xAF\x92a\0\x85V[a\0\x93V[a\0\x88V[\x90V[a\0\xBB\x90a\0\x96V[\x90V[\x90a\0\xCF`\x01\x80`\xA0\x1B\x03\x91a\x006V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\0\xEDa\0\xE8a\0\xF2\x92a\0\x88V[a\0\x93V[a\0\x88V[\x90V[a\0\xFE\x90a\0\xD9V[\x90V[a\x01\n\x90a\0\xF5V[\x90V[\x90V[\x90a\x01%a\x01 a\x01,\x92a\x01\x01V[a\x01\rV[\x82Ta\0\xBEV[\x90UV[\x90V[a\x01Ga\x01Ba\x01L\x92a\x010V[a\0\x93V[a\0\x88V[\x90V[a\x01X\x90a\x013V[\x90V[`\xA0\x1B\x90V[\x90a\x01v`\x01`\xA0\x1B`\x01`\xE0\x1B\x03\x91a\x01[V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[`\x01\x80`@\x1B\x03\x16\x90V[a\x01\xA2a\x01\x9Da\x01\xA7\x92a\x01\x80V[a\0\x93V[a\x01\x83V[\x90V[\x90V[\x90a\x01\xC2a\x01\xBDa\x01\xC9\x92a\x01\x8EV[a\x01\xAAV[\x82Ta\x01aV[\x90UV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_\x01\x90V[a\x01\xEEa\0,V[=_\x82>=\x90\xFD[a\x01\xFF\x90a\0\xD9V[\x90V[a\x02\x0B\x90a\x01\xF6V[\x90V[\x90V[\x90a\x02&a\x02!a\x02-\x92a\x02\x02V[a\x02\x0EV[\x82Ta\0\xBEV[\x90UV[_\x1C\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x02Ma\x02R\x91a\x021V[a\x026V[\x90V[a\x02_\x90Ta\x02AV[\x90V[a\x02k\x90a\0\xF5V[\x90V[a\x02w\x90a\x02bV[\x90RV[\x91\x90a\x02\x8E\x90_` \x85\x01\x94\x01\x90a\x02nV[V[a\x02\x99\x90a\0\xD9V[\x90V[a\x02\xA5\x90a\x02\x90V[\x90V[\x90V[\x90a\x02\xC0a\x02\xBBa\x02\xC7\x92a\x02\x9CV[a\x02\xA8V[\x82Ta\0\xBEV[\x90UV[a\x02\xD5__a\0eV[a\x02\xEAa\x02\xE3a\t\x99a\0\xB2V[`\x07a\x01\x10V[a\x02\xFFa\x02\xF8a\t\x98a\x01OV[`\x08a\x01\x10V[a\x03\x0Ca'\x10`\x08a\x01\xADV[a\x03\x14a\0,V[a\x03\xB4\x81\x01\x81\x81\x10`\x01\x80`@\x1B\x03\x82\x11\x17a\x03\xB3Wa\x03<\x82\x91a\x03\xB4a R\x849a\x01\xE1V[\x03\x90_\xF0\x80\x15a\x03\xAEWa\x03Q\x90`\ta\x02\x11V[a\x03[`\ta\x02UV[a\x03ca\0,V[\x90a\x07\xE6\x82\x01\x82\x81\x10`\x01\x80`@\x1B\x03\x82\x11\x17a\x03\xA9W\x82\x91a\x03\x8D\x91a\x07\xE6a$\x06\x859a\x02{V[\x03\x90_\xF0\x80\x15a\x03\xA4Wa\x03\xA2\x90`\na\x02\xABV[V[a\x01\xE6V[a\x01\xCDV[a\x01\xE6V[a\x01\xCDV\xFE`\x80`@R`\x046\x10\x15a\0\x13W[a\x10qV[a\0\x1D_5a\x01\xDCV[\x80c\x02:\x96\xFE\x14a\x01\xD7W\x80c\x06\xAEXQ\x14a\x01\xD2W\x80c\rV\x1B7\x14a\x01\xCDW\x80c\x13\xAF@5\x14a\x01\xC8W\x80c\x1D9\xE3\x89\x14a\x01\xC3W\x80c,$\xEC\xCD\x14a\x01\xBEW\x80c.z\xCF\xA6\x14a\x01\xB9W\x80c/yh\xE8\x14a\x01\xB4W\x80c3c_\xC2\x14a\x01\xAFW\x80c53%\xE0\x14a\x01\xAAW\x80cF\x8E\xFFP\x14a\x01\xA5W\x80cG\r\xCEN\x14a\x01\xA0W\x80c\\\x97Z\xBB\x14a\x01\x9BW\x80cd \xFB\x9F\x14a\x01\x96W\x80cv\xE7\xE2;\x14a\x01\x91W\x80c\x84V\xCBY\x14a\x01\x8CW\x80c\x898I`\x14a\x01\x87W\x80c\x8D\xA5\xCB[\x14a\x01\x82W\x80c\x8E\xE1\xA1&\x14a\x01}W\x80c\x93\0\xC9&\x14a\x01xW\x80c\xA3\xFF\xB7r\x14a\x01sW\x80c\xB7\xABM\xB5\x14a\x01nW\x80c\xCEf\xD0\\\x14a\x01iW\x80c\xD2\x02\xDE\xAA\x14a\x01dW\x80c\xE7\x8C\xEA\x92\x14a\x01_W\x80c\xEE5\xF3'\x14a\x01ZW\x80c\xF1\x12\xCE\xA3\x14a\x01UWc\xF3\xEFK6\x03a\0\x0EWa\x10>V[a\x10\x0BV[a\x0F\xD6V[a\x0FsV[a\x0E\xE7V[a\x0E\xB4V[a\x0EaV[a\r\x8EV[a\x0CgV[a\x0BfV[a\x0B1V[a\n\xFEV[a\n\xCBV[a\n\x96V[a\n@V[a\t\xC8V[a\toV[a\x06\x85V[a\x06#V[a\x05\xEDV[a\x05EV[a\x04\xB3V[a\x04QV[a\x03\xDAV[a\x03aV[a\x03.V[a\x02\xBAV[a\x028V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x91\x03\x12a\x01\xFAWV[a\x01\xECV[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x02\x13\x90a\x01\xFFV[\x90V[a\x02\x1F\x90a\x02\nV[\x90RV[\x91\x90a\x026\x90_` \x85\x01\x94\x01\x90a\x02\x16V[V[4a\x02hWa\x02H6`\x04a\x01\xF0V[a\x02da\x02Sa\x10\xAAV[a\x02[a\x01\xE2V[\x91\x82\x91\x82a\x02#V[\x03\x90\xF3[a\x01\xE8V[_\x80\xFD[\x90V[a\x02}\x81a\x02qV[\x03a\x02\x84WV[_\x80\xFD[\x90P5\x90a\x02\x95\x82a\x02tV[V[\x90` \x82\x82\x03\x12a\x02\xB0Wa\x02\xAD\x91_\x01a\x02\x88V[\x90V[a\x01\xECV[_\x01\x90V[4a\x02\xE8Wa\x02\xD2a\x02\xCD6`\x04a\x02\x97V[a\x11\x1AV[a\x02\xDAa\x01\xE2V[\x80a\x02\xE4\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[a\x02\xF6\x81a\x02\nV[\x03a\x02\xFDWV[_\x80\xFD[\x90P5\x90a\x03\x0E\x82a\x02\xEDV[V[\x90` \x82\x82\x03\x12a\x03)Wa\x03&\x91_\x01a\x03\x01V[\x90V[a\x01\xECV[4a\x03\\Wa\x03Fa\x03A6`\x04a\x03\x10V[a\x11'V[a\x03Na\x01\xE2V[\x80a\x03X\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[4a\x03\x8FWa\x03ya\x03t6`\x04a\x03\x10V[a\x11\xACV[a\x03\x81a\x01\xE2V[\x80a\x03\x8B\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[\x15\x15\x90V[a\x03\xA2\x81a\x03\x94V[\x03a\x03\xA9WV[_\x80\xFD[\x90P5\x90a\x03\xBA\x82a\x03\x99V[V[\x90` \x82\x82\x03\x12a\x03\xD5Wa\x03\xD2\x91_\x01a\x03\xADV[\x90V[a\x01\xECV[4a\x04\x08Wa\x03\xF2a\x03\xED6`\x04a\x03\xBCV[a\x11\xFEV[a\x03\xFAa\x01\xE2V[\x80a\x04\x04\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[\x90V[a\x04\x19\x81a\x04\rV[\x03a\x04 WV[_\x80\xFD[\x90P5\x90a\x041\x82a\x04\x10V[V[\x90` \x82\x82\x03\x12a\x04LWa\x04I\x91_\x01a\x04$V[\x90V[a\x01\xECV[4a\x04\x7FWa\x04ia\x04d6`\x04a\x043V[a\x12BV[a\x04qa\x01\xE2V[\x80a\x04{\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x04\x9A\x90a\x04\x84V[\x90RV[\x91\x90a\x04\xB1\x90_` \x85\x01\x94\x01\x90a\x04\x91V[V[4a\x04\xE3Wa\x04\xC36`\x04a\x01\xF0V[a\x04\xDFa\x04\xCEa\x12\x81V[a\x04\xD6a\x01\xE2V[\x91\x82\x91\x82a\x04\x9EV[\x03\x90\xF3[a\x01\xE8V[a\x04\xF1\x81a\x04\x84V[\x03a\x04\xF8WV[_\x80\xFD[\x90P5\x90a\x05\t\x82a\x04\xE8V[V[\x90\x91``\x82\x84\x03\x12a\x05@Wa\x05=a\x05&\x84_\x85\x01a\x04\xFCV[\x93a\x054\x81` \x86\x01a\x04$V[\x93`@\x01a\x04$V[\x90V[a\x01\xECV[4a\x05tWa\x05^a\x05X6`\x04a\x05\x0BV[\x91a\x12\xC9V[a\x05fa\x01\xE2V[\x80a\x05p\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[_\x80\xFD[\x90\x81`\xC0\x91\x03\x12a\x05\x8BW\x90V[a\x05yV[\x90\x91a\x01\0\x82\x84\x03\x12a\x05\xC6Wa\x05\xC3a\x05\xAC\x84_\x85\x01a\x04$V[\x93a\x05\xBA\x81` \x86\x01a\x05}V[\x93`\xE0\x01a\x04$V[\x90V[a\x01\xECV[a\x05\xD4\x90a\x04\rV[\x90RV[\x91\x90a\x05\xEB\x90_` \x85\x01\x94\x01\x90a\x05\xCBV[V[4a\x06\x1EWa\x06\x1Aa\x06\ta\x06\x036`\x04a\x05\x90V[\x91a\x13,V[a\x06\x11a\x01\xE2V[\x91\x82\x91\x82a\x05\xD8V[\x03\x90\xF3[a\x01\xE8V[4a\x06SWa\x0636`\x04a\x01\xF0V[a\x06Oa\x06>a\x14\x1DV[a\x06Fa\x01\xE2V[\x91\x82\x91\x82a\x05\xD8V[\x03\x90\xF3[a\x01\xE8V[\x91\x90`@\x83\x82\x03\x12a\x06\x80W\x80a\x06ta\x06}\x92_\x86\x01a\x02\x88V[\x93` \x01a\x04$V[\x90V[a\x01\xECV[4a\x06\xB4Wa\x06\x9Ea\x06\x986`\x04a\x06XV[\x90a\x14\xC5V[a\x06\xA6a\x01\xE2V[\x80a\x06\xB0\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x06\xE5\x90a\x06\xBDV[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x06\xFFW`@RV[a\x06\xC7V[\x90a\x07\x17a\x07\x10a\x01\xE2V[\x92\x83a\x06\xDBV[V[_\x80\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x072W` \x02\x90V[a\x06\xC7V[_\x80\xFD[\x90\x92\x91\x92a\x07Pa\x07K\x82a\x07\x1DV[a\x07\x04V[\x93` \x85\x92\x02\x83\x01\x92\x81\x84\x11a\x07\x88W\x91[\x83\x83\x10a\x07oWPPPPV[` \x80\x91a\x07}\x84\x86a\x04$V[\x81R\x01\x92\x01\x91a\x07bV[a\x077V[\x90\x80`\x1F\x83\x01\x12\x15a\x07\xA8Wa\x07\xA5\x91`\x02\x90a\x07;V[\x90V[a\x07\x19V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x07\xC2W` \x02\x90V[a\x06\xC7V[\x90\x92\x91\x92a\x07\xDCa\x07\xD7\x82a\x07\xADV[a\x07\x04V[\x93` \x85\x92\x02\x83\x01\x92\x81\x84\x11a\x08\x14W\x91[\x83\x83\x10a\x07\xFBWPPPPV[` \x80\x91a\x08\t\x84\x86a\x04\xFCV[\x81R\x01\x92\x01\x91a\x07\xEEV[a\x077V[\x90\x80`\x1F\x83\x01\x12\x15a\x084Wa\x081\x91`\x02\x90a\x07\xC7V[\x90V[a\x07\x19V[\x91\x90`\x80\x83\x82\x03\x12a\x08sWa\x08l\x90a\x08S`@a\x07\x04V[\x93a\x08`\x82_\x83\x01a\x07\x8DV[_\x86\x01R`@\x01a\x08\x19V[` \x83\x01RV[a\x06\xB9V[`\x04\x11\x15a\x08\x82WV[_\x80\xFD[\x90P5\x90a\x08\x93\x82a\x08xV[V[\x91\x90`\xA0\x83\x82\x03\x12a\x08\xCFWa\x08\xC8\x90a\x08\xAF`@a\x07\x04V[\x93a\x08\xBC\x82_\x83\x01a\x089V[_\x86\x01R`\x80\x01a\x08\x86V[` \x83\x01RV[a\x06\xB9V[\x91\x90a\x01`\x83\x82\x03\x12a\t\"Wa\t\x1B\x90a\x08\xEF``a\x07\x04V[\x93a\x08\xFC\x82_\x83\x01a\x08\x95V[_\x86\x01Ra\t\r\x82`\xA0\x83\x01a\x08\x95V[` \x86\x01Ra\x01@\x01a\x04\xFCV[`@\x83\x01RV[a\x06\xB9V[a\x01\xC0\x81\x83\x03\x12a\tjWa\t>\x82_\x83\x01a\x04\xFCV[\x92a\tga\tO\x84` \x85\x01a\x02\x88V[\x93a\t]\x81`@\x86\x01a\x08\xD4V[\x93a\x01\xA0\x01a\x04$V[\x90V[a\x01\xECV[4a\t\xA1Wa\t\x8Ba\t\x826`\x04a\t'V[\x92\x91\x90\x91a\x15\x89V[a\t\x93a\x01\xE2V[\x80a\t\x9D\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[a\t\xAF\x90a\x03\x94V[\x90RV[\x91\x90a\t\xC6\x90_` \x85\x01\x94\x01\x90a\t\xA6V[V[4a\t\xF8Wa\t\xD86`\x04a\x01\xF0V[a\t\xF4a\t\xE3a\x15\xCFV[a\t\xEBa\x01\xE2V[\x91\x82\x91\x82a\t\xB3V[\x03\x90\xF3[a\x01\xE8V[\x90\x81a\x02`\x91\x03\x12a\n\x0CW\x90V[a\x05yV[\x91\x90a\x02\x80\x83\x82\x03\x12a\n;W\x80a\n.a\n8\x92_\x86\x01a\t\xFDV[\x93a\x02`\x01a\x04$V[\x90V[a\x01\xECV[4a\noWa\nYa\nS6`\x04a\n\x11V[\x90a\x15\xDCV[a\naa\x01\xE2V[\x80a\nk\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[a\n}\x90a\x02qV[\x90RV[\x91\x90a\n\x94\x90_` \x85\x01\x94\x01\x90a\ntV[V[4a\n\xC6Wa\n\xA66`\x04a\x01\xF0V[a\n\xC2a\n\xB1a\x16@V[a\n\xB9a\x01\xE2V[\x91\x82\x91\x82a\n\x81V[\x03\x90\xF3[a\x01\xE8V[4a\n\xF9Wa\n\xDB6`\x04a\x01\xF0V[a\n\xE3a\x16VV[a\n\xEBa\x01\xE2V[\x80a\n\xF5\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[4a\x0B,Wa\x0B\x16a\x0B\x116`\x04a\x043V[a\x16\x8EV[a\x0B\x1Ea\x01\xE2V[\x80a\x0B(\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[4a\x0BaWa\x0BA6`\x04a\x01\xF0V[a\x0B]a\x0BLa\x16\x9BV[a\x0BTa\x01\xE2V[\x91\x82\x91\x82a\x02#V[\x03\x90\xF3[a\x01\xE8V[4a\x0B\x96Wa\x0Bv6`\x04a\x01\xF0V[a\x0B\x92a\x0B\x81a\x16\xB1V[a\x0B\x89a\x01\xE2V[\x91\x82\x91\x82a\x05\xD8V[\x03\x90\xF3[a\x01\xE8V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x0B\xB3W` \x80\x91\x02\x01\x90V[a\x06\xC7V[\x90\x92\x91\x92a\x0B\xCDa\x0B\xC8\x82a\x0B\x9BV[a\x07\x04V[\x93\x81\x85R` \x80\x86\x01\x92\x02\x83\x01\x92\x81\x84\x11a\x0C\nW\x91[\x83\x83\x10a\x0B\xF1WPPPPV[` \x80\x91a\x0B\xFF\x84\x86a\x03\x01V[\x81R\x01\x92\x01\x91a\x0B\xE4V[a\x077V[\x90\x80`\x1F\x83\x01\x12\x15a\x0C-W\x81` a\x0C*\x935\x91\x01a\x0B\xB8V[\x90V[a\x07\x19V[\x90` \x82\x82\x03\x12a\x0CbW_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x0C]Wa\x0CZ\x92\x01a\x0C\x0FV[\x90V[a\x02mV[a\x01\xECV[4a\x0C\x95Wa\x0C\x7Fa\x0Cz6`\x04a\x0C2V[a\x19JV[a\x0C\x87a\x01\xE2V[\x80a\x0C\x91\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x0C\xB2W` \x80\x91\x02\x01\x90V[a\x06\xC7V[\x90\x92\x91\x92a\x0C\xCCa\x0C\xC7\x82a\x0C\x9AV[a\x07\x04V[\x93\x81\x85R` \x80\x86\x01\x92\x02\x83\x01\x92\x81\x84\x11a\r\tW\x91[\x83\x83\x10a\x0C\xF0WPPPPV[` \x80\x91a\x0C\xFE\x84\x86a\x03\xADV[\x81R\x01\x92\x01\x91a\x0C\xE3V[a\x077V[\x90\x80`\x1F\x83\x01\x12\x15a\r,W\x81` a\r)\x935\x91\x01a\x0C\xB7V[\x90V[a\x07\x19V[\x91\x90\x91`@\x81\x84\x03\x12a\r\x89W_\x81\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\r\x84W\x83a\r]\x91\x83\x01a\x0C\x0FV[\x92` \x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\r\x7FWa\r|\x92\x01a\r\x0EV[\x90V[a\x02mV[a\x02mV[a\x01\xECV[4a\r\xBDWa\r\xA7a\r\xA16`\x04a\r1V[\x90a\x19\xA1V[a\r\xAFa\x01\xE2V[\x80a\r\xB9\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\r\xDE\x90a\x02\nV[\x90RV[\x90a\r\xEF\x81` \x93a\r\xD5V[\x01\x90V[` \x01\x90V[\x90a\x0E\x16a\x0E\x10a\x0E\t\x84a\r\xC2V[\x80\x93a\r\xC6V[\x92a\r\xCFV[\x90_[\x81\x81\x10a\x0E&WPPP\x90V[\x90\x91\x92a\x0E?a\x0E9`\x01\x92\x86Qa\r\xE2V[\x94a\r\xF3V[\x91\x01\x91\x90\x91a\x0E\x19V[a\x0E^\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\r\xF9V[\x90V[4a\x0E\x91Wa\x0Eq6`\x04a\x01\xF0V[a\x0E\x8Da\x0E|a\x1A\x90V[a\x0E\x84a\x01\xE2V[\x91\x82\x91\x82a\x0EIV[\x03\x90\xF3[a\x01\xE8V[\x90` \x82\x82\x03\x12a\x0E\xAFWa\x0E\xAC\x91_\x01a\x04\xFCV[\x90V[a\x01\xECV[4a\x0E\xE2Wa\x0E\xCCa\x0E\xC76`\x04a\x0E\x96V[a\x1B\x02V[a\x0E\xD4a\x01\xE2V[\x80a\x0E\xDE\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[4a\x0F\x15Wa\x0E\xFFa\x0E\xFA6`\x04a\x02\x97V[a\x1B\x0FV[a\x0F\x07a\x01\xE2V[\x80a\x0F\x11\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[\x90V[a\x0F1a\x0F,a\x0F6\x92a\x01\xFFV[a\x0F\x1AV[a\x01\xFFV[\x90V[a\x0FB\x90a\x0F\x1DV[\x90V[a\x0FN\x90a\x0F9V[\x90V[a\x0FZ\x90a\x0FEV[\x90RV[\x91\x90a\x0Fq\x90_` \x85\x01\x94\x01\x90a\x0FQV[V[4a\x0F\xA3Wa\x0F\x836`\x04a\x01\xF0V[a\x0F\x9Fa\x0F\x8Ea\x1B\xA4V[a\x0F\x96a\x01\xE2V[\x91\x82\x91\x82a\x0F^V[\x03\x90\xF3[a\x01\xE8V[a\x0F\xB1\x90a\x0F9V[\x90V[a\x0F\xBD\x90a\x0F\xA8V[\x90RV[\x91\x90a\x0F\xD4\x90_` \x85\x01\x94\x01\x90a\x0F\xB4V[V[4a\x10\x06Wa\x0F\xE66`\x04a\x01\xF0V[a\x10\x02a\x0F\xF1a\x1B\xEAV[a\x0F\xF9a\x01\xE2V[\x91\x82\x91\x82a\x0F\xC1V[\x03\x90\xF3[a\x01\xE8V[4a\x109Wa\x10#a\x10\x1E6`\x04a\x0E\x96V[a\x1CFV[a\x10+a\x01\xE2V[\x80a\x105\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[4a\x10lWa\x10Va\x10Q6`\x04a\x043V[a\x1C\x8CV[a\x10^a\x01\xE2V[\x80a\x10h\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[_\x80\xFD[_\x90V[_\x1C\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x10\x95a\x10\x9A\x91a\x10yV[a\x10~V[\x90V[a\x10\xA7\x90Ta\x10\x89V[\x90V[a\x10\xB2a\x10uV[Pa\x10\xBD`\x08a\x10\x9DV[\x90V[_\x1B\x90V[\x90a\x10\xD1_\x19\x91a\x10\xC0V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x10\xEFa\x10\xEAa\x10\xF4\x92a\x02qV[a\x0F\x1AV[a\x02qV[\x90V[\x90V[\x90a\x11\x0Fa\x11\na\x11\x16\x92a\x10\xDBV[a\x10\xF7V[\x82Ta\x10\xC5V[\x90UV[a\x11%\x90`\x03a\x10\xFAV[V[a\x11]\x7F\xD3\xABL\xBE\x1BoQ\x9E\xB4?\t\xDE\xD1z\x12\xE8\x1B\x81\x1E)pc\xAD\xA2\xD6]\xDD\xEF[a,|\x91a\x11Ta\x01\xE2V[\x91\x82\x91\x82a\x02#V[\x03\x90\xA1V[\x90a\x11s`\x01\x80`\xA0\x1B\x03\x91a\x10\xC0V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x11\x86\x90a\x0F9V[\x90V[\x90V[\x90a\x11\xA1a\x11\x9Ca\x11\xA8\x92a\x11}V[a\x11\x89V[\x82Ta\x11bV[\x90UV[a\x11\xB7\x90`\x07a\x11\x8CV[V[\x90a\x11\xC5`\xFF\x91a\x10\xC0V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x11\xD8\x90a\x03\x94V[\x90V[\x90V[\x90a\x11\xF3a\x11\xEEa\x11\xFA\x92a\x11\xCFV[a\x11\xDBV[\x82Ta\x11\xB9V[\x90UV[a\x12\x08\x90_a\x11\xDEV[V[a\x12\x13\x90a\x04\rV[\x90V[a\x12\x1F\x90a\x10yV[\x90V[\x90a\x127a\x122a\x12>\x92a\x12\nV[a\x12\x16V[\x82Ta\x10\xC5V[\x90UV[a\x12M\x90`\x05a\x12\"V[V[_\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x12la\x12q\x91a\x10yV[a\x12SV[\x90V[a\x12~\x90Ta\x12`V[\x90V[a\x12\x89a\x12OV[Pa\x12\x94`\x04a\x12tV[\x90V[`@\x90a\x12\xC0a\x12\xC7\x94\x96\x95\x93\x96a\x12\xB6``\x84\x01\x98_\x85\x01\x90a\x04\x91V[` \x83\x01\x90a\x05\xCBV[\x01\x90a\x05\xCBV[V[a\x12\xFF\x7F\x8C\x8BxY\xBB\xC9i\xBE\xC9\x9A\xC5d\xF3\x7F\x81(\xE2\xDE\x9F\x85\xD3@\x08a9\xAD\x98\xA8\x85\x98\x95\x1B\x93a\x12\xF6a\x01\xE2V[\x93\x84\x93\x84a\x12\x97V[\x03\x90\xA1V[_\x90V[\x90V[a\x13\x17a\x13\x1C\x91a\x10yV[a\x13\x08V[\x90V[a\x13)\x90Ta\x13\x0BV[\x90V[PPPa\x137a\x13\x04V[Pa\x13B`\x05a\x13\x1FV[\x90V[`\xFF\x16\x90V[a\x13Wa\x13\\\x91a\x10yV[a\x13EV[\x90V[a\x13i\x90Ta\x13KV[\x90V[` \x91\x81R\x01\x90V[` \x7Fn hash\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FLegacy mode: no genesis assertio_\x82\x01R\x01RV[a\x13\xCF`&`@\x92a\x13lV[a\x13\xD8\x81a\x13uV[\x01\x90V[a\x13\xF1\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x13\xC2V[\x90V[\x15a\x13\xFBWV[a\x14\x03a\x01\xE2V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x14\x19`\x04\x82\x01a\x13\xDCV[\x03\x90\xFD[a\x14%a\x13\x04V[Pa\x14@a\x14;a\x145_a\x13_V[\x15a\x03\x94V[a\x13\xF4V[a\x14J`\x01a\x13\x1FV[\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x14da\x14i\x91a\x10yV[a\x14MV[\x90V[a\x14v\x90Ta\x14XV[\x90V[_\x80\xFD[`\xE0\x1B\x90V[_\x91\x03\x12a\x14\x8DWV[a\x01\xECV[\x91` a\x14\xB3\x92\x94\x93a\x14\xAC`@\x82\x01\x96_\x83\x01\x90a\ntV[\x01\x90a\x05\xCBV[V[a\x14\xBDa\x01\xE2V[=_\x82>=\x90\xFD[a\x14\xD7a\x14\xD2`\ta\x14lV[a\x0FEV[\x91cF\x8E\xFFP\x91\x90\x92\x80;\x15a\x15RWa\x15\x04_\x80\x94a\x15\x0Fa\x14\xF8a\x01\xE2V[\x97\x88\x96\x87\x95\x86\x94a\x14}V[\x84R`\x04\x84\x01a\x14\x92V[\x03\x92Z\xF1\x80\x15a\x15MWa\x15!W[PV[a\x15@\x90_=\x81\x11a\x15FW[a\x158\x81\x83a\x06\xDBV[\x81\x01\x90a\x14\x83V[_a\x15\x1EV[P=a\x15.V[a\x14\xB5V[a\x14yV[`@\x90a\x15\x80a\x15\x87\x94\x96\x95\x93\x96a\x15v``\x84\x01\x98_\x85\x01\x90a\x04\x91V[` \x83\x01\x90a\ntV[\x01\x90a\x05\xCBV[V[\x90\x92\x91P\x91\x90\x91a\x15\xC6\x7FHjs\xD3\x8B\x9A\xDF\xB3\xEC\x83\xA2\x01;\x18\xF5w\x1A\x94\x8Ffk\x03\x8E\x1B[\x03\xF8X\x8Ab\xCD\xD7\x93a\x15\xBDa\x01\xE2V[\x93\x84\x93\x84a\x15WV[\x03\x90\xA1V[_\x90V[a\x15\xD7a\x15\xCBV[P_\x90V[Pa\x16\x13\x7F6\xD6\tme\x86b\xBA\x82\xAE)\xE7m\xE7\xDA\xAB\"\xD6\xC3\xB26\x1A\x82\x94F\x07f\xA2\x8C\xF5\x05\xD5\x91a\x16\na\x01\xE2V[\x91\x82\x91\x82a\x05\xD8V[\x03\x90\xA1V[_\x90V[\x90V[a\x16+a\x160\x91a\x10yV[a\x16\x1CV[\x90V[a\x16=\x90Ta\x16\x1FV[\x90V[a\x16Ha\x16\x18V[Pa\x16S`\x03a\x163V[\x90V[\x7F\xA6\x9B\x97~\x94t\xB4T\xC0\xBE\x01\x918\xB2l\xD4m%\xE4\xE2\xFB\xCC\xF8# *\x0Bm{\xBD:$a\x16\x7Fa\x01\xE2V[\x80a\x16\x89\x81a\x02\xB5V[\x03\x90\xA1V[a\x16\x99\x90`\x02a\x12\"V[V[a\x16\xA3a\x10uV[Pa\x16\xAE`\x07a\x10\x9DV[\x90V[a\x16\xB9a\x13\x04V[Pa\x16\xC4`\x02a\x13\x1FV[\x90V[T\x90V[`\x01\x90\x81\x80\x03\x01\x04\x90V[_R` _ \x90V[\x1B\x90V[\x91\x90`\x08a\x16\xFE\x91\x02\x91a\x16\xF8_\x19\x84a\x16\xDFV[\x92a\x16\xDFV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\x17\x1Ea\x17\x19a\x17&\x93a\x10\xDBV[a\x10\xF7V[\x90\x83Ta\x16\xE3V[\x90UV[a\x17<\x91a\x176a\x16\x18V[\x91a\x17\x08V[V[[\x81\x81\x10a\x17JWPPV[\x80a\x17W_`\x01\x93a\x17*V[\x01a\x17?V[\x90\x91\x82\x81\x10a\x17lW[PPPV[a\x17\x8Aa\x17\x84a\x17~a\x17\x95\x95a\x16\xCBV[\x92a\x16\xCBV[\x92a\x16\xD6V[\x91\x82\x01\x91\x01\x90a\x17>V[_\x80\x80a\x17gV[\x90h\x01\0\0\0\0\0\0\0\0\x81\x11a\x17\xC6W\x81a\x17\xBBa\x17\xC4\x93a\x16\xC7V[\x90\x82\x81Ua\x17]V[V[a\x06\xC7V[a\x17\xD5\x90Qa\x02\nV[\x90V[a\x17\xE1\x82a\r\xC2V[\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x18DWa\x18\x0Fa\x18\t`\x01\x92a\x18\x04\x86\x86a\x17\x9DV[a\r\xCFV[\x92a\x16\xD6V[\x92\x04\x91_[\x83\x81\x10a\x18!WPPPPV[`\x01\x90` a\x187a\x182\x86a\x17\xCBV[a\x11\x89V[\x94\x01\x93\x81\x84\x01U\x01a\x18\x14V[a\x06\xC7V[\x90a\x18S\x91a\x17\xD8V[V[\x90a\x18ga\x18b\x83a\x0C\x9AV[a\x07\x04V[\x91\x82RV[6\x907V[\x90a\x18\x96a\x18~\x83a\x18UV[\x92` \x80a\x18\x8C\x86\x93a\x0C\x9AV[\x92\x01\x91\x03\x90a\x18lV[V[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\x18\xB4\x90a\x03\x94V[\x90RV[\x90a\x18\xC5\x81` \x93a\x18\xABV[\x01\x90V[` \x01\x90V[\x90a\x18\xECa\x18\xE6a\x18\xDF\x84a\x18\x98V[\x80\x93a\x18\x9CV[\x92a\x18\xA5V[\x90_[\x81\x81\x10a\x18\xFCWPPP\x90V[\x90\x91\x92a\x19\x15a\x19\x0F`\x01\x92\x86Qa\x18\xB8V[\x94a\x18\xC9V[\x91\x01\x91\x90\x91a\x18\xEFV[\x90\x91a\x199a\x19G\x93`@\x84\x01\x90\x84\x82\x03_\x86\x01Ra\r\xF9V[\x91` \x81\x84\x03\x91\x01Ra\x18\xCFV[\x90V[a\x19U\x81`\x06a\x18IV[a\x19fa\x19a\x82a\r\xC2V[a\x18qV[\x7F\r\x96\x90\xF9qe\xF3Y\x91\xAE`\xD2\xA9~\x04\xAF\xF4r\xC0\x87)r*\x926\xFF\x1B\xC8\xB9\xBA\x90\xC0\x91a\x19\x9Ca\x19\x93a\x01\xE2V[\x92\x83\x92\x83a\x19\x1FV[\x03\x90\xA1V[\x90\x7F\r\x96\x90\xF9qe\xF3Y\x91\xAE`\xD2\xA9~\x04\xAF\xF4r\xC0\x87)r*\x926\xFF\x1B\xC8\xB9\xBA\x90\xC0\x91a\x19\xD8a\x19\xCFa\x01\xE2V[\x92\x83\x92\x83a\x19\x1FV[\x03\x90\xA1V[``\x90V[` \x91\x81R\x01\x90V[a\x19\xF5\x90Ta\x10\x89V[\x90V[`\x01\x01\x90V[\x90a\x1A\x1Ba\x1A\x15a\x1A\x0E\x84a\x16\xC7V[\x80\x93a\x19\xE2V[\x92a\x16\xD6V[\x90_[\x81\x81\x10a\x1A+WPPP\x90V[\x90\x91\x92a\x1AKa\x1AE`\x01\x92a\x1A@\x87a\x19\xEBV[a\r\xE2V[\x94a\x19\xF8V[\x91\x01\x91\x90\x91a\x1A\x1EV[\x90a\x1A_\x91a\x19\xFEV[\x90V[\x90a\x1A\x82a\x1A{\x92a\x1Ara\x01\xE2V[\x93\x84\x80\x92a\x1AUV[\x03\x83a\x06\xDBV[V[a\x1A\x8D\x90a\x1AbV[\x90V[a\x1A\x98a\x19\xDDV[Pa\x1A\xA3`\x06a\x1A\x84V[\x90V[\x90a\x1A\xB9g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x10\xC0V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1A\xD7a\x1A\xD2a\x1A\xDC\x92a\x04\x84V[a\x0F\x1AV[a\x04\x84V[\x90V[\x90V[\x90a\x1A\xF7a\x1A\xF2a\x1A\xFE\x92a\x1A\xC3V[a\x1A\xDFV[\x82Ta\x1A\xA6V[\x90UV[a\x1B\r\x90`\x04a\x1A\xE2V[V[a\x1B!a\x1B\x1C`\ta\x14lV[a\x0FEV[\x90c\xD2\x02\xDE\xAA\x90\x82;\x15a\x1B\x9BWa\x1BX\x92a\x1BM_\x80\x94a\x1BAa\x01\xE2V[\x96\x87\x95\x86\x94\x85\x93a\x14}V[\x83R`\x04\x83\x01a\n\x81V[\x03\x92Z\xF1\x80\x15a\x1B\x96Wa\x1BjW[PV[a\x1B\x89\x90_=\x81\x11a\x1B\x8FW[a\x1B\x81\x81\x83a\x06\xDBV[\x81\x01\x90a\x14\x83V[_a\x1BgV[P=a\x1BwV[a\x14\xB5V[a\x14yV[_\x90V[a\x1B\xACa\x1B\xA0V[Pa\x1B\xB7`\ta\x14lV[\x90V[_\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x1B\xD5a\x1B\xDA\x91a\x10yV[a\x1B\xBEV[\x90V[a\x1B\xE7\x90Ta\x1B\xC9V[\x90V[a\x1B\xF2a\x1B\xBAV[Pa\x1B\xFD`\na\x1B\xDDV[\x90V[`\xA0\x1B\x90V[\x90a\x1C\x1Cg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA0\x1B\x91a\x1C\0V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x1C;a\x1C6a\x1CB\x92a\x1A\xC3V[a\x1A\xDFV[\x82Ta\x1C\x06V[\x90UV[a\x1CQ\x81`\x08a\x1C&V[a\x1C\x87\x7Fw\xBB|\xC2r!\x14\xE0\x17\x1B\xCB\xD5\xE7\x87Q\t\x81I\r\x07d\xC5\xFC\x10\xB9|I\xB0\xB8/$\xD6\x91a\x1C~a\x01\xE2V[\x91\x82\x91\x82a\x04\x9EV[\x03\x90\xA1V[a\x1C\x97\x90`\x01a\x12\"V[V`\x80`@R4`\x1CW`\x0E` V[a\x03\x89a\0+\x829a\x03\x89\x90\xF3[`&V[`@Q\x90V[_\x80\xFD\xFE`\x80`@R`\x046\x10\x15a\0\x13W[a\x02/V[a\0\x1D_5a\0[V[\x80b\x84\x12\x0C\x14a\0VW\x80c\x16\xBFUy\x14a\0QW\x80cF\x8E\xFFP\x14a\0LWc\xD2\x02\xDE\xAA\x03a\0\x0EWa\x01\xFCV[a\x01\xC8V[a\x01>V[a\0\xA3V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x91\x03\x12a\0yWV[a\0kV[\x90V[a\0\x8A\x90a\0~V[\x90RV[\x91\x90a\0\xA1\x90_` \x85\x01\x94\x01\x90a\0\x81V[V[4a\0\xD3Wa\0\xB36`\x04a\0oV[a\0\xCFa\0\xBEa\x02`V[a\0\xC6a\0aV[\x91\x82\x91\x82a\0\x8EV[\x03\x90\xF3[a\0gV[a\0\xE1\x81a\0~V[\x03a\0\xE8WV[_\x80\xFD[\x90P5\x90a\0\xF9\x82a\0\xD8V[V[\x90` \x82\x82\x03\x12a\x01\x14Wa\x01\x11\x91_\x01a\0\xECV[\x90V[a\0kV[\x90V[a\x01%\x90a\x01\x19V[\x90RV[\x91\x90a\x01<\x90_` \x85\x01\x94\x01\x90a\x01\x1CV[V[4a\x01nWa\x01ja\x01Ya\x01T6`\x04a\0\xFBV[a\x02\xD2V[a\x01aa\0aV[\x91\x82\x91\x82a\x01)V[\x03\x90\xF3[a\0gV[a\x01|\x81a\x01\x19V[\x03a\x01\x83WV[_\x80\xFD[\x90P5\x90a\x01\x94\x82a\x01sV[V[\x91\x90`@\x83\x82\x03\x12a\x01\xBEW\x80a\x01\xB2a\x01\xBB\x92_\x86\x01a\0\xECV[\x93` \x01a\x01\x87V[\x90V[a\0kV[_\x01\x90V[4a\x01\xF7Wa\x01\xE1a\x01\xDB6`\x04a\x01\x96V[\x90a\x03DV[a\x01\xE9a\0aV[\x80a\x01\xF3\x81a\x01\xC3V[\x03\x90\xF3[a\0gV[4a\x02*Wa\x02\x14a\x02\x0F6`\x04a\0\xFBV[a\x03}V[a\x02\x1Ca\0aV[\x80a\x02&\x81a\x01\xC3V[\x03\x90\xF3[a\0gV[_\x80\xFD[_\x90V[_\x1C\x90V[\x90V[a\x02Ka\x02P\x91a\x027V[a\x02<V[\x90V[a\x02]\x90Ta\x02?V[\x90V[a\x02ha\x023V[Pa\x02r_a\x02SV[\x90V[_\x90V[\x90V[a\x02\x90a\x02\x8Ba\x02\x95\x92a\0~V[a\x02yV[a\0~V[\x90V[\x90a\x02\xA2\x90a\x02|V[_R` R`@_ \x90V[\x90V[a\x02\xBDa\x02\xC2\x91a\x027V[a\x02\xAEV[\x90V[a\x02\xCF\x90Ta\x02\xB1V[\x90V[a\x02\xE9a\x02\xEE\x91a\x02\xE1a\x02uV[P`\x01a\x02\x98V[a\x02\xC5V[\x90V[_\x1B\x90V[\x90a\x03\x02_\x19\x91a\x02\xF1V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x03\x15\x90a\x01\x19V[\x90V[a\x03!\x90a\x027V[\x90V[\x90a\x039a\x034a\x03@\x92a\x03\x0CV[a\x03\x18V[\x82Ta\x02\xF6V[\x90UV[a\x03Sa\x03X\x92\x91`\x01a\x02\x98V[a\x03$V[V[\x90V[\x90a\x03ra\x03ma\x03y\x92a\x02|V[a\x03ZV[\x82Ta\x02\xF6V[\x90UV[a\x03\x87\x90_a\x03]V[V`\x80`@R4a\0/Wa\0\x19a\0\x14a\x01\0V[a\x01\x9BV[a\0!a\x004V[a\x06=a\x01\xA9\x829a\x06=\x90\xF3[a\0:V[`@Q\x90V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\0f\x90a\0>V[\x81\x01\x90\x81\x10`\x01\x80`@\x1B\x03\x82\x11\x17a\0~W`@RV[a\0HV[\x90a\0\x96a\0\x8Fa\x004V[\x92\x83a\0\\V[V[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\0\xB0\x90a\0\x9CV[\x90V[a\0\xBC\x90a\0\xA7V[\x90V[a\0\xC8\x81a\0\xB3V[\x03a\0\xCFWV[_\x80\xFD[\x90PQ\x90a\0\xE0\x82a\0\xBFV[V[\x90` \x82\x82\x03\x12a\0\xFBWa\0\xF8\x91_\x01a\0\xD3V[\x90V[a\0\x98V[a\x01\x1Ea\x07\xE6\x808\x03\x80a\x01\x13\x81a\0\x83V[\x92\x839\x81\x01\x90a\0\xE2V[\x90V[_\x1B\x90V[\x90a\x017`\x01\x80`\xA0\x1B\x03\x91a\x01!V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[a\x01Xa\x01Sa\x01]\x92a\0\x9CV[a\x01AV[a\0\x9CV[\x90V[a\x01i\x90a\x01DV[\x90V[a\x01u\x90a\x01`V[\x90V[\x90V[\x90a\x01\x90a\x01\x8Ba\x01\x97\x92a\x01lV[a\x01xV[\x82Ta\x01&V[\x90UV[a\x01\xA6\x90`\x01a\x01{V[V\xFE`\x80`@R`\x046\x10\x15a\0\x13W[a\x02\xF8V[a\0\x1D_5a\0LV[\x80cn}\xF3\xE7\x14a\0GW\x80cq\xC3\xE6\xFE\x14a\0BWc\xE0\xBC\x97)\x03a\0\x0EWa\x02\xBEV[a\x01lV[a\0\xF8V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\0x\x90a\0dV[\x90V[a\0\x84\x81a\0oV[\x03a\0\x8BWV[_\x80\xFD[\x90P5\x90a\0\x9C\x82a\0{V[V[\x15\x15\x90V[a\0\xAC\x81a\0\x9EV[\x03a\0\xB3WV[_\x80\xFD[\x90P5\x90a\0\xC4\x82a\0\xA3V[V[\x91\x90`@\x83\x82\x03\x12a\0\xEEW\x80a\0\xE2a\0\xEB\x92_\x86\x01a\0\x8FV[\x93` \x01a\0\xB7V[\x90V[a\0\\V[_\x01\x90V[4a\x01'Wa\x01\x11a\x01\x0B6`\x04a\0\xC6V[\x90a\x03\xC3V[a\x01\x19a\0RV[\x80a\x01#\x81a\0\xF3V[\x03\x90\xF3[a\0XV[\x90` \x82\x82\x03\x12a\x01EWa\x01B\x91_\x01a\0\x8FV[\x90V[a\0\\V[a\x01S\x90a\0\x9EV[\x90RV[\x91\x90a\x01j\x90_` \x85\x01\x94\x01\x90a\x01JV[V[4a\x01\x9CWa\x01\x98a\x01\x87a\x01\x826`\x04a\x01,V[a\x04CV[a\x01\x8Fa\0RV[\x91\x82\x91\x82a\x01WV[\x03\x90\xF3[a\0XV[\x90V[a\x01\xAD\x81a\x01\xA1V[\x03a\x01\xB4WV[_\x80\xFD[\x90P5\x90a\x01\xC5\x82a\x01\xA4V[V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x02\rW\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x02\x08W` \x01\x92`\x01\x83\x02\x84\x01\x11a\x02\x03WV[a\x01\xCFV[a\x01\xCBV[a\x01\xC7V[a\x02\x1B\x90a\0oV[\x90V[a\x02'\x81a\x02\x12V[\x03a\x02.WV[_\x80\xFD[\x90P5\x90a\x02?\x82a\x02\x1EV[V[\x90`\xC0\x82\x82\x03\x12a\x02\xB9Wa\x02X\x81_\x84\x01a\x01\xB8V[\x92` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02\xB4W\x82a\x02y\x91\x85\x01a\x01\xD3V[\x92\x90\x93a\x02\x89\x82`@\x83\x01a\x01\xB8V[\x92a\x02\xB1a\x02\x9A\x84``\x85\x01a\x022V[\x93a\x02\xA8\x81`\x80\x86\x01a\x01\xB8V[\x93`\xA0\x01a\x01\xB8V[\x90V[a\0`V[a\0\\V[4a\x02\xF3Wa\x02\xDDa\x02\xD16`\x04a\x02AV[\x95\x94\x90\x94\x93\x91\x93a\x05lV[a\x02\xE5a\0RV[\x80a\x02\xEF\x81a\0\xF3V[\x03\x90\xF3[a\0XV[_\x80\xFD[\x90V[a\x03\x13a\x03\x0Ea\x03\x18\x92a\0dV[a\x02\xFCV[a\0dV[\x90V[a\x03$\x90a\x02\xFFV[\x90V[a\x030\x90a\x03\x1BV[\x90V[\x90a\x03=\x90a\x03'V[_R` R`@_ \x90V[_\x1B\x90V[\x90a\x03Z`\xFF\x91a\x03IV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x03m\x90a\0\x9EV[\x90V[\x90V[\x90a\x03\x88a\x03\x83a\x03\x8F\x92a\x03dV[a\x03pV[\x82Ta\x03NV[\x90UV[a\x03\x9C\x90a\0oV[\x90RV[\x91` a\x03\xC1\x92\x94\x93a\x03\xBA`@\x82\x01\x96_\x83\x01\x90a\x03\x93V[\x01\x90a\x01JV[V[a\x03\xD7\x82a\x03\xD2_\x84\x90a\x033V[a\x03sV[\x90\x7F(\xBC\xC5bm5~\xFE\x96kK\x08v\xAA\x1E\xE8\xAB\x99\xE2m\xA4\xF11\xF6\xA2b?\x18\0p\x1C!\x91a\x04\x0Ea\x04\x05a\0RV[\x92\x83\x92\x83a\x03\xA0V[\x03\x90\xA1V[_\x90V[_\x1C\x90V[`\xFF\x16\x90V[a\x04.a\x043\x91a\x04\x17V[a\x04\x1CV[\x90V[a\x04@\x90Ta\x04\"V[\x90V[a\x04Ya\x04^\x91a\x04Ra\x04\x13V[P_a\x033V[a\x046V[\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x04xa\x04}\x91a\x04\x17V[a\x04aV[\x90V[a\x04\x8A\x90Ta\x04lV[\x90V[a\x04\x96\x90a\x03\x1BV[\x90V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x04\xC5\x90a\x04\x9DV[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x04\xDFW`@RV[a\x04\xA7V[`\xE0\x1B\x90V[_\x91\x03\x12a\x04\xF4WV[a\0\\V[\x90V[a\x05\x10a\x05\x0Ba\x05\x15\x92a\x04\xF9V[a\x02\xFCV[a\x01\xA1V[\x90V[a\x05!\x90a\x04\xFCV[\x90RV[\x91\x90a\x058\x90_` \x85\x01\x94\x01\x90a\x05\x18V[V[a\x05Ba\0RV[=_\x82>=\x90\xFD[a\x05S\x90a\x01\xA1V[\x90RV[\x91\x90a\x05j\x90_` \x85\x01\x94\x01\x90a\x05JV[V[\x95PPPPPPa\x05\x85a\x05\x80`\x01a\x04\x80V[a\x04\x8DV[c\xD2\x02\xDE\xAA`\x02\x82;\x15a\x068Wa\x05\xBC\x92a\x05\xB1_\x80\x94a\x05\xA5a\0RV[\x96\x87\x95\x86\x94\x85\x93a\x04\xE4V[\x83R`\x04\x83\x01a\x05%V[\x03\x92Z\xF1\x80\x15a\x063Wa\x06\x07W[Pa\x06\x02\x7F\x1E\xB1:\x7F\x15!+V\xAD`WJ+\n\xD5B\xF1%\xDB\x9C\xF1&7Kr\xE8L\x8B\x9D\x95>\xC3\x91a\x05\xF9a\0RV[\x91\x82\x91\x82a\x05WV[\x03\x90\xA1V[a\x06&\x90_=\x81\x11a\x06,W[a\x06\x1E\x81\x83a\x04\xBBV[\x81\x01\x90a\x04\xEAV[_a\x05\xCBV[P=a\x06\x14V[a\x05:V[a\x04\x99V",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610013575b611071565b61001d5f356101dc565b8063023a96fe146101d757806306ae5851146101d25780630d561b37146101cd57806313af4035146101c85780631d39e389146101c35780632c24eccd146101be5780632e7acfa6146101b95780632f7968e8146101b457806333635fc2146101af578063353325e0146101aa578063468eff50146101a5578063470dce4e146101a05780635c975abb1461019b5780636420fb9f1461019657806376e7e23b146101915780638456cb591461018c57806389384960146101875780638da5cb5b146101825780638ee1a1261461017d5780639300c92614610178578063a3ffb77214610173578063b7ab4db51461016e578063ce66d05c14610169578063d202deaa14610164578063e78cea921461015f578063ee35f3271461015a578063f112cea3146101555763f3ef4b360361000e5761103e565b61100b565b610fd6565b610f73565b610ee7565b610eb4565b610e61565b610d8e565b610c67565b610b66565b610b31565b610afe565b610acb565b610a96565b610a40565b6109c8565b61096f565b610685565b610623565b6105ed565b610545565b6104b3565b610451565b6103da565b610361565b61032e565b6102ba565b610238565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f9103126101fa57565b6101ec565b60018060a01b031690565b610213906101ff565b90565b61021f9061020a565b9052565b9190610236905f60208501940190610216565b565b34610268576102483660046101f0565b6102646102536110aa565b61025b6101e2565b91829182610223565b0390f35b6101e8565b5f80fd5b90565b61027d81610271565b0361028457565b5f80fd5b9050359061029582610274565b565b906020828203126102b0576102ad915f01610288565b90565b6101ec565b5f0190565b346102e8576102d26102cd366004610297565b61111a565b6102da6101e2565b806102e4816102b5565b0390f35b6101e8565b6102f68161020a565b036102fd57565b5f80fd5b9050359061030e826102ed565b565b9060208282031261032957610326915f01610301565b90565b6101ec565b3461035c57610346610341366004610310565b611127565b61034e6101e2565b80610358816102b5565b0390f35b6101e8565b3461038f57610379610374366004610310565b6111ac565b6103816101e2565b8061038b816102b5565b0390f35b6101e8565b151590565b6103a281610394565b036103a957565b5f80fd5b905035906103ba82610399565b565b906020828203126103d5576103d2915f016103ad565b90565b6101ec565b34610408576103f26103ed3660046103bc565b6111fe565b6103fa6101e2565b80610404816102b5565b0390f35b6101e8565b90565b6104198161040d565b0361042057565b5f80fd5b9050359061043182610410565b565b9060208282031261044c57610449915f01610424565b90565b6101ec565b3461047f57610469610464366004610433565b611242565b6104716101e2565b8061047b816102b5565b0390f35b6101e8565b67ffffffffffffffff1690565b61049a90610484565b9052565b91906104b1905f60208501940190610491565b565b346104e3576104c33660046101f0565b6104df6104ce611281565b6104d66101e2565b9182918261049e565b0390f35b6101e8565b6104f181610484565b036104f857565b5f80fd5b90503590610509826104e8565b565b90916060828403126105405761053d610526845f85016104fc565b936105348160208601610424565b93604001610424565b90565b6101ec565b346105745761055e61055836600461050b565b916112c9565b6105666101e2565b80610570816102b5565b0390f35b6101e8565b5f80fd5b908160c091031261058b5790565b610579565b9091610100828403126105c6576105c36105ac845f8501610424565b936105ba816020860161057d565b9360e001610424565b90565b6101ec565b6105d49061040d565b9052565b91906105eb905f602085019401906105cb565b565b3461061e5761061a610609610603366004610590565b9161132c565b6106116101e2565b918291826105d8565b0390f35b6101e8565b34610653576106333660046101f0565b61064f61063e61141d565b6106466101e2565b918291826105d8565b0390f35b6101e8565b9190604083820312610680578061067461067d925f8601610288565b93602001610424565b90565b6101ec565b346106b45761069e610698366004610658565b906114c5565b6106a66101e2565b806106b0816102b5565b0390f35b6101e8565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906106e5906106bd565b810190811067ffffffffffffffff8211176106ff57604052565b6106c7565b906107176107106101e2565b92836106db565b565b5f80fd5b67ffffffffffffffff81116107325760200290565b6106c7565b5f80fd5b9092919261075061074b8261071d565b610704565b93602085920283019281841161078857915b83831061076f5750505050565b6020809161077d8486610424565b815201920191610762565b610737565b9080601f830112156107a8576107a59160029061073b565b90565b610719565b67ffffffffffffffff81116107c25760200290565b6106c7565b909291926107dc6107d7826107ad565b610704565b93602085920283019281841161081457915b8383106107fb5750505050565b6020809161080984866104fc565b8152019201916107ee565b610737565b9080601f8301121561083457610831916002906107c7565b90565b610719565b91906080838203126108735761086c906108536040610704565b93610860825f830161078d565b5f860152604001610819565b6020830152565b6106b9565b6004111561088257565b5f80fd5b9050359061089382610878565b565b919060a0838203126108cf576108c8906108af6040610704565b936108bc825f8301610839565b5f860152608001610886565b6020830152565b6106b9565b9190610160838203126109225761091b906108ef6060610704565b936108fc825f8301610895565b5f86015261090d8260a08301610895565b6020860152610140016104fc565b6040830152565b6106b9565b6101c08183031261096a5761093e825f83016104fc565b9261096761094f8460208501610288565b9361095d81604086016108d4565b936101a001610424565b90565b6101ec565b346109a15761098b610982366004610927565b92919091611589565b6109936101e2565b8061099d816102b5565b0390f35b6101e8565b6109af90610394565b9052565b91906109c6905f602085019401906109a6565b565b346109f8576109d83660046101f0565b6109f46109e36115cf565b6109eb6101e2565b918291826109b3565b0390f35b6101e8565b9081610260910312610a0c5790565b610579565b919061028083820312610a3b5780610a2e610a38925f86016109fd565b9361026001610424565b90565b6101ec565b34610a6f57610a59610a53366004610a11565b906115dc565b610a616101e2565b80610a6b816102b5565b0390f35b6101e8565b610a7d90610271565b9052565b9190610a94905f60208501940190610a74565b565b34610ac657610aa63660046101f0565b610ac2610ab1611640565b610ab96101e2565b91829182610a81565b0390f35b6101e8565b34610af957610adb3660046101f0565b610ae3611656565b610aeb6101e2565b80610af5816102b5565b0390f35b6101e8565b34610b2c57610b16610b11366004610433565b61168e565b610b1e6101e2565b80610b28816102b5565b0390f35b6101e8565b34610b6157610b413660046101f0565b610b5d610b4c61169b565b610b546101e2565b91829182610223565b0390f35b6101e8565b34610b9657610b763660046101f0565b610b92610b816116b1565b610b896101e2565b918291826105d8565b0390f35b6101e8565b67ffffffffffffffff8111610bb35760208091020190565b6106c7565b90929192610bcd610bc882610b9b565b610704565b9381855260208086019202830192818411610c0a57915b838310610bf15750505050565b60208091610bff8486610301565b815201920191610be4565b610737565b9080601f83011215610c2d57816020610c2a93359101610bb8565b90565b610719565b90602082820312610c62575f82013567ffffffffffffffff8111610c5d57610c5a9201610c0f565b90565b61026d565b6101ec565b34610c9557610c7f610c7a366004610c32565b61194a565b610c876101e2565b80610c91816102b5565b0390f35b6101e8565b67ffffffffffffffff8111610cb25760208091020190565b6106c7565b90929192610ccc610cc782610c9a565b610704565b9381855260208086019202830192818411610d0957915b838310610cf05750505050565b60208091610cfe84866103ad565b815201920191610ce3565b610737565b9080601f83011215610d2c57816020610d2993359101610cb7565b90565b610719565b919091604081840312610d89575f81013567ffffffffffffffff8111610d845783610d5d918301610c0f565b92602082013567ffffffffffffffff8111610d7f57610d7c9201610d0e565b90565b61026d565b61026d565b6101ec565b34610dbd57610da7610da1366004610d31565b906119a1565b610daf6101e2565b80610db9816102b5565b0390f35b6101e8565b5190565b60209181520190565b60200190565b610dde9061020a565b9052565b90610def81602093610dd5565b0190565b60200190565b90610e16610e10610e0984610dc2565b8093610dc6565b92610dcf565b905f5b818110610e265750505090565b909192610e3f610e396001928651610de2565b94610df3565b9101919091610e19565b610e5e9160208201915f818403910152610df9565b90565b34610e9157610e713660046101f0565b610e8d610e7c611a90565b610e846101e2565b91829182610e49565b0390f35b6101e8565b90602082820312610eaf57610eac915f016104fc565b90565b6101ec565b34610ee257610ecc610ec7366004610e96565b611b02565b610ed46101e2565b80610ede816102b5565b0390f35b6101e8565b34610f1557610eff610efa366004610297565b611b0f565b610f076101e2565b80610f11816102b5565b0390f35b6101e8565b90565b610f31610f2c610f36926101ff565b610f1a565b6101ff565b90565b610f4290610f1d565b90565b610f4e90610f39565b90565b610f5a90610f45565b9052565b9190610f71905f60208501940190610f51565b565b34610fa357610f833660046101f0565b610f9f610f8e611ba4565b610f966101e2565b91829182610f5e565b0390f35b6101e8565b610fb190610f39565b90565b610fbd90610fa8565b9052565b9190610fd4905f60208501940190610fb4565b565b3461100657610fe63660046101f0565b611002610ff1611bea565b610ff96101e2565b91829182610fc1565b0390f35b6101e8565b346110395761102361101e366004610e96565b611c46565b61102b6101e2565b80611035816102b5565b0390f35b6101e8565b3461106c57611056611051366004610433565b611c8c565b61105e6101e2565b80611068816102b5565b0390f35b6101e8565b5f80fd5b5f90565b5f1c90565b60018060a01b031690565b61109561109a91611079565b61107e565b90565b6110a79054611089565b90565b6110b2611075565b506110bd600861109d565b90565b5f1b90565b906110d15f19916110c0565b9181191691161790565b6110ef6110ea6110f492610271565b610f1a565b610271565b90565b90565b9061110f61110a611116926110db565b6110f7565b82546110c5565b9055565b6111259060036110fa565b565b61115d7fd3ab4cbe1b6f519eb43f09ded17a12e81b811e297063ada2d65dddef5b612c7c916111546101e2565b91829182610223565b0390a1565b9061117360018060a01b03916110c0565b9181191691161790565b61118690610f39565b90565b90565b906111a161119c6111a89261117d565b611189565b8254611162565b9055565b6111b790600761118c565b565b906111c560ff916110c0565b9181191691161790565b6111d890610394565b90565b90565b906111f36111ee6111fa926111cf565b6111db565b82546111b9565b9055565b611208905f6111de565b565b6112139061040d565b90565b61121f90611079565b90565b9061123761123261123e9261120a565b611216565b82546110c5565b9055565b61124d906005611222565b565b5f90565b67ffffffffffffffff1690565b61126c61127191611079565b611253565b90565b61127e9054611260565b90565b61128961124f565b506112946004611274565b90565b6040906112c06112c794969593966112b660608401985f850190610491565b60208301906105cb565b01906105cb565b565b6112ff7f8c8b7859bbc969bec99ac564f37f8128e2de9f85d340086139ad98a88598951b936112f66101e2565b93849384611297565b0390a1565b5f90565b90565b61131761131c91611079565b611308565b90565b611329905461130b565b90565b505050611337611304565b50611342600561131f565b90565b60ff1690565b61135761135c91611079565b611345565b90565b611369905461134b565b90565b60209181520190565b60207f6e20686173680000000000000000000000000000000000000000000000000000917f4c6567616379206d6f64653a206e6f2067656e6573697320617373657274696f5f8201520152565b6113cf602660409261136c565b6113d881611375565b0190565b6113f19060208101905f8183039101526113c2565b90565b156113fb57565b6114036101e2565b62461bcd60e51b815280611419600482016113dc565b0390fd5b611425611304565b5061144061143b6114355f61135f565b15610394565b6113f4565b61144a600161131f565b90565b60018060a01b031690565b61146461146991611079565b61144d565b90565b6114769054611458565b90565b5f80fd5b60e01b90565b5f91031261148d57565b6101ec565b9160206114b39294936114ac60408201965f830190610a74565b01906105cb565b565b6114bd6101e2565b3d5f823e3d90fd5b6114d76114d2600961146c565b610f45565b9163468eff50919092803b15611552576115045f809461150f6114f86101e2565b9788968795869461147d565b845260048401611492565b03925af1801561154d57611521575b50565b611540905f3d8111611546575b61153881836106db565b810190611483565b5f61151e565b503d61152e565b6114b5565b611479565b604090611580611587949695939661157660608401985f850190610491565b6020830190610a74565b01906105cb565b565b909291509190916115c67f486a73d38b9adfb3ec83a2013b18f5771a948f666b038e1b5b03f8588a62cdd7936115bd6101e2565b93849384611557565b0390a1565b5f90565b6115d76115cb565b505f90565b506116137f36d6096d658662ba82ae29e76de7daab22d6c3b2361a8294460766a28cf505d59161160a6101e2565b918291826105d8565b0390a1565b5f90565b90565b61162b61163091611079565b61161c565b90565b61163d905461161f565b90565b611648611618565b506116536003611633565b90565b7fa69b977e9474b454c0be019138b26cd46d25e4e2fbccf823202a0b6d7bbd3a2461167f6101e2565b80611689816102b5565b0390a1565b611699906002611222565b565b6116a3611075565b506116ae600761109d565b90565b6116b9611304565b506116c4600261131f565b90565b5490565b600190818003010490565b5f5260205f2090565b1b90565b919060086116fe9102916116f85f19846116df565b926116df565b9181191691161790565b919061171e611719611726936110db565b6110f7565b9083546116e3565b9055565b61173c91611736611618565b91611708565b565b5b81811061174a575050565b806117575f60019361172a565b0161173f565b909182811061176c575b505050565b61178a61178461177e611795956116cb565b926116cb565b926116d6565b91820191019061173e565b5f8080611767565b906801000000000000000081116117c657816117bb6117c4936116c7565b9082815561175d565b565b6106c7565b6117d5905161020a565b90565b6117e182610dc2565b9167ffffffffffffffff83116118445761180f611809600192611804868661179d565b610dcf565b926116d6565b9204915f5b8381106118215750505050565b6001906020611837611832866117cb565b611189565b9401938184015501611814565b6106c7565b90611853916117d8565b565b9061186761186283610c9a565b610704565b918252565b369037565b9061189661187e83611855565b9260208061188c8693610c9a565b920191039061186c565b565b5190565b60209181520190565b60200190565b6118b490610394565b9052565b906118c5816020936118ab565b0190565b60200190565b906118ec6118e66118df84611898565b809361189c565b926118a5565b905f5b8181106118fc5750505090565b90919261191561190f60019286516118b8565b946118c9565b91019190916118ef565b90916119396119479360408401908482035f860152610df9565b9160208184039101526118cf565b90565b611955816006611849565b61196661196182610dc2565b611871565b7f0d9690f97165f35991ae60d2a97e04aff472c08729722a9236ff1bc8b9ba90c09161199c6119936101e2565b9283928361191f565b0390a1565b907f0d9690f97165f35991ae60d2a97e04aff472c08729722a9236ff1bc8b9ba90c0916119d86119cf6101e2565b9283928361191f565b0390a1565b606090565b60209181520190565b6119f59054611089565b90565b60010190565b90611a1b611a15611a0e846116c7565b80936119e2565b926116d6565b905f5b818110611a2b5750505090565b909192611a4b611a45600192611a40876119eb565b610de2565b946119f8565b9101919091611a1e565b90611a5f916119fe565b90565b90611a82611a7b92611a726101e2565b93848092611a55565b03836106db565b565b611a8d90611a62565b90565b611a986119dd565b50611aa36006611a84565b90565b90611ab967ffffffffffffffff916110c0565b9181191691161790565b611ad7611ad2611adc92610484565b610f1a565b610484565b90565b90565b90611af7611af2611afe92611ac3565b611adf565b8254611aa6565b9055565b611b0d906004611ae2565b565b611b21611b1c600961146c565b610f45565b9063d202deaa90823b15611b9b57611b5892611b4d5f8094611b416101e2565b9687958694859361147d565b835260048301610a81565b03925af18015611b9657611b6a575b50565b611b89905f3d8111611b8f575b611b8181836106db565b810190611483565b5f611b67565b503d611b77565b6114b5565b611479565b5f90565b611bac611ba0565b50611bb7600961146c565b90565b5f90565b60018060a01b031690565b611bd5611bda91611079565b611bbe565b90565b611be79054611bc9565b90565b611bf2611bba565b50611bfd600a611bdd565b90565b60a01b90565b90611c1c67ffffffffffffffff60a01b91611c00565b9181191691161790565b90611c3b611c36611c4292611ac3565b611adf565b8254611c06565b9055565b611c51816008611c26565b611c877f77bb7cc2722114e0171bcbd5e787510981490d0764c5fc10b97c49b0b82f24d691611c7e6101e2565b9182918261049e565b0390a1565b611c97906001611222565b56
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x13W[a\x10qV[a\0\x1D_5a\x01\xDCV[\x80c\x02:\x96\xFE\x14a\x01\xD7W\x80c\x06\xAEXQ\x14a\x01\xD2W\x80c\rV\x1B7\x14a\x01\xCDW\x80c\x13\xAF@5\x14a\x01\xC8W\x80c\x1D9\xE3\x89\x14a\x01\xC3W\x80c,$\xEC\xCD\x14a\x01\xBEW\x80c.z\xCF\xA6\x14a\x01\xB9W\x80c/yh\xE8\x14a\x01\xB4W\x80c3c_\xC2\x14a\x01\xAFW\x80c53%\xE0\x14a\x01\xAAW\x80cF\x8E\xFFP\x14a\x01\xA5W\x80cG\r\xCEN\x14a\x01\xA0W\x80c\\\x97Z\xBB\x14a\x01\x9BW\x80cd \xFB\x9F\x14a\x01\x96W\x80cv\xE7\xE2;\x14a\x01\x91W\x80c\x84V\xCBY\x14a\x01\x8CW\x80c\x898I`\x14a\x01\x87W\x80c\x8D\xA5\xCB[\x14a\x01\x82W\x80c\x8E\xE1\xA1&\x14a\x01}W\x80c\x93\0\xC9&\x14a\x01xW\x80c\xA3\xFF\xB7r\x14a\x01sW\x80c\xB7\xABM\xB5\x14a\x01nW\x80c\xCEf\xD0\\\x14a\x01iW\x80c\xD2\x02\xDE\xAA\x14a\x01dW\x80c\xE7\x8C\xEA\x92\x14a\x01_W\x80c\xEE5\xF3'\x14a\x01ZW\x80c\xF1\x12\xCE\xA3\x14a\x01UWc\xF3\xEFK6\x03a\0\x0EWa\x10>V[a\x10\x0BV[a\x0F\xD6V[a\x0FsV[a\x0E\xE7V[a\x0E\xB4V[a\x0EaV[a\r\x8EV[a\x0CgV[a\x0BfV[a\x0B1V[a\n\xFEV[a\n\xCBV[a\n\x96V[a\n@V[a\t\xC8V[a\toV[a\x06\x85V[a\x06#V[a\x05\xEDV[a\x05EV[a\x04\xB3V[a\x04QV[a\x03\xDAV[a\x03aV[a\x03.V[a\x02\xBAV[a\x028V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x91\x03\x12a\x01\xFAWV[a\x01\xECV[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x02\x13\x90a\x01\xFFV[\x90V[a\x02\x1F\x90a\x02\nV[\x90RV[\x91\x90a\x026\x90_` \x85\x01\x94\x01\x90a\x02\x16V[V[4a\x02hWa\x02H6`\x04a\x01\xF0V[a\x02da\x02Sa\x10\xAAV[a\x02[a\x01\xE2V[\x91\x82\x91\x82a\x02#V[\x03\x90\xF3[a\x01\xE8V[_\x80\xFD[\x90V[a\x02}\x81a\x02qV[\x03a\x02\x84WV[_\x80\xFD[\x90P5\x90a\x02\x95\x82a\x02tV[V[\x90` \x82\x82\x03\x12a\x02\xB0Wa\x02\xAD\x91_\x01a\x02\x88V[\x90V[a\x01\xECV[_\x01\x90V[4a\x02\xE8Wa\x02\xD2a\x02\xCD6`\x04a\x02\x97V[a\x11\x1AV[a\x02\xDAa\x01\xE2V[\x80a\x02\xE4\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[a\x02\xF6\x81a\x02\nV[\x03a\x02\xFDWV[_\x80\xFD[\x90P5\x90a\x03\x0E\x82a\x02\xEDV[V[\x90` \x82\x82\x03\x12a\x03)Wa\x03&\x91_\x01a\x03\x01V[\x90V[a\x01\xECV[4a\x03\\Wa\x03Fa\x03A6`\x04a\x03\x10V[a\x11'V[a\x03Na\x01\xE2V[\x80a\x03X\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[4a\x03\x8FWa\x03ya\x03t6`\x04a\x03\x10V[a\x11\xACV[a\x03\x81a\x01\xE2V[\x80a\x03\x8B\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[\x15\x15\x90V[a\x03\xA2\x81a\x03\x94V[\x03a\x03\xA9WV[_\x80\xFD[\x90P5\x90a\x03\xBA\x82a\x03\x99V[V[\x90` \x82\x82\x03\x12a\x03\xD5Wa\x03\xD2\x91_\x01a\x03\xADV[\x90V[a\x01\xECV[4a\x04\x08Wa\x03\xF2a\x03\xED6`\x04a\x03\xBCV[a\x11\xFEV[a\x03\xFAa\x01\xE2V[\x80a\x04\x04\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[\x90V[a\x04\x19\x81a\x04\rV[\x03a\x04 WV[_\x80\xFD[\x90P5\x90a\x041\x82a\x04\x10V[V[\x90` \x82\x82\x03\x12a\x04LWa\x04I\x91_\x01a\x04$V[\x90V[a\x01\xECV[4a\x04\x7FWa\x04ia\x04d6`\x04a\x043V[a\x12BV[a\x04qa\x01\xE2V[\x80a\x04{\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x04\x9A\x90a\x04\x84V[\x90RV[\x91\x90a\x04\xB1\x90_` \x85\x01\x94\x01\x90a\x04\x91V[V[4a\x04\xE3Wa\x04\xC36`\x04a\x01\xF0V[a\x04\xDFa\x04\xCEa\x12\x81V[a\x04\xD6a\x01\xE2V[\x91\x82\x91\x82a\x04\x9EV[\x03\x90\xF3[a\x01\xE8V[a\x04\xF1\x81a\x04\x84V[\x03a\x04\xF8WV[_\x80\xFD[\x90P5\x90a\x05\t\x82a\x04\xE8V[V[\x90\x91``\x82\x84\x03\x12a\x05@Wa\x05=a\x05&\x84_\x85\x01a\x04\xFCV[\x93a\x054\x81` \x86\x01a\x04$V[\x93`@\x01a\x04$V[\x90V[a\x01\xECV[4a\x05tWa\x05^a\x05X6`\x04a\x05\x0BV[\x91a\x12\xC9V[a\x05fa\x01\xE2V[\x80a\x05p\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[_\x80\xFD[\x90\x81`\xC0\x91\x03\x12a\x05\x8BW\x90V[a\x05yV[\x90\x91a\x01\0\x82\x84\x03\x12a\x05\xC6Wa\x05\xC3a\x05\xAC\x84_\x85\x01a\x04$V[\x93a\x05\xBA\x81` \x86\x01a\x05}V[\x93`\xE0\x01a\x04$V[\x90V[a\x01\xECV[a\x05\xD4\x90a\x04\rV[\x90RV[\x91\x90a\x05\xEB\x90_` \x85\x01\x94\x01\x90a\x05\xCBV[V[4a\x06\x1EWa\x06\x1Aa\x06\ta\x06\x036`\x04a\x05\x90V[\x91a\x13,V[a\x06\x11a\x01\xE2V[\x91\x82\x91\x82a\x05\xD8V[\x03\x90\xF3[a\x01\xE8V[4a\x06SWa\x0636`\x04a\x01\xF0V[a\x06Oa\x06>a\x14\x1DV[a\x06Fa\x01\xE2V[\x91\x82\x91\x82a\x05\xD8V[\x03\x90\xF3[a\x01\xE8V[\x91\x90`@\x83\x82\x03\x12a\x06\x80W\x80a\x06ta\x06}\x92_\x86\x01a\x02\x88V[\x93` \x01a\x04$V[\x90V[a\x01\xECV[4a\x06\xB4Wa\x06\x9Ea\x06\x986`\x04a\x06XV[\x90a\x14\xC5V[a\x06\xA6a\x01\xE2V[\x80a\x06\xB0\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x06\xE5\x90a\x06\xBDV[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x06\xFFW`@RV[a\x06\xC7V[\x90a\x07\x17a\x07\x10a\x01\xE2V[\x92\x83a\x06\xDBV[V[_\x80\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x072W` \x02\x90V[a\x06\xC7V[_\x80\xFD[\x90\x92\x91\x92a\x07Pa\x07K\x82a\x07\x1DV[a\x07\x04V[\x93` \x85\x92\x02\x83\x01\x92\x81\x84\x11a\x07\x88W\x91[\x83\x83\x10a\x07oWPPPPV[` \x80\x91a\x07}\x84\x86a\x04$V[\x81R\x01\x92\x01\x91a\x07bV[a\x077V[\x90\x80`\x1F\x83\x01\x12\x15a\x07\xA8Wa\x07\xA5\x91`\x02\x90a\x07;V[\x90V[a\x07\x19V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x07\xC2W` \x02\x90V[a\x06\xC7V[\x90\x92\x91\x92a\x07\xDCa\x07\xD7\x82a\x07\xADV[a\x07\x04V[\x93` \x85\x92\x02\x83\x01\x92\x81\x84\x11a\x08\x14W\x91[\x83\x83\x10a\x07\xFBWPPPPV[` \x80\x91a\x08\t\x84\x86a\x04\xFCV[\x81R\x01\x92\x01\x91a\x07\xEEV[a\x077V[\x90\x80`\x1F\x83\x01\x12\x15a\x084Wa\x081\x91`\x02\x90a\x07\xC7V[\x90V[a\x07\x19V[\x91\x90`\x80\x83\x82\x03\x12a\x08sWa\x08l\x90a\x08S`@a\x07\x04V[\x93a\x08`\x82_\x83\x01a\x07\x8DV[_\x86\x01R`@\x01a\x08\x19V[` \x83\x01RV[a\x06\xB9V[`\x04\x11\x15a\x08\x82WV[_\x80\xFD[\x90P5\x90a\x08\x93\x82a\x08xV[V[\x91\x90`\xA0\x83\x82\x03\x12a\x08\xCFWa\x08\xC8\x90a\x08\xAF`@a\x07\x04V[\x93a\x08\xBC\x82_\x83\x01a\x089V[_\x86\x01R`\x80\x01a\x08\x86V[` \x83\x01RV[a\x06\xB9V[\x91\x90a\x01`\x83\x82\x03\x12a\t\"Wa\t\x1B\x90a\x08\xEF``a\x07\x04V[\x93a\x08\xFC\x82_\x83\x01a\x08\x95V[_\x86\x01Ra\t\r\x82`\xA0\x83\x01a\x08\x95V[` \x86\x01Ra\x01@\x01a\x04\xFCV[`@\x83\x01RV[a\x06\xB9V[a\x01\xC0\x81\x83\x03\x12a\tjWa\t>\x82_\x83\x01a\x04\xFCV[\x92a\tga\tO\x84` \x85\x01a\x02\x88V[\x93a\t]\x81`@\x86\x01a\x08\xD4V[\x93a\x01\xA0\x01a\x04$V[\x90V[a\x01\xECV[4a\t\xA1Wa\t\x8Ba\t\x826`\x04a\t'V[\x92\x91\x90\x91a\x15\x89V[a\t\x93a\x01\xE2V[\x80a\t\x9D\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[a\t\xAF\x90a\x03\x94V[\x90RV[\x91\x90a\t\xC6\x90_` \x85\x01\x94\x01\x90a\t\xA6V[V[4a\t\xF8Wa\t\xD86`\x04a\x01\xF0V[a\t\xF4a\t\xE3a\x15\xCFV[a\t\xEBa\x01\xE2V[\x91\x82\x91\x82a\t\xB3V[\x03\x90\xF3[a\x01\xE8V[\x90\x81a\x02`\x91\x03\x12a\n\x0CW\x90V[a\x05yV[\x91\x90a\x02\x80\x83\x82\x03\x12a\n;W\x80a\n.a\n8\x92_\x86\x01a\t\xFDV[\x93a\x02`\x01a\x04$V[\x90V[a\x01\xECV[4a\noWa\nYa\nS6`\x04a\n\x11V[\x90a\x15\xDCV[a\naa\x01\xE2V[\x80a\nk\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[a\n}\x90a\x02qV[\x90RV[\x91\x90a\n\x94\x90_` \x85\x01\x94\x01\x90a\ntV[V[4a\n\xC6Wa\n\xA66`\x04a\x01\xF0V[a\n\xC2a\n\xB1a\x16@V[a\n\xB9a\x01\xE2V[\x91\x82\x91\x82a\n\x81V[\x03\x90\xF3[a\x01\xE8V[4a\n\xF9Wa\n\xDB6`\x04a\x01\xF0V[a\n\xE3a\x16VV[a\n\xEBa\x01\xE2V[\x80a\n\xF5\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[4a\x0B,Wa\x0B\x16a\x0B\x116`\x04a\x043V[a\x16\x8EV[a\x0B\x1Ea\x01\xE2V[\x80a\x0B(\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[4a\x0BaWa\x0BA6`\x04a\x01\xF0V[a\x0B]a\x0BLa\x16\x9BV[a\x0BTa\x01\xE2V[\x91\x82\x91\x82a\x02#V[\x03\x90\xF3[a\x01\xE8V[4a\x0B\x96Wa\x0Bv6`\x04a\x01\xF0V[a\x0B\x92a\x0B\x81a\x16\xB1V[a\x0B\x89a\x01\xE2V[\x91\x82\x91\x82a\x05\xD8V[\x03\x90\xF3[a\x01\xE8V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x0B\xB3W` \x80\x91\x02\x01\x90V[a\x06\xC7V[\x90\x92\x91\x92a\x0B\xCDa\x0B\xC8\x82a\x0B\x9BV[a\x07\x04V[\x93\x81\x85R` \x80\x86\x01\x92\x02\x83\x01\x92\x81\x84\x11a\x0C\nW\x91[\x83\x83\x10a\x0B\xF1WPPPPV[` \x80\x91a\x0B\xFF\x84\x86a\x03\x01V[\x81R\x01\x92\x01\x91a\x0B\xE4V[a\x077V[\x90\x80`\x1F\x83\x01\x12\x15a\x0C-W\x81` a\x0C*\x935\x91\x01a\x0B\xB8V[\x90V[a\x07\x19V[\x90` \x82\x82\x03\x12a\x0CbW_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x0C]Wa\x0CZ\x92\x01a\x0C\x0FV[\x90V[a\x02mV[a\x01\xECV[4a\x0C\x95Wa\x0C\x7Fa\x0Cz6`\x04a\x0C2V[a\x19JV[a\x0C\x87a\x01\xE2V[\x80a\x0C\x91\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x0C\xB2W` \x80\x91\x02\x01\x90V[a\x06\xC7V[\x90\x92\x91\x92a\x0C\xCCa\x0C\xC7\x82a\x0C\x9AV[a\x07\x04V[\x93\x81\x85R` \x80\x86\x01\x92\x02\x83\x01\x92\x81\x84\x11a\r\tW\x91[\x83\x83\x10a\x0C\xF0WPPPPV[` \x80\x91a\x0C\xFE\x84\x86a\x03\xADV[\x81R\x01\x92\x01\x91a\x0C\xE3V[a\x077V[\x90\x80`\x1F\x83\x01\x12\x15a\r,W\x81` a\r)\x935\x91\x01a\x0C\xB7V[\x90V[a\x07\x19V[\x91\x90\x91`@\x81\x84\x03\x12a\r\x89W_\x81\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\r\x84W\x83a\r]\x91\x83\x01a\x0C\x0FV[\x92` \x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\r\x7FWa\r|\x92\x01a\r\x0EV[\x90V[a\x02mV[a\x02mV[a\x01\xECV[4a\r\xBDWa\r\xA7a\r\xA16`\x04a\r1V[\x90a\x19\xA1V[a\r\xAFa\x01\xE2V[\x80a\r\xB9\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\r\xDE\x90a\x02\nV[\x90RV[\x90a\r\xEF\x81` \x93a\r\xD5V[\x01\x90V[` \x01\x90V[\x90a\x0E\x16a\x0E\x10a\x0E\t\x84a\r\xC2V[\x80\x93a\r\xC6V[\x92a\r\xCFV[\x90_[\x81\x81\x10a\x0E&WPPP\x90V[\x90\x91\x92a\x0E?a\x0E9`\x01\x92\x86Qa\r\xE2V[\x94a\r\xF3V[\x91\x01\x91\x90\x91a\x0E\x19V[a\x0E^\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\r\xF9V[\x90V[4a\x0E\x91Wa\x0Eq6`\x04a\x01\xF0V[a\x0E\x8Da\x0E|a\x1A\x90V[a\x0E\x84a\x01\xE2V[\x91\x82\x91\x82a\x0EIV[\x03\x90\xF3[a\x01\xE8V[\x90` \x82\x82\x03\x12a\x0E\xAFWa\x0E\xAC\x91_\x01a\x04\xFCV[\x90V[a\x01\xECV[4a\x0E\xE2Wa\x0E\xCCa\x0E\xC76`\x04a\x0E\x96V[a\x1B\x02V[a\x0E\xD4a\x01\xE2V[\x80a\x0E\xDE\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[4a\x0F\x15Wa\x0E\xFFa\x0E\xFA6`\x04a\x02\x97V[a\x1B\x0FV[a\x0F\x07a\x01\xE2V[\x80a\x0F\x11\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[\x90V[a\x0F1a\x0F,a\x0F6\x92a\x01\xFFV[a\x0F\x1AV[a\x01\xFFV[\x90V[a\x0FB\x90a\x0F\x1DV[\x90V[a\x0FN\x90a\x0F9V[\x90V[a\x0FZ\x90a\x0FEV[\x90RV[\x91\x90a\x0Fq\x90_` \x85\x01\x94\x01\x90a\x0FQV[V[4a\x0F\xA3Wa\x0F\x836`\x04a\x01\xF0V[a\x0F\x9Fa\x0F\x8Ea\x1B\xA4V[a\x0F\x96a\x01\xE2V[\x91\x82\x91\x82a\x0F^V[\x03\x90\xF3[a\x01\xE8V[a\x0F\xB1\x90a\x0F9V[\x90V[a\x0F\xBD\x90a\x0F\xA8V[\x90RV[\x91\x90a\x0F\xD4\x90_` \x85\x01\x94\x01\x90a\x0F\xB4V[V[4a\x10\x06Wa\x0F\xE66`\x04a\x01\xF0V[a\x10\x02a\x0F\xF1a\x1B\xEAV[a\x0F\xF9a\x01\xE2V[\x91\x82\x91\x82a\x0F\xC1V[\x03\x90\xF3[a\x01\xE8V[4a\x109Wa\x10#a\x10\x1E6`\x04a\x0E\x96V[a\x1CFV[a\x10+a\x01\xE2V[\x80a\x105\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[4a\x10lWa\x10Va\x10Q6`\x04a\x043V[a\x1C\x8CV[a\x10^a\x01\xE2V[\x80a\x10h\x81a\x02\xB5V[\x03\x90\xF3[a\x01\xE8V[_\x80\xFD[_\x90V[_\x1C\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x10\x95a\x10\x9A\x91a\x10yV[a\x10~V[\x90V[a\x10\xA7\x90Ta\x10\x89V[\x90V[a\x10\xB2a\x10uV[Pa\x10\xBD`\x08a\x10\x9DV[\x90V[_\x1B\x90V[\x90a\x10\xD1_\x19\x91a\x10\xC0V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x10\xEFa\x10\xEAa\x10\xF4\x92a\x02qV[a\x0F\x1AV[a\x02qV[\x90V[\x90V[\x90a\x11\x0Fa\x11\na\x11\x16\x92a\x10\xDBV[a\x10\xF7V[\x82Ta\x10\xC5V[\x90UV[a\x11%\x90`\x03a\x10\xFAV[V[a\x11]\x7F\xD3\xABL\xBE\x1BoQ\x9E\xB4?\t\xDE\xD1z\x12\xE8\x1B\x81\x1E)pc\xAD\xA2\xD6]\xDD\xEF[a,|\x91a\x11Ta\x01\xE2V[\x91\x82\x91\x82a\x02#V[\x03\x90\xA1V[\x90a\x11s`\x01\x80`\xA0\x1B\x03\x91a\x10\xC0V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x11\x86\x90a\x0F9V[\x90V[\x90V[\x90a\x11\xA1a\x11\x9Ca\x11\xA8\x92a\x11}V[a\x11\x89V[\x82Ta\x11bV[\x90UV[a\x11\xB7\x90`\x07a\x11\x8CV[V[\x90a\x11\xC5`\xFF\x91a\x10\xC0V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x11\xD8\x90a\x03\x94V[\x90V[\x90V[\x90a\x11\xF3a\x11\xEEa\x11\xFA\x92a\x11\xCFV[a\x11\xDBV[\x82Ta\x11\xB9V[\x90UV[a\x12\x08\x90_a\x11\xDEV[V[a\x12\x13\x90a\x04\rV[\x90V[a\x12\x1F\x90a\x10yV[\x90V[\x90a\x127a\x122a\x12>\x92a\x12\nV[a\x12\x16V[\x82Ta\x10\xC5V[\x90UV[a\x12M\x90`\x05a\x12\"V[V[_\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x12la\x12q\x91a\x10yV[a\x12SV[\x90V[a\x12~\x90Ta\x12`V[\x90V[a\x12\x89a\x12OV[Pa\x12\x94`\x04a\x12tV[\x90V[`@\x90a\x12\xC0a\x12\xC7\x94\x96\x95\x93\x96a\x12\xB6``\x84\x01\x98_\x85\x01\x90a\x04\x91V[` \x83\x01\x90a\x05\xCBV[\x01\x90a\x05\xCBV[V[a\x12\xFF\x7F\x8C\x8BxY\xBB\xC9i\xBE\xC9\x9A\xC5d\xF3\x7F\x81(\xE2\xDE\x9F\x85\xD3@\x08a9\xAD\x98\xA8\x85\x98\x95\x1B\x93a\x12\xF6a\x01\xE2V[\x93\x84\x93\x84a\x12\x97V[\x03\x90\xA1V[_\x90V[\x90V[a\x13\x17a\x13\x1C\x91a\x10yV[a\x13\x08V[\x90V[a\x13)\x90Ta\x13\x0BV[\x90V[PPPa\x137a\x13\x04V[Pa\x13B`\x05a\x13\x1FV[\x90V[`\xFF\x16\x90V[a\x13Wa\x13\\\x91a\x10yV[a\x13EV[\x90V[a\x13i\x90Ta\x13KV[\x90V[` \x91\x81R\x01\x90V[` \x7Fn hash\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FLegacy mode: no genesis assertio_\x82\x01R\x01RV[a\x13\xCF`&`@\x92a\x13lV[a\x13\xD8\x81a\x13uV[\x01\x90V[a\x13\xF1\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x13\xC2V[\x90V[\x15a\x13\xFBWV[a\x14\x03a\x01\xE2V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x14\x19`\x04\x82\x01a\x13\xDCV[\x03\x90\xFD[a\x14%a\x13\x04V[Pa\x14@a\x14;a\x145_a\x13_V[\x15a\x03\x94V[a\x13\xF4V[a\x14J`\x01a\x13\x1FV[\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x14da\x14i\x91a\x10yV[a\x14MV[\x90V[a\x14v\x90Ta\x14XV[\x90V[_\x80\xFD[`\xE0\x1B\x90V[_\x91\x03\x12a\x14\x8DWV[a\x01\xECV[\x91` a\x14\xB3\x92\x94\x93a\x14\xAC`@\x82\x01\x96_\x83\x01\x90a\ntV[\x01\x90a\x05\xCBV[V[a\x14\xBDa\x01\xE2V[=_\x82>=\x90\xFD[a\x14\xD7a\x14\xD2`\ta\x14lV[a\x0FEV[\x91cF\x8E\xFFP\x91\x90\x92\x80;\x15a\x15RWa\x15\x04_\x80\x94a\x15\x0Fa\x14\xF8a\x01\xE2V[\x97\x88\x96\x87\x95\x86\x94a\x14}V[\x84R`\x04\x84\x01a\x14\x92V[\x03\x92Z\xF1\x80\x15a\x15MWa\x15!W[PV[a\x15@\x90_=\x81\x11a\x15FW[a\x158\x81\x83a\x06\xDBV[\x81\x01\x90a\x14\x83V[_a\x15\x1EV[P=a\x15.V[a\x14\xB5V[a\x14yV[`@\x90a\x15\x80a\x15\x87\x94\x96\x95\x93\x96a\x15v``\x84\x01\x98_\x85\x01\x90a\x04\x91V[` \x83\x01\x90a\ntV[\x01\x90a\x05\xCBV[V[\x90\x92\x91P\x91\x90\x91a\x15\xC6\x7FHjs\xD3\x8B\x9A\xDF\xB3\xEC\x83\xA2\x01;\x18\xF5w\x1A\x94\x8Ffk\x03\x8E\x1B[\x03\xF8X\x8Ab\xCD\xD7\x93a\x15\xBDa\x01\xE2V[\x93\x84\x93\x84a\x15WV[\x03\x90\xA1V[_\x90V[a\x15\xD7a\x15\xCBV[P_\x90V[Pa\x16\x13\x7F6\xD6\tme\x86b\xBA\x82\xAE)\xE7m\xE7\xDA\xAB\"\xD6\xC3\xB26\x1A\x82\x94F\x07f\xA2\x8C\xF5\x05\xD5\x91a\x16\na\x01\xE2V[\x91\x82\x91\x82a\x05\xD8V[\x03\x90\xA1V[_\x90V[\x90V[a\x16+a\x160\x91a\x10yV[a\x16\x1CV[\x90V[a\x16=\x90Ta\x16\x1FV[\x90V[a\x16Ha\x16\x18V[Pa\x16S`\x03a\x163V[\x90V[\x7F\xA6\x9B\x97~\x94t\xB4T\xC0\xBE\x01\x918\xB2l\xD4m%\xE4\xE2\xFB\xCC\xF8# *\x0Bm{\xBD:$a\x16\x7Fa\x01\xE2V[\x80a\x16\x89\x81a\x02\xB5V[\x03\x90\xA1V[a\x16\x99\x90`\x02a\x12\"V[V[a\x16\xA3a\x10uV[Pa\x16\xAE`\x07a\x10\x9DV[\x90V[a\x16\xB9a\x13\x04V[Pa\x16\xC4`\x02a\x13\x1FV[\x90V[T\x90V[`\x01\x90\x81\x80\x03\x01\x04\x90V[_R` _ \x90V[\x1B\x90V[\x91\x90`\x08a\x16\xFE\x91\x02\x91a\x16\xF8_\x19\x84a\x16\xDFV[\x92a\x16\xDFV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\x17\x1Ea\x17\x19a\x17&\x93a\x10\xDBV[a\x10\xF7V[\x90\x83Ta\x16\xE3V[\x90UV[a\x17<\x91a\x176a\x16\x18V[\x91a\x17\x08V[V[[\x81\x81\x10a\x17JWPPV[\x80a\x17W_`\x01\x93a\x17*V[\x01a\x17?V[\x90\x91\x82\x81\x10a\x17lW[PPPV[a\x17\x8Aa\x17\x84a\x17~a\x17\x95\x95a\x16\xCBV[\x92a\x16\xCBV[\x92a\x16\xD6V[\x91\x82\x01\x91\x01\x90a\x17>V[_\x80\x80a\x17gV[\x90h\x01\0\0\0\0\0\0\0\0\x81\x11a\x17\xC6W\x81a\x17\xBBa\x17\xC4\x93a\x16\xC7V[\x90\x82\x81Ua\x17]V[V[a\x06\xC7V[a\x17\xD5\x90Qa\x02\nV[\x90V[a\x17\xE1\x82a\r\xC2V[\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x18DWa\x18\x0Fa\x18\t`\x01\x92a\x18\x04\x86\x86a\x17\x9DV[a\r\xCFV[\x92a\x16\xD6V[\x92\x04\x91_[\x83\x81\x10a\x18!WPPPPV[`\x01\x90` a\x187a\x182\x86a\x17\xCBV[a\x11\x89V[\x94\x01\x93\x81\x84\x01U\x01a\x18\x14V[a\x06\xC7V[\x90a\x18S\x91a\x17\xD8V[V[\x90a\x18ga\x18b\x83a\x0C\x9AV[a\x07\x04V[\x91\x82RV[6\x907V[\x90a\x18\x96a\x18~\x83a\x18UV[\x92` \x80a\x18\x8C\x86\x93a\x0C\x9AV[\x92\x01\x91\x03\x90a\x18lV[V[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\x18\xB4\x90a\x03\x94V[\x90RV[\x90a\x18\xC5\x81` \x93a\x18\xABV[\x01\x90V[` \x01\x90V[\x90a\x18\xECa\x18\xE6a\x18\xDF\x84a\x18\x98V[\x80\x93a\x18\x9CV[\x92a\x18\xA5V[\x90_[\x81\x81\x10a\x18\xFCWPPP\x90V[\x90\x91\x92a\x19\x15a\x19\x0F`\x01\x92\x86Qa\x18\xB8V[\x94a\x18\xC9V[\x91\x01\x91\x90\x91a\x18\xEFV[\x90\x91a\x199a\x19G\x93`@\x84\x01\x90\x84\x82\x03_\x86\x01Ra\r\xF9V[\x91` \x81\x84\x03\x91\x01Ra\x18\xCFV[\x90V[a\x19U\x81`\x06a\x18IV[a\x19fa\x19a\x82a\r\xC2V[a\x18qV[\x7F\r\x96\x90\xF9qe\xF3Y\x91\xAE`\xD2\xA9~\x04\xAF\xF4r\xC0\x87)r*\x926\xFF\x1B\xC8\xB9\xBA\x90\xC0\x91a\x19\x9Ca\x19\x93a\x01\xE2V[\x92\x83\x92\x83a\x19\x1FV[\x03\x90\xA1V[\x90\x7F\r\x96\x90\xF9qe\xF3Y\x91\xAE`\xD2\xA9~\x04\xAF\xF4r\xC0\x87)r*\x926\xFF\x1B\xC8\xB9\xBA\x90\xC0\x91a\x19\xD8a\x19\xCFa\x01\xE2V[\x92\x83\x92\x83a\x19\x1FV[\x03\x90\xA1V[``\x90V[` \x91\x81R\x01\x90V[a\x19\xF5\x90Ta\x10\x89V[\x90V[`\x01\x01\x90V[\x90a\x1A\x1Ba\x1A\x15a\x1A\x0E\x84a\x16\xC7V[\x80\x93a\x19\xE2V[\x92a\x16\xD6V[\x90_[\x81\x81\x10a\x1A+WPPP\x90V[\x90\x91\x92a\x1AKa\x1AE`\x01\x92a\x1A@\x87a\x19\xEBV[a\r\xE2V[\x94a\x19\xF8V[\x91\x01\x91\x90\x91a\x1A\x1EV[\x90a\x1A_\x91a\x19\xFEV[\x90V[\x90a\x1A\x82a\x1A{\x92a\x1Ara\x01\xE2V[\x93\x84\x80\x92a\x1AUV[\x03\x83a\x06\xDBV[V[a\x1A\x8D\x90a\x1AbV[\x90V[a\x1A\x98a\x19\xDDV[Pa\x1A\xA3`\x06a\x1A\x84V[\x90V[\x90a\x1A\xB9g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x10\xC0V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1A\xD7a\x1A\xD2a\x1A\xDC\x92a\x04\x84V[a\x0F\x1AV[a\x04\x84V[\x90V[\x90V[\x90a\x1A\xF7a\x1A\xF2a\x1A\xFE\x92a\x1A\xC3V[a\x1A\xDFV[\x82Ta\x1A\xA6V[\x90UV[a\x1B\r\x90`\x04a\x1A\xE2V[V[a\x1B!a\x1B\x1C`\ta\x14lV[a\x0FEV[\x90c\xD2\x02\xDE\xAA\x90\x82;\x15a\x1B\x9BWa\x1BX\x92a\x1BM_\x80\x94a\x1BAa\x01\xE2V[\x96\x87\x95\x86\x94\x85\x93a\x14}V[\x83R`\x04\x83\x01a\n\x81V[\x03\x92Z\xF1\x80\x15a\x1B\x96Wa\x1BjW[PV[a\x1B\x89\x90_=\x81\x11a\x1B\x8FW[a\x1B\x81\x81\x83a\x06\xDBV[\x81\x01\x90a\x14\x83V[_a\x1BgV[P=a\x1BwV[a\x14\xB5V[a\x14yV[_\x90V[a\x1B\xACa\x1B\xA0V[Pa\x1B\xB7`\ta\x14lV[\x90V[_\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x1B\xD5a\x1B\xDA\x91a\x10yV[a\x1B\xBEV[\x90V[a\x1B\xE7\x90Ta\x1B\xC9V[\x90V[a\x1B\xF2a\x1B\xBAV[Pa\x1B\xFD`\na\x1B\xDDV[\x90V[`\xA0\x1B\x90V[\x90a\x1C\x1Cg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA0\x1B\x91a\x1C\0V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x1C;a\x1C6a\x1CB\x92a\x1A\xC3V[a\x1A\xDFV[\x82Ta\x1C\x06V[\x90UV[a\x1CQ\x81`\x08a\x1C&V[a\x1C\x87\x7Fw\xBB|\xC2r!\x14\xE0\x17\x1B\xCB\xD5\xE7\x87Q\t\x81I\r\x07d\xC5\xFC\x10\xB9|I\xB0\xB8/$\xD6\x91a\x1C~a\x01\xE2V[\x91\x82\x91\x82a\x04\x9EV[\x03\x90\xA1V[a\x1C\x97\x90`\x01a\x12\"V[V",
    );
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MachineStatus(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<MachineStatus> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl MachineStatus {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for MachineStatus {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for MachineStatus {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    /**```solidity
struct Assertion { ExecutionState beforeState; ExecutionState afterState; uint64 numBlocks; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Assertion {
        #[allow(missing_docs)]
        pub beforeState: <ExecutionState as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub afterState: <ExecutionState as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub numBlocks: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ExecutionState,
            ExecutionState,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <ExecutionState as alloy::sol_types::SolType>::RustType,
            <ExecutionState as alloy::sol_types::SolType>::RustType,
            u64,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Assertion> for UnderlyingRustTuple<'_> {
            fn from(value: Assertion) -> Self {
                (value.beforeState, value.afterState, value.numBlocks)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Assertion {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    beforeState: tuple.0,
                    afterState: tuple.1,
                    numBlocks: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Assertion {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Assertion {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <ExecutionState as alloy_sol_types::SolType>::tokenize(
                        &self.beforeState,
                    ),
                    <ExecutionState as alloy_sol_types::SolType>::tokenize(
                        &self.afterState,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBlocks),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Assertion {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Assertion {
            const NAME: &'static str = "Assertion";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Assertion(ExecutionState beforeState,ExecutionState afterState,uint64 numBlocks)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(2);
                components
                    .push(
                        <ExecutionState as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <ExecutionState as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
                    .push(
                        <ExecutionState as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <ExecutionState as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <ExecutionState as alloy_sol_types::SolType>::eip712_data_word(
                            &self.beforeState,
                        )
                        .0,
                    <ExecutionState as alloy_sol_types::SolType>::eip712_data_word(
                            &self.afterState,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.numBlocks)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Assertion {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <ExecutionState as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.beforeState,
                    )
                    + <ExecutionState as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.afterState,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.numBlocks,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <ExecutionState as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.beforeState,
                    out,
                );
                <ExecutionState as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.afterState,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.numBlocks,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct AssertionInputs { BeforeStateData beforeStateData; AssertionState beforeState; AssertionState afterState; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssertionInputs {
        #[allow(missing_docs)]
        pub beforeStateData: <BeforeStateData as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub beforeState: <AssertionState as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub afterState: <AssertionState as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (BeforeStateData, AssertionState, AssertionState);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <BeforeStateData as alloy::sol_types::SolType>::RustType,
            <AssertionState as alloy::sol_types::SolType>::RustType,
            <AssertionState as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssertionInputs> for UnderlyingRustTuple<'_> {
            fn from(value: AssertionInputs) -> Self {
                (value.beforeStateData, value.beforeState, value.afterState)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssertionInputs {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    beforeStateData: tuple.0,
                    beforeState: tuple.1,
                    afterState: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for AssertionInputs {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for AssertionInputs {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <BeforeStateData as alloy_sol_types::SolType>::tokenize(
                        &self.beforeStateData,
                    ),
                    <AssertionState as alloy_sol_types::SolType>::tokenize(
                        &self.beforeState,
                    ),
                    <AssertionState as alloy_sol_types::SolType>::tokenize(
                        &self.afterState,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for AssertionInputs {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for AssertionInputs {
            const NAME: &'static str = "AssertionInputs";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "AssertionInputs(BeforeStateData beforeStateData,AssertionState beforeState,AssertionState afterState)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(3);
                components
                    .push(
                        <BeforeStateData as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BeforeStateData as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
                    .push(
                        <AssertionState as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <AssertionState as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
                    .push(
                        <AssertionState as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <AssertionState as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <BeforeStateData as alloy_sol_types::SolType>::eip712_data_word(
                            &self.beforeStateData,
                        )
                        .0,
                    <AssertionState as alloy_sol_types::SolType>::eip712_data_word(
                            &self.beforeState,
                        )
                        .0,
                    <AssertionState as alloy_sol_types::SolType>::eip712_data_word(
                            &self.afterState,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for AssertionInputs {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <BeforeStateData as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.beforeStateData,
                    )
                    + <AssertionState as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.beforeState,
                    )
                    + <AssertionState as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.afterState,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <BeforeStateData as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.beforeStateData,
                    out,
                );
                <AssertionState as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.beforeState,
                    out,
                );
                <AssertionState as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.afterState,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct AssertionState { GlobalState globalState; MachineStatus machineStatus; bytes32 endHistoryRoot; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssertionState {
        #[allow(missing_docs)]
        pub globalState: <GlobalState as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub machineStatus: <MachineStatus as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            GlobalState,
            MachineStatus,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <GlobalState as alloy::sol_types::SolType>::RustType,
            <MachineStatus as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssertionState> for UnderlyingRustTuple<'_> {
            fn from(value: AssertionState) -> Self {
                (value.globalState, value.machineStatus, value.endHistoryRoot)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssertionState {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    globalState: tuple.0,
                    machineStatus: tuple.1,
                    endHistoryRoot: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for AssertionState {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for AssertionState {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <GlobalState as alloy_sol_types::SolType>::tokenize(
                        &self.globalState,
                    ),
                    <MachineStatus as alloy_sol_types::SolType>::tokenize(
                        &self.machineStatus,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHistoryRoot),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for AssertionState {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for AssertionState {
            const NAME: &'static str = "AssertionState";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "AssertionState(GlobalState globalState,uint8 machineStatus,bytes32 endHistoryRoot)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <GlobalState as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <GlobalState as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <GlobalState as alloy_sol_types::SolType>::eip712_data_word(
                            &self.globalState,
                        )
                        .0,
                    <MachineStatus as alloy_sol_types::SolType>::eip712_data_word(
                            &self.machineStatus,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.endHistoryRoot,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for AssertionState {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <GlobalState as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.globalState,
                    )
                    + <MachineStatus as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.machineStatus,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.endHistoryRoot,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <GlobalState as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.globalState,
                    out,
                );
                <MachineStatus as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.machineStatus,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.endHistoryRoot,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct BeforeStateData { bytes32 prevPrevAssertionHash; bytes32 sequencerBatchAcc; ConfigData configData; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BeforeStateData {
        #[allow(missing_docs)]
        pub prevPrevAssertionHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sequencerBatchAcc: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub configData: <ConfigData as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            ConfigData,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            <ConfigData as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BeforeStateData> for UnderlyingRustTuple<'_> {
            fn from(value: BeforeStateData) -> Self {
                (value.prevPrevAssertionHash, value.sequencerBatchAcc, value.configData)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BeforeStateData {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    prevPrevAssertionHash: tuple.0,
                    sequencerBatchAcc: tuple.1,
                    configData: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BeforeStateData {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BeforeStateData {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.prevPrevAssertionHash,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.sequencerBatchAcc),
                    <ConfigData as alloy_sol_types::SolType>::tokenize(&self.configData),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BeforeStateData {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BeforeStateData {
            const NAME: &'static str = "BeforeStateData";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BeforeStateData(bytes32 prevPrevAssertionHash,bytes32 sequencerBatchAcc,ConfigData configData)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <ConfigData as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <ConfigData as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.prevPrevAssertionHash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sequencerBatchAcc,
                        )
                        .0,
                    <ConfigData as alloy_sol_types::SolType>::eip712_data_word(
                            &self.configData,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BeforeStateData {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.prevPrevAssertionHash,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sequencerBatchAcc,
                    )
                    + <ConfigData as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.configData,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.prevPrevAssertionHash,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sequencerBatchAcc,
                    out,
                );
                <ConfigData as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.configData,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ConfigData { bytes32 wasmModuleRoot; uint256 requiredStake; address challengeManager; uint64 confirmPeriodBlocks; uint64 nextInboxPosition; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ConfigData {
        #[allow(missing_docs)]
        pub wasmModuleRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub requiredStake: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub challengeManager: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub confirmPeriodBlocks: u64,
        #[allow(missing_docs)]
        pub nextInboxPosition: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            u64,
            u64,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ConfigData> for UnderlyingRustTuple<'_> {
            fn from(value: ConfigData) -> Self {
                (
                    value.wasmModuleRoot,
                    value.requiredStake,
                    value.challengeManager,
                    value.confirmPeriodBlocks,
                    value.nextInboxPosition,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ConfigData {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    wasmModuleRoot: tuple.0,
                    requiredStake: tuple.1,
                    challengeManager: tuple.2,
                    confirmPeriodBlocks: tuple.3,
                    nextInboxPosition: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ConfigData {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ConfigData {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.wasmModuleRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.requiredStake),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.challengeManager,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.confirmPeriodBlocks),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.nextInboxPosition),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ConfigData {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ConfigData {
            const NAME: &'static str = "ConfigData";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ConfigData(bytes32 wasmModuleRoot,uint256 requiredStake,address challengeManager,uint64 confirmPeriodBlocks,uint64 nextInboxPosition)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.wasmModuleRoot,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.requiredStake)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.challengeManager,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.confirmPeriodBlocks,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.nextInboxPosition,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ConfigData {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.wasmModuleRoot,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.requiredStake,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.challengeManager,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.confirmPeriodBlocks,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.nextInboxPosition,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.wasmModuleRoot,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.requiredStake,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.challengeManager,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.confirmPeriodBlocks,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nextInboxPosition,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExecutionState { GlobalState globalState; MachineStatus machineStatus; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExecutionState {
        #[allow(missing_docs)]
        pub globalState: <GlobalState as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub machineStatus: <MachineStatus as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (GlobalState, MachineStatus);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <GlobalState as alloy::sol_types::SolType>::RustType,
            <MachineStatus as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExecutionState> for UnderlyingRustTuple<'_> {
            fn from(value: ExecutionState) -> Self {
                (value.globalState, value.machineStatus)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExecutionState {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    globalState: tuple.0,
                    machineStatus: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExecutionState {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ExecutionState {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <GlobalState as alloy_sol_types::SolType>::tokenize(
                        &self.globalState,
                    ),
                    <MachineStatus as alloy_sol_types::SolType>::tokenize(
                        &self.machineStatus,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExecutionState {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExecutionState {
            const NAME: &'static str = "ExecutionState";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExecutionState(GlobalState globalState,uint8 machineStatus)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <GlobalState as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <GlobalState as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <GlobalState as alloy_sol_types::SolType>::eip712_data_word(
                            &self.globalState,
                        )
                        .0,
                    <MachineStatus as alloy_sol_types::SolType>::eip712_data_word(
                            &self.machineStatus,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExecutionState {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <GlobalState as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.globalState,
                    )
                    + <MachineStatus as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.machineStatus,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <GlobalState as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.globalState,
                    out,
                );
                <MachineStatus as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.machineStatus,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct GlobalState { bytes32[2] bytes32Vals; uint64[2] u64Vals; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GlobalState {
        #[allow(missing_docs)]
        pub bytes32Vals: [alloy::sol_types::private::FixedBytes<32>; 2usize],
        #[allow(missing_docs)]
        pub u64Vals: [u64; 2usize],
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedArray<
                alloy::sol_types::sol_data::FixedBytes<32>,
                2usize,
            >,
            alloy::sol_types::sol_data::FixedArray<
                alloy::sol_types::sol_data::Uint<64>,
                2usize,
            >,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            [alloy::sol_types::private::FixedBytes<32>; 2usize],
            [u64; 2usize],
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<GlobalState> for UnderlyingRustTuple<'_> {
            fn from(value: GlobalState) -> Self {
                (value.bytes32Vals, value.u64Vals)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for GlobalState {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    bytes32Vals: tuple.0,
                    u64Vals: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for GlobalState {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for GlobalState {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.bytes32Vals),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<64>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.u64Vals),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for GlobalState {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for GlobalState {
            const NAME: &'static str = "GlobalState";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "GlobalState(bytes32[2] bytes32Vals,uint64[2] u64Vals)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                        2usize,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.bytes32Vals)
                        .0,
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<64>,
                        2usize,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.u64Vals)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for GlobalState {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                        2usize,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.bytes32Vals,
                    )
                    + <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<64>,
                        2usize,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.u64Vals,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                    2usize,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.bytes32Vals,
                    out,
                );
                <alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<64>,
                    2usize,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.u64Vals,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Event with signature `AnyTrustFastConfirmerSet(address)` and selector `0xd3ab4cbe1b6f519eb43f09ded17a12e81b811e297063ada2d65dddef5b612c7c`.
```solidity
event AnyTrustFastConfirmerSet(address confimer);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct AnyTrustFastConfirmerSet {
        #[allow(missing_docs)]
        pub confimer: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for AnyTrustFastConfirmerSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "AnyTrustFastConfirmerSet(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                211u8,
                171u8,
                76u8,
                190u8,
                27u8,
                111u8,
                81u8,
                158u8,
                180u8,
                63u8,
                9u8,
                222u8,
                209u8,
                122u8,
                18u8,
                232u8,
                27u8,
                129u8,
                30u8,
                41u8,
                112u8,
                99u8,
                173u8,
                162u8,
                214u8,
                93u8,
                221u8,
                239u8,
                91u8,
                97u8,
                44u8,
                124u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { confimer: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.confimer,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for AnyTrustFastConfirmerSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&AnyTrustFastConfirmerSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &AnyTrustFastConfirmerSet,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `FastConfirmNewAssertionCalled(bytes32)` and selector `0x36d6096d658662ba82ae29e76de7daab22d6c3b2361a8294460766a28cf505d5`.
```solidity
event FastConfirmNewAssertionCalled(bytes32 expectedAssertionHash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct FastConfirmNewAssertionCalled {
        #[allow(missing_docs)]
        pub expectedAssertionHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for FastConfirmNewAssertionCalled {
            type DataTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "FastConfirmNewAssertionCalled(bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                54u8,
                214u8,
                9u8,
                109u8,
                101u8,
                134u8,
                98u8,
                186u8,
                130u8,
                174u8,
                41u8,
                231u8,
                109u8,
                231u8,
                218u8,
                171u8,
                34u8,
                214u8,
                195u8,
                178u8,
                54u8,
                26u8,
                130u8,
                148u8,
                70u8,
                7u8,
                102u8,
                162u8,
                140u8,
                245u8,
                5u8,
                213u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    expectedAssertionHash: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.expectedAssertionHash,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for FastConfirmNewAssertionCalled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&FastConfirmNewAssertionCalled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &FastConfirmNewAssertionCalled,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ForceConfirmNodeCalled(uint64,bytes32,bytes32)` and selector `0x8c8b7859bbc969bec99ac564f37f8128e2de9f85d340086139ad98a88598951b`.
```solidity
event ForceConfirmNodeCalled(uint64 nodeNum, bytes32 blockHash, bytes32 sendRoot);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ForceConfirmNodeCalled {
        #[allow(missing_docs)]
        pub nodeNum: u64,
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sendRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ForceConfirmNodeCalled {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ForceConfirmNodeCalled(uint64,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                140u8,
                139u8,
                120u8,
                89u8,
                187u8,
                201u8,
                105u8,
                190u8,
                201u8,
                154u8,
                197u8,
                100u8,
                243u8,
                127u8,
                129u8,
                40u8,
                226u8,
                222u8,
                159u8,
                133u8,
                211u8,
                64u8,
                8u8,
                97u8,
                57u8,
                173u8,
                152u8,
                168u8,
                133u8,
                152u8,
                149u8,
                27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    nodeNum: data.0,
                    blockHash: data.1,
                    sendRoot: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.nodeNum),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.sendRoot),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ForceConfirmNodeCalled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ForceConfirmNodeCalled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ForceConfirmNodeCalled) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ForceCreateNodeCalled(uint64,uint256,bytes32)` and selector `0x486a73d38b9adfb3ec83a2013b18f5771a948f666b038e1b5b03f8588a62cdd7`.
```solidity
event ForceCreateNodeCalled(uint64 prevNode, uint256 prevNodeInboxMaxCount, bytes32 expectedNodeHash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ForceCreateNodeCalled {
        #[allow(missing_docs)]
        pub prevNode: u64,
        #[allow(missing_docs)]
        pub prevNodeInboxMaxCount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub expectedNodeHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ForceCreateNodeCalled {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ForceCreateNodeCalled(uint64,uint256,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                72u8,
                106u8,
                115u8,
                211u8,
                139u8,
                154u8,
                223u8,
                179u8,
                236u8,
                131u8,
                162u8,
                1u8,
                59u8,
                24u8,
                245u8,
                119u8,
                26u8,
                148u8,
                143u8,
                102u8,
                107u8,
                3u8,
                142u8,
                27u8,
                91u8,
                3u8,
                248u8,
                88u8,
                138u8,
                98u8,
                205u8,
                215u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    prevNode: data.0,
                    prevNodeInboxMaxCount: data.1,
                    expectedNodeHash: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.prevNode),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.prevNodeInboxMaxCount,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.expectedNodeHash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ForceCreateNodeCalled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ForceCreateNodeCalled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ForceCreateNodeCalled) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RolePaused()` and selector `0xa69b977e9474b454c0be019138b26cd46d25e4e2fbccf823202a0b6d7bbd3a24`.
```solidity
event RolePaused();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RolePaused {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RolePaused {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "RolePaused()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                166u8,
                155u8,
                151u8,
                126u8,
                148u8,
                116u8,
                180u8,
                84u8,
                192u8,
                190u8,
                1u8,
                145u8,
                56u8,
                178u8,
                108u8,
                212u8,
                109u8,
                37u8,
                228u8,
                226u8,
                251u8,
                204u8,
                248u8,
                35u8,
                32u8,
                42u8,
                11u8,
                109u8,
                123u8,
                189u8,
                58u8,
                36u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RolePaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RolePaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RolePaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ValidatorAfkBlocksSet(uint64)` and selector `0x77bb7cc2722114e0171bcbd5e787510981490d0764c5fc10b97c49b0b82f24d6`.
```solidity
event ValidatorAfkBlocksSet(uint64 blocks);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ValidatorAfkBlocksSet {
        #[allow(missing_docs)]
        pub blocks: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ValidatorAfkBlocksSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ValidatorAfkBlocksSet(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                119u8,
                187u8,
                124u8,
                194u8,
                114u8,
                33u8,
                20u8,
                224u8,
                23u8,
                27u8,
                203u8,
                213u8,
                231u8,
                135u8,
                81u8,
                9u8,
                129u8,
                73u8,
                13u8,
                7u8,
                100u8,
                197u8,
                252u8,
                16u8,
                185u8,
                124u8,
                73u8,
                176u8,
                184u8,
                47u8,
                36u8,
                214u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { blocks: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blocks),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ValidatorAfkBlocksSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ValidatorAfkBlocksSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ValidatorAfkBlocksSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ValidatorsSet(address[],bool[])` and selector `0x0d9690f97165f35991ae60d2a97e04aff472c08729722a9236ff1bc8b9ba90c0`.
```solidity
event ValidatorsSet(address[] validators, bool[] values);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ValidatorsSet {
        #[allow(missing_docs)]
        pub validators: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
        #[allow(missing_docs)]
        pub values: alloy::sol_types::private::Vec<bool>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ValidatorsSet {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ValidatorsSet(address[],bool[])";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                13u8,
                150u8,
                144u8,
                249u8,
                113u8,
                101u8,
                243u8,
                89u8,
                145u8,
                174u8,
                96u8,
                210u8,
                169u8,
                126u8,
                4u8,
                175u8,
                244u8,
                114u8,
                192u8,
                135u8,
                41u8,
                114u8,
                42u8,
                146u8,
                54u8,
                255u8,
                27u8,
                200u8,
                185u8,
                186u8,
                144u8,
                192u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    validators: data.0,
                    values: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.validators),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bool,
                    > as alloy_sol_types::SolType>::tokenize(&self.values),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ValidatorsSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ValidatorsSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ValidatorsSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Function with signature `baseStake()` and selector `0x76e7e23b`.
```solidity
function baseStake() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct baseStakeCall {}
    ///Container type for the return parameters of the [`baseStake()`](baseStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct baseStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<baseStakeCall> for UnderlyingRustTuple<'_> {
                fn from(value: baseStakeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for baseStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<baseStakeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: baseStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for baseStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for baseStakeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = baseStakeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "baseStake()";
            const SELECTOR: [u8; 4] = [118u8, 231u8, 226u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridge()` and selector `0xe78cea92`.
```solidity
function bridge() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeCall {}
    ///Container type for the return parameters of the [`bridge()`](bridgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridge()";
            const SELECTOR: [u8; 4] = [231u8, 140u8, 234u8, 146u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `challengeManager()` and selector `0x023a96fe`.
```solidity
function challengeManager() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeManagerCall {}
    ///Container type for the return parameters of the [`challengeManager()`](challengeManagerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeManagerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeManagerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeManagerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeManagerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeManagerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeManagerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeManagerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for challengeManagerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = challengeManagerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "challengeManager()";
            const SELECTOR: [u8; 4] = [2u8, 58u8, 150u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `computeAssertionHash(bytes32,((bytes32[2],uint64[2]),uint8,bytes32),bytes32)` and selector `0x33635fc2`.
```solidity
function computeAssertionHash(bytes32, AssertionState memory, bytes32) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct computeAssertionHashCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub _1: <AssertionState as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub _2: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`computeAssertionHash(bytes32,((bytes32[2],uint64[2]),uint8,bytes32),bytes32)`](computeAssertionHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct computeAssertionHashReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                AssertionState,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                <AssertionState as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<computeAssertionHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: computeAssertionHashCall) -> Self {
                    (value._0, value._1, value._2)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for computeAssertionHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                        _2: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<computeAssertionHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: computeAssertionHashReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for computeAssertionHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for computeAssertionHashCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                AssertionState,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = computeAssertionHashReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "computeAssertionHash(bytes32,((bytes32[2],uint64[2]),uint8,bytes32),bytes32)";
            const SELECTOR: [u8; 4] = [51u8, 99u8, 95u8, 194u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <AssertionState as alloy_sol_types::SolType>::tokenize(&self._1),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._2),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `confirmPeriodBlocks()` and selector `0x2e7acfa6`.
```solidity
function confirmPeriodBlocks() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct confirmPeriodBlocksCall {}
    ///Container type for the return parameters of the [`confirmPeriodBlocks()`](confirmPeriodBlocksCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct confirmPeriodBlocksReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<confirmPeriodBlocksCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: confirmPeriodBlocksCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for confirmPeriodBlocksCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<confirmPeriodBlocksReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: confirmPeriodBlocksReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for confirmPeriodBlocksReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for confirmPeriodBlocksCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = confirmPeriodBlocksReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "confirmPeriodBlocks()";
            const SELECTOR: [u8; 4] = [46u8, 122u8, 207u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `fastConfirmNewAssertion(((bytes32,bytes32,(bytes32,uint256,address,uint64,uint64)),((bytes32[2],uint64[2]),uint8,bytes32),((bytes32[2],uint64[2]),uint8,bytes32)),bytes32)` and selector `0x6420fb9f`.
```solidity
function fastConfirmNewAssertion(AssertionInputs memory, bytes32 expectedAssertionHash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fastConfirmNewAssertionCall {
        #[allow(missing_docs)]
        pub _0: <AssertionInputs as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub expectedAssertionHash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`fastConfirmNewAssertion(((bytes32,bytes32,(bytes32,uint256,address,uint64,uint64)),((bytes32[2],uint64[2]),uint8,bytes32),((bytes32[2],uint64[2]),uint8,bytes32)),bytes32)`](fastConfirmNewAssertionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fastConfirmNewAssertionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                AssertionInputs,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <AssertionInputs as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fastConfirmNewAssertionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: fastConfirmNewAssertionCall) -> Self {
                    (value._0, value.expectedAssertionHash)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for fastConfirmNewAssertionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        expectedAssertionHash: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fastConfirmNewAssertionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: fastConfirmNewAssertionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for fastConfirmNewAssertionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fastConfirmNewAssertionCall {
            type Parameters<'a> = (
                AssertionInputs,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = fastConfirmNewAssertionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fastConfirmNewAssertion(((bytes32,bytes32,(bytes32,uint256,address,uint64,uint64)),((bytes32[2],uint64[2]),uint8,bytes32),((bytes32[2],uint64[2]),uint8,bytes32)),bytes32)";
            const SELECTOR: [u8; 4] = [100u8, 32u8, 251u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <AssertionInputs as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.expectedAssertionHash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `forceConfirmNode(uint64,bytes32,bytes32)` and selector `0x2f7968e8`.
```solidity
function forceConfirmNode(uint64 nodeNum, bytes32 blockHash, bytes32 sendRoot) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct forceConfirmNodeCall {
        #[allow(missing_docs)]
        pub nodeNum: u64,
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sendRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`forceConfirmNode(uint64,bytes32,bytes32)`](forceConfirmNodeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct forceConfirmNodeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u64,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<forceConfirmNodeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: forceConfirmNodeCall) -> Self {
                    (value.nodeNum, value.blockHash, value.sendRoot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for forceConfirmNodeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        nodeNum: tuple.0,
                        blockHash: tuple.1,
                        sendRoot: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<forceConfirmNodeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: forceConfirmNodeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for forceConfirmNodeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for forceConfirmNodeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = forceConfirmNodeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "forceConfirmNode(uint64,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [47u8, 121u8, 104u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.nodeNum),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.sendRoot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `forceCreateNode(uint64,uint256,(((bytes32[2],uint64[2]),uint8),((bytes32[2],uint64[2]),uint8),uint64),bytes32)` and selector `0x470dce4e`.
```solidity
function forceCreateNode(uint64 prevNode, uint256 prevNodeInboxMaxCount, Assertion memory, bytes32 expectedNodeHash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct forceCreateNodeCall {
        #[allow(missing_docs)]
        pub prevNode: u64,
        #[allow(missing_docs)]
        pub prevNodeInboxMaxCount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _2: <Assertion as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub expectedNodeHash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`forceCreateNode(uint64,uint256,(((bytes32[2],uint64[2]),uint8),((bytes32[2],uint64[2]),uint8),uint64),bytes32)`](forceCreateNodeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct forceCreateNodeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                Assertion,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u64,
                alloy::sol_types::private::primitives::aliases::U256,
                <Assertion as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<forceCreateNodeCall> for UnderlyingRustTuple<'_> {
                fn from(value: forceCreateNodeCall) -> Self {
                    (
                        value.prevNode,
                        value.prevNodeInboxMaxCount,
                        value._2,
                        value.expectedNodeHash,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for forceCreateNodeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        prevNode: tuple.0,
                        prevNodeInboxMaxCount: tuple.1,
                        _2: tuple.2,
                        expectedNodeHash: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<forceCreateNodeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: forceCreateNodeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for forceCreateNodeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for forceCreateNodeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                Assertion,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = forceCreateNodeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "forceCreateNode(uint64,uint256,(((bytes32[2],uint64[2]),uint8),((bytes32[2],uint64[2]),uint8),uint64),bytes32)";
            const SELECTOR: [u8; 4] = [71u8, 13u8, 206u8, 78u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.prevNode),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.prevNodeInboxMaxCount,
                    ),
                    <Assertion as alloy_sol_types::SolType>::tokenize(&self._2),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.expectedNodeHash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `genesisAssertionHash()` and selector `0x353325e0`.
```solidity
function genesisAssertionHash() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct genesisAssertionHashCall {}
    ///Container type for the return parameters of the [`genesisAssertionHash()`](genesisAssertionHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct genesisAssertionHashReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<genesisAssertionHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: genesisAssertionHashCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for genesisAssertionHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<genesisAssertionHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: genesisAssertionHashReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for genesisAssertionHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for genesisAssertionHashCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = genesisAssertionHashReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "genesisAssertionHash()";
            const SELECTOR: [u8; 4] = [53u8, 51u8, 37u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getValidators()` and selector `0xb7ab4db5`.
```solidity
function getValidators() external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getValidatorsCall {}
    ///Container type for the return parameters of the [`getValidators()`](getValidatorsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getValidatorsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getValidatorsCall> for UnderlyingRustTuple<'_> {
                fn from(value: getValidatorsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getValidatorsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getValidatorsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getValidatorsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getValidatorsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getValidatorsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getValidatorsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getValidators()";
            const SELECTOR: [u8; 4] = [183u8, 171u8, 77u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall {}
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pause()` and selector `0x8456cb59`.
```solidity
function pause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseCall {}
    ///Container type for the return parameters of the [`pause()`](pauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause()";
            const SELECTOR: [u8; 4] = [132u8, 86u8, 203u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `paused()` and selector `0x5c975abb`.
```solidity
function paused() external pure returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedCall {}
    ///Container type for the return parameters of the [`paused()`](pausedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedCall> for UnderlyingRustTuple<'_> {
                fn from(value: pausedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pausedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pausedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pausedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sequencerInbox()` and selector `0xee35f327`.
```solidity
function sequencerInbox() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sequencerInboxCall {}
    ///Container type for the return parameters of the [`sequencerInbox()`](sequencerInboxCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sequencerInboxReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sequencerInboxCall> for UnderlyingRustTuple<'_> {
                fn from(value: sequencerInboxCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sequencerInboxCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sequencerInboxReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: sequencerInboxReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sequencerInboxReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sequencerInboxCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sequencerInboxReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sequencerInbox()";
            const SELECTOR: [u8; 4] = [238u8, 53u8, 243u8, 39u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setAnyTrustFastConfirmer(address)` and selector `0x0d561b37`.
```solidity
function setAnyTrustFastConfirmer(address confimer) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAnyTrustFastConfirmerCall {
        #[allow(missing_docs)]
        pub confimer: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setAnyTrustFastConfirmer(address)`](setAnyTrustFastConfirmerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAnyTrustFastConfirmerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAnyTrustFastConfirmerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAnyTrustFastConfirmerCall) -> Self {
                    (value.confimer,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAnyTrustFastConfirmerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { confimer: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAnyTrustFastConfirmerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAnyTrustFastConfirmerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAnyTrustFastConfirmerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setAnyTrustFastConfirmerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setAnyTrustFastConfirmerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setAnyTrustFastConfirmer(address)";
            const SELECTOR: [u8; 4] = [13u8, 86u8, 27u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.confimer,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBaseStake(uint256)` and selector `0x06ae5851`.
```solidity
function setBaseStake(uint256 stake) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBaseStakeCall {
        #[allow(missing_docs)]
        pub stake: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setBaseStake(uint256)`](setBaseStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBaseStakeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBaseStakeCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBaseStakeCall) -> Self {
                    (value.stake,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBaseStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stake: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBaseStakeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setBaseStakeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBaseStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBaseStakeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBaseStakeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBaseStake(uint256)";
            const SELECTOR: [u8; 4] = [6u8, 174u8, 88u8, 81u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.stake),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setComputedAssertionHash(bytes32)` and selector `0x2c24eccd`.
```solidity
function setComputedAssertionHash(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setComputedAssertionHashCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`setComputedAssertionHash(bytes32)`](setComputedAssertionHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setComputedAssertionHashReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setComputedAssertionHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setComputedAssertionHashCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setComputedAssertionHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setComputedAssertionHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setComputedAssertionHashReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setComputedAssertionHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setComputedAssertionHashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setComputedAssertionHashReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setComputedAssertionHash(bytes32)";
            const SELECTOR: [u8; 4] = [44u8, 36u8, 236u8, 205u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setConfirmPeriodBlocks(uint64)` and selector `0xce66d05c`.
```solidity
function setConfirmPeriodBlocks(uint64 blocks) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setConfirmPeriodBlocksCall {
        #[allow(missing_docs)]
        pub blocks: u64,
    }
    ///Container type for the return parameters of the [`setConfirmPeriodBlocks(uint64)`](setConfirmPeriodBlocksCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setConfirmPeriodBlocksReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setConfirmPeriodBlocksCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setConfirmPeriodBlocksCall) -> Self {
                    (value.blocks,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setConfirmPeriodBlocksCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blocks: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setConfirmPeriodBlocksReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setConfirmPeriodBlocksReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setConfirmPeriodBlocksReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setConfirmPeriodBlocksCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setConfirmPeriodBlocksReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setConfirmPeriodBlocks(uint64)";
            const SELECTOR: [u8; 4] = [206u8, 102u8, 208u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blocks),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setGenesisAssertionHash(bytes32)` and selector `0xf3ef4b36`.
```solidity
function setGenesisAssertionHash(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setGenesisAssertionHashCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`setGenesisAssertionHash(bytes32)`](setGenesisAssertionHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setGenesisAssertionHashReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setGenesisAssertionHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setGenesisAssertionHashCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setGenesisAssertionHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setGenesisAssertionHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setGenesisAssertionHashReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setGenesisAssertionHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setGenesisAssertionHashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setGenesisAssertionHashReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setGenesisAssertionHash(bytes32)";
            const SELECTOR: [u8; 4] = [243u8, 239u8, 75u8, 54u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setLegacyMode(bool)` and selector `0x1d39e389`.
```solidity
function setLegacyMode(bool mode) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setLegacyModeCall {
        #[allow(missing_docs)]
        pub mode: bool,
    }
    ///Container type for the return parameters of the [`setLegacyMode(bool)`](setLegacyModeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setLegacyModeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setLegacyModeCall> for UnderlyingRustTuple<'_> {
                fn from(value: setLegacyModeCall) -> Self {
                    (value.mode,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setLegacyModeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { mode: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setLegacyModeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setLegacyModeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setLegacyModeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setLegacyModeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bool,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setLegacyModeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setLegacyMode(bool)";
            const SELECTOR: [u8; 4] = [29u8, 57u8, 227u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.mode,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setOwner(address)` and selector `0x13af4035`.
```solidity
function setOwner(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setOwnerCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setOwner(address)`](setOwnerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setOwnerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setOwnerCall> for UnderlyingRustTuple<'_> {
                fn from(value: setOwnerCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setOwnerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setOwnerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setOwnerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setOwnerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setOwnerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setOwnerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setOwner(address)";
            const SELECTOR: [u8; 4] = [19u8, 175u8, 64u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setSequencerInboxAcc(uint256,bytes32)` and selector `0x468eff50`.
```solidity
function setSequencerInboxAcc(uint256 index, bytes32 acc) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSequencerInboxAccCall {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub acc: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`setSequencerInboxAcc(uint256,bytes32)`](setSequencerInboxAccCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSequencerInboxAccReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSequencerInboxAccCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setSequencerInboxAccCall) -> Self {
                    (value.index, value.acc)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setSequencerInboxAccCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        index: tuple.0,
                        acc: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSequencerInboxAccReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setSequencerInboxAccReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setSequencerInboxAccReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setSequencerInboxAccCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setSequencerInboxAccReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setSequencerInboxAcc(uint256,bytes32)";
            const SELECTOR: [u8; 4] = [70u8, 142u8, 255u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.acc),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setSequencerMessageCount(uint256)` and selector `0xd202deaa`.
```solidity
function setSequencerMessageCount(uint256 count) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSequencerMessageCountCall {
        #[allow(missing_docs)]
        pub count: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setSequencerMessageCount(uint256)`](setSequencerMessageCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSequencerMessageCountReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSequencerMessageCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setSequencerMessageCountCall) -> Self {
                    (value.count,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setSequencerMessageCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { count: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSequencerMessageCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setSequencerMessageCountReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setSequencerMessageCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setSequencerMessageCountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setSequencerMessageCountReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setSequencerMessageCount(uint256)";
            const SELECTOR: [u8; 4] = [210u8, 2u8, 222u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.count),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setValidator(address[],bool[])` and selector `0xa3ffb772`.
```solidity
function setValidator(address[] memory validators, bool[] memory values) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setValidatorCall {
        #[allow(missing_docs)]
        pub validators: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
        #[allow(missing_docs)]
        pub values: alloy::sol_types::private::Vec<bool>,
    }
    ///Container type for the return parameters of the [`setValidator(address[],bool[])`](setValidatorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setValidatorReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::Vec<bool>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setValidatorCall> for UnderlyingRustTuple<'_> {
                fn from(value: setValidatorCall) -> Self {
                    (value.validators, value.values)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setValidatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        validators: tuple.0,
                        values: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setValidatorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setValidatorReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setValidatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setValidatorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setValidatorReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setValidator(address[],bool[])";
            const SELECTOR: [u8; 4] = [163u8, 255u8, 183u8, 114u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.validators),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bool,
                    > as alloy_sol_types::SolType>::tokenize(&self.values),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setValidatorAfkBlocks(uint64)` and selector `0xf112cea3`.
```solidity
function setValidatorAfkBlocks(uint64 blocks) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setValidatorAfkBlocksCall {
        #[allow(missing_docs)]
        pub blocks: u64,
    }
    ///Container type for the return parameters of the [`setValidatorAfkBlocks(uint64)`](setValidatorAfkBlocksCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setValidatorAfkBlocksReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setValidatorAfkBlocksCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setValidatorAfkBlocksCall) -> Self {
                    (value.blocks,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setValidatorAfkBlocksCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blocks: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setValidatorAfkBlocksReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setValidatorAfkBlocksReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setValidatorAfkBlocksReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setValidatorAfkBlocksCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setValidatorAfkBlocksReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setValidatorAfkBlocks(uint64)";
            const SELECTOR: [u8; 4] = [241u8, 18u8, 206u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blocks),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setValidators(address[])` and selector `0x9300c926`.
```solidity
function setValidators(address[] memory validators) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setValidatorsCall {
        #[allow(missing_docs)]
        pub validators: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    ///Container type for the return parameters of the [`setValidators(address[])`](setValidatorsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setValidatorsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setValidatorsCall> for UnderlyingRustTuple<'_> {
                fn from(value: setValidatorsCall) -> Self {
                    (value.validators,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setValidatorsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { validators: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setValidatorsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setValidatorsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setValidatorsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setValidatorsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setValidatorsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setValidators(address[])";
            const SELECTOR: [u8; 4] = [147u8, 0u8, 201u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.validators),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setWasmModuleRoot(bytes32)` and selector `0x89384960`.
```solidity
function setWasmModuleRoot(bytes32 root) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setWasmModuleRootCall {
        #[allow(missing_docs)]
        pub root: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`setWasmModuleRoot(bytes32)`](setWasmModuleRootCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setWasmModuleRootReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setWasmModuleRootCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setWasmModuleRootCall) -> Self {
                    (value.root,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setWasmModuleRootCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { root: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setWasmModuleRootReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setWasmModuleRootReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setWasmModuleRootReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setWasmModuleRootCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setWasmModuleRootReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setWasmModuleRoot(bytes32)";
            const SELECTOR: [u8; 4] = [137u8, 56u8, 73u8, 96u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.root),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `wasmModuleRoot()` and selector `0x8ee1a126`.
```solidity
function wasmModuleRoot() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct wasmModuleRootCall {}
    ///Container type for the return parameters of the [`wasmModuleRoot()`](wasmModuleRootCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct wasmModuleRootReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<wasmModuleRootCall> for UnderlyingRustTuple<'_> {
                fn from(value: wasmModuleRootCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for wasmModuleRootCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<wasmModuleRootReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: wasmModuleRootReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for wasmModuleRootReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for wasmModuleRootCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = wasmModuleRootReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "wasmModuleRoot()";
            const SELECTOR: [u8; 4] = [142u8, 225u8, 161u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`MockRollup`](self) function calls.
    pub enum MockRollupCalls {
        #[allow(missing_docs)]
        baseStake(baseStakeCall),
        #[allow(missing_docs)]
        bridge(bridgeCall),
        #[allow(missing_docs)]
        challengeManager(challengeManagerCall),
        #[allow(missing_docs)]
        computeAssertionHash(computeAssertionHashCall),
        #[allow(missing_docs)]
        confirmPeriodBlocks(confirmPeriodBlocksCall),
        #[allow(missing_docs)]
        fastConfirmNewAssertion(fastConfirmNewAssertionCall),
        #[allow(missing_docs)]
        forceConfirmNode(forceConfirmNodeCall),
        #[allow(missing_docs)]
        forceCreateNode(forceCreateNodeCall),
        #[allow(missing_docs)]
        genesisAssertionHash(genesisAssertionHashCall),
        #[allow(missing_docs)]
        getValidators(getValidatorsCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        pause(pauseCall),
        #[allow(missing_docs)]
        paused(pausedCall),
        #[allow(missing_docs)]
        sequencerInbox(sequencerInboxCall),
        #[allow(missing_docs)]
        setAnyTrustFastConfirmer(setAnyTrustFastConfirmerCall),
        #[allow(missing_docs)]
        setBaseStake(setBaseStakeCall),
        #[allow(missing_docs)]
        setComputedAssertionHash(setComputedAssertionHashCall),
        #[allow(missing_docs)]
        setConfirmPeriodBlocks(setConfirmPeriodBlocksCall),
        #[allow(missing_docs)]
        setGenesisAssertionHash(setGenesisAssertionHashCall),
        #[allow(missing_docs)]
        setLegacyMode(setLegacyModeCall),
        #[allow(missing_docs)]
        setOwner(setOwnerCall),
        #[allow(missing_docs)]
        setSequencerInboxAcc(setSequencerInboxAccCall),
        #[allow(missing_docs)]
        setSequencerMessageCount(setSequencerMessageCountCall),
        #[allow(missing_docs)]
        setValidator(setValidatorCall),
        #[allow(missing_docs)]
        setValidatorAfkBlocks(setValidatorAfkBlocksCall),
        #[allow(missing_docs)]
        setValidators(setValidatorsCall),
        #[allow(missing_docs)]
        setWasmModuleRoot(setWasmModuleRootCall),
        #[allow(missing_docs)]
        wasmModuleRoot(wasmModuleRootCall),
    }
    #[automatically_derived]
    impl MockRollupCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [2u8, 58u8, 150u8, 254u8],
            [6u8, 174u8, 88u8, 81u8],
            [13u8, 86u8, 27u8, 55u8],
            [19u8, 175u8, 64u8, 53u8],
            [29u8, 57u8, 227u8, 137u8],
            [44u8, 36u8, 236u8, 205u8],
            [46u8, 122u8, 207u8, 166u8],
            [47u8, 121u8, 104u8, 232u8],
            [51u8, 99u8, 95u8, 194u8],
            [53u8, 51u8, 37u8, 224u8],
            [70u8, 142u8, 255u8, 80u8],
            [71u8, 13u8, 206u8, 78u8],
            [92u8, 151u8, 90u8, 187u8],
            [100u8, 32u8, 251u8, 159u8],
            [118u8, 231u8, 226u8, 59u8],
            [132u8, 86u8, 203u8, 89u8],
            [137u8, 56u8, 73u8, 96u8],
            [141u8, 165u8, 203u8, 91u8],
            [142u8, 225u8, 161u8, 38u8],
            [147u8, 0u8, 201u8, 38u8],
            [163u8, 255u8, 183u8, 114u8],
            [183u8, 171u8, 77u8, 181u8],
            [206u8, 102u8, 208u8, 92u8],
            [210u8, 2u8, 222u8, 170u8],
            [231u8, 140u8, 234u8, 146u8],
            [238u8, 53u8, 243u8, 39u8],
            [241u8, 18u8, 206u8, 163u8],
            [243u8, 239u8, 75u8, 54u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for MockRollupCalls {
        const NAME: &'static str = "MockRollupCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 28usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::baseStake(_) => {
                    <baseStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridge(_) => <bridgeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::challengeManager(_) => {
                    <challengeManagerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::computeAssertionHash(_) => {
                    <computeAssertionHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::confirmPeriodBlocks(_) => {
                    <confirmPeriodBlocksCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::fastConfirmNewAssertion(_) => {
                    <fastConfirmNewAssertionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::forceConfirmNode(_) => {
                    <forceConfirmNodeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::forceCreateNode(_) => {
                    <forceCreateNodeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::genesisAssertionHash(_) => {
                    <genesisAssertionHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getValidators(_) => {
                    <getValidatorsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::paused(_) => <pausedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::sequencerInbox(_) => {
                    <sequencerInboxCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setAnyTrustFastConfirmer(_) => {
                    <setAnyTrustFastConfirmerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBaseStake(_) => {
                    <setBaseStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setComputedAssertionHash(_) => {
                    <setComputedAssertionHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setConfirmPeriodBlocks(_) => {
                    <setConfirmPeriodBlocksCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setGenesisAssertionHash(_) => {
                    <setGenesisAssertionHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setLegacyMode(_) => {
                    <setLegacyModeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setOwner(_) => <setOwnerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::setSequencerInboxAcc(_) => {
                    <setSequencerInboxAccCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setSequencerMessageCount(_) => {
                    <setSequencerMessageCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setValidator(_) => {
                    <setValidatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setValidatorAfkBlocks(_) => {
                    <setValidatorAfkBlocksCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setValidators(_) => {
                    <setValidatorsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setWasmModuleRoot(_) => {
                    <setWasmModuleRootCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::wasmModuleRoot(_) => {
                    <wasmModuleRootCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<MockRollupCalls>] = &[
                {
                    fn challengeManager(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <challengeManagerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::challengeManager)
                    }
                    challengeManager
                },
                {
                    fn setBaseStake(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setBaseStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setBaseStake)
                    }
                    setBaseStake
                },
                {
                    fn setAnyTrustFastConfirmer(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setAnyTrustFastConfirmerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setAnyTrustFastConfirmer)
                    }
                    setAnyTrustFastConfirmer
                },
                {
                    fn setOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setOwnerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setOwner)
                    }
                    setOwner
                },
                {
                    fn setLegacyMode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setLegacyModeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setLegacyMode)
                    }
                    setLegacyMode
                },
                {
                    fn setComputedAssertionHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setComputedAssertionHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setComputedAssertionHash)
                    }
                    setComputedAssertionHash
                },
                {
                    fn confirmPeriodBlocks(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <confirmPeriodBlocksCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::confirmPeriodBlocks)
                    }
                    confirmPeriodBlocks
                },
                {
                    fn forceConfirmNode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <forceConfirmNodeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::forceConfirmNode)
                    }
                    forceConfirmNode
                },
                {
                    fn computeAssertionHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <computeAssertionHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::computeAssertionHash)
                    }
                    computeAssertionHash
                },
                {
                    fn genesisAssertionHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <genesisAssertionHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::genesisAssertionHash)
                    }
                    genesisAssertionHash
                },
                {
                    fn setSequencerInboxAcc(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setSequencerInboxAccCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setSequencerInboxAcc)
                    }
                    setSequencerInboxAcc
                },
                {
                    fn forceCreateNode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <forceCreateNodeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::forceCreateNode)
                    }
                    forceCreateNode
                },
                {
                    fn paused(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::paused)
                    }
                    paused
                },
                {
                    fn fastConfirmNewAssertion(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <fastConfirmNewAssertionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::fastConfirmNewAssertion)
                    }
                    fastConfirmNewAssertion
                },
                {
                    fn baseStake(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <baseStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::baseStake)
                    }
                    baseStake
                },
                {
                    fn pause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::pause)
                    }
                    pause
                },
                {
                    fn setWasmModuleRoot(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setWasmModuleRootCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setWasmModuleRoot)
                    }
                    setWasmModuleRoot
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::owner)
                    }
                    owner
                },
                {
                    fn wasmModuleRoot(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <wasmModuleRootCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::wasmModuleRoot)
                    }
                    wasmModuleRoot
                },
                {
                    fn setValidators(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setValidatorsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setValidators)
                    }
                    setValidators
                },
                {
                    fn setValidator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setValidatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setValidator)
                    }
                    setValidator
                },
                {
                    fn getValidators(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <getValidatorsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::getValidators)
                    }
                    getValidators
                },
                {
                    fn setConfirmPeriodBlocks(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setConfirmPeriodBlocksCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setConfirmPeriodBlocks)
                    }
                    setConfirmPeriodBlocks
                },
                {
                    fn setSequencerMessageCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setSequencerMessageCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setSequencerMessageCount)
                    }
                    setSequencerMessageCount
                },
                {
                    fn bridge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <bridgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::bridge)
                    }
                    bridge
                },
                {
                    fn sequencerInbox(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <sequencerInboxCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::sequencerInbox)
                    }
                    sequencerInbox
                },
                {
                    fn setValidatorAfkBlocks(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setValidatorAfkBlocksCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setValidatorAfkBlocks)
                    }
                    setValidatorAfkBlocks
                },
                {
                    fn setGenesisAssertionHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockRollupCalls> {
                        <setGenesisAssertionHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockRollupCalls::setGenesisAssertionHash)
                    }
                    setGenesisAssertionHash
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::baseStake(inner) => {
                    <baseStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::bridge(inner) => {
                    <bridgeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::challengeManager(inner) => {
                    <challengeManagerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::computeAssertionHash(inner) => {
                    <computeAssertionHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::confirmPeriodBlocks(inner) => {
                    <confirmPeriodBlocksCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::fastConfirmNewAssertion(inner) => {
                    <fastConfirmNewAssertionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::forceConfirmNode(inner) => {
                    <forceConfirmNodeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::forceCreateNode(inner) => {
                    <forceCreateNodeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::genesisAssertionHash(inner) => {
                    <genesisAssertionHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getValidators(inner) => {
                    <getValidatorsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::sequencerInbox(inner) => {
                    <sequencerInboxCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setAnyTrustFastConfirmer(inner) => {
                    <setAnyTrustFastConfirmerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setBaseStake(inner) => {
                    <setBaseStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setComputedAssertionHash(inner) => {
                    <setComputedAssertionHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setConfirmPeriodBlocks(inner) => {
                    <setConfirmPeriodBlocksCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setGenesisAssertionHash(inner) => {
                    <setGenesisAssertionHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setLegacyMode(inner) => {
                    <setLegacyModeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setOwner(inner) => {
                    <setOwnerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setSequencerInboxAcc(inner) => {
                    <setSequencerInboxAccCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setSequencerMessageCount(inner) => {
                    <setSequencerMessageCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setValidator(inner) => {
                    <setValidatorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setValidatorAfkBlocks(inner) => {
                    <setValidatorAfkBlocksCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setValidators(inner) => {
                    <setValidatorsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setWasmModuleRoot(inner) => {
                    <setWasmModuleRootCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::wasmModuleRoot(inner) => {
                    <wasmModuleRootCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::baseStake(inner) => {
                    <baseStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridge(inner) => {
                    <bridgeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::challengeManager(inner) => {
                    <challengeManagerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::computeAssertionHash(inner) => {
                    <computeAssertionHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::confirmPeriodBlocks(inner) => {
                    <confirmPeriodBlocksCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fastConfirmNewAssertion(inner) => {
                    <fastConfirmNewAssertionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::forceConfirmNode(inner) => {
                    <forceConfirmNodeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::forceCreateNode(inner) => {
                    <forceCreateNodeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::genesisAssertionHash(inner) => {
                    <genesisAssertionHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getValidators(inner) => {
                    <getValidatorsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::sequencerInbox(inner) => {
                    <sequencerInboxCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setAnyTrustFastConfirmer(inner) => {
                    <setAnyTrustFastConfirmerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBaseStake(inner) => {
                    <setBaseStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setComputedAssertionHash(inner) => {
                    <setComputedAssertionHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setConfirmPeriodBlocks(inner) => {
                    <setConfirmPeriodBlocksCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setGenesisAssertionHash(inner) => {
                    <setGenesisAssertionHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setLegacyMode(inner) => {
                    <setLegacyModeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setOwner(inner) => {
                    <setOwnerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setSequencerInboxAcc(inner) => {
                    <setSequencerInboxAccCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setSequencerMessageCount(inner) => {
                    <setSequencerMessageCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setValidator(inner) => {
                    <setValidatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setValidatorAfkBlocks(inner) => {
                    <setValidatorAfkBlocksCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setValidators(inner) => {
                    <setValidatorsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setWasmModuleRoot(inner) => {
                    <setWasmModuleRootCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::wasmModuleRoot(inner) => {
                    <wasmModuleRootCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`MockRollup`](self) events.
    pub enum MockRollupEvents {
        #[allow(missing_docs)]
        AnyTrustFastConfirmerSet(AnyTrustFastConfirmerSet),
        #[allow(missing_docs)]
        FastConfirmNewAssertionCalled(FastConfirmNewAssertionCalled),
        #[allow(missing_docs)]
        ForceConfirmNodeCalled(ForceConfirmNodeCalled),
        #[allow(missing_docs)]
        ForceCreateNodeCalled(ForceCreateNodeCalled),
        #[allow(missing_docs)]
        RolePaused(RolePaused),
        #[allow(missing_docs)]
        ValidatorAfkBlocksSet(ValidatorAfkBlocksSet),
        #[allow(missing_docs)]
        ValidatorsSet(ValidatorsSet),
    }
    #[automatically_derived]
    impl MockRollupEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                13u8,
                150u8,
                144u8,
                249u8,
                113u8,
                101u8,
                243u8,
                89u8,
                145u8,
                174u8,
                96u8,
                210u8,
                169u8,
                126u8,
                4u8,
                175u8,
                244u8,
                114u8,
                192u8,
                135u8,
                41u8,
                114u8,
                42u8,
                146u8,
                54u8,
                255u8,
                27u8,
                200u8,
                185u8,
                186u8,
                144u8,
                192u8,
            ],
            [
                54u8,
                214u8,
                9u8,
                109u8,
                101u8,
                134u8,
                98u8,
                186u8,
                130u8,
                174u8,
                41u8,
                231u8,
                109u8,
                231u8,
                218u8,
                171u8,
                34u8,
                214u8,
                195u8,
                178u8,
                54u8,
                26u8,
                130u8,
                148u8,
                70u8,
                7u8,
                102u8,
                162u8,
                140u8,
                245u8,
                5u8,
                213u8,
            ],
            [
                72u8,
                106u8,
                115u8,
                211u8,
                139u8,
                154u8,
                223u8,
                179u8,
                236u8,
                131u8,
                162u8,
                1u8,
                59u8,
                24u8,
                245u8,
                119u8,
                26u8,
                148u8,
                143u8,
                102u8,
                107u8,
                3u8,
                142u8,
                27u8,
                91u8,
                3u8,
                248u8,
                88u8,
                138u8,
                98u8,
                205u8,
                215u8,
            ],
            [
                119u8,
                187u8,
                124u8,
                194u8,
                114u8,
                33u8,
                20u8,
                224u8,
                23u8,
                27u8,
                203u8,
                213u8,
                231u8,
                135u8,
                81u8,
                9u8,
                129u8,
                73u8,
                13u8,
                7u8,
                100u8,
                197u8,
                252u8,
                16u8,
                185u8,
                124u8,
                73u8,
                176u8,
                184u8,
                47u8,
                36u8,
                214u8,
            ],
            [
                140u8,
                139u8,
                120u8,
                89u8,
                187u8,
                201u8,
                105u8,
                190u8,
                201u8,
                154u8,
                197u8,
                100u8,
                243u8,
                127u8,
                129u8,
                40u8,
                226u8,
                222u8,
                159u8,
                133u8,
                211u8,
                64u8,
                8u8,
                97u8,
                57u8,
                173u8,
                152u8,
                168u8,
                133u8,
                152u8,
                149u8,
                27u8,
            ],
            [
                166u8,
                155u8,
                151u8,
                126u8,
                148u8,
                116u8,
                180u8,
                84u8,
                192u8,
                190u8,
                1u8,
                145u8,
                56u8,
                178u8,
                108u8,
                212u8,
                109u8,
                37u8,
                228u8,
                226u8,
                251u8,
                204u8,
                248u8,
                35u8,
                32u8,
                42u8,
                11u8,
                109u8,
                123u8,
                189u8,
                58u8,
                36u8,
            ],
            [
                211u8,
                171u8,
                76u8,
                190u8,
                27u8,
                111u8,
                81u8,
                158u8,
                180u8,
                63u8,
                9u8,
                222u8,
                209u8,
                122u8,
                18u8,
                232u8,
                27u8,
                129u8,
                30u8,
                41u8,
                112u8,
                99u8,
                173u8,
                162u8,
                214u8,
                93u8,
                221u8,
                239u8,
                91u8,
                97u8,
                44u8,
                124u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for MockRollupEvents {
        const NAME: &'static str = "MockRollupEvents";
        const COUNT: usize = 7usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <AnyTrustFastConfirmerSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <AnyTrustFastConfirmerSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::AnyTrustFastConfirmerSet)
                }
                Some(
                    <FastConfirmNewAssertionCalled as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <FastConfirmNewAssertionCalled as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::FastConfirmNewAssertionCalled)
                }
                Some(
                    <ForceConfirmNodeCalled as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ForceConfirmNodeCalled as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ForceConfirmNodeCalled)
                }
                Some(
                    <ForceCreateNodeCalled as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ForceCreateNodeCalled as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ForceCreateNodeCalled)
                }
                Some(<RolePaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RolePaused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RolePaused)
                }
                Some(
                    <ValidatorAfkBlocksSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ValidatorAfkBlocksSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ValidatorAfkBlocksSet)
                }
                Some(<ValidatorsSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ValidatorsSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ValidatorsSet)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for MockRollupEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AnyTrustFastConfirmerSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::FastConfirmNewAssertionCalled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ForceConfirmNodeCalled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ForceCreateNodeCalled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RolePaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ValidatorAfkBlocksSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ValidatorsSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AnyTrustFastConfirmerSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::FastConfirmNewAssertionCalled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ForceConfirmNodeCalled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ForceCreateNodeCalled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RolePaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ValidatorAfkBlocksSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ValidatorsSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`MockRollup`](self) contract instance.

See the [wrapper's documentation](`MockRollupInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> MockRollupInstance<T, P, N> {
        MockRollupInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<MockRollupInstance<T, P, N>>,
    > {
        MockRollupInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        MockRollupInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`MockRollup`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`MockRollup`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct MockRollupInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for MockRollupInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("MockRollupInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockRollupInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`MockRollup`](self) contract instance.

See the [wrapper's documentation](`MockRollupInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<MockRollupInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> MockRollupInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> MockRollupInstance<T, P, N> {
            MockRollupInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockRollupInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`baseStake`] function.
        pub fn baseStake(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, baseStakeCall, N> {
            self.call_builder(&baseStakeCall {})
        }
        ///Creates a new call builder for the [`bridge`] function.
        pub fn bridge(&self) -> alloy_contract::SolCallBuilder<T, &P, bridgeCall, N> {
            self.call_builder(&bridgeCall {})
        }
        ///Creates a new call builder for the [`challengeManager`] function.
        pub fn challengeManager(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, challengeManagerCall, N> {
            self.call_builder(&challengeManagerCall {})
        }
        ///Creates a new call builder for the [`computeAssertionHash`] function.
        pub fn computeAssertionHash(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
            _1: <AssertionState as alloy::sol_types::SolType>::RustType,
            _2: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, computeAssertionHashCall, N> {
            self.call_builder(
                &computeAssertionHashCall {
                    _0,
                    _1,
                    _2,
                },
            )
        }
        ///Creates a new call builder for the [`confirmPeriodBlocks`] function.
        pub fn confirmPeriodBlocks(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, confirmPeriodBlocksCall, N> {
            self.call_builder(&confirmPeriodBlocksCall {})
        }
        ///Creates a new call builder for the [`fastConfirmNewAssertion`] function.
        pub fn fastConfirmNewAssertion(
            &self,
            _0: <AssertionInputs as alloy::sol_types::SolType>::RustType,
            expectedAssertionHash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, fastConfirmNewAssertionCall, N> {
            self.call_builder(
                &fastConfirmNewAssertionCall {
                    _0,
                    expectedAssertionHash,
                },
            )
        }
        ///Creates a new call builder for the [`forceConfirmNode`] function.
        pub fn forceConfirmNode(
            &self,
            nodeNum: u64,
            blockHash: alloy::sol_types::private::FixedBytes<32>,
            sendRoot: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, forceConfirmNodeCall, N> {
            self.call_builder(
                &forceConfirmNodeCall {
                    nodeNum,
                    blockHash,
                    sendRoot,
                },
            )
        }
        ///Creates a new call builder for the [`forceCreateNode`] function.
        pub fn forceCreateNode(
            &self,
            prevNode: u64,
            prevNodeInboxMaxCount: alloy::sol_types::private::primitives::aliases::U256,
            _2: <Assertion as alloy::sol_types::SolType>::RustType,
            expectedNodeHash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, forceCreateNodeCall, N> {
            self.call_builder(
                &forceCreateNodeCall {
                    prevNode,
                    prevNodeInboxMaxCount,
                    _2,
                    expectedNodeHash,
                },
            )
        }
        ///Creates a new call builder for the [`genesisAssertionHash`] function.
        pub fn genesisAssertionHash(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, genesisAssertionHashCall, N> {
            self.call_builder(&genesisAssertionHashCall {})
        }
        ///Creates a new call builder for the [`getValidators`] function.
        pub fn getValidators(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getValidatorsCall, N> {
            self.call_builder(&getValidatorsCall {})
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        ///Creates a new call builder for the [`pause`] function.
        pub fn pause(&self) -> alloy_contract::SolCallBuilder<T, &P, pauseCall, N> {
            self.call_builder(&pauseCall {})
        }
        ///Creates a new call builder for the [`paused`] function.
        pub fn paused(&self) -> alloy_contract::SolCallBuilder<T, &P, pausedCall, N> {
            self.call_builder(&pausedCall {})
        }
        ///Creates a new call builder for the [`sequencerInbox`] function.
        pub fn sequencerInbox(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, sequencerInboxCall, N> {
            self.call_builder(&sequencerInboxCall {})
        }
        ///Creates a new call builder for the [`setAnyTrustFastConfirmer`] function.
        pub fn setAnyTrustFastConfirmer(
            &self,
            confimer: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setAnyTrustFastConfirmerCall, N> {
            self.call_builder(
                &setAnyTrustFastConfirmerCall {
                    confimer,
                },
            )
        }
        ///Creates a new call builder for the [`setBaseStake`] function.
        pub fn setBaseStake(
            &self,
            stake: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBaseStakeCall, N> {
            self.call_builder(&setBaseStakeCall { stake })
        }
        ///Creates a new call builder for the [`setComputedAssertionHash`] function.
        pub fn setComputedAssertionHash(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setComputedAssertionHashCall, N> {
            self.call_builder(
                &setComputedAssertionHashCall {
                    hash,
                },
            )
        }
        ///Creates a new call builder for the [`setConfirmPeriodBlocks`] function.
        pub fn setConfirmPeriodBlocks(
            &self,
            blocks: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, setConfirmPeriodBlocksCall, N> {
            self.call_builder(
                &setConfirmPeriodBlocksCall {
                    blocks,
                },
            )
        }
        ///Creates a new call builder for the [`setGenesisAssertionHash`] function.
        pub fn setGenesisAssertionHash(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setGenesisAssertionHashCall, N> {
            self.call_builder(
                &setGenesisAssertionHashCall {
                    hash,
                },
            )
        }
        ///Creates a new call builder for the [`setLegacyMode`] function.
        pub fn setLegacyMode(
            &self,
            mode: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, setLegacyModeCall, N> {
            self.call_builder(&setLegacyModeCall { mode })
        }
        ///Creates a new call builder for the [`setOwner`] function.
        pub fn setOwner(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setOwnerCall, N> {
            self.call_builder(&setOwnerCall { newOwner })
        }
        ///Creates a new call builder for the [`setSequencerInboxAcc`] function.
        pub fn setSequencerInboxAcc(
            &self,
            index: alloy::sol_types::private::primitives::aliases::U256,
            acc: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setSequencerInboxAccCall, N> {
            self.call_builder(
                &setSequencerInboxAccCall {
                    index,
                    acc,
                },
            )
        }
        ///Creates a new call builder for the [`setSequencerMessageCount`] function.
        pub fn setSequencerMessageCount(
            &self,
            count: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setSequencerMessageCountCall, N> {
            self.call_builder(
                &setSequencerMessageCountCall {
                    count,
                },
            )
        }
        ///Creates a new call builder for the [`setValidator`] function.
        pub fn setValidator(
            &self,
            validators: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
            values: alloy::sol_types::private::Vec<bool>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setValidatorCall, N> {
            self.call_builder(
                &setValidatorCall {
                    validators,
                    values,
                },
            )
        }
        ///Creates a new call builder for the [`setValidatorAfkBlocks`] function.
        pub fn setValidatorAfkBlocks(
            &self,
            blocks: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, setValidatorAfkBlocksCall, N> {
            self.call_builder(
                &setValidatorAfkBlocksCall {
                    blocks,
                },
            )
        }
        ///Creates a new call builder for the [`setValidators`] function.
        pub fn setValidators(
            &self,
            validators: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, setValidatorsCall, N> {
            self.call_builder(&setValidatorsCall { validators })
        }
        ///Creates a new call builder for the [`setWasmModuleRoot`] function.
        pub fn setWasmModuleRoot(
            &self,
            root: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setWasmModuleRootCall, N> {
            self.call_builder(&setWasmModuleRootCall { root })
        }
        ///Creates a new call builder for the [`wasmModuleRoot`] function.
        pub fn wasmModuleRoot(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, wasmModuleRootCall, N> {
            self.call_builder(&wasmModuleRootCall {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockRollupInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`AnyTrustFastConfirmerSet`] event.
        pub fn AnyTrustFastConfirmerSet_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, AnyTrustFastConfirmerSet, N> {
            self.event_filter::<AnyTrustFastConfirmerSet>()
        }
        ///Creates a new event filter for the [`FastConfirmNewAssertionCalled`] event.
        pub fn FastConfirmNewAssertionCalled_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, FastConfirmNewAssertionCalled, N> {
            self.event_filter::<FastConfirmNewAssertionCalled>()
        }
        ///Creates a new event filter for the [`ForceConfirmNodeCalled`] event.
        pub fn ForceConfirmNodeCalled_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ForceConfirmNodeCalled, N> {
            self.event_filter::<ForceConfirmNodeCalled>()
        }
        ///Creates a new event filter for the [`ForceCreateNodeCalled`] event.
        pub fn ForceCreateNodeCalled_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ForceCreateNodeCalled, N> {
            self.event_filter::<ForceCreateNodeCalled>()
        }
        ///Creates a new event filter for the [`RolePaused`] event.
        pub fn RolePaused_filter(&self) -> alloy_contract::Event<T, &P, RolePaused, N> {
            self.event_filter::<RolePaused>()
        }
        ///Creates a new event filter for the [`ValidatorAfkBlocksSet`] event.
        pub fn ValidatorAfkBlocksSet_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ValidatorAfkBlocksSet, N> {
            self.event_filter::<ValidatorAfkBlocksSet>()
        }
        ///Creates a new event filter for the [`ValidatorsSet`] event.
        pub fn ValidatorsSet_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ValidatorsSet, N> {
            self.event_filter::<ValidatorsSet>()
        }
    }
}
