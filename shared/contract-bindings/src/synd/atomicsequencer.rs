/**

Generated by the following Solidity interface...
```solidity
interface AtomicSequencer {
    constructor();

    fallback() external payable;

    function implementation() external view returns (address);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "fallback",
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "implementation",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod AtomicSequencer {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a060405234610035576100116100af565b61001961003a565b61017361010282396080518181816051015260fd015261017390f35b610040565b60405190565b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b5f0190565b61006561003a565b3d5f823e3d90fd5b60018060a01b031690565b90565b61008f61008a6100949261006d565b610078565b61006d565b90565b6100a09061007b565b90565b6100ac90610097565b90565b6100b761003a565b610acb810181811060018060401b038211176100fc576100df8291610acb6102758439610058565b03905ff080156100f7576100f2906100a3565b608052565b61005d565b61004456fe60806040526004361015610013575b6100e1565b61001d5f3561002c565b635c60da1b0361000e576100ac565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f91031261004a57565b61003c565b7f000000000000000000000000000000000000000000000000000000000000000090565b60018060a01b031690565b61008790610073565b90565b6100939061007e565b9052565b91906100aa905f6020850194019061008a565b565b346100dc576100bc366004610040565b6100d86100c761004f565b6100cf610032565b91829182610097565b0390f35b610038565b6100e96100f2565b61011f565b5f90565b6100fa6100ee565b507f000000000000000000000000000000000000000000000000000000000000000090565b5f8091368280378136915af43d5f803e5f14610139573d5ff35b3d5ffdfea264697066735822122080cff6d47351357134354912f8cf492c6f48fd7a4b4b1df71eef3fb83d59c1a964736f6c63430008190033608060405234601c57600e6020565b610aa061002b8239610aa090f35b6026565b60405190565b5f80fdfe60806040526004361015610013575b6102b7565b61001d5f3561003c565b806334993fa31461003757636bae6e1c0361000e57610280565b6101a8565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b5f80fd5b5f80fd5b5f80fd5b909182601f8301121561009a5781359167ffffffffffffffff831161009557602001926020830284011161009057565b61005c565b610058565b610054565b909182601f830112156100d95781359167ffffffffffffffff83116100d45760200192602083028401116100cf57565b61005c565b610058565b610054565b909182601f830112156101185781359167ffffffffffffffff831161011357602001926020830284011161010e57565b61005c565b610058565b610054565b9060608282031261019e575f82013567ffffffffffffffff81116101995781610147918401610060565b929093602082013567ffffffffffffffff8111610194578361016a91840161009f565b929093604082013567ffffffffffffffff811161018f5761018b92016100de565b9091565b610050565b610050565b610050565b61004c565b5f0190565b346101dd576101c76101bb36600461011d565b9493909392919261050b565b6101cf610042565b806101d9816101a3565b0390f35b610048565b909182601f8301121561021c5781359167ffffffffffffffff831161021757602001926020830284011161021257565b61005c565b610058565b610054565b909160408284031261027b575f82013567ffffffffffffffff8111610276578361024c918401610060565b929093602082013567ffffffffffffffff81116102715761026d92016101e2565b9091565b610050565b610050565b61004c565b346102b25761029c610293366004610221565b92919091610904565b6102a4610042565b806102ae816101a3565b0390f35b610048565b5f80fd5b5090565b90565b90565b90565b6102dc6102d76102e1926102c2565b6102c5565b6102bf565b90565b5090565b5090565b60016102f891016102bf565b90565b634e487b7160e01b5f52603260045260245ffd5b919081101561031f576020020190565b6102fb565b151590565b61033281610324565b0361033957565b5f80fd5b3561034781610329565b90565b919081101561035a576020020190565b6102fb565b60018060a01b031690565b6103739061035f565b90565b61037f9061036a565b90565b61038b81610376565b0361039257565b5f80fd5b356103a081610382565b90565b6103b76103b26103bc9261035f565b6102c5565b61035f565b90565b6103c8906103a3565b90565b6103d4906103bf565b90565b5f80fd5b5f80fd5b5f80fd5b903590600160200381360303821215610425570180359067ffffffffffffffff82116104205760200191600182023603831361041b57565b6103df565b6103db565b6103d7565b9082101561044557602061044192028101906103e3565b9091565b6102fb565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906104769061044e565b810190811067ffffffffffffffff82111761049057604052565b610458565b60e01b90565b5f9103126104a557565b61004c565b60209181520190565b90825f939282370152565b91906104d8816104d1816104dd956104aa565b80956104b3565b61044e565b0190565b90916104f89260208301925f8185039101526104be565b90565b610503610042565b3d5f823e3d90fd5b9193959490929561051d8385906102bb565b61052f6105295f6102c8565b916102bf565b148015610747575b8015610718575b6106f55761054b5f6102c8565b5b8061056961056361055e8789906102bb565b6102bf565b916102bf565b10156106eb5761058361057e8385849161030f565b61033d565b5f1461063d576105a56105a061059b8688859161034a565b610396565b6103cb565b90633514d37b6105b7888b849161042a565b93803b15610638576105dc5f80946105e76105d0610042565b98899687958694610495565b8452600484016104e1565b03925af19182156106335761060292610607575b505b6102ec565b61054c565b610626905f3d811161062c575b61061e818361046c565b81019061049b565b5f6105fb565b503d610614565b6104fb565b61044a565b61065961065461064f8688859161034a565b610396565b6103cb565b906346e2cc0961066b888b849161042a565b93803b156106e6576106905f809461069b610684610042565b98899687958694610495565b8452600484016104e1565b03925af19182156106e157610602926106b5575b506105fd565b6106d4905f3d81116106da575b6106cc818361046c565b81019061049b565b5f6106af565b503d6106c2565b6104fb565b61044a565b5050505050509050565b6106fd610042565b63415439a560e11b815280610714600482016101a3565b0390fd5b506107248385906102bb565b61074061073a6107358486906102e8565b6102bf565b916102bf565b141561053e565b506107538385906102bb565b61076f610769610764888b906102e4565b6102bf565b916102bf565b1415610537565b5090565b9035906001602003813603038212156107bc570180359067ffffffffffffffff82116107b7576020019160208202360383136107b257565b6103df565b6103db565b6103d7565b908210156107dc5760206107d8920281019061077a565b9091565b6102fb565b60209181520190565b90565b60209181520190565b91906108108161080981610815956107ed565b80956104b3565b61044e565b0190565b9061082492916107f6565b90565b5f80fd5b5f80fd5b5f80fd5b903560016020038236030381121561087457016020813591019167ffffffffffffffff821161086f57600182023603831361086a57565b61082b565b610827565b61082f565b60200190565b918161088a916107e1565b908161089b602083028401946107ea565b92835f925b8484106108b05750505050505090565b90919293949560206108dc6108d683856001950388526108d08b88610833565b90610819565b98610879565b9401940192949391906108a0565b90916109019260208301925f81850391015261087f565b90565b9392936109128183906102bb565b61092461091e5f6102c8565b916102bf565b148015610a3b575b610a18576109395f6102c8565b5b8061095761095161094c8587906102bb565b6102bf565b916102bf565b1015610a105761097961097461096f8486859161034a565b610396565b6103cb565b90630b83249d61098b868984916107c1565b93803b15610a0b576109b05f80946109bb6109a4610042565b98899687958694610495565b8452600484016108ea565b03925af1918215610a06576109d5926109da575b506102ec565b61093a565b6109f9905f3d81116109ff575b6109f1818361046c565b81019061049b565b5f6109cf565b503d6109e7565b6104fb565b61044a565b505050509050565b610a20610042565b63415439a560e11b815280610a37600482016101a3565b0390fd5b50610a478183906102bb565b610a63610a5d610a58868990610776565b6102bf565b916102bf565b141561092c56fea26469706673582212203faa16cf90fbf3deeb31cb5a5e3a4706d27bf94131ad893b0dc3a7ff0028f5b864736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R4a\x005Wa\0\x11a\0\xAFV[a\0\x19a\0:V[a\x01sa\x01\x02\x829`\x80Q\x81\x81\x81`Q\x01R`\xFD\x01Ra\x01s\x90\xF3[a\0@V[`@Q\x90V[_\x80\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_\x01\x90V[a\0ea\0:V[=_\x82>=\x90\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[\x90V[a\0\x8Fa\0\x8Aa\0\x94\x92a\0mV[a\0xV[a\0mV[\x90V[a\0\xA0\x90a\0{V[\x90V[a\0\xAC\x90a\0\x97V[\x90V[a\0\xB7a\0:V[a\n\xCB\x81\x01\x81\x81\x10`\x01\x80`@\x1B\x03\x82\x11\x17a\0\xFCWa\0\xDF\x82\x91a\n\xCBa\x02u\x849a\0XV[\x03\x90_\xF0\x80\x15a\0\xF7Wa\0\xF2\x90a\0\xA3V[`\x80RV[a\0]V[a\0DV\xFE`\x80`@R`\x046\x10\x15a\0\x13W[a\0\xE1V[a\0\x1D_5a\0,V[c\\`\xDA\x1B\x03a\0\x0EWa\0\xACV[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x91\x03\x12a\0JWV[a\0<V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\0\x87\x90a\0sV[\x90V[a\0\x93\x90a\0~V[\x90RV[\x91\x90a\0\xAA\x90_` \x85\x01\x94\x01\x90a\0\x8AV[V[4a\0\xDCWa\0\xBC6`\x04a\0@V[a\0\xD8a\0\xC7a\0OV[a\0\xCFa\x002V[\x91\x82\x91\x82a\0\x97V[\x03\x90\xF3[a\08V[a\0\xE9a\0\xF2V[a\x01\x1FV[_\x90V[a\0\xFAa\0\xEEV[P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[_\x80\x916\x82\x807\x816\x91Z\xF4=_\x80>_\x14a\x019W=_\xF3[=_\xFD\xFE\xA2dipfsX\"\x12 \x80\xCF\xF6\xD4sQ5q45I\x12\xF8\xCFI,oH\xFDzKK\x1D\xF7\x1E\xEF?\xB8=Y\xC1\xA9dsolcC\0\x08\x19\x003`\x80`@R4`\x1CW`\x0E` V[a\n\xA0a\0+\x829a\n\xA0\x90\xF3[`&V[`@Q\x90V[_\x80\xFD\xFE`\x80`@R`\x046\x10\x15a\0\x13W[a\x02\xB7V[a\0\x1D_5a\0<V[\x80c4\x99?\xA3\x14a\x007Wck\xAEn\x1C\x03a\0\x0EWa\x02\x80V[a\x01\xA8V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\0\x9AW\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\0\x95W` \x01\x92` \x83\x02\x84\x01\x11a\0\x90WV[a\0\\V[a\0XV[a\0TV[\x90\x91\x82`\x1F\x83\x01\x12\x15a\0\xD9W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\0\xD4W` \x01\x92` \x83\x02\x84\x01\x11a\0\xCFWV[a\0\\V[a\0XV[a\0TV[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x01\x18W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x01\x13W` \x01\x92` \x83\x02\x84\x01\x11a\x01\x0EWV[a\0\\V[a\0XV[a\0TV[\x90``\x82\x82\x03\x12a\x01\x9EW_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x01\x99W\x81a\x01G\x91\x84\x01a\0`V[\x92\x90\x93` \x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x01\x94W\x83a\x01j\x91\x84\x01a\0\x9FV[\x92\x90\x93`@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x01\x8FWa\x01\x8B\x92\x01a\0\xDEV[\x90\x91V[a\0PV[a\0PV[a\0PV[a\0LV[_\x01\x90V[4a\x01\xDDWa\x01\xC7a\x01\xBB6`\x04a\x01\x1DV[\x94\x93\x90\x93\x92\x91\x92a\x05\x0BV[a\x01\xCFa\0BV[\x80a\x01\xD9\x81a\x01\xA3V[\x03\x90\xF3[a\0HV[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x02\x1CW\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x02\x17W` \x01\x92` \x83\x02\x84\x01\x11a\x02\x12WV[a\0\\V[a\0XV[a\0TV[\x90\x91`@\x82\x84\x03\x12a\x02{W_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02vW\x83a\x02L\x91\x84\x01a\0`V[\x92\x90\x93` \x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02qWa\x02m\x92\x01a\x01\xE2V[\x90\x91V[a\0PV[a\0PV[a\0LV[4a\x02\xB2Wa\x02\x9Ca\x02\x936`\x04a\x02!V[\x92\x91\x90\x91a\t\x04V[a\x02\xA4a\0BV[\x80a\x02\xAE\x81a\x01\xA3V[\x03\x90\xF3[a\0HV[_\x80\xFD[P\x90V[\x90V[\x90V[\x90V[a\x02\xDCa\x02\xD7a\x02\xE1\x92a\x02\xC2V[a\x02\xC5V[a\x02\xBFV[\x90V[P\x90V[P\x90V[`\x01a\x02\xF8\x91\x01a\x02\xBFV[\x90V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[\x91\x90\x81\x10\x15a\x03\x1FW` \x02\x01\x90V[a\x02\xFBV[\x15\x15\x90V[a\x032\x81a\x03$V[\x03a\x039WV[_\x80\xFD[5a\x03G\x81a\x03)V[\x90V[\x91\x90\x81\x10\x15a\x03ZW` \x02\x01\x90V[a\x02\xFBV[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x03s\x90a\x03_V[\x90V[a\x03\x7F\x90a\x03jV[\x90V[a\x03\x8B\x81a\x03vV[\x03a\x03\x92WV[_\x80\xFD[5a\x03\xA0\x81a\x03\x82V[\x90V[a\x03\xB7a\x03\xB2a\x03\xBC\x92a\x03_V[a\x02\xC5V[a\x03_V[\x90V[a\x03\xC8\x90a\x03\xA3V[\x90V[a\x03\xD4\x90a\x03\xBFV[\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x905\x90`\x01` \x03\x816\x03\x03\x82\x12\x15a\x04%W\x01\x805\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x04 W` \x01\x91`\x01\x82\x026\x03\x83\x13a\x04\x1BWV[a\x03\xDFV[a\x03\xDBV[a\x03\xD7V[\x90\x82\x10\x15a\x04EW` a\x04A\x92\x02\x81\x01\x90a\x03\xE3V[\x90\x91V[a\x02\xFBV[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x04v\x90a\x04NV[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x04\x90W`@RV[a\x04XV[`\xE0\x1B\x90V[_\x91\x03\x12a\x04\xA5WV[a\0LV[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x827\x01RV[\x91\x90a\x04\xD8\x81a\x04\xD1\x81a\x04\xDD\x95a\x04\xAAV[\x80\x95a\x04\xB3V[a\x04NV[\x01\x90V[\x90\x91a\x04\xF8\x92` \x83\x01\x92_\x81\x85\x03\x91\x01Ra\x04\xBEV[\x90V[a\x05\x03a\0BV[=_\x82>=\x90\xFD[\x91\x93\x95\x94\x90\x92\x95a\x05\x1D\x83\x85\x90a\x02\xBBV[a\x05/a\x05)_a\x02\xC8V[\x91a\x02\xBFV[\x14\x80\x15a\x07GW[\x80\x15a\x07\x18W[a\x06\xF5Wa\x05K_a\x02\xC8V[[\x80a\x05ia\x05ca\x05^\x87\x89\x90a\x02\xBBV[a\x02\xBFV[\x91a\x02\xBFV[\x10\x15a\x06\xEBWa\x05\x83a\x05~\x83\x85\x84\x91a\x03\x0FV[a\x03=V[_\x14a\x06=Wa\x05\xA5a\x05\xA0a\x05\x9B\x86\x88\x85\x91a\x03JV[a\x03\x96V[a\x03\xCBV[\x90c5\x14\xD3{a\x05\xB7\x88\x8B\x84\x91a\x04*V[\x93\x80;\x15a\x068Wa\x05\xDC_\x80\x94a\x05\xE7a\x05\xD0a\0BV[\x98\x89\x96\x87\x95\x86\x94a\x04\x95V[\x84R`\x04\x84\x01a\x04\xE1V[\x03\x92Z\xF1\x91\x82\x15a\x063Wa\x06\x02\x92a\x06\x07W[P[a\x02\xECV[a\x05LV[a\x06&\x90_=\x81\x11a\x06,W[a\x06\x1E\x81\x83a\x04lV[\x81\x01\x90a\x04\x9BV[_a\x05\xFBV[P=a\x06\x14V[a\x04\xFBV[a\x04JV[a\x06Ya\x06Ta\x06O\x86\x88\x85\x91a\x03JV[a\x03\x96V[a\x03\xCBV[\x90cF\xE2\xCC\ta\x06k\x88\x8B\x84\x91a\x04*V[\x93\x80;\x15a\x06\xE6Wa\x06\x90_\x80\x94a\x06\x9Ba\x06\x84a\0BV[\x98\x89\x96\x87\x95\x86\x94a\x04\x95V[\x84R`\x04\x84\x01a\x04\xE1V[\x03\x92Z\xF1\x91\x82\x15a\x06\xE1Wa\x06\x02\x92a\x06\xB5W[Pa\x05\xFDV[a\x06\xD4\x90_=\x81\x11a\x06\xDAW[a\x06\xCC\x81\x83a\x04lV[\x81\x01\x90a\x04\x9BV[_a\x06\xAFV[P=a\x06\xC2V[a\x04\xFBV[a\x04JV[PPPPPP\x90PV[a\x06\xFDa\0BV[cAT9\xA5`\xE1\x1B\x81R\x80a\x07\x14`\x04\x82\x01a\x01\xA3V[\x03\x90\xFD[Pa\x07$\x83\x85\x90a\x02\xBBV[a\x07@a\x07:a\x075\x84\x86\x90a\x02\xE8V[a\x02\xBFV[\x91a\x02\xBFV[\x14\x15a\x05>V[Pa\x07S\x83\x85\x90a\x02\xBBV[a\x07oa\x07ia\x07d\x88\x8B\x90a\x02\xE4V[a\x02\xBFV[\x91a\x02\xBFV[\x14\x15a\x057V[P\x90V[\x905\x90`\x01` \x03\x816\x03\x03\x82\x12\x15a\x07\xBCW\x01\x805\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x07\xB7W` \x01\x91` \x82\x026\x03\x83\x13a\x07\xB2WV[a\x03\xDFV[a\x03\xDBV[a\x03\xD7V[\x90\x82\x10\x15a\x07\xDCW` a\x07\xD8\x92\x02\x81\x01\x90a\x07zV[\x90\x91V[a\x02\xFBV[` \x91\x81R\x01\x90V[\x90V[` \x91\x81R\x01\x90V[\x91\x90a\x08\x10\x81a\x08\t\x81a\x08\x15\x95a\x07\xEDV[\x80\x95a\x04\xB3V[a\x04NV[\x01\x90V[\x90a\x08$\x92\x91a\x07\xF6V[\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x905`\x01` \x03\x826\x03\x03\x81\x12\x15a\x08tW\x01` \x815\x91\x01\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x08oW`\x01\x82\x026\x03\x83\x13a\x08jWV[a\x08+V[a\x08'V[a\x08/V[` \x01\x90V[\x91\x81a\x08\x8A\x91a\x07\xE1V[\x90\x81a\x08\x9B` \x83\x02\x84\x01\x94a\x07\xEAV[\x92\x83_\x92[\x84\x84\x10a\x08\xB0WPPPPPP\x90V[\x90\x91\x92\x93\x94\x95` a\x08\xDCa\x08\xD6\x83\x85`\x01\x95\x03\x88Ra\x08\xD0\x8B\x88a\x083V[\x90a\x08\x19V[\x98a\x08yV[\x94\x01\x94\x01\x92\x94\x93\x91\x90a\x08\xA0V[\x90\x91a\t\x01\x92` \x83\x01\x92_\x81\x85\x03\x91\x01Ra\x08\x7FV[\x90V[\x93\x92\x93a\t\x12\x81\x83\x90a\x02\xBBV[a\t$a\t\x1E_a\x02\xC8V[\x91a\x02\xBFV[\x14\x80\x15a\n;W[a\n\x18Wa\t9_a\x02\xC8V[[\x80a\tWa\tQa\tL\x85\x87\x90a\x02\xBBV[a\x02\xBFV[\x91a\x02\xBFV[\x10\x15a\n\x10Wa\tya\tta\to\x84\x86\x85\x91a\x03JV[a\x03\x96V[a\x03\xCBV[\x90c\x0B\x83$\x9Da\t\x8B\x86\x89\x84\x91a\x07\xC1V[\x93\x80;\x15a\n\x0BWa\t\xB0_\x80\x94a\t\xBBa\t\xA4a\0BV[\x98\x89\x96\x87\x95\x86\x94a\x04\x95V[\x84R`\x04\x84\x01a\x08\xEAV[\x03\x92Z\xF1\x91\x82\x15a\n\x06Wa\t\xD5\x92a\t\xDAW[Pa\x02\xECV[a\t:V[a\t\xF9\x90_=\x81\x11a\t\xFFW[a\t\xF1\x81\x83a\x04lV[\x81\x01\x90a\x04\x9BV[_a\t\xCFV[P=a\t\xE7V[a\x04\xFBV[a\x04JV[PPPP\x90PV[a\n a\0BV[cAT9\xA5`\xE1\x1B\x81R\x80a\n7`\x04\x82\x01a\x01\xA3V[\x03\x90\xFD[Pa\nG\x81\x83\x90a\x02\xBBV[a\nca\n]a\nX\x86\x89\x90a\x07vV[a\x02\xBFV[\x91a\x02\xBFV[\x14\x15a\t,V\xFE\xA2dipfsX\"\x12 ?\xAA\x16\xCF\x90\xFB\xF3\xDE\xEB1\xCBZ^:G\x06\xD2{\xF9A1\xAD\x89;\r\xC3\xA7\xFF\0(\xF5\xB8dsolcC\0\x08\x19\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610013575b6100e1565b61001d5f3561002c565b635c60da1b0361000e576100ac565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f91031261004a57565b61003c565b7f000000000000000000000000000000000000000000000000000000000000000090565b60018060a01b031690565b61008790610073565b90565b6100939061007e565b9052565b91906100aa905f6020850194019061008a565b565b346100dc576100bc366004610040565b6100d86100c761004f565b6100cf610032565b91829182610097565b0390f35b610038565b6100e96100f2565b61011f565b5f90565b6100fa6100ee565b507f000000000000000000000000000000000000000000000000000000000000000090565b5f8091368280378136915af43d5f803e5f14610139573d5ff35b3d5ffdfea264697066735822122080cff6d47351357134354912f8cf492c6f48fd7a4b4b1df71eef3fb83d59c1a964736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x13W[a\0\xE1V[a\0\x1D_5a\0,V[c\\`\xDA\x1B\x03a\0\x0EWa\0\xACV[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x91\x03\x12a\0JWV[a\0<V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\0\x87\x90a\0sV[\x90V[a\0\x93\x90a\0~V[\x90RV[\x91\x90a\0\xAA\x90_` \x85\x01\x94\x01\x90a\0\x8AV[V[4a\0\xDCWa\0\xBC6`\x04a\0@V[a\0\xD8a\0\xC7a\0OV[a\0\xCFa\x002V[\x91\x82\x91\x82a\0\x97V[\x03\x90\xF3[a\08V[a\0\xE9a\0\xF2V[a\x01\x1FV[_\x90V[a\0\xFAa\0\xEEV[P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[_\x80\x916\x82\x807\x816\x91Z\xF4=_\x80>_\x14a\x019W=_\xF3[=_\xFD\xFE\xA2dipfsX\"\x12 \x80\xCF\xF6\xD4sQ5q45I\x12\xF8\xCFI,oH\xFDzKK\x1D\xF7\x1E\xEF?\xB8=Y\xC1\xA9dsolcC\0\x08\x19\x003",
    );
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Function with signature `implementation()` and selector `0x5c60da1b`.
```solidity
function implementation() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct implementationCall {}
    ///Container type for the return parameters of the [`implementation()`](implementationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct implementationReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<implementationCall> for UnderlyingRustTuple<'_> {
                fn from(value: implementationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for implementationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<implementationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: implementationReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for implementationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for implementationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = implementationReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "implementation()";
            const SELECTOR: [u8; 4] = [92u8, 96u8, 218u8, 27u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`AtomicSequencer`](self) function calls.
    pub enum AtomicSequencerCalls {
        #[allow(missing_docs)]
        implementation(implementationCall),
    }
    #[automatically_derived]
    impl AtomicSequencerCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[[92u8, 96u8, 218u8, 27u8]];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for AtomicSequencerCalls {
        const NAME: &'static str = "AtomicSequencerCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 1usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::implementation(_) => {
                    <implementationCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<AtomicSequencerCalls>] = &[
                {
                    fn implementation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AtomicSequencerCalls> {
                        <implementationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AtomicSequencerCalls::implementation)
                    }
                    implementation
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::implementation(inner) => {
                    <implementationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::implementation(inner) => {
                    <implementationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`AtomicSequencer`](self) contract instance.

See the [wrapper's documentation](`AtomicSequencerInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> AtomicSequencerInstance<T, P, N> {
        AtomicSequencerInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<AtomicSequencerInstance<T, P, N>>,
    > {
        AtomicSequencerInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        AtomicSequencerInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`AtomicSequencer`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`AtomicSequencer`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct AtomicSequencerInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for AtomicSequencerInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("AtomicSequencerInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > AtomicSequencerInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`AtomicSequencer`](self) contract instance.

See the [wrapper's documentation](`AtomicSequencerInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<AtomicSequencerInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> AtomicSequencerInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> AtomicSequencerInstance<T, P, N> {
            AtomicSequencerInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > AtomicSequencerInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`implementation`] function.
        pub fn implementation(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, implementationCall, N> {
            self.call_builder(&implementationCall {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > AtomicSequencerInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
