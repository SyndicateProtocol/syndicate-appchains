/**

Generated by the following Solidity interface...
```solidity
interface TeeModule {
    struct PendingAssertion {
        bytes32 blockHash;
        bytes32 sendRoot;
        bytes32 seqBlockHash;
    }
    struct TeeTrustedInput {
        bytes32 appchainConfigHash;
        bytes32 appchainStartBlockHash;
        bytes32 seqConfigHash;
        bytes32 seqStartBlockHash;
        bytes32 setDelayedMessageAcc;
        bytes32 l1StartBlockHash;
        bytes32 l1EndBlockHash;
    }

    error ECDSAInvalidSignature();
    error ECDSAInvalidSignatureLength(uint256 length);
    error ECDSAInvalidSignatureS(bytes32 s);
    error OwnableInvalidOwner(address owner);
    error OwnableUnauthorizedAccount(address account);

    event ChallengeResolved(PendingAssertion);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event TeeAppchainConfigHash(bytes32 configHash, bytes32 blockHash);
    event TeeHacked(uint256);
    event TeeInput(TeeTrustedInput input);
    event TeeKeysRevoked();
    event TeeProgramAdded(bytes32 hash);
    event TeeProgramRemoved(bytes32 hash);
    event TeeSeqConfigHash(bytes32 configHash, bytes32 blockHash);

    constructor(address poster_, address bridge_, bytes32 appchainConfigHash_, bytes32 appchainStartBlockHash_, bytes32 seqConfigHash_, bytes32 seqStartBlockHash_, bytes32 l1StartBlockHash_, address l1block_, uint64 challengeWindowDuration_, bytes32 teeProgram);

    receive() external payable;

    function addTeeKey(address publicKey, bytes32 programHash, bytes memory zkProof) external;
    function addTeeProgram(bytes32 hash) external;
    function bridge() external view returns (address);
    function challengeWindowDuration() external view returns (uint64);
    function challengeWindowEnd() external view returns (uint64);
    function closeChallengeWindow() external;
    function isTeeKey(address) external view returns (bool);
    function l1block() external view returns (address);
    function owner() external view returns (address);
    function pendingAssertions(uint256) external view returns (bytes32 blockHash, bytes32 sendRoot, bytes32 seqBlockHash);
    function poster() external view returns (address);
    function removeTeeProgram(bytes32 hash) external;
    function renounceOwnership() external;
    function resolveChallenge(PendingAssertion memory assertion) external;
    function revokeAllTeeKeys() external;
    function setAppchainConfigHash(bytes32 hash) external;
    function setChallengeWindowDuration(uint64 duration) external;
    function setSeqConfigHash(bytes32 hash) external;
    function submitAssertion(PendingAssertion memory assertion, bytes memory signature, address rewardAddr) external;
    function teeHackCount() external view returns (uint256);
    function teeProgramKeys(bytes32, uint256) external view returns (address);
    function teePrograms(uint256) external view returns (bytes32);
    function teeTrustedInput() external view returns (bytes32 appchainConfigHash, bytes32 appchainStartBlockHash, bytes32 seqConfigHash, bytes32 seqStartBlockHash, bytes32 setDelayedMessageAcc, bytes32 l1StartBlockHash, bytes32 l1EndBlockHash);
    function transferOwnership(address newOwner) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "poster_",
        "type": "address",
        "internalType": "contract AssertionPoster"
      },
      {
        "name": "bridge_",
        "type": "address",
        "internalType": "contract IBridge"
      },
      {
        "name": "appchainConfigHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "appchainStartBlockHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "seqConfigHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "seqStartBlockHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "l1StartBlockHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "l1block_",
        "type": "address",
        "internalType": "contract IL1Block"
      },
      {
        "name": "challengeWindowDuration_",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "teeProgram",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "receive",
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "addTeeKey",
    "inputs": [
      {
        "name": "publicKey",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "programHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "zkProof",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addTeeProgram",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "bridge",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IBridge"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "challengeWindowDuration",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "challengeWindowEnd",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "closeChallengeWindow",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "isTeeKey",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "l1block",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IL1Block"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pendingAssertions",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "blockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "sendRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "seqBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "poster",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract AssertionPoster"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "removeTeeProgram",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "resolveChallenge",
    "inputs": [
      {
        "name": "assertion",
        "type": "tuple",
        "internalType": "struct PendingAssertion",
        "components": [
          {
            "name": "blockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "sendRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "seqBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeAllTeeKeys",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setAppchainConfigHash",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setChallengeWindowDuration",
    "inputs": [
      {
        "name": "duration",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setSeqConfigHash",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "submitAssertion",
    "inputs": [
      {
        "name": "assertion",
        "type": "tuple",
        "internalType": "struct PendingAssertion",
        "components": [
          {
            "name": "blockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "sendRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "seqBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      },
      {
        "name": "signature",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "rewardAddr",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "teeHackCount",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "teeProgramKeys",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "teePrograms",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "teeTrustedInput",
    "inputs": [],
    "outputs": [
      {
        "name": "appchainConfigHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "appchainStartBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "seqConfigHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "seqStartBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "setDelayedMessageAcc",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "l1StartBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "l1EndBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "ChallengeResolved",
    "inputs": [
      {
        "name": "",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct PendingAssertion",
        "components": [
          {
            "name": "blockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "sendRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "seqBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeAppchainConfigHash",
    "inputs": [
      {
        "name": "configHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "blockHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeHacked",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeInput",
    "inputs": [
      {
        "name": "input",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct TeeTrustedInput",
        "components": [
          {
            "name": "appchainConfigHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "appchainStartBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "seqConfigHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "seqStartBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "setDelayedMessageAcc",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "l1StartBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "l1EndBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeKeysRevoked",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeProgramAdded",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeProgramRemoved",
    "inputs": [
      {
        "name": "hash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeSeqConfigHash",
    "inputs": [
      {
        "name": "configHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "blockHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureLength",
    "inputs": [
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureS",
    "inputs": [
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "OwnableInvalidOwner",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OwnableUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod TeeModule {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60e0604052346100885761002661001461028a565b98979097969196959295949394610876565b61002e61008d565b613a0d6117768239608051818181610a8c0152611e93015260a051818181610d5401528181611b680152611b9b015260c05181818161051101528181611ace01528181611c5a01528181611d2f0152611f7b0152613a0d90f35b610093565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906100bf90610097565b810190811060018060401b038211176100d757604052565b6100a1565b906100ef6100e861008d565b92836100b5565b565b5f80fd5b60018060a01b031690565b610109906100f5565b90565b61011590610100565b90565b6101218161010c565b0361012857565b5f80fd5b9050519061013982610118565b565b61014490610100565b90565b6101508161013b565b0361015757565b5f80fd5b9050519061016882610147565b565b90565b6101768161016a565b0361017d57565b5f80fd5b9050519061018e8261016d565b565b61019990610100565b90565b6101a581610190565b036101ac57565b5f80fd5b905051906101bd8261019c565b565b60018060401b031690565b6101d3816101bf565b036101da57565b5f80fd5b905051906101eb826101ca565b565b6101408183031261028557610204825f830161012c565b92610212836020840161015b565b926102208160408501610181565b9261022e8260608301610181565b9261023c8360808401610181565b9261024a8160a08501610181565b926102588260c08301610181565b926102826102698460e085016101b0565b936102788161010086016101de565b9361012001610181565b90565b6100f1565b6102a86151838038038061029d816100dc565b9283398101906101ed565b90919293949596979899565b60401b90565b906102d468010000000000000000600160801b03916102b4565b9181191691161790565b90565b6102f56102f06102fa926101bf565b6102de565b6101bf565b90565b90565b9061031561031061031c926102e1565b6102fd565b82546102ba565b9055565b61033461032f610339926100f5565b6102de565b6100f5565b90565b61034590610320565b90565b6103519061033c565b90565b90565b61036b61036661037092610354565b6102de565b6100f5565b90565b61037c90610357565b90565b5f80fd5b60e01b90565b906020828203126103a25761039f915f016101de565b90565b6100f1565b5f0190565b6103b461008d565b3d5f823e3d90fd5b6103d06103cb6103d592610354565b6102de565b6101bf565b90565b906020828203126103f1576103ee915f01610181565b90565b6100f1565b5f1b90565b61040f61040a61041492610354565b6103f6565b61016a565b90565b60209181520190565b5f7f6c3120636f6e747261637420696e76616c696400000000000000000000000000910152565b6104546013602092610417565b61045d81610420565b0190565b6104769060208101905f818303910152610447565b90565b1561048057565b61048861008d565b62461bcd60e51b81528061049e60048201610461565b0390fd5b6104ab9061033c565b90565b90565b6104c56104c06104ca92610354565b6102de565b6104ae565b90565b60207f20636f6465000000000000000000000000000000000000000000000000000000917f706f73746572206164647265737320646f6573206e6f74206861766520616e795f8201520152565b6105276025604092610417565b610530816104cd565b0190565b6105499060208101905f81830391015261051a565b90565b1561055357565b61055b61008d565b62461bcd60e51b81528061057160048201610534565b0390fd5b61057e9061033c565b90565b61058a816104ae565b0361059157565b5f80fd5b905051906105a282610581565b565b906020828203126105bd576105ba915f01610595565b90565b6100f1565b60207f2062726964676500000000000000000000000000000000000000000000000000917f696e73756666696369656e742064656c61796564206d6573736167657320696e5f8201520152565b61061c6027604092610417565b610625816105c2565b0190565b61063e9060208101905f81830391015261060f565b90565b1561064857565b61065061008d565b62461bcd60e51b81528061066660048201610629565b0390fd5b906106765f19916103f6565b9181191691161790565b6106899061016a565b90565b5f1c90565b61069a9061068c565b90565b906106b26106ad6106b992610680565b610691565b825461066a565b9055565b6106c69061016a565b9052565b9160206106eb9294936106e460408201965f8301906106bd565b01906106bd565b565b60207f6f00000000000000000000000000000000000000000000000000000000000000917f7465652070726f6772616d2068617368206d757374206265206e6f6e2d7a65725f8201520152565b6107476021604092610417565b610750816106ed565b0190565b6107699060208101905f81830391015261073a565b90565b1561077357565b61077b61008d565b62461bcd60e51b81528061079160048201610754565b0390fd5b90565b5f5260205f2090565b634e487b7160e01b5f52603260045260245ffd5b5490565b6107c2816107b5565b8210156107dc576107d4600191610798565b910201905f90565b6107a1565b1b90565b919060086108009102916107fa5f19846107e1565b926107e1565b9181191691161790565b919061082061081b61082893610680565b610691565b9083546107e5565b9055565b908154916801000000000000000083101561085c578261085491600161085a950181556107b9565b9061080a565b565b6100a1565b9190610874905f602085019401906106bd565b565b90919293949596976108929061088b33610c1d565b600d610300565b61089b88610348565b6108b56108af6108aa5f610373565b610100565b91610100565b148015610ab7575b976108ca61091699610479565b60c0526108f26108d9826104a2565b3b6108ec6108e65f6104b1565b916104ae565b1161054c565b608052602061090082610575565b63eca067ad9061090e61008d565b998a92610383565b82528180610926600482016103a7565b03915afa968715610ab257610a1097610959915f91610a84575b5061095361094d5f6104b1565b916104ae565b11610641565b60a052610969815f60010161069d565b610976826001800161069d565b907fc985bccbd0c90e197f4a7373020a33ba6ff864d0399fd7d65c5c7c32ffb015ec916109ad6109a461008d565b928392836106ca565b0390a16109be81600260010161069d565b6109cc82600360010161069d565b907fb9eb20b32fac965884cb58326102257cae604504f0a36cd1008a32845ad5c29b91610a036109fa61008d565b928392836106ca565b0390a1600560010161069d565b610a2d81610a26610a205f6103fb565b9161016a565b141561076c565b610a41610a3a600a610795565b829061082c565b610a777f9a7a6469c25cf017890607695e4a149cc771f294fd871e2080d24cd109033ab691610a6e61008d565b91829182610861565b0390a1610a826111d0565b565b610aa5915060203d8111610aab575b610a9d81836100b5565b8101906105a4565b5f610940565b503d610a93565b6103ac565b50610adc6020610ac68a610348565b63b80777ea90610ad461008d565b938492610383565b82528180610aec600482016103a7565b03915afa908115610bf6575f91610bc8575b50610b11610b0b5f6103bc565b916101bf565b119788610b29575b6108ca61091699919950506108bd565b610b4f98506020610b3982610348565b6309bd5a6090610b4761008d565b9b8c92610383565b82528180610b5f600482016103a7565b03915afa988915610bc357610916996108ca915f91610b95575b50610b8c610b865f6103fb565b9161016a565b11995050610b19565b610bb6915060203d8111610bbc575b610bae81836100b5565b8101906103d8565b5f610b79565b503d610ba4565b6103ac565b610be9915060203d8111610bef575b610be181836100b5565b810190610389565b5f610afe565b503d610bd7565b6103ac565b610c0490610100565b9052565b9190610c1b905f60208501940190610bfb565b565b80610c38610c32610c2d5f610373565b610100565b91610100565b14610c4857610c4690611716565b565b610c6b610c545f610373565b5f918291631e4fbdf760e01b835260048301610c08565b0390fd5b5490565b90565b610c8a610c85610c8f92610c73565b6102de565b6104ae565b90565b60207f746f6f206d616e7920617373657274696f6e7300000000000000000000000000917f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201520152565b610cec6033604092610417565b610cf581610c92565b0190565b610d0e9060208101905f818303910152610cdf565b90565b15610d1857565b610d2061008d565b62461bcd60e51b815280610d3660048201610cf9565b0390fd5b610d449051610190565b90565b610d5b610d56610d60926104ae565b6102de565b6101bf565b90565b60018060401b031690565b610d7a610d7f9161068c565b610d63565b90565b610d8c9054610d6e565b90565b60207f696e73756666696369656e742074696d65206861732070617373656400000000917f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201520152565b610de9603c604092610417565b610df281610d8f565b0190565b610e0b9060208101905f818303910152610ddc565b90565b15610e1557565b610e1d61008d565b62461bcd60e51b815280610e3360048201610df6565b0390fd5b5f5260205f2090565b610e4981610c6f565b821015610e6357610e5b600391610e37565b910201905f90565b6107a1565b90565b610e77610e7c9161068c565b610e68565b90565b610e899054610e6b565b90565b610e96905161010c565b90565b5f910312610ea357565b6100f1565b634e487b7160e01b5f52601160045260245ffd5b610ecb610ed1919392936104ae565b926104ae565b91610edd8382026104ae565b928184041490151715610eec57565b610ea8565b610efc906003610ebc565b90565b5f90565b610f1591610f0f610eff565b9161080a565b565b5f6002610f3d92610f2a83808301610f03565b610f378360018301610f03565b01610f03565b565b634e487b7160e01b5f525f60045260245ffd5b905f03610f6457610f6290610f17565b565b610f3f565b5b818110610f75575050565b80610f825f600393610f52565b01610f6a565b9091828110610f97575b505050565b610fb5610faf610fa9610fc095610ef1565b92610ef1565b92610e37565b918201910190610f69565b5f8080610f92565b90680100000000000000008111610ff15781610fe6610fef93610c6f565b90828155610f88565b565b6100a1565b5f61100091610fc8565b565b905f036110145761101290610ff6565b565b610f3f565b611023905161013b565b90565b61103561103b919392936104ae565b926104ae565b820391821161104657565b610ea8565b611054906104ae565b9052565b919061106b905f6020850194019061104b565b565b6110769061016a565b9052565b9060c0611127600661112f9461109e6110955f830154610e6b565b5f87019061106d565b6110b86110ae6001830154610e6b565b602087019061106d565b6110d26110c86002830154610e6b565b604087019061106d565b6110ec6110e26003830154610e6b565b606087019061106d565b6111066110fc6004830154610e6b565b608087019061106d565b6111206111166005830154610e6b565b60a087019061106d565b0154610e6b565b91019061106d565b565b9190611144905f60e0850194019061107a565b565b60401c90565b61115861115d91611146565b610d63565b90565b61116a905461114c565b90565b61117961117f916101bf565b916101bf565b019060018060401b03821161119057565b610ea8565b906111a660018060401b03916103f6565b9181191691161790565b906111c56111c06111cc926102e1565b6102fd565b8254611195565b9055565b6111f76111dd6008610c6f565b6111f06111ea6001610c76565b916104ae565b1115610d11565b61120961120460c0610d3a565b610348565b61122361121d6112185f610373565b610100565b91610100565b145f146116155761125861123642610d47565b5b61125261124c611247600d610d82565b6101bf565b916101bf565b11610e0e565b6112626008610c6f565b61127461126e5f6104b1565b916104ae565b116114e7575b61128c61128760a0611019565b610575565b6112be63d5719dc260206112a86112a360a0611019565b610575565b63eca067ad906112b661008d565b948592610383565b825281806112ce600482016103a7565b03915afa9283156114e2576113136112fe61131e956020955f916114b5575b506112f86001610c76565b90611026565b9261130761008d565b95869485938493610383565b835260048301611058565b03915afa80156114b05761133e915f91611482575b50600460010161069d565b61135061134b60c0610d3a565b610348565b61136a61136461135f5f610373565b610100565b91610100565b145f146113f757611394611388436113826001610c76565b90611026565b405b600660010161069d565b60016113cc7f91092bcf550921e381e81f06693320534b144a7e561c5fc08f1940d508a85cdc916113c361008d565b91829182611131565b0390a16113f56113ee6113de42610d47565b6113e8600d611160565b9061116d565b600d6111b0565b565b611424602061140e61140960c0610d3a565b610348565b6309bd5a609061141c61008d565b938492610383565b82528180611434600482016103a7565b03915afa801561147d57611394915f9161144f575b5061138a565b611470915060203d8111611476575b61146881836100b5565b8101906103d8565b5f611449565b503d61145e565b6103ac565b6114a3915060203d81116114a9575b61149b81836100b5565b8101906103d8565b5f611333565b503d611491565b6103ac565b6114d59150863d81116114db575b6114cd81836100b5565b8101906105a4565b5f6112ed565b503d6114c3565b6103ac565b61150a6115015f6114fa60088290610e40565b5001610e7f565b6001800161069d565b61152f611525600261151e60085f90610e40565b5001610e7f565b600360010161069d565b61154961153f6006600101610e7f565b600560010161069d565b61155b6115566080610e8c565b6104a2565b63daeab4126115775f61157060088290610e40565b5001610e7f565b61158f600161158860085f90610e40565b5001610e7f565b92803b15611610576115b45f80946115bf6115a861008d565b97889687958694610383565b8452600484016106ca565b03925af1801561160b576115df575b506115da5f6008611002565b61127a565b6115fe905f3d8111611604575b6115f681836100b5565b810190610e99565b5f6115ce565b503d6115ec565b6103ac565b61037f565b611642602061162c61162760c0610d3a565b610348565b63b80777ea9061163a61008d565b938492610383565b82528180611652600482016103a7565b03915afa801561169b57611258915f9161166d575b50611237565b61168e915060203d8111611694575b61168681836100b5565b810190610389565b5f611667565b503d61167c565b6103ac565b60018060a01b031690565b6116b76116bc9161068c565b6116a0565b90565b6116c990546116ab565b90565b906116dd60018060a01b03916103f6565b9181191691161790565b6116f09061033c565b90565b90565b9061170b611706611712926116e7565b6116f3565b82546116cc565b9055565b61171f5f6116bf565b611729825f6116f6565b9061175d6117577f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0936116e7565b916116e7565b9161176661008d565b80611770816103a7565b0390a356fe60806040526004361015610015575b36610ef757005b61001f5f3561019e565b80631c12427f1461019957806333339006146101945780633ceaae7d1461018f578063420caf3a1461018a57806347742640146101855780634afffcc9146101805780634bd167c91461017b5780635f70c44114610176578063697b5e62146101715780636c4c20601461016c5780636ef012011461016757806370646ea214610162578063715018a61461015d57806380959721146101585780638da5cb5b146101535780638fed55a31461014e578063a56ec6cd14610149578063c3f2dbd314610144578063e50c61561461013f578063e78cea921461013a578063eb60553a14610135578063ee1c28b814610130578063f223055c1461012b5763f2fde38b0361000e57610ec4565b610e91565b610e5c565b610e1a565b610da4565b610d1b565b610c95565b610c5d565b610b7b565b610b11565b610adc565b610a57565b610a20565b610950565b61091d565b6108e8565b61085b565b610826565b61077f565b610690565b61058c565b6104d3565b610393565b6101ff565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b90565b6101c2816101b6565b036101c957565b5f80fd5b905035906101da826101b9565b565b906020828203126101f5576101f2915f016101cd565b90565b6101ae565b5f0190565b3461022d576102176102123660046101dc565b61115a565b61021f6101a4565b80610229816101fa565b0390f35b6101aa565b90565b61023e81610232565b0361024557565b5f80fd5b9050359061025682610235565b565b9190604083820312610280578061027461027d925f86016101cd565b93602001610249565b90565b6101ae565b61028e906101b6565b90565b9061029b90610285565b5f5260205260405f2090565b634e487b7160e01b5f52603260045260245ffd5b5490565b5f5260205f2090565b6102d1816102bb565b8210156102eb576102e36001916102bf565b910201905f90565b6102a7565b1c90565b60018060a01b031690565b61030f90600861031493026102f0565b6102f4565b90565b9061032291546102ff565b90565b61033090600b610291565b610339816102bb565b821015610356576103539161034d916102c8565b90610317565b90565b5f80fd5b60018060a01b031690565b61036e9061035a565b90565b61037a90610365565b9052565b9190610391905f60208501940190610371565b565b346103c4576103c06103af6103a9366004610258565b90610325565b6103b76101a4565b9182918261037e565b0390f35b6101aa565b5f9103126103d357565b6101ae565b5f1c90565b90565b6103ec6103f1916103d8565b6103dd565b90565b6103fe90546103e0565b90565b600161040e5f82016103f4565b9161041b600183016103f4565b91610428600282016103f4565b91610435600383016103f4565b91610442600482016103f4565b9161045b6006610454600585016103f4565b93016103f4565b90565b610467906101b6565b9052565b949290979695939160e08601985f87016104849161045e565b602086016104919161045e565b6040850161049e9161045e565b606084016104ab9161045e565b608083016104b89161045e565b60a082016104c59161045e565b60c0016104d19161045e565b565b3461050a576104e33660046103c9565b6105066104ee610401565b936104fd9795979391936101a4565b9788978861046b565b0390f35b6101aa565b7f000000000000000000000000000000000000000000000000000000000000000090565b90565b61054a61054561054f9261035a565b610533565b61035a565b90565b61055b90610536565b90565b61056790610552565b90565b6105739061055e565b9052565b919061058a905f6020850194019061056a565b565b346105bc5761059c3660046103c9565b6105b86105a761050f565b6105af6101a4565b91829182610577565b0390f35b6101aa565b6105ca81610365565b036105d157565b5f80fd5b905035906105e2826105c1565b565b906020828203126105fd576105fa915f016105d5565b90565b6101ae565b61060b90610552565b90565b9061061890610602565b5f5260205260405f2090565b60ff1690565b61063a90600861063f93026102f0565b610624565b90565b9061064d915461062a565b90565b61066690610661600c915f9261060e565b610642565b90565b151590565b61067790610669565b9052565b919061068e905f6020850194019061066e565b565b346106c0576106bc6106ab6106a63660046105e4565b610650565b6106b36101a4565b9182918261067b565b0390f35b6101aa565b906020828203126106de576106db915f01610249565b90565b6101ae565b5490565b5f5260205f2090565b6106f9816106e3565b8210156107135761070b6001916106e7565b910201905f90565b6102a7565b61072890600861072d93026102f0565b6103dd565b90565b9061073b9154610718565b90565b600a610749816106e3565b821015610766576107639161075d916106f0565b90610730565b90565b5f80fd5b919061077d905f6020850194019061045e565b565b346107af576107ab61079a6107953660046106c5565b61073e565b6107a26101a4565b9182918261076a565b0390f35b6101aa565b67ffffffffffffffff1690565b6107d19060086107d693026102f0565b6107b4565b90565b906107e491546107c1565b90565b6107f4600d6008906107d9565b90565b67ffffffffffffffff1690565b61080d906107f7565b9052565b9190610824905f60208501940190610804565b565b34610856576108363660046103c9565b6108526108416107e7565b6108496101a4565b91829182610811565b0390f35b6101aa565b346108895761087361086e3660046101dc565b6114c7565b61087b6101a4565b80610885816101fa565b0390f35b6101aa565b90565b6108a19060086108a693026102f0565b61088e565b90565b906108b49154610891565b90565b6108c360095f906108a9565b90565b6108cf90610232565b9052565b91906108e6905f602085019401906108c6565b565b34610918576108f83660046103c9565b6109146109036108b7565b61090b6101a4565b918291826108d3565b0390f35b6101aa565b3461094b5761092d3660046103c9565b610935611aa2565b61093d6101a4565b80610947816101fa565b0390f35b6101aa565b3461097e576109603660046103c9565b61096861217b565b6109706101a4565b8061097a816101fa565b0390f35b6101aa565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156109c95781359167ffffffffffffffff83116109c45760200192600183028401116109bf57565b61098b565b610987565b610983565b91606083830312610a1b576109e5825f85016105d5565b926109f383602083016101cd565b92604082013567ffffffffffffffff8111610a1657610a12920161098f565b9091565b6101b2565b6101ae565b34610a5257610a3c610a333660046109ce565b92919091612386565b610a446101a4565b80610a4e816101fa565b0390f35b6101aa565b34610a8557610a673660046103c9565b610a6f6124f5565b610a776101a4565b80610a81816101fa565b0390f35b6101aa565b7f000000000000000000000000000000000000000000000000000000000000000090565b610ab790610552565b90565b610ac390610aae565b9052565b9190610ada905f60208501940190610aba565b565b34610b0c57610aec3660046103c9565b610b08610af7610a8a565b610aff6101a4565b91829182610ac7565b0390f35b6101aa565b34610b4157610b213660046103c9565b610b3d610b2c612524565b610b346101a4565b9182918261037e565b0390f35b6101aa565b5f80fd5b90816060910312610b585790565b610b46565b90606082820312610b7657610b73915f01610b4a565b90565b6101ae565b34610ba957610b93610b8e366004610b5d565b6128d0565b610b9b6101a4565b80610ba5816101fa565b0390f35b6101aa565b5490565b5f5260205f2090565b610bc481610bae565b821015610bde57610bd6600391610bb2565b910201905f90565b6102a7565b600890610bef82610bae565b811015610c2757610bff91610bbb565b50610c0b5f82016103f4565b91610c246002610c1d600185016103f4565b93016103f4565b90565b5f80fd5b604090610c54610c5b9496959396610c4a60608401985f85019061045e565b602083019061045e565b019061045e565b565b34610c9057610c8c610c78610c733660046106c5565b610be3565b610c839391936101a4565b93849384610c2b565b0390f35b6101aa565b34610cc357610cad610ca83660046101dc565b612a11565b610cb56101a4565b80610cbf816101fa565b0390f35b6101aa565b9060a082820312610d1657610cdf815f8401610b4a565b92606083013567ffffffffffffffff8111610d1157610d0383610d0e92860161098f565b9390946080016105d5565b90565b6101b2565b6101ae565b34610d4d57610d37610d2e366004610cc8565b92919091612ead565b610d3f6101a4565b80610d49816101fa565b0390f35b6101aa565b7f000000000000000000000000000000000000000000000000000000000000000090565b610d7f90610552565b90565b610d8b90610d76565b9052565b9190610da2905f60208501940190610d82565b565b34610dd457610db43660046103c9565b610dd0610dbf610d52565b610dc76101a4565b91829182610d8f565b0390f35b6101aa565b610de2816107f7565b03610de957565b5f80fd5b90503590610dfa82610dd9565b565b90602082820312610e1557610e12915f01610ded565b90565b6101ae565b34610e4857610e32610e2d366004610dfc565b61327d565b610e3a6101a4565b80610e44816101fa565b0390f35b6101aa565b610e59600d5f906107d9565b90565b34610e8c57610e6c3660046103c9565b610e88610e77610e4d565b610e7f6101a4565b91829182610811565b0390f35b6101aa565b34610ebf57610ea9610ea43660046101dc565b613314565b610eb16101a4565b80610ebb816101fa565b0390f35b6101aa565b34610ef257610edc610ed73660046105e4565b613384565b610ee46101a4565b80610eee816101fa565b0390f35b6101aa565b5f80fd5b610f0c90610f0761338f565b61109f565b565b90565b610f25610f20610f2a92610f0e565b610533565b610232565b90565b6001610f399101610232565b90565b60209181520190565b5f7f7465652070726f6772616d20616c726561647920657869737473000000000000910152565b610f79601a602092610f3c565b610f8281610f45565b0190565b610f9b9060208101905f818303910152610f6c565b90565b15610fa557565b610fad6101a4565b62461bcd60e51b815280610fc360048201610f86565b0390fd5b90565b634e487b7160e01b5f52604160045260245ffd5b5f5260205f2090565b5490565b610ff481610fe7565b82101561100e57611006600191610fde565b910201905f90565b6102a7565b1b90565b9190600861103291029161102c5f1984611013565b92611013565b9181191691161790565b611045906103d8565b90565b919061105e61105961106693610285565b61103c565b908354611017565b9055565b908154916801000000000000000083101561109a578261109291600161109895018155610feb565b90611048565b565b610fca565b6110a85f610f11565b5b806110c56110bf6110ba600a6106e3565b610232565b91610232565b101561110a57611105906111006110e76110e1600a84906106f0565b90610730565b6110f96110f3866101b6565b916101b6565b1415610f9e565b610f2d565b6110a9565b5061111f611118600a610fc7565b829061106a565b6111557f9a7a6469c25cf017890607695e4a149cc771f294fd871e2080d24cd109033ab69161114c6101a4565b9182918261076a565b0390a1565b61116390610efb565b565b6111769061117161338f565b6113da565b565b60207f617373657274696f6e2069732070656e64696e67000000000000000000000000917f63616e6e6f742072656d6f7665207465652070726f6772616d207768696c65205f8201520152565b6111d26034604092610f3c565b6111db81611178565b0190565b6111f49060208101905f8183039101526111c5565b90565b156111fe57565b6112066101a4565b62461bcd60e51b81528061121c600482016111df565b0390fd5b5f1b90565b9061123160ff91611220565b9181191691161790565b61124490610669565b90565b90565b9061125f61125a6112669261123b565b611247565b8254611225565b9055565b634e487b7160e01b5f52601160045260245ffd5b61128d61129391939293610232565b92610232565b9161129f838202610232565b9281840414901517156112ae57565b61126a565b600190818003010490565b6112d26112cd6112d792610232565b610533565b610232565b90565b90565b91906112f36112ee6112fb936112be565b6112da565b908354611017565b9055565b5f90565b6113159161130f6112ff565b916112dd565b565b5b818110611323575050565b806113305f600193611303565b01611318565b9091828110611345575b505050565b61136361135d61135761136e956112b3565b926112b3565b926102bf565b918201910190611317565b5f8080611340565b9068010000000000000000811161139f578161139461139d936102bb565b90828155611336565b565b610fca565b5f6113ae91611376565b565b634e487b7160e01b5f525f60045260245ffd5b905f036113d5576113d3906113a4565b565b6113b0565b6113ff6113e76008610bae565b6113f96113f35f610f11565b91610232565b146111f7565b6114085f610f11565b5b8061142f61142961142461141f600b8790610291565b6102bb565b610232565b91610232565b1015611476576114719061146c5f611467600c61146161145b611454600b8a90610291565b87906102c8565b90610317565b9061060e565b61124a565b610f2d565b611409565b5061148c5f611487600b8490610291565b6113c3565b6114c27f2621c61d3315f2a3d26b22d746ba21a96d249f51ada323f7226cce5fe5fc3d64916114b96101a4565b9182918261076a565b0390a1565b6114d090611165565b565b90565b6114e96114e46114ee926114d2565b610533565b610232565b90565b60207f746f6f206d616e7920617373657274696f6e7300000000000000000000000000917f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201520152565b61154b6033604092610f3c565b611554816114f1565b0190565b61156d9060208101905f81830391015261153e565b90565b1561157757565b61157f6101a4565b62461bcd60e51b81528061159560048201611558565b0390fd5b6115ad6115a86115b292610f0e565b610533565b61035a565b90565b6115be90611599565b90565b5f80fd5b601f801991011690565b906115d9906115c5565b810190811067ffffffffffffffff8211176115f357604052565b610fca565b60e01b90565b9050519061160b82610dd9565b565b9060208282031261162657611623915f016115fe565b90565b6101ae565b6116336101a4565b3d5f823e3d90fd5b61164f61164a61165492610232565b610533565b6107f7565b90565b611663611668916103d8565b6107b4565b90565b6116759054611657565b90565b60207f696e73756666696369656e742074696d65206861732070617373656400000000917f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201520152565b6116d2603c604092610f3c565b6116db81611678565b0190565b6116f49060208101905f8183039101526116c5565b90565b156116fe57565b6117066101a4565b62461bcd60e51b81528061171c600482016116df565b0390fd5b9061172c5f1991611220565b9181191691161790565b9061174b61174661175292610285565b61103c565b8254611720565b9055565b5f91031261176057565b6101ae565b91602061178692949361177f60408201965f83019061045e565b019061045e565b565b61179390600361127e565b90565b5f90565b6117ac916117a6611796565b91611048565b565b5f60026117d4926117c18380830161179a565b6117ce836001830161179a565b0161179a565b565b905f036117e8576117e6906117ae565b565b6113b0565b5b8181106117f9575050565b806118065f6003936117d6565b016117ee565b909182811061181b575b505050565b61183961183361182d61184495611788565b92611788565b92610bb2565b9182019101906117ed565b5f8080611816565b90680100000000000000008111611875578161186a61187393610bae565b9082815561180c565b565b610fca565b5f6118849161184c565b565b905f03611898576118969061187a565b565b6113b0565b905051906118aa82610235565b565b906020828203126118c5576118c2915f0161189d565b90565b6101ae565b6118d96118df91939293610232565b92610232565b82039182116118ea57565b61126a565b905051906118fc826101b9565b565b9060208282031261191757611914915f016118ef565b90565b6101ae565b611925906101b6565b9052565b9060c06119d660066119de9461194d6119445f8301546103e0565b5f87019061191c565b61196761195d60018301546103e0565b602087019061191c565b61198161197760028301546103e0565b604087019061191c565b61199b61199160038301546103e0565b606087019061191c565b6119b56119ab60048301546103e0565b608087019061191c565b6119cf6119c560058301546103e0565b60a087019061191c565b01546103e0565b91019061191c565b565b91906119f3905f60e08501940190611929565b565b60401c90565b611a07611a0c916119f5565b6107b4565b90565b611a1990546119fb565b90565b611a28611a2e916107f7565b916107f7565b019067ffffffffffffffff8211611a4157565b61126a565b90611a5967ffffffffffffffff91611220565b9181191691161790565b611a77611a72611a7c926107f7565b610533565b6107f7565b90565b90565b90611a97611a92611a9e92611a63565b611a7f565b8254611a46565b9055565b611ac9611aaf6008610bae565b611ac2611abc60016114d5565b91610232565b1115611570565b611af27f000000000000000000000000000000000000000000000000000000000000000061055e565b611b0c611b06611b015f6115b5565b610365565b91610365565b145f14611f7157611b41611b1f4261163b565b5b611b3b611b35611b30600d61166b565b6107f7565b916107f7565b116116f7565b611b4b6008610bae565b611b5d611b575f610f11565b91610232565b11611e2c575b611b8c7f0000000000000000000000000000000000000000000000000000000000000000610d76565b611bd563d5719dc26020611bbf7f0000000000000000000000000000000000000000000000000000000000000000610d76565b63eca067ad90611bcd6101a4565b9485926115f8565b82528180611be5600482016101fa565b03915afa928315611e2757611c2a611c15611c35956020955f91611dfa575b50611c0f60016114d5565b906118ca565b92611c1e6101a4565b958694859384936115f8565b8352600483016108d3565b03915afa8015611df557611c55915f91611dc7575b506004600101611736565b611c7e7f000000000000000000000000000000000000000000000000000000000000000061055e565b611c98611c92611c8d5f6115b5565b610365565b91610365565b145f14611d2557611cc2611cb643611cb060016114d5565b906118ca565b405b6006600101611736565b6001611cfa7f91092bcf550921e381e81f06693320534b144a7e561c5fc08f1940d508a85cdc91611cf16101a4565b918291826119e0565b0390a1611d23611d1c611d0c4261163b565b611d16600d611a0f565b90611a1c565b600d611a82565b565b611d696020611d537f000000000000000000000000000000000000000000000000000000000000000061055e565b6309bd5a6090611d616101a4565b9384926115f8565b82528180611d79600482016101fa565b03915afa8015611dc257611cc2915f91611d94575b50611cb8565b611db5915060203d8111611dbb575b611dad81836115cf565b8101906118fe565b5f611d8e565b503d611da3565b61162b565b611de8915060203d8111611dee575b611de081836115cf565b8101906118fe565b5f611c4a565b503d611dd6565b61162b565b611e1a9150863d8111611e20575b611e1281836115cf565b8101906118ac565b5f611c04565b503d611e08565b61162b565b611e4f611e465f611e3f60088290610bbb565b50016103f4565b60018001611736565b611e74611e6a6002611e6360085f90610bbb565b50016103f4565b6003600101611736565b611e8e611e8460066001016103f4565b6005600101611736565b611eb77f0000000000000000000000000000000000000000000000000000000000000000610aae565b63daeab412611ed35f611ecc60088290610bbb565b50016103f4565b611eeb6001611ee460085f90610bbb565b50016103f4565b92803b15611f6c57611f105f8094611f1b611f046101a4565b978896879586946115f8565b845260048401611765565b03925af18015611f6757611f3b575b50611f365f6008611886565b611b63565b611f5a905f3d8111611f60575b611f5281836115cf565b810190611756565b5f611f2a565b503d611f48565b61162b565b6115c1565b611fb56020611f9f7f000000000000000000000000000000000000000000000000000000000000000061055e565b63b80777ea90611fad6101a4565b9384926115f8565b82528180611fc5600482016101fa565b03915afa801561200e57611b41915f91611fe0575b50611b20565b612001915060203d8111612007575b611ff981836115cf565b81019061160d565b5f611fda565b503d611fef565b61162b565b61201b61338f565b6120236120e0565b565b600190818003010490565b5b81811061203c575050565b806120495f60019361179a565b01612031565b909182811061205e575b505050565b61207c61207661207061208795612025565b92612025565b926106e7565b918201910190612030565b5f8080612059565b906801000000000000000081116120b857816120ad6120b6936106e3565b9082815561204f565b565b610fca565b5f6120c79161208f565b565b905f036120db576120d9906120bd565b565b6113b0565b6120e95f610f11565b5b806121066121006120fb600a6106e3565b610232565b91610232565b1015612137576121329061212d612128612122600a84906106f0565b90610730565b6114c7565b610f2d565b6120ea565b506121435f600a6120c9565b7feca62e0074a13a90d600f003b7cb8d5bd50100008d3f3915f2554f3f8552c5cc61216c6101a4565b80612176816101fa565b0390a1565b612183612013565b565b5090565b5f7f746f646f3a2076616c6964617465207a6b207a6b50726f6f6600000000000000910152565b6121bd6019602092610f3c565b6121c681612189565b0190565b6121df9060208101905f8183039101526121b0565b90565b156121e957565b6121f16101a4565b62461bcd60e51b815280612207600482016121ca565b0390fd5b61221761221c916103d8565b610624565b90565b612229905461220b565b90565b5f7f6b657920616c7265616479206164646564000000000000000000000000000000910152565b6122606011602092610f3c565b6122698161222c565b0190565b6122829060208101905f818303910152612253565b90565b1561228c57565b6122946101a4565b62461bcd60e51b8152806122aa6004820161226d565b0390fd5b6122b790610232565b5f81146122c5576001900390565b61126a565b90565b5f5260205f2090565b5490565b6122e3816122d6565b8210156122fd576122f56001916122cd565b910201905f90565b6102a7565b9190600861232291029161231c60018060a01b0384611013565b92611013565b9181191691161790565b90565b919061234561234061234d93610602565b61232c565b908354612302565b9055565b9081549168010000000000000000831015612381578261237991600161237f950181556122da565b9061232f565b565b610fca565b92612395906123ae9293612185565b6123a86123a260016114d5565b91610232565b146121e2565b6123d36123ce6123c86123c3600c869061060e565b61221f565b15610669565b612285565b6123e76123e2600b8390610291565b6102bb565b6123f96123f35f610f11565b91610232565b14612433575b9061242c61242761243193612420600161241b600c879061060e565b61124a565b600b610291565b6122ca565b612351565b565b5f9161243f600a6106e3565b5b8061245361244d5f610f11565b91610232565b11156124c45761248161247b600a6124758461246f60016114d5565b906118ca565b906106f0565b90610730565b61249361248d856101b6565b916101b6565b146124a6576124a1906122ae565b612440565b509091506124b660015b15610669565b6124c057906123ff565b5050565b5090916124b6906124b0565b6124d861338f565b6124e06124e2565b565b6124f36124ee5f6115b5565b613418565b565b6124fd6124d0565b565b5f90565b61250f612514916103d8565b6102f4565b90565b6125219054612503565b90565b61252c6124ff565b506125365f612517565b90565b61254a9061254561338f565b612798565b565b5f7f6368616c6c656e676520646f6573206e6f742065786973740000000000000000910152565b6125806018602092610f3c565b6125898161254c565b0190565b6125a29060208101905f818303910152612573565b90565b156125ac57565b6125b46101a4565b62461bcd60e51b8152806125ca6004820161258d565b0390fd5b90565b90565b5f5260205f2090565b5490565b6125ea816125dd565b821015612604576125fc6003916125d4565b910201905f90565b6102a7565b35612613816101b9565b90565b9061265a60406002612660946126395f82016126335f8801612609565b90611736565b6126526001820161264c60208801612609565b90611736565b019201612609565b90611736565b565b91906126735761267191612616565b565b6113b0565b90815491680100000000000000008310156126a857826126a09160016126a6950181556125e1565b90612662565b565b610fca565b6126c16126bc6126c692610f0e565b610533565b6107f7565b90565b506126d89060208101906101cd565b90565b906040612720612728936126fd6126f45f8301836126c9565b5f86019061191c565b61271761270d60208301836126c9565b602086019061191c565b828101906126c9565b91019061191c565b565b919061273d905f606085019401906126db565b565b5f7f617373657274696f6e206e6f7420666f756e6400000000000000000000000000910152565b6127736013602092610f3c565b61277c8161273f565b0190565b6127959060208101905f818303910152612766565b90565b6127be6127a56008610bae565b6127b86127b260016114d5565b91610232565b116125a5565b6127c7816134a2565b906127d15f610f11565b5b806127ee6127e86127e36008610bae565b610232565b91610232565b10156128ae578261282361281d61281861281361280d60088790610bbb565b506125ce565b61350d565b6101b6565b916101b6565b146128365761283190610f2d565b6127d2565b5090506128445f6008611886565b61285861285160086125d1565b8290612678565b61286b6128645f6126ad565b600d611a82565b612873611aa2565b6128a97fe42eaf0737e2478a5f5aed3a0610ae7b09a27cbac9ad6a5cc4d68f78afd1425b916128a06101a4565b9182918261272a565b0390a1565b6128b66101a4565b62461bcd60e51b8152806128cc60048201612780565b0390fd5b6128d990612539565b565b6128ec906128e761338f565b612996565b565b60207f617373657274696f6e73206172652070656e64696e6700000000000000000000917f63616e6e6f742075706461746520636f6e6669672068617368207768696c65205f8201520152565b6129486036604092610f3c565b612951816128ee565b0190565b61296a9060208101905f81830391015261293b565b90565b1561297457565b61297c6101a4565b62461bcd60e51b81528061299260048201612955565b0390fd5b6129bb6129a36008610bae565b6129b56129af5f610f11565b91610232565b1461296d565b6129c9816002600101611736565b6129d660036001016103f4565b7fb9eb20b32fac965884cb58326102257cae604504f0a36cd1008a32845ad5c29b91612a0c612a036101a4565b92839283611765565b0390a1565b612a1a906128db565b565b90565b612a33612a2e612a3892612a1c565b610533565b610232565b90565b5f7f696e76616c6964207369676e6174757265206c656e6774680000000000000000910152565b612a6f6018602092610f3c565b612a7881612a3b565b0190565b612a919060208101905f818303910152612a62565b90565b15612a9b57565b612aa36101a4565b62461bcd60e51b815280612ab960048201612a7c565b0390fd5b90565b90565b612acf612ad4916101b6565b612ac0565b9052565b602081612aea612af293839695612ac3565b018092612ac3565b0190565b60200190565b5190565b5f80fd5b90612b17612b106101a4565b92836115cf565b565b67ffffffffffffffff8111612b3757612b336020916115c5565b0190565b610fca565b90825f939282370152565b90929192612b5c612b5782612b19565b612b04565b93818552602085019082840111612b7857612b7692612b3c565b565b612b00565b612b88913691612b47565b90565b5f7f696e76616c696420746565207369676e61747572650000000000000000000000910152565b612bbf6015602092610f3c565b612bc881612b8b565b0190565b612be19060208101905f818303910152612bb2565b90565b15612beb57565b612bf36101a4565b62461bcd60e51b815280612c0960048201612bcc565b0390fd5b5f7f617070636861696e20626c6f636b206861736820756e6368616e676564000000910152565b612c41601d602092610f3c565b612c4a81612c0d565b0190565b612c639060208101905f818303910152612c34565b90565b15612c6d57565b612c756101a4565b62461bcd60e51b815280612c8b60048201612c4e565b0390fd5b5f7f617373657274696f6e20616c7265616479206578697374730000000000000000910152565b612cc36018602092610f3c565b612ccc81612c8f565b0190565b612ce59060208101905f818303910152612cb6565b90565b15612cef57565b612cf76101a4565b62461bcd60e51b815280612d0d60048201612cd0565b0390fd5b90565b612d28612d23612d2d92612d11565b610533565b610232565b90565b612d3c612d41916103d8565b61088e565b90565b612d4e9054612d30565b90565b612d60612d6691939293610232565b92610232565b8201809211612d7157565b61126a565b90612d8b612d86612d92926112be565b6112da565b8254611720565b9055565b612d9f90610536565b90565b612dab90612d96565b90565b612db790610552565b90565b612dc390610552565b90565b905090565b612dd65f8092612dc6565b0190565b612de390612dcb565b90565b90612df8612df383612b19565b612b04565b918252565b606090565b3d5f14612e1d57612e123d612de6565b903d5f602084013e5b565b612e25612dfd565b90612e1b565b5f7f7061796d656e74206661696c6564000000000000000000000000000000000000910152565b612e5f600e602092610f3c565b612e6881612e2b565b0190565b612e819060208101905f818303910152612e52565b90565b15612e8b57565b612e936101a4565b62461bcd60e51b815280612ea960048201612e6c565b0390fd5b92909391612f5d612f58612f6292612ee2612ec9898390612185565b612edc612ed66041612a1f565b91610232565b14612a94565b612f52612eee886134a2565b98612f4c612f04612eff6001612abd565b6135da565b612f2f8c91612f20612f146101a4565b93849260208401612ad8565b602082018103825203826115cf565b612f41612f3b82612afc565b91612af6565b2093600c9492612b7d565b90613679565b9061060e565b61221f565b612be4565b612f94612f705f8501612609565b612f8d612f87612f82600180016103f4565b6101b6565b916101b6565b1415612c66565b612f9d5f610f11565b5b80612fba612fb4612faf6008610bae565b610232565b91610232565b10156130075761300290612ffd86612ff6612ff0612feb612fe6612fe060088890610bbb565b506125ce565b61350d565b6101b6565b916101b6565b1415612ce8565b610f2d565b612f9e565b50916130409193506130196008610bae565b61302b6130255f610f11565b91610232565b1461311a575b61303b60086125d1565b612678565b61304a6008610bae565b61305d6130576002612d14565b91610232565b14613066575b50565b5f806130e56130e06131149461309861309161308260016114d5565b61308c6009612d44565b612d51565b6009612d76565b6130a26009612d44565b6130d87f37e8add694c5926d564e971160f5974103cbbbc7c90747c4c6f802031d3567a7916130cf6101a4565b918291826108d3565b0390a1612da2565b612dae565b6130ee30612dba565b316130f76101a4565b908161310281612dda565b03925af161310e612e02565b50612e84565b5f613063565b6131406131396131294261163b565b613133600d611a0f565b90611a1c565b600d611a82565b613031565b6131569061315161338f565b61324b565b565b60207f68696c6520617373657274696f6e2069732070656e64696e6700000000000000917f63616e6e6f7420757064617465206368616c6c656e67652077696e646f7720775f8201520152565b6131b26039604092610f3c565b6131bb81613158565b0190565b6131d49060208101905f8183039101526131a5565b90565b156131de57565b6131e66101a4565b62461bcd60e51b8152806131fc600482016131bf565b0390fd5b60401b90565b906132216fffffffffffffffff000000000000000091613200565b9181191691161790565b9061324061323b61324792611a63565b611a7f565b8254613206565b9055565b61327b9061327461325c6008610bae565b61326e6132685f610f11565b91610232565b146131d7565b600d61322b565b565b61328690613145565b565b6132999061329461338f565b61329b565b565b6132c06132a86008610bae565b6132ba6132b45f610f11565b91610232565b1461296d565b6132cd815f600101611736565b6132d9600180016103f4565b7fc985bccbd0c90e197f4a7373020a33ba6ff864d0399fd7d65c5c7c32ffb015ec9161330f6133066101a4565b92839283611765565b0390a1565b61331d90613288565b565b6133309061332b61338f565b613332565b565b8061334d6133476133425f6115b5565b610365565b91610365565b1461335d5761335b90613418565b565b6133806133695f6115b5565b5f918291631e4fbdf760e01b83526004830161037e565b0390fd5b61338d9061331f565b565b613397612524565b6133b06133aa6133a561369b565b610365565b91610365565b036133b757565b6133d96133c261369b565b5f91829163118cdaa760e01b83526004830161037e565b0390fd5b906133ee60018060a01b0391611220565b9181191691161790565b9061340d61340861341492610602565b61232c565b82546133dd565b9055565b6134215f612517565b61342b825f6133f8565b9061345f6134597f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e093610602565b91610602565b916134686101a4565b80613472816101fa565b0390a3565b60209392613496858361348e829561349e97612ac3565b018092612ac3565b018092612ac3565b0190565b6134aa611796565b506134f76134b95f8301612609565b6134e86134d460406134cd60208701612609565b9501612609565b6134dc6101a4565b94859360208501613477565b602082018103825203826115cf565b61350961350382612afc565b91612af6565b2090565b613515611796565b506135626135245f83016103f4565b61355361353f6002613538600187016103f4565b95016103f4565b6135476101a4565b94859360208501613477565b602082018103825203826115cf565b61357461356e82612afc565b91612af6565b2090565b946135c6602080999895966135be8280996135b6826135ce9a6135ae6135d69f806135a6859e928693612ac3565b018092612ac3565b018092612ac3565b018092612ac3565b018092612ac3565b018092612ac3565b018092612ac3565b0190565b6135e2611796565b506136636135f15f83016103f4565b613654613600600185016103f4565b9361360d600282016103f4565b9061361a600382016103f4565b613626600483016103f4565b9061363f6006613638600586016103f4565b94016103f4565b936136486101a4565b98899760208901613578565b602082018103825203826115cf565b61367561366f82612afc565b91612af6565b2090565b6136989161368f916136896124ff565b506136cc565b909291926137b4565b90565b6136a36124ff565b503390565b5f90565b6136c06136bb6136c592610232565b611220565b6101b6565b90565b5f90565b9190916136d76124ff565b506136e06136a8565b506136e9611796565b506136f383612afc565b6137066137006041612a1f565b91610232565b145f1461374d57613746919261371a611796565b50613723611796565b5061372c6136c8565b506020810151606060408301519201515f1a909192613911565b9192909190565b506137575f6115b5565b9061376b613766600294612afc565b6136ac565b91929190565b634e487b7160e01b5f52602160045260245ffd5b6004111561378f57565b613771565b9061379e82613785565b565b6137ac6137b1916103d8565b6112be565b90565b806137c76137c15f613794565b91613794565b145f146137d2575050565b806137e66137e06001613794565b91613794565b145f14613809575f63f645eedf60e01b815280613805600482016101fa565b0390fd5b8061381d6138176002613794565b91613794565b145f1461384b57613847613830836137a0565b5f91829163fce698f760e01b8352600483016108d3565b0390fd5b61385e6138586003613794565b91613794565b146138665750565b613881905f9182916335e2f38360e21b83526004830161076a565b0390fd5b90565b61389c6138976138a192613885565b610533565b610232565b90565b60ff1690565b6138b3906138a4565b9052565b6138ec6138f3946138e26060949897956138d8608086019a5f87019061045e565b60208501906138aa565b604083019061045e565b019061045e565b565b61390961390461390e92610f0e565b611220565b6101b6565b90565b93929361391c6124ff565b506139256136a8565b5061392e611796565b50613938856137a0565b61396a6139647f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0613888565b91610232565b116139f7579061398d602094955f949392936139846101a4565b948594856138b7565b838052039060015afa156139f2576139a55f51611220565b806139c06139ba6139b55f6115b5565b610365565b91610365565b146139d6575f916139d05f6138f5565b91929190565b506139e05f6115b5565b6001916139ec5f6138f5565b91929190565b61162b565b505050613a035f6115b5565b906003929192919056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xE0`@R4a\0\x88Wa\0&a\0\x14a\x02\x8AV[\x98\x97\x90\x97\x96\x91\x96\x95\x92\x95\x94\x93\x94a\x08vV[a\0.a\0\x8DV[a:\ra\x17v\x829`\x80Q\x81\x81\x81a\n\x8C\x01Ra\x1E\x93\x01R`\xA0Q\x81\x81\x81a\rT\x01R\x81\x81a\x1Bh\x01Ra\x1B\x9B\x01R`\xC0Q\x81\x81\x81a\x05\x11\x01R\x81\x81a\x1A\xCE\x01R\x81\x81a\x1CZ\x01R\x81\x81a\x1D/\x01Ra\x1F{\x01Ra:\r\x90\xF3[a\0\x93V[`@Q\x90V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\0\xBF\x90a\0\x97V[\x81\x01\x90\x81\x10`\x01\x80`@\x1B\x03\x82\x11\x17a\0\xD7W`@RV[a\0\xA1V[\x90a\0\xEFa\0\xE8a\0\x8DV[\x92\x83a\0\xB5V[V[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x01\t\x90a\0\xF5V[\x90V[a\x01\x15\x90a\x01\0V[\x90V[a\x01!\x81a\x01\x0CV[\x03a\x01(WV[_\x80\xFD[\x90PQ\x90a\x019\x82a\x01\x18V[V[a\x01D\x90a\x01\0V[\x90V[a\x01P\x81a\x01;V[\x03a\x01WWV[_\x80\xFD[\x90PQ\x90a\x01h\x82a\x01GV[V[\x90V[a\x01v\x81a\x01jV[\x03a\x01}WV[_\x80\xFD[\x90PQ\x90a\x01\x8E\x82a\x01mV[V[a\x01\x99\x90a\x01\0V[\x90V[a\x01\xA5\x81a\x01\x90V[\x03a\x01\xACWV[_\x80\xFD[\x90PQ\x90a\x01\xBD\x82a\x01\x9CV[V[`\x01\x80`@\x1B\x03\x16\x90V[a\x01\xD3\x81a\x01\xBFV[\x03a\x01\xDAWV[_\x80\xFD[\x90PQ\x90a\x01\xEB\x82a\x01\xCAV[V[a\x01@\x81\x83\x03\x12a\x02\x85Wa\x02\x04\x82_\x83\x01a\x01,V[\x92a\x02\x12\x83` \x84\x01a\x01[V[\x92a\x02 \x81`@\x85\x01a\x01\x81V[\x92a\x02.\x82``\x83\x01a\x01\x81V[\x92a\x02<\x83`\x80\x84\x01a\x01\x81V[\x92a\x02J\x81`\xA0\x85\x01a\x01\x81V[\x92a\x02X\x82`\xC0\x83\x01a\x01\x81V[\x92a\x02\x82a\x02i\x84`\xE0\x85\x01a\x01\xB0V[\x93a\x02x\x81a\x01\0\x86\x01a\x01\xDEV[\x93a\x01 \x01a\x01\x81V[\x90V[a\0\xF1V[a\x02\xA8aQ\x83\x808\x03\x80a\x02\x9D\x81a\0\xDCV[\x92\x839\x81\x01\x90a\x01\xEDV[\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99V[`@\x1B\x90V[\x90a\x02\xD4h\x01\0\0\0\0\0\0\0\0`\x01`\x80\x1B\x03\x91a\x02\xB4V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[a\x02\xF5a\x02\xF0a\x02\xFA\x92a\x01\xBFV[a\x02\xDEV[a\x01\xBFV[\x90V[\x90V[\x90a\x03\x15a\x03\x10a\x03\x1C\x92a\x02\xE1V[a\x02\xFDV[\x82Ta\x02\xBAV[\x90UV[a\x034a\x03/a\x039\x92a\0\xF5V[a\x02\xDEV[a\0\xF5V[\x90V[a\x03E\x90a\x03 V[\x90V[a\x03Q\x90a\x03<V[\x90V[\x90V[a\x03ka\x03fa\x03p\x92a\x03TV[a\x02\xDEV[a\0\xF5V[\x90V[a\x03|\x90a\x03WV[\x90V[_\x80\xFD[`\xE0\x1B\x90V[\x90` \x82\x82\x03\x12a\x03\xA2Wa\x03\x9F\x91_\x01a\x01\xDEV[\x90V[a\0\xF1V[_\x01\x90V[a\x03\xB4a\0\x8DV[=_\x82>=\x90\xFD[a\x03\xD0a\x03\xCBa\x03\xD5\x92a\x03TV[a\x02\xDEV[a\x01\xBFV[\x90V[\x90` \x82\x82\x03\x12a\x03\xF1Wa\x03\xEE\x91_\x01a\x01\x81V[\x90V[a\0\xF1V[_\x1B\x90V[a\x04\x0Fa\x04\na\x04\x14\x92a\x03TV[a\x03\xF6V[a\x01jV[\x90V[` \x91\x81R\x01\x90V[_\x7Fl1 contract invalid\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x04T`\x13` \x92a\x04\x17V[a\x04]\x81a\x04 V[\x01\x90V[a\x04v\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x04GV[\x90V[\x15a\x04\x80WV[a\x04\x88a\0\x8DV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x04\x9E`\x04\x82\x01a\x04aV[\x03\x90\xFD[a\x04\xAB\x90a\x03<V[\x90V[\x90V[a\x04\xC5a\x04\xC0a\x04\xCA\x92a\x03TV[a\x02\xDEV[a\x04\xAEV[\x90V[` \x7F code\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7Fposter address does not have any_\x82\x01R\x01RV[a\x05'`%`@\x92a\x04\x17V[a\x050\x81a\x04\xCDV[\x01\x90V[a\x05I\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x05\x1AV[\x90V[\x15a\x05SWV[a\x05[a\0\x8DV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x05q`\x04\x82\x01a\x054V[\x03\x90\xFD[a\x05~\x90a\x03<V[\x90V[a\x05\x8A\x81a\x04\xAEV[\x03a\x05\x91WV[_\x80\xFD[\x90PQ\x90a\x05\xA2\x82a\x05\x81V[V[\x90` \x82\x82\x03\x12a\x05\xBDWa\x05\xBA\x91_\x01a\x05\x95V[\x90V[a\0\xF1V[` \x7F bridge\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7Finsufficient delayed messages in_\x82\x01R\x01RV[a\x06\x1C`'`@\x92a\x04\x17V[a\x06%\x81a\x05\xC2V[\x01\x90V[a\x06>\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x06\x0FV[\x90V[\x15a\x06HWV[a\x06Pa\0\x8DV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x06f`\x04\x82\x01a\x06)V[\x03\x90\xFD[\x90a\x06v_\x19\x91a\x03\xF6V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x06\x89\x90a\x01jV[\x90V[_\x1C\x90V[a\x06\x9A\x90a\x06\x8CV[\x90V[\x90a\x06\xB2a\x06\xADa\x06\xB9\x92a\x06\x80V[a\x06\x91V[\x82Ta\x06jV[\x90UV[a\x06\xC6\x90a\x01jV[\x90RV[\x91` a\x06\xEB\x92\x94\x93a\x06\xE4`@\x82\x01\x96_\x83\x01\x90a\x06\xBDV[\x01\x90a\x06\xBDV[V[` \x7Fo\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7Ftee program hash must be non-zer_\x82\x01R\x01RV[a\x07G`!`@\x92a\x04\x17V[a\x07P\x81a\x06\xEDV[\x01\x90V[a\x07i\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x07:V[\x90V[\x15a\x07sWV[a\x07{a\0\x8DV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x07\x91`\x04\x82\x01a\x07TV[\x03\x90\xFD[\x90V[_R` _ \x90V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[T\x90V[a\x07\xC2\x81a\x07\xB5V[\x82\x10\x15a\x07\xDCWa\x07\xD4`\x01\x91a\x07\x98V[\x91\x02\x01\x90_\x90V[a\x07\xA1V[\x1B\x90V[\x91\x90`\x08a\x08\0\x91\x02\x91a\x07\xFA_\x19\x84a\x07\xE1V[\x92a\x07\xE1V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\x08 a\x08\x1Ba\x08(\x93a\x06\x80V[a\x06\x91V[\x90\x83Ta\x07\xE5V[\x90UV[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a\x08\\W\x82a\x08T\x91`\x01a\x08Z\x95\x01\x81Ua\x07\xB9V[\x90a\x08\nV[V[a\0\xA1V[\x91\x90a\x08t\x90_` \x85\x01\x94\x01\x90a\x06\xBDV[V[\x90\x91\x92\x93\x94\x95\x96\x97a\x08\x92\x90a\x08\x8B3a\x0C\x1DV[`\ra\x03\0V[a\x08\x9B\x88a\x03HV[a\x08\xB5a\x08\xAFa\x08\xAA_a\x03sV[a\x01\0V[\x91a\x01\0V[\x14\x80\x15a\n\xB7W[\x97a\x08\xCAa\t\x16\x99a\x04yV[`\xC0Ra\x08\xF2a\x08\xD9\x82a\x04\xA2V[;a\x08\xECa\x08\xE6_a\x04\xB1V[\x91a\x04\xAEV[\x11a\x05LV[`\x80R` a\t\0\x82a\x05uV[c\xEC\xA0g\xAD\x90a\t\x0Ea\0\x8DV[\x99\x8A\x92a\x03\x83V[\x82R\x81\x80a\t&`\x04\x82\x01a\x03\xA7V[\x03\x91Z\xFA\x96\x87\x15a\n\xB2Wa\n\x10\x97a\tY\x91_\x91a\n\x84W[Pa\tSa\tM_a\x04\xB1V[\x91a\x04\xAEV[\x11a\x06AV[`\xA0Ra\ti\x81_`\x01\x01a\x06\x9DV[a\tv\x82`\x01\x80\x01a\x06\x9DV[\x90\x7F\xC9\x85\xBC\xCB\xD0\xC9\x0E\x19\x7FJss\x02\n3\xBAo\xF8d\xD09\x9F\xD7\xD6\\\\|2\xFF\xB0\x15\xEC\x91a\t\xADa\t\xA4a\0\x8DV[\x92\x83\x92\x83a\x06\xCAV[\x03\x90\xA1a\t\xBE\x81`\x02`\x01\x01a\x06\x9DV[a\t\xCC\x82`\x03`\x01\x01a\x06\x9DV[\x90\x7F\xB9\xEB \xB3/\xAC\x96X\x84\xCBX2a\x02%|\xAE`E\x04\xF0\xA3l\xD1\0\x8A2\x84Z\xD5\xC2\x9B\x91a\n\x03a\t\xFAa\0\x8DV[\x92\x83\x92\x83a\x06\xCAV[\x03\x90\xA1`\x05`\x01\x01a\x06\x9DV[a\n-\x81a\n&a\n _a\x03\xFBV[\x91a\x01jV[\x14\x15a\x07lV[a\nAa\n:`\na\x07\x95V[\x82\x90a\x08,V[a\nw\x7F\x9Azdi\xC2\\\xF0\x17\x89\x06\x07i^J\x14\x9C\xC7q\xF2\x94\xFD\x87\x1E \x80\xD2L\xD1\t\x03:\xB6\x91a\nna\0\x8DV[\x91\x82\x91\x82a\x08aV[\x03\x90\xA1a\n\x82a\x11\xD0V[V[a\n\xA5\x91P` =\x81\x11a\n\xABW[a\n\x9D\x81\x83a\0\xB5V[\x81\x01\x90a\x05\xA4V[_a\t@V[P=a\n\x93V[a\x03\xACV[Pa\n\xDC` a\n\xC6\x8Aa\x03HV[c\xB8\x07w\xEA\x90a\n\xD4a\0\x8DV[\x93\x84\x92a\x03\x83V[\x82R\x81\x80a\n\xEC`\x04\x82\x01a\x03\xA7V[\x03\x91Z\xFA\x90\x81\x15a\x0B\xF6W_\x91a\x0B\xC8W[Pa\x0B\x11a\x0B\x0B_a\x03\xBCV[\x91a\x01\xBFV[\x11\x97\x88a\x0B)W[a\x08\xCAa\t\x16\x99\x91\x99PPa\x08\xBDV[a\x0BO\x98P` a\x0B9\x82a\x03HV[c\t\xBDZ`\x90a\x0BGa\0\x8DV[\x9B\x8C\x92a\x03\x83V[\x82R\x81\x80a\x0B_`\x04\x82\x01a\x03\xA7V[\x03\x91Z\xFA\x98\x89\x15a\x0B\xC3Wa\t\x16\x99a\x08\xCA\x91_\x91a\x0B\x95W[Pa\x0B\x8Ca\x0B\x86_a\x03\xFBV[\x91a\x01jV[\x11\x99PPa\x0B\x19V[a\x0B\xB6\x91P` =\x81\x11a\x0B\xBCW[a\x0B\xAE\x81\x83a\0\xB5V[\x81\x01\x90a\x03\xD8V[_a\x0ByV[P=a\x0B\xA4V[a\x03\xACV[a\x0B\xE9\x91P` =\x81\x11a\x0B\xEFW[a\x0B\xE1\x81\x83a\0\xB5V[\x81\x01\x90a\x03\x89V[_a\n\xFEV[P=a\x0B\xD7V[a\x03\xACV[a\x0C\x04\x90a\x01\0V[\x90RV[\x91\x90a\x0C\x1B\x90_` \x85\x01\x94\x01\x90a\x0B\xFBV[V[\x80a\x0C8a\x0C2a\x0C-_a\x03sV[a\x01\0V[\x91a\x01\0V[\x14a\x0CHWa\x0CF\x90a\x17\x16V[V[a\x0Cka\x0CT_a\x03sV[_\x91\x82\x91c\x1EO\xBD\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x0C\x08V[\x03\x90\xFD[T\x90V[\x90V[a\x0C\x8Aa\x0C\x85a\x0C\x8F\x92a\x0CsV[a\x02\xDEV[a\x04\xAEV[\x90V[` \x7Ftoo many assertions\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7Fcannot close challenge window - _\x82\x01R\x01RV[a\x0C\xEC`3`@\x92a\x04\x17V[a\x0C\xF5\x81a\x0C\x92V[\x01\x90V[a\r\x0E\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x0C\xDFV[\x90V[\x15a\r\x18WV[a\r a\0\x8DV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\r6`\x04\x82\x01a\x0C\xF9V[\x03\x90\xFD[a\rD\x90Qa\x01\x90V[\x90V[a\r[a\rVa\r`\x92a\x04\xAEV[a\x02\xDEV[a\x01\xBFV[\x90V[`\x01\x80`@\x1B\x03\x16\x90V[a\rza\r\x7F\x91a\x06\x8CV[a\rcV[\x90V[a\r\x8C\x90Ta\rnV[\x90V[` \x7Finsufficient time has passed\0\0\0\0\x91\x7Fcannot close challenge window - _\x82\x01R\x01RV[a\r\xE9`<`@\x92a\x04\x17V[a\r\xF2\x81a\r\x8FV[\x01\x90V[a\x0E\x0B\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\r\xDCV[\x90V[\x15a\x0E\x15WV[a\x0E\x1Da\0\x8DV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x0E3`\x04\x82\x01a\r\xF6V[\x03\x90\xFD[_R` _ \x90V[a\x0EI\x81a\x0CoV[\x82\x10\x15a\x0EcWa\x0E[`\x03\x91a\x0E7V[\x91\x02\x01\x90_\x90V[a\x07\xA1V[\x90V[a\x0Ewa\x0E|\x91a\x06\x8CV[a\x0EhV[\x90V[a\x0E\x89\x90Ta\x0EkV[\x90V[a\x0E\x96\x90Qa\x01\x0CV[\x90V[_\x91\x03\x12a\x0E\xA3WV[a\0\xF1V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x0E\xCBa\x0E\xD1\x91\x93\x92\x93a\x04\xAEV[\x92a\x04\xAEV[\x91a\x0E\xDD\x83\x82\x02a\x04\xAEV[\x92\x81\x84\x04\x14\x90\x15\x17\x15a\x0E\xECWV[a\x0E\xA8V[a\x0E\xFC\x90`\x03a\x0E\xBCV[\x90V[_\x90V[a\x0F\x15\x91a\x0F\x0Fa\x0E\xFFV[\x91a\x08\nV[V[_`\x02a\x0F=\x92a\x0F*\x83\x80\x83\x01a\x0F\x03V[a\x0F7\x83`\x01\x83\x01a\x0F\x03V[\x01a\x0F\x03V[V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[\x90_\x03a\x0FdWa\x0Fb\x90a\x0F\x17V[V[a\x0F?V[[\x81\x81\x10a\x0FuWPPV[\x80a\x0F\x82_`\x03\x93a\x0FRV[\x01a\x0FjV[\x90\x91\x82\x81\x10a\x0F\x97W[PPPV[a\x0F\xB5a\x0F\xAFa\x0F\xA9a\x0F\xC0\x95a\x0E\xF1V[\x92a\x0E\xF1V[\x92a\x0E7V[\x91\x82\x01\x91\x01\x90a\x0FiV[_\x80\x80a\x0F\x92V[\x90h\x01\0\0\0\0\0\0\0\0\x81\x11a\x0F\xF1W\x81a\x0F\xE6a\x0F\xEF\x93a\x0CoV[\x90\x82\x81Ua\x0F\x88V[V[a\0\xA1V[_a\x10\0\x91a\x0F\xC8V[V[\x90_\x03a\x10\x14Wa\x10\x12\x90a\x0F\xF6V[V[a\x0F?V[a\x10#\x90Qa\x01;V[\x90V[a\x105a\x10;\x91\x93\x92\x93a\x04\xAEV[\x92a\x04\xAEV[\x82\x03\x91\x82\x11a\x10FWV[a\x0E\xA8V[a\x10T\x90a\x04\xAEV[\x90RV[\x91\x90a\x10k\x90_` \x85\x01\x94\x01\x90a\x10KV[V[a\x10v\x90a\x01jV[\x90RV[\x90`\xC0a\x11'`\x06a\x11/\x94a\x10\x9Ea\x10\x95_\x83\x01Ta\x0EkV[_\x87\x01\x90a\x10mV[a\x10\xB8a\x10\xAE`\x01\x83\x01Ta\x0EkV[` \x87\x01\x90a\x10mV[a\x10\xD2a\x10\xC8`\x02\x83\x01Ta\x0EkV[`@\x87\x01\x90a\x10mV[a\x10\xECa\x10\xE2`\x03\x83\x01Ta\x0EkV[``\x87\x01\x90a\x10mV[a\x11\x06a\x10\xFC`\x04\x83\x01Ta\x0EkV[`\x80\x87\x01\x90a\x10mV[a\x11 a\x11\x16`\x05\x83\x01Ta\x0EkV[`\xA0\x87\x01\x90a\x10mV[\x01Ta\x0EkV[\x91\x01\x90a\x10mV[V[\x91\x90a\x11D\x90_`\xE0\x85\x01\x94\x01\x90a\x10zV[V[`@\x1C\x90V[a\x11Xa\x11]\x91a\x11FV[a\rcV[\x90V[a\x11j\x90Ta\x11LV[\x90V[a\x11ya\x11\x7F\x91a\x01\xBFV[\x91a\x01\xBFV[\x01\x90`\x01\x80`@\x1B\x03\x82\x11a\x11\x90WV[a\x0E\xA8V[\x90a\x11\xA6`\x01\x80`@\x1B\x03\x91a\x03\xF6V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x11\xC5a\x11\xC0a\x11\xCC\x92a\x02\xE1V[a\x02\xFDV[\x82Ta\x11\x95V[\x90UV[a\x11\xF7a\x11\xDD`\x08a\x0CoV[a\x11\xF0a\x11\xEA`\x01a\x0CvV[\x91a\x04\xAEV[\x11\x15a\r\x11V[a\x12\ta\x12\x04`\xC0a\r:V[a\x03HV[a\x12#a\x12\x1Da\x12\x18_a\x03sV[a\x01\0V[\x91a\x01\0V[\x14_\x14a\x16\x15Wa\x12Xa\x126Ba\rGV[[a\x12Ra\x12La\x12G`\ra\r\x82V[a\x01\xBFV[\x91a\x01\xBFV[\x11a\x0E\x0EV[a\x12b`\x08a\x0CoV[a\x12ta\x12n_a\x04\xB1V[\x91a\x04\xAEV[\x11a\x14\xE7W[a\x12\x8Ca\x12\x87`\xA0a\x10\x19V[a\x05uV[a\x12\xBEc\xD5q\x9D\xC2` a\x12\xA8a\x12\xA3`\xA0a\x10\x19V[a\x05uV[c\xEC\xA0g\xAD\x90a\x12\xB6a\0\x8DV[\x94\x85\x92a\x03\x83V[\x82R\x81\x80a\x12\xCE`\x04\x82\x01a\x03\xA7V[\x03\x91Z\xFA\x92\x83\x15a\x14\xE2Wa\x13\x13a\x12\xFEa\x13\x1E\x95` \x95_\x91a\x14\xB5W[Pa\x12\xF8`\x01a\x0CvV[\x90a\x10&V[\x92a\x13\x07a\0\x8DV[\x95\x86\x94\x85\x93\x84\x93a\x03\x83V[\x83R`\x04\x83\x01a\x10XV[\x03\x91Z\xFA\x80\x15a\x14\xB0Wa\x13>\x91_\x91a\x14\x82W[P`\x04`\x01\x01a\x06\x9DV[a\x13Pa\x13K`\xC0a\r:V[a\x03HV[a\x13ja\x13da\x13__a\x03sV[a\x01\0V[\x91a\x01\0V[\x14_\x14a\x13\xF7Wa\x13\x94a\x13\x88Ca\x13\x82`\x01a\x0CvV[\x90a\x10&V[@[`\x06`\x01\x01a\x06\x9DV[`\x01a\x13\xCC\x7F\x91\t+\xCFU\t!\xE3\x81\xE8\x1F\x06i3 SK\x14J~V\x1C_\xC0\x8F\x19@\xD5\x08\xA8\\\xDC\x91a\x13\xC3a\0\x8DV[\x91\x82\x91\x82a\x111V[\x03\x90\xA1a\x13\xF5a\x13\xEEa\x13\xDEBa\rGV[a\x13\xE8`\ra\x11`V[\x90a\x11mV[`\ra\x11\xB0V[V[a\x14$` a\x14\x0Ea\x14\t`\xC0a\r:V[a\x03HV[c\t\xBDZ`\x90a\x14\x1Ca\0\x8DV[\x93\x84\x92a\x03\x83V[\x82R\x81\x80a\x144`\x04\x82\x01a\x03\xA7V[\x03\x91Z\xFA\x80\x15a\x14}Wa\x13\x94\x91_\x91a\x14OW[Pa\x13\x8AV[a\x14p\x91P` =\x81\x11a\x14vW[a\x14h\x81\x83a\0\xB5V[\x81\x01\x90a\x03\xD8V[_a\x14IV[P=a\x14^V[a\x03\xACV[a\x14\xA3\x91P` =\x81\x11a\x14\xA9W[a\x14\x9B\x81\x83a\0\xB5V[\x81\x01\x90a\x03\xD8V[_a\x133V[P=a\x14\x91V[a\x03\xACV[a\x14\xD5\x91P\x86=\x81\x11a\x14\xDBW[a\x14\xCD\x81\x83a\0\xB5V[\x81\x01\x90a\x05\xA4V[_a\x12\xEDV[P=a\x14\xC3V[a\x03\xACV[a\x15\na\x15\x01_a\x14\xFA`\x08\x82\x90a\x0E@V[P\x01a\x0E\x7FV[`\x01\x80\x01a\x06\x9DV[a\x15/a\x15%`\x02a\x15\x1E`\x08_\x90a\x0E@V[P\x01a\x0E\x7FV[`\x03`\x01\x01a\x06\x9DV[a\x15Ia\x15?`\x06`\x01\x01a\x0E\x7FV[`\x05`\x01\x01a\x06\x9DV[a\x15[a\x15V`\x80a\x0E\x8CV[a\x04\xA2V[c\xDA\xEA\xB4\x12a\x15w_a\x15p`\x08\x82\x90a\x0E@V[P\x01a\x0E\x7FV[a\x15\x8F`\x01a\x15\x88`\x08_\x90a\x0E@V[P\x01a\x0E\x7FV[\x92\x80;\x15a\x16\x10Wa\x15\xB4_\x80\x94a\x15\xBFa\x15\xA8a\0\x8DV[\x97\x88\x96\x87\x95\x86\x94a\x03\x83V[\x84R`\x04\x84\x01a\x06\xCAV[\x03\x92Z\xF1\x80\x15a\x16\x0BWa\x15\xDFW[Pa\x15\xDA_`\x08a\x10\x02V[a\x12zV[a\x15\xFE\x90_=\x81\x11a\x16\x04W[a\x15\xF6\x81\x83a\0\xB5V[\x81\x01\x90a\x0E\x99V[_a\x15\xCEV[P=a\x15\xECV[a\x03\xACV[a\x03\x7FV[a\x16B` a\x16,a\x16'`\xC0a\r:V[a\x03HV[c\xB8\x07w\xEA\x90a\x16:a\0\x8DV[\x93\x84\x92a\x03\x83V[\x82R\x81\x80a\x16R`\x04\x82\x01a\x03\xA7V[\x03\x91Z\xFA\x80\x15a\x16\x9BWa\x12X\x91_\x91a\x16mW[Pa\x127V[a\x16\x8E\x91P` =\x81\x11a\x16\x94W[a\x16\x86\x81\x83a\0\xB5V[\x81\x01\x90a\x03\x89V[_a\x16gV[P=a\x16|V[a\x03\xACV[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x16\xB7a\x16\xBC\x91a\x06\x8CV[a\x16\xA0V[\x90V[a\x16\xC9\x90Ta\x16\xABV[\x90V[\x90a\x16\xDD`\x01\x80`\xA0\x1B\x03\x91a\x03\xF6V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x16\xF0\x90a\x03<V[\x90V[\x90V[\x90a\x17\x0Ba\x17\x06a\x17\x12\x92a\x16\xE7V[a\x16\xF3V[\x82Ta\x16\xCCV[\x90UV[a\x17\x1F_a\x16\xBFV[a\x17)\x82_a\x16\xF6V[\x90a\x17]a\x17W\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x93a\x16\xE7V[\x91a\x16\xE7V[\x91a\x17fa\0\x8DV[\x80a\x17p\x81a\x03\xA7V[\x03\x90\xA3V\xFE`\x80`@R`\x046\x10\x15a\0\x15W[6a\x0E\xF7W\0[a\0\x1F_5a\x01\x9EV[\x80c\x1C\x12B\x7F\x14a\x01\x99W\x80c33\x90\x06\x14a\x01\x94W\x80c<\xEA\xAE}\x14a\x01\x8FW\x80cB\x0C\xAF:\x14a\x01\x8AW\x80cGt&@\x14a\x01\x85W\x80cJ\xFF\xFC\xC9\x14a\x01\x80W\x80cK\xD1g\xC9\x14a\x01{W\x80c_p\xC4A\x14a\x01vW\x80ci{^b\x14a\x01qW\x80clL `\x14a\x01lW\x80cn\xF0\x12\x01\x14a\x01gW\x80cpdn\xA2\x14a\x01bW\x80cqP\x18\xA6\x14a\x01]W\x80c\x80\x95\x97!\x14a\x01XW\x80c\x8D\xA5\xCB[\x14a\x01SW\x80c\x8F\xEDU\xA3\x14a\x01NW\x80c\xA5n\xC6\xCD\x14a\x01IW\x80c\xC3\xF2\xDB\xD3\x14a\x01DW\x80c\xE5\x0CaV\x14a\x01?W\x80c\xE7\x8C\xEA\x92\x14a\x01:W\x80c\xEB`U:\x14a\x015W\x80c\xEE\x1C(\xB8\x14a\x010W\x80c\xF2#\x05\\\x14a\x01+Wc\xF2\xFD\xE3\x8B\x03a\0\x0EWa\x0E\xC4V[a\x0E\x91V[a\x0E\\V[a\x0E\x1AV[a\r\xA4V[a\r\x1BV[a\x0C\x95V[a\x0C]V[a\x0B{V[a\x0B\x11V[a\n\xDCV[a\nWV[a\n V[a\tPV[a\t\x1DV[a\x08\xE8V[a\x08[V[a\x08&V[a\x07\x7FV[a\x06\x90V[a\x05\x8CV[a\x04\xD3V[a\x03\x93V[a\x01\xFFV[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90V[a\x01\xC2\x81a\x01\xB6V[\x03a\x01\xC9WV[_\x80\xFD[\x90P5\x90a\x01\xDA\x82a\x01\xB9V[V[\x90` \x82\x82\x03\x12a\x01\xF5Wa\x01\xF2\x91_\x01a\x01\xCDV[\x90V[a\x01\xAEV[_\x01\x90V[4a\x02-Wa\x02\x17a\x02\x126`\x04a\x01\xDCV[a\x11ZV[a\x02\x1Fa\x01\xA4V[\x80a\x02)\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[\x90V[a\x02>\x81a\x022V[\x03a\x02EWV[_\x80\xFD[\x90P5\x90a\x02V\x82a\x025V[V[\x91\x90`@\x83\x82\x03\x12a\x02\x80W\x80a\x02ta\x02}\x92_\x86\x01a\x01\xCDV[\x93` \x01a\x02IV[\x90V[a\x01\xAEV[a\x02\x8E\x90a\x01\xB6V[\x90V[\x90a\x02\x9B\x90a\x02\x85V[_R` R`@_ \x90V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[T\x90V[_R` _ \x90V[a\x02\xD1\x81a\x02\xBBV[\x82\x10\x15a\x02\xEBWa\x02\xE3`\x01\x91a\x02\xBFV[\x91\x02\x01\x90_\x90V[a\x02\xA7V[\x1C\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x03\x0F\x90`\x08a\x03\x14\x93\x02a\x02\xF0V[a\x02\xF4V[\x90V[\x90a\x03\"\x91Ta\x02\xFFV[\x90V[a\x030\x90`\x0Ba\x02\x91V[a\x039\x81a\x02\xBBV[\x82\x10\x15a\x03VWa\x03S\x91a\x03M\x91a\x02\xC8V[\x90a\x03\x17V[\x90V[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x03n\x90a\x03ZV[\x90V[a\x03z\x90a\x03eV[\x90RV[\x91\x90a\x03\x91\x90_` \x85\x01\x94\x01\x90a\x03qV[V[4a\x03\xC4Wa\x03\xC0a\x03\xAFa\x03\xA96`\x04a\x02XV[\x90a\x03%V[a\x03\xB7a\x01\xA4V[\x91\x82\x91\x82a\x03~V[\x03\x90\xF3[a\x01\xAAV[_\x91\x03\x12a\x03\xD3WV[a\x01\xAEV[_\x1C\x90V[\x90V[a\x03\xECa\x03\xF1\x91a\x03\xD8V[a\x03\xDDV[\x90V[a\x03\xFE\x90Ta\x03\xE0V[\x90V[`\x01a\x04\x0E_\x82\x01a\x03\xF4V[\x91a\x04\x1B`\x01\x83\x01a\x03\xF4V[\x91a\x04(`\x02\x82\x01a\x03\xF4V[\x91a\x045`\x03\x83\x01a\x03\xF4V[\x91a\x04B`\x04\x82\x01a\x03\xF4V[\x91a\x04[`\x06a\x04T`\x05\x85\x01a\x03\xF4V[\x93\x01a\x03\xF4V[\x90V[a\x04g\x90a\x01\xB6V[\x90RV[\x94\x92\x90\x97\x96\x95\x93\x91`\xE0\x86\x01\x98_\x87\x01a\x04\x84\x91a\x04^V[` \x86\x01a\x04\x91\x91a\x04^V[`@\x85\x01a\x04\x9E\x91a\x04^V[``\x84\x01a\x04\xAB\x91a\x04^V[`\x80\x83\x01a\x04\xB8\x91a\x04^V[`\xA0\x82\x01a\x04\xC5\x91a\x04^V[`\xC0\x01a\x04\xD1\x91a\x04^V[V[4a\x05\nWa\x04\xE36`\x04a\x03\xC9V[a\x05\x06a\x04\xEEa\x04\x01V[\x93a\x04\xFD\x97\x95\x97\x93\x91\x93a\x01\xA4V[\x97\x88\x97\x88a\x04kV[\x03\x90\xF3[a\x01\xAAV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[\x90V[a\x05Ja\x05Ea\x05O\x92a\x03ZV[a\x053V[a\x03ZV[\x90V[a\x05[\x90a\x056V[\x90V[a\x05g\x90a\x05RV[\x90V[a\x05s\x90a\x05^V[\x90RV[\x91\x90a\x05\x8A\x90_` \x85\x01\x94\x01\x90a\x05jV[V[4a\x05\xBCWa\x05\x9C6`\x04a\x03\xC9V[a\x05\xB8a\x05\xA7a\x05\x0FV[a\x05\xAFa\x01\xA4V[\x91\x82\x91\x82a\x05wV[\x03\x90\xF3[a\x01\xAAV[a\x05\xCA\x81a\x03eV[\x03a\x05\xD1WV[_\x80\xFD[\x90P5\x90a\x05\xE2\x82a\x05\xC1V[V[\x90` \x82\x82\x03\x12a\x05\xFDWa\x05\xFA\x91_\x01a\x05\xD5V[\x90V[a\x01\xAEV[a\x06\x0B\x90a\x05RV[\x90V[\x90a\x06\x18\x90a\x06\x02V[_R` R`@_ \x90V[`\xFF\x16\x90V[a\x06:\x90`\x08a\x06?\x93\x02a\x02\xF0V[a\x06$V[\x90V[\x90a\x06M\x91Ta\x06*V[\x90V[a\x06f\x90a\x06a`\x0C\x91_\x92a\x06\x0EV[a\x06BV[\x90V[\x15\x15\x90V[a\x06w\x90a\x06iV[\x90RV[\x91\x90a\x06\x8E\x90_` \x85\x01\x94\x01\x90a\x06nV[V[4a\x06\xC0Wa\x06\xBCa\x06\xABa\x06\xA66`\x04a\x05\xE4V[a\x06PV[a\x06\xB3a\x01\xA4V[\x91\x82\x91\x82a\x06{V[\x03\x90\xF3[a\x01\xAAV[\x90` \x82\x82\x03\x12a\x06\xDEWa\x06\xDB\x91_\x01a\x02IV[\x90V[a\x01\xAEV[T\x90V[_R` _ \x90V[a\x06\xF9\x81a\x06\xE3V[\x82\x10\x15a\x07\x13Wa\x07\x0B`\x01\x91a\x06\xE7V[\x91\x02\x01\x90_\x90V[a\x02\xA7V[a\x07(\x90`\x08a\x07-\x93\x02a\x02\xF0V[a\x03\xDDV[\x90V[\x90a\x07;\x91Ta\x07\x18V[\x90V[`\na\x07I\x81a\x06\xE3V[\x82\x10\x15a\x07fWa\x07c\x91a\x07]\x91a\x06\xF0V[\x90a\x070V[\x90V[_\x80\xFD[\x91\x90a\x07}\x90_` \x85\x01\x94\x01\x90a\x04^V[V[4a\x07\xAFWa\x07\xABa\x07\x9Aa\x07\x956`\x04a\x06\xC5V[a\x07>V[a\x07\xA2a\x01\xA4V[\x91\x82\x91\x82a\x07jV[\x03\x90\xF3[a\x01\xAAV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x07\xD1\x90`\x08a\x07\xD6\x93\x02a\x02\xF0V[a\x07\xB4V[\x90V[\x90a\x07\xE4\x91Ta\x07\xC1V[\x90V[a\x07\xF4`\r`\x08\x90a\x07\xD9V[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x08\r\x90a\x07\xF7V[\x90RV[\x91\x90a\x08$\x90_` \x85\x01\x94\x01\x90a\x08\x04V[V[4a\x08VWa\x0866`\x04a\x03\xC9V[a\x08Ra\x08Aa\x07\xE7V[a\x08Ia\x01\xA4V[\x91\x82\x91\x82a\x08\x11V[\x03\x90\xF3[a\x01\xAAV[4a\x08\x89Wa\x08sa\x08n6`\x04a\x01\xDCV[a\x14\xC7V[a\x08{a\x01\xA4V[\x80a\x08\x85\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[\x90V[a\x08\xA1\x90`\x08a\x08\xA6\x93\x02a\x02\xF0V[a\x08\x8EV[\x90V[\x90a\x08\xB4\x91Ta\x08\x91V[\x90V[a\x08\xC3`\t_\x90a\x08\xA9V[\x90V[a\x08\xCF\x90a\x022V[\x90RV[\x91\x90a\x08\xE6\x90_` \x85\x01\x94\x01\x90a\x08\xC6V[V[4a\t\x18Wa\x08\xF86`\x04a\x03\xC9V[a\t\x14a\t\x03a\x08\xB7V[a\t\x0Ba\x01\xA4V[\x91\x82\x91\x82a\x08\xD3V[\x03\x90\xF3[a\x01\xAAV[4a\tKWa\t-6`\x04a\x03\xC9V[a\t5a\x1A\xA2V[a\t=a\x01\xA4V[\x80a\tG\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[4a\t~Wa\t`6`\x04a\x03\xC9V[a\tha!{V[a\tpa\x01\xA4V[\x80a\tz\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\t\xC9W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\t\xC4W` \x01\x92`\x01\x83\x02\x84\x01\x11a\t\xBFWV[a\t\x8BV[a\t\x87V[a\t\x83V[\x91``\x83\x83\x03\x12a\n\x1BWa\t\xE5\x82_\x85\x01a\x05\xD5V[\x92a\t\xF3\x83` \x83\x01a\x01\xCDV[\x92`@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\n\x16Wa\n\x12\x92\x01a\t\x8FV[\x90\x91V[a\x01\xB2V[a\x01\xAEV[4a\nRWa\n<a\n36`\x04a\t\xCEV[\x92\x91\x90\x91a#\x86V[a\nDa\x01\xA4V[\x80a\nN\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[4a\n\x85Wa\ng6`\x04a\x03\xC9V[a\noa$\xF5V[a\nwa\x01\xA4V[\x80a\n\x81\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[a\n\xB7\x90a\x05RV[\x90V[a\n\xC3\x90a\n\xAEV[\x90RV[\x91\x90a\n\xDA\x90_` \x85\x01\x94\x01\x90a\n\xBAV[V[4a\x0B\x0CWa\n\xEC6`\x04a\x03\xC9V[a\x0B\x08a\n\xF7a\n\x8AV[a\n\xFFa\x01\xA4V[\x91\x82\x91\x82a\n\xC7V[\x03\x90\xF3[a\x01\xAAV[4a\x0BAWa\x0B!6`\x04a\x03\xC9V[a\x0B=a\x0B,a%$V[a\x0B4a\x01\xA4V[\x91\x82\x91\x82a\x03~V[\x03\x90\xF3[a\x01\xAAV[_\x80\xFD[\x90\x81``\x91\x03\x12a\x0BXW\x90V[a\x0BFV[\x90``\x82\x82\x03\x12a\x0BvWa\x0Bs\x91_\x01a\x0BJV[\x90V[a\x01\xAEV[4a\x0B\xA9Wa\x0B\x93a\x0B\x8E6`\x04a\x0B]V[a(\xD0V[a\x0B\x9Ba\x01\xA4V[\x80a\x0B\xA5\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[T\x90V[_R` _ \x90V[a\x0B\xC4\x81a\x0B\xAEV[\x82\x10\x15a\x0B\xDEWa\x0B\xD6`\x03\x91a\x0B\xB2V[\x91\x02\x01\x90_\x90V[a\x02\xA7V[`\x08\x90a\x0B\xEF\x82a\x0B\xAEV[\x81\x10\x15a\x0C'Wa\x0B\xFF\x91a\x0B\xBBV[Pa\x0C\x0B_\x82\x01a\x03\xF4V[\x91a\x0C$`\x02a\x0C\x1D`\x01\x85\x01a\x03\xF4V[\x93\x01a\x03\xF4V[\x90V[_\x80\xFD[`@\x90a\x0CTa\x0C[\x94\x96\x95\x93\x96a\x0CJ``\x84\x01\x98_\x85\x01\x90a\x04^V[` \x83\x01\x90a\x04^V[\x01\x90a\x04^V[V[4a\x0C\x90Wa\x0C\x8Ca\x0Cxa\x0Cs6`\x04a\x06\xC5V[a\x0B\xE3V[a\x0C\x83\x93\x91\x93a\x01\xA4V[\x93\x84\x93\x84a\x0C+V[\x03\x90\xF3[a\x01\xAAV[4a\x0C\xC3Wa\x0C\xADa\x0C\xA86`\x04a\x01\xDCV[a*\x11V[a\x0C\xB5a\x01\xA4V[\x80a\x0C\xBF\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[\x90`\xA0\x82\x82\x03\x12a\r\x16Wa\x0C\xDF\x81_\x84\x01a\x0BJV[\x92``\x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\r\x11Wa\r\x03\x83a\r\x0E\x92\x86\x01a\t\x8FV[\x93\x90\x94`\x80\x01a\x05\xD5V[\x90V[a\x01\xB2V[a\x01\xAEV[4a\rMWa\r7a\r.6`\x04a\x0C\xC8V[\x92\x91\x90\x91a.\xADV[a\r?a\x01\xA4V[\x80a\rI\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[a\r\x7F\x90a\x05RV[\x90V[a\r\x8B\x90a\rvV[\x90RV[\x91\x90a\r\xA2\x90_` \x85\x01\x94\x01\x90a\r\x82V[V[4a\r\xD4Wa\r\xB46`\x04a\x03\xC9V[a\r\xD0a\r\xBFa\rRV[a\r\xC7a\x01\xA4V[\x91\x82\x91\x82a\r\x8FV[\x03\x90\xF3[a\x01\xAAV[a\r\xE2\x81a\x07\xF7V[\x03a\r\xE9WV[_\x80\xFD[\x90P5\x90a\r\xFA\x82a\r\xD9V[V[\x90` \x82\x82\x03\x12a\x0E\x15Wa\x0E\x12\x91_\x01a\r\xEDV[\x90V[a\x01\xAEV[4a\x0EHWa\x0E2a\x0E-6`\x04a\r\xFCV[a2}V[a\x0E:a\x01\xA4V[\x80a\x0ED\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[a\x0EY`\r_\x90a\x07\xD9V[\x90V[4a\x0E\x8CWa\x0El6`\x04a\x03\xC9V[a\x0E\x88a\x0Ewa\x0EMV[a\x0E\x7Fa\x01\xA4V[\x91\x82\x91\x82a\x08\x11V[\x03\x90\xF3[a\x01\xAAV[4a\x0E\xBFWa\x0E\xA9a\x0E\xA46`\x04a\x01\xDCV[a3\x14V[a\x0E\xB1a\x01\xA4V[\x80a\x0E\xBB\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[4a\x0E\xF2Wa\x0E\xDCa\x0E\xD76`\x04a\x05\xE4V[a3\x84V[a\x0E\xE4a\x01\xA4V[\x80a\x0E\xEE\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[_\x80\xFD[a\x0F\x0C\x90a\x0F\x07a3\x8FV[a\x10\x9FV[V[\x90V[a\x0F%a\x0F a\x0F*\x92a\x0F\x0EV[a\x053V[a\x022V[\x90V[`\x01a\x0F9\x91\x01a\x022V[\x90V[` \x91\x81R\x01\x90V[_\x7Ftee program already exists\0\0\0\0\0\0\x91\x01RV[a\x0Fy`\x1A` \x92a\x0F<V[a\x0F\x82\x81a\x0FEV[\x01\x90V[a\x0F\x9B\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x0FlV[\x90V[\x15a\x0F\xA5WV[a\x0F\xADa\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x0F\xC3`\x04\x82\x01a\x0F\x86V[\x03\x90\xFD[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_R` _ \x90V[T\x90V[a\x0F\xF4\x81a\x0F\xE7V[\x82\x10\x15a\x10\x0EWa\x10\x06`\x01\x91a\x0F\xDEV[\x91\x02\x01\x90_\x90V[a\x02\xA7V[\x1B\x90V[\x91\x90`\x08a\x102\x91\x02\x91a\x10,_\x19\x84a\x10\x13V[\x92a\x10\x13V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x10E\x90a\x03\xD8V[\x90V[\x91\x90a\x10^a\x10Ya\x10f\x93a\x02\x85V[a\x10<V[\x90\x83Ta\x10\x17V[\x90UV[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a\x10\x9AW\x82a\x10\x92\x91`\x01a\x10\x98\x95\x01\x81Ua\x0F\xEBV[\x90a\x10HV[V[a\x0F\xCAV[a\x10\xA8_a\x0F\x11V[[\x80a\x10\xC5a\x10\xBFa\x10\xBA`\na\x06\xE3V[a\x022V[\x91a\x022V[\x10\x15a\x11\nWa\x11\x05\x90a\x11\0a\x10\xE7a\x10\xE1`\n\x84\x90a\x06\xF0V[\x90a\x070V[a\x10\xF9a\x10\xF3\x86a\x01\xB6V[\x91a\x01\xB6V[\x14\x15a\x0F\x9EV[a\x0F-V[a\x10\xA9V[Pa\x11\x1Fa\x11\x18`\na\x0F\xC7V[\x82\x90a\x10jV[a\x11U\x7F\x9Azdi\xC2\\\xF0\x17\x89\x06\x07i^J\x14\x9C\xC7q\xF2\x94\xFD\x87\x1E \x80\xD2L\xD1\t\x03:\xB6\x91a\x11La\x01\xA4V[\x91\x82\x91\x82a\x07jV[\x03\x90\xA1V[a\x11c\x90a\x0E\xFBV[V[a\x11v\x90a\x11qa3\x8FV[a\x13\xDAV[V[` \x7Fassertion is pending\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7Fcannot remove tee program while _\x82\x01R\x01RV[a\x11\xD2`4`@\x92a\x0F<V[a\x11\xDB\x81a\x11xV[\x01\x90V[a\x11\xF4\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x11\xC5V[\x90V[\x15a\x11\xFEWV[a\x12\x06a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x12\x1C`\x04\x82\x01a\x11\xDFV[\x03\x90\xFD[_\x1B\x90V[\x90a\x121`\xFF\x91a\x12 V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x12D\x90a\x06iV[\x90V[\x90V[\x90a\x12_a\x12Za\x12f\x92a\x12;V[a\x12GV[\x82Ta\x12%V[\x90UV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x12\x8Da\x12\x93\x91\x93\x92\x93a\x022V[\x92a\x022V[\x91a\x12\x9F\x83\x82\x02a\x022V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a\x12\xAEWV[a\x12jV[`\x01\x90\x81\x80\x03\x01\x04\x90V[a\x12\xD2a\x12\xCDa\x12\xD7\x92a\x022V[a\x053V[a\x022V[\x90V[\x90V[\x91\x90a\x12\xF3a\x12\xEEa\x12\xFB\x93a\x12\xBEV[a\x12\xDAV[\x90\x83Ta\x10\x17V[\x90UV[_\x90V[a\x13\x15\x91a\x13\x0Fa\x12\xFFV[\x91a\x12\xDDV[V[[\x81\x81\x10a\x13#WPPV[\x80a\x130_`\x01\x93a\x13\x03V[\x01a\x13\x18V[\x90\x91\x82\x81\x10a\x13EW[PPPV[a\x13ca\x13]a\x13Wa\x13n\x95a\x12\xB3V[\x92a\x12\xB3V[\x92a\x02\xBFV[\x91\x82\x01\x91\x01\x90a\x13\x17V[_\x80\x80a\x13@V[\x90h\x01\0\0\0\0\0\0\0\0\x81\x11a\x13\x9FW\x81a\x13\x94a\x13\x9D\x93a\x02\xBBV[\x90\x82\x81Ua\x136V[V[a\x0F\xCAV[_a\x13\xAE\x91a\x13vV[V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[\x90_\x03a\x13\xD5Wa\x13\xD3\x90a\x13\xA4V[V[a\x13\xB0V[a\x13\xFFa\x13\xE7`\x08a\x0B\xAEV[a\x13\xF9a\x13\xF3_a\x0F\x11V[\x91a\x022V[\x14a\x11\xF7V[a\x14\x08_a\x0F\x11V[[\x80a\x14/a\x14)a\x14$a\x14\x1F`\x0B\x87\x90a\x02\x91V[a\x02\xBBV[a\x022V[\x91a\x022V[\x10\x15a\x14vWa\x14q\x90a\x14l_a\x14g`\x0Ca\x14aa\x14[a\x14T`\x0B\x8A\x90a\x02\x91V[\x87\x90a\x02\xC8V[\x90a\x03\x17V[\x90a\x06\x0EV[a\x12JV[a\x0F-V[a\x14\tV[Pa\x14\x8C_a\x14\x87`\x0B\x84\x90a\x02\x91V[a\x13\xC3V[a\x14\xC2\x7F&!\xC6\x1D3\x15\xF2\xA3\xD2k\"\xD7F\xBA!\xA9m$\x9FQ\xAD\xA3#\xF7\"l\xCE_\xE5\xFC=d\x91a\x14\xB9a\x01\xA4V[\x91\x82\x91\x82a\x07jV[\x03\x90\xA1V[a\x14\xD0\x90a\x11eV[V[\x90V[a\x14\xE9a\x14\xE4a\x14\xEE\x92a\x14\xD2V[a\x053V[a\x022V[\x90V[` \x7Ftoo many assertions\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7Fcannot close challenge window - _\x82\x01R\x01RV[a\x15K`3`@\x92a\x0F<V[a\x15T\x81a\x14\xF1V[\x01\x90V[a\x15m\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x15>V[\x90V[\x15a\x15wWV[a\x15\x7Fa\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x15\x95`\x04\x82\x01a\x15XV[\x03\x90\xFD[a\x15\xADa\x15\xA8a\x15\xB2\x92a\x0F\x0EV[a\x053V[a\x03ZV[\x90V[a\x15\xBE\x90a\x15\x99V[\x90V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[\x90a\x15\xD9\x90a\x15\xC5V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x15\xF3W`@RV[a\x0F\xCAV[`\xE0\x1B\x90V[\x90PQ\x90a\x16\x0B\x82a\r\xD9V[V[\x90` \x82\x82\x03\x12a\x16&Wa\x16#\x91_\x01a\x15\xFEV[\x90V[a\x01\xAEV[a\x163a\x01\xA4V[=_\x82>=\x90\xFD[a\x16Oa\x16Ja\x16T\x92a\x022V[a\x053V[a\x07\xF7V[\x90V[a\x16ca\x16h\x91a\x03\xD8V[a\x07\xB4V[\x90V[a\x16u\x90Ta\x16WV[\x90V[` \x7Finsufficient time has passed\0\0\0\0\x91\x7Fcannot close challenge window - _\x82\x01R\x01RV[a\x16\xD2`<`@\x92a\x0F<V[a\x16\xDB\x81a\x16xV[\x01\x90V[a\x16\xF4\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x16\xC5V[\x90V[\x15a\x16\xFEWV[a\x17\x06a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x17\x1C`\x04\x82\x01a\x16\xDFV[\x03\x90\xFD[\x90a\x17,_\x19\x91a\x12 V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x17Ka\x17Fa\x17R\x92a\x02\x85V[a\x10<V[\x82Ta\x17 V[\x90UV[_\x91\x03\x12a\x17`WV[a\x01\xAEV[\x91` a\x17\x86\x92\x94\x93a\x17\x7F`@\x82\x01\x96_\x83\x01\x90a\x04^V[\x01\x90a\x04^V[V[a\x17\x93\x90`\x03a\x12~V[\x90V[_\x90V[a\x17\xAC\x91a\x17\xA6a\x17\x96V[\x91a\x10HV[V[_`\x02a\x17\xD4\x92a\x17\xC1\x83\x80\x83\x01a\x17\x9AV[a\x17\xCE\x83`\x01\x83\x01a\x17\x9AV[\x01a\x17\x9AV[V[\x90_\x03a\x17\xE8Wa\x17\xE6\x90a\x17\xAEV[V[a\x13\xB0V[[\x81\x81\x10a\x17\xF9WPPV[\x80a\x18\x06_`\x03\x93a\x17\xD6V[\x01a\x17\xEEV[\x90\x91\x82\x81\x10a\x18\x1BW[PPPV[a\x189a\x183a\x18-a\x18D\x95a\x17\x88V[\x92a\x17\x88V[\x92a\x0B\xB2V[\x91\x82\x01\x91\x01\x90a\x17\xEDV[_\x80\x80a\x18\x16V[\x90h\x01\0\0\0\0\0\0\0\0\x81\x11a\x18uW\x81a\x18ja\x18s\x93a\x0B\xAEV[\x90\x82\x81Ua\x18\x0CV[V[a\x0F\xCAV[_a\x18\x84\x91a\x18LV[V[\x90_\x03a\x18\x98Wa\x18\x96\x90a\x18zV[V[a\x13\xB0V[\x90PQ\x90a\x18\xAA\x82a\x025V[V[\x90` \x82\x82\x03\x12a\x18\xC5Wa\x18\xC2\x91_\x01a\x18\x9DV[\x90V[a\x01\xAEV[a\x18\xD9a\x18\xDF\x91\x93\x92\x93a\x022V[\x92a\x022V[\x82\x03\x91\x82\x11a\x18\xEAWV[a\x12jV[\x90PQ\x90a\x18\xFC\x82a\x01\xB9V[V[\x90` \x82\x82\x03\x12a\x19\x17Wa\x19\x14\x91_\x01a\x18\xEFV[\x90V[a\x01\xAEV[a\x19%\x90a\x01\xB6V[\x90RV[\x90`\xC0a\x19\xD6`\x06a\x19\xDE\x94a\x19Ma\x19D_\x83\x01Ta\x03\xE0V[_\x87\x01\x90a\x19\x1CV[a\x19ga\x19]`\x01\x83\x01Ta\x03\xE0V[` \x87\x01\x90a\x19\x1CV[a\x19\x81a\x19w`\x02\x83\x01Ta\x03\xE0V[`@\x87\x01\x90a\x19\x1CV[a\x19\x9Ba\x19\x91`\x03\x83\x01Ta\x03\xE0V[``\x87\x01\x90a\x19\x1CV[a\x19\xB5a\x19\xAB`\x04\x83\x01Ta\x03\xE0V[`\x80\x87\x01\x90a\x19\x1CV[a\x19\xCFa\x19\xC5`\x05\x83\x01Ta\x03\xE0V[`\xA0\x87\x01\x90a\x19\x1CV[\x01Ta\x03\xE0V[\x91\x01\x90a\x19\x1CV[V[\x91\x90a\x19\xF3\x90_`\xE0\x85\x01\x94\x01\x90a\x19)V[V[`@\x1C\x90V[a\x1A\x07a\x1A\x0C\x91a\x19\xF5V[a\x07\xB4V[\x90V[a\x1A\x19\x90Ta\x19\xFBV[\x90V[a\x1A(a\x1A.\x91a\x07\xF7V[\x91a\x07\xF7V[\x01\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x1AAWV[a\x12jV[\x90a\x1AYg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x12 V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1Awa\x1Ara\x1A|\x92a\x07\xF7V[a\x053V[a\x07\xF7V[\x90V[\x90V[\x90a\x1A\x97a\x1A\x92a\x1A\x9E\x92a\x1AcV[a\x1A\x7FV[\x82Ta\x1AFV[\x90UV[a\x1A\xC9a\x1A\xAF`\x08a\x0B\xAEV[a\x1A\xC2a\x1A\xBC`\x01a\x14\xD5V[\x91a\x022V[\x11\x15a\x15pV[a\x1A\xF2\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x05^V[a\x1B\x0Ca\x1B\x06a\x1B\x01_a\x15\xB5V[a\x03eV[\x91a\x03eV[\x14_\x14a\x1FqWa\x1BAa\x1B\x1FBa\x16;V[[a\x1B;a\x1B5a\x1B0`\ra\x16kV[a\x07\xF7V[\x91a\x07\xF7V[\x11a\x16\xF7V[a\x1BK`\x08a\x0B\xAEV[a\x1B]a\x1BW_a\x0F\x11V[\x91a\x022V[\x11a\x1E,W[a\x1B\x8C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\rvV[a\x1B\xD5c\xD5q\x9D\xC2` a\x1B\xBF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\rvV[c\xEC\xA0g\xAD\x90a\x1B\xCDa\x01\xA4V[\x94\x85\x92a\x15\xF8V[\x82R\x81\x80a\x1B\xE5`\x04\x82\x01a\x01\xFAV[\x03\x91Z\xFA\x92\x83\x15a\x1E'Wa\x1C*a\x1C\x15a\x1C5\x95` \x95_\x91a\x1D\xFAW[Pa\x1C\x0F`\x01a\x14\xD5V[\x90a\x18\xCAV[\x92a\x1C\x1Ea\x01\xA4V[\x95\x86\x94\x85\x93\x84\x93a\x15\xF8V[\x83R`\x04\x83\x01a\x08\xD3V[\x03\x91Z\xFA\x80\x15a\x1D\xF5Wa\x1CU\x91_\x91a\x1D\xC7W[P`\x04`\x01\x01a\x176V[a\x1C~\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x05^V[a\x1C\x98a\x1C\x92a\x1C\x8D_a\x15\xB5V[a\x03eV[\x91a\x03eV[\x14_\x14a\x1D%Wa\x1C\xC2a\x1C\xB6Ca\x1C\xB0`\x01a\x14\xD5V[\x90a\x18\xCAV[@[`\x06`\x01\x01a\x176V[`\x01a\x1C\xFA\x7F\x91\t+\xCFU\t!\xE3\x81\xE8\x1F\x06i3 SK\x14J~V\x1C_\xC0\x8F\x19@\xD5\x08\xA8\\\xDC\x91a\x1C\xF1a\x01\xA4V[\x91\x82\x91\x82a\x19\xE0V[\x03\x90\xA1a\x1D#a\x1D\x1Ca\x1D\x0CBa\x16;V[a\x1D\x16`\ra\x1A\x0FV[\x90a\x1A\x1CV[`\ra\x1A\x82V[V[a\x1Di` a\x1DS\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x05^V[c\t\xBDZ`\x90a\x1Daa\x01\xA4V[\x93\x84\x92a\x15\xF8V[\x82R\x81\x80a\x1Dy`\x04\x82\x01a\x01\xFAV[\x03\x91Z\xFA\x80\x15a\x1D\xC2Wa\x1C\xC2\x91_\x91a\x1D\x94W[Pa\x1C\xB8V[a\x1D\xB5\x91P` =\x81\x11a\x1D\xBBW[a\x1D\xAD\x81\x83a\x15\xCFV[\x81\x01\x90a\x18\xFEV[_a\x1D\x8EV[P=a\x1D\xA3V[a\x16+V[a\x1D\xE8\x91P` =\x81\x11a\x1D\xEEW[a\x1D\xE0\x81\x83a\x15\xCFV[\x81\x01\x90a\x18\xFEV[_a\x1CJV[P=a\x1D\xD6V[a\x16+V[a\x1E\x1A\x91P\x86=\x81\x11a\x1E W[a\x1E\x12\x81\x83a\x15\xCFV[\x81\x01\x90a\x18\xACV[_a\x1C\x04V[P=a\x1E\x08V[a\x16+V[a\x1EOa\x1EF_a\x1E?`\x08\x82\x90a\x0B\xBBV[P\x01a\x03\xF4V[`\x01\x80\x01a\x176V[a\x1Eta\x1Ej`\x02a\x1Ec`\x08_\x90a\x0B\xBBV[P\x01a\x03\xF4V[`\x03`\x01\x01a\x176V[a\x1E\x8Ea\x1E\x84`\x06`\x01\x01a\x03\xF4V[`\x05`\x01\x01a\x176V[a\x1E\xB7\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\n\xAEV[c\xDA\xEA\xB4\x12a\x1E\xD3_a\x1E\xCC`\x08\x82\x90a\x0B\xBBV[P\x01a\x03\xF4V[a\x1E\xEB`\x01a\x1E\xE4`\x08_\x90a\x0B\xBBV[P\x01a\x03\xF4V[\x92\x80;\x15a\x1FlWa\x1F\x10_\x80\x94a\x1F\x1Ba\x1F\x04a\x01\xA4V[\x97\x88\x96\x87\x95\x86\x94a\x15\xF8V[\x84R`\x04\x84\x01a\x17eV[\x03\x92Z\xF1\x80\x15a\x1FgWa\x1F;W[Pa\x1F6_`\x08a\x18\x86V[a\x1BcV[a\x1FZ\x90_=\x81\x11a\x1F`W[a\x1FR\x81\x83a\x15\xCFV[\x81\x01\x90a\x17VV[_a\x1F*V[P=a\x1FHV[a\x16+V[a\x15\xC1V[a\x1F\xB5` a\x1F\x9F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x05^V[c\xB8\x07w\xEA\x90a\x1F\xADa\x01\xA4V[\x93\x84\x92a\x15\xF8V[\x82R\x81\x80a\x1F\xC5`\x04\x82\x01a\x01\xFAV[\x03\x91Z\xFA\x80\x15a \x0EWa\x1BA\x91_\x91a\x1F\xE0W[Pa\x1B V[a \x01\x91P` =\x81\x11a \x07W[a\x1F\xF9\x81\x83a\x15\xCFV[\x81\x01\x90a\x16\rV[_a\x1F\xDAV[P=a\x1F\xEFV[a\x16+V[a \x1Ba3\x8FV[a #a \xE0V[V[`\x01\x90\x81\x80\x03\x01\x04\x90V[[\x81\x81\x10a <WPPV[\x80a I_`\x01\x93a\x17\x9AV[\x01a 1V[\x90\x91\x82\x81\x10a ^W[PPPV[a |a va pa \x87\x95a %V[\x92a %V[\x92a\x06\xE7V[\x91\x82\x01\x91\x01\x90a 0V[_\x80\x80a YV[\x90h\x01\0\0\0\0\0\0\0\0\x81\x11a \xB8W\x81a \xADa \xB6\x93a\x06\xE3V[\x90\x82\x81Ua OV[V[a\x0F\xCAV[_a \xC7\x91a \x8FV[V[\x90_\x03a \xDBWa \xD9\x90a \xBDV[V[a\x13\xB0V[a \xE9_a\x0F\x11V[[\x80a!\x06a!\0a \xFB`\na\x06\xE3V[a\x022V[\x91a\x022V[\x10\x15a!7Wa!2\x90a!-a!(a!\"`\n\x84\x90a\x06\xF0V[\x90a\x070V[a\x14\xC7V[a\x0F-V[a \xEAV[Pa!C_`\na \xC9V[\x7F\xEC\xA6.\0t\xA1:\x90\xD6\0\xF0\x03\xB7\xCB\x8D[\xD5\x01\0\0\x8D?9\x15\xF2UO?\x85R\xC5\xCCa!la\x01\xA4V[\x80a!v\x81a\x01\xFAV[\x03\x90\xA1V[a!\x83a \x13V[V[P\x90V[_\x7Ftodo: validate zk zkProof\0\0\0\0\0\0\0\x91\x01RV[a!\xBD`\x19` \x92a\x0F<V[a!\xC6\x81a!\x89V[\x01\x90V[a!\xDF\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra!\xB0V[\x90V[\x15a!\xE9WV[a!\xF1a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\"\x07`\x04\x82\x01a!\xCAV[\x03\x90\xFD[a\"\x17a\"\x1C\x91a\x03\xD8V[a\x06$V[\x90V[a\")\x90Ta\"\x0BV[\x90V[_\x7Fkey already added\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\"``\x11` \x92a\x0F<V[a\"i\x81a\",V[\x01\x90V[a\"\x82\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\"SV[\x90V[\x15a\"\x8CWV[a\"\x94a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\"\xAA`\x04\x82\x01a\"mV[\x03\x90\xFD[a\"\xB7\x90a\x022V[_\x81\x14a\"\xC5W`\x01\x90\x03\x90V[a\x12jV[\x90V[_R` _ \x90V[T\x90V[a\"\xE3\x81a\"\xD6V[\x82\x10\x15a\"\xFDWa\"\xF5`\x01\x91a\"\xCDV[\x91\x02\x01\x90_\x90V[a\x02\xA7V[\x91\x90`\x08a#\"\x91\x02\x91a#\x1C`\x01\x80`\xA0\x1B\x03\x84a\x10\x13V[\x92a\x10\x13V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x91\x90a#Ea#@a#M\x93a\x06\x02V[a#,V[\x90\x83Ta#\x02V[\x90UV[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a#\x81W\x82a#y\x91`\x01a#\x7F\x95\x01\x81Ua\"\xDAV[\x90a#/V[V[a\x0F\xCAV[\x92a#\x95\x90a#\xAE\x92\x93a!\x85V[a#\xA8a#\xA2`\x01a\x14\xD5V[\x91a\x022V[\x14a!\xE2V[a#\xD3a#\xCEa#\xC8a#\xC3`\x0C\x86\x90a\x06\x0EV[a\"\x1FV[\x15a\x06iV[a\"\x85V[a#\xE7a#\xE2`\x0B\x83\x90a\x02\x91V[a\x02\xBBV[a#\xF9a#\xF3_a\x0F\x11V[\x91a\x022V[\x14a$3W[\x90a$,a$'a$1\x93a$ `\x01a$\x1B`\x0C\x87\x90a\x06\x0EV[a\x12JV[`\x0Ba\x02\x91V[a\"\xCAV[a#QV[V[_\x91a$?`\na\x06\xE3V[[\x80a$Sa$M_a\x0F\x11V[\x91a\x022V[\x11\x15a$\xC4Wa$\x81a${`\na$u\x84a$o`\x01a\x14\xD5V[\x90a\x18\xCAV[\x90a\x06\xF0V[\x90a\x070V[a$\x93a$\x8D\x85a\x01\xB6V[\x91a\x01\xB6V[\x14a$\xA6Wa$\xA1\x90a\"\xAEV[a$@V[P\x90\x91Pa$\xB6`\x01[\x15a\x06iV[a$\xC0W\x90a#\xFFV[PPV[P\x90\x91a$\xB6\x90a$\xB0V[a$\xD8a3\x8FV[a$\xE0a$\xE2V[V[a$\xF3a$\xEE_a\x15\xB5V[a4\x18V[V[a$\xFDa$\xD0V[V[_\x90V[a%\x0Fa%\x14\x91a\x03\xD8V[a\x02\xF4V[\x90V[a%!\x90Ta%\x03V[\x90V[a%,a$\xFFV[Pa%6_a%\x17V[\x90V[a%J\x90a%Ea3\x8FV[a'\x98V[V[_\x7Fchallenge does not exist\0\0\0\0\0\0\0\0\x91\x01RV[a%\x80`\x18` \x92a\x0F<V[a%\x89\x81a%LV[\x01\x90V[a%\xA2\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra%sV[\x90V[\x15a%\xACWV[a%\xB4a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a%\xCA`\x04\x82\x01a%\x8DV[\x03\x90\xFD[\x90V[\x90V[_R` _ \x90V[T\x90V[a%\xEA\x81a%\xDDV[\x82\x10\x15a&\x04Wa%\xFC`\x03\x91a%\xD4V[\x91\x02\x01\x90_\x90V[a\x02\xA7V[5a&\x13\x81a\x01\xB9V[\x90V[\x90a&Z`@`\x02a&`\x94a&9_\x82\x01a&3_\x88\x01a&\tV[\x90a\x176V[a&R`\x01\x82\x01a&L` \x88\x01a&\tV[\x90a\x176V[\x01\x92\x01a&\tV[\x90a\x176V[V[\x91\x90a&sWa&q\x91a&\x16V[V[a\x13\xB0V[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a&\xA8W\x82a&\xA0\x91`\x01a&\xA6\x95\x01\x81Ua%\xE1V[\x90a&bV[V[a\x0F\xCAV[a&\xC1a&\xBCa&\xC6\x92a\x0F\x0EV[a\x053V[a\x07\xF7V[\x90V[Pa&\xD8\x90` \x81\x01\x90a\x01\xCDV[\x90V[\x90`@a' a'(\x93a&\xFDa&\xF4_\x83\x01\x83a&\xC9V[_\x86\x01\x90a\x19\x1CV[a'\x17a'\r` \x83\x01\x83a&\xC9V[` \x86\x01\x90a\x19\x1CV[\x82\x81\x01\x90a&\xC9V[\x91\x01\x90a\x19\x1CV[V[\x91\x90a'=\x90_``\x85\x01\x94\x01\x90a&\xDBV[V[_\x7Fassertion not found\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a's`\x13` \x92a\x0F<V[a'|\x81a'?V[\x01\x90V[a'\x95\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra'fV[\x90V[a'\xBEa'\xA5`\x08a\x0B\xAEV[a'\xB8a'\xB2`\x01a\x14\xD5V[\x91a\x022V[\x11a%\xA5V[a'\xC7\x81a4\xA2V[\x90a'\xD1_a\x0F\x11V[[\x80a'\xEEa'\xE8a'\xE3`\x08a\x0B\xAEV[a\x022V[\x91a\x022V[\x10\x15a(\xAEW\x82a(#a(\x1Da(\x18a(\x13a(\r`\x08\x87\x90a\x0B\xBBV[Pa%\xCEV[a5\rV[a\x01\xB6V[\x91a\x01\xB6V[\x14a(6Wa(1\x90a\x0F-V[a'\xD2V[P\x90Pa(D_`\x08a\x18\x86V[a(Xa(Q`\x08a%\xD1V[\x82\x90a&xV[a(ka(d_a&\xADV[`\ra\x1A\x82V[a(sa\x1A\xA2V[a(\xA9\x7F\xE4.\xAF\x077\xE2G\x8A_Z\xED:\x06\x10\xAE{\t\xA2|\xBA\xC9\xADj\\\xC4\xD6\x8Fx\xAF\xD1B[\x91a(\xA0a\x01\xA4V[\x91\x82\x91\x82a'*V[\x03\x90\xA1V[a(\xB6a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a(\xCC`\x04\x82\x01a'\x80V[\x03\x90\xFD[a(\xD9\x90a%9V[V[a(\xEC\x90a(\xE7a3\x8FV[a)\x96V[V[` \x7Fassertions are pending\0\0\0\0\0\0\0\0\0\0\x91\x7Fcannot update config hash while _\x82\x01R\x01RV[a)H`6`@\x92a\x0F<V[a)Q\x81a(\xEEV[\x01\x90V[a)j\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra);V[\x90V[\x15a)tWV[a)|a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a)\x92`\x04\x82\x01a)UV[\x03\x90\xFD[a)\xBBa)\xA3`\x08a\x0B\xAEV[a)\xB5a)\xAF_a\x0F\x11V[\x91a\x022V[\x14a)mV[a)\xC9\x81`\x02`\x01\x01a\x176V[a)\xD6`\x03`\x01\x01a\x03\xF4V[\x7F\xB9\xEB \xB3/\xAC\x96X\x84\xCBX2a\x02%|\xAE`E\x04\xF0\xA3l\xD1\0\x8A2\x84Z\xD5\xC2\x9B\x91a*\x0Ca*\x03a\x01\xA4V[\x92\x83\x92\x83a\x17eV[\x03\x90\xA1V[a*\x1A\x90a(\xDBV[V[\x90V[a*3a*.a*8\x92a*\x1CV[a\x053V[a\x022V[\x90V[_\x7Finvalid signature length\0\0\0\0\0\0\0\0\x91\x01RV[a*o`\x18` \x92a\x0F<V[a*x\x81a*;V[\x01\x90V[a*\x91\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra*bV[\x90V[\x15a*\x9BWV[a*\xA3a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a*\xB9`\x04\x82\x01a*|V[\x03\x90\xFD[\x90V[\x90V[a*\xCFa*\xD4\x91a\x01\xB6V[a*\xC0V[\x90RV[` \x81a*\xEAa*\xF2\x93\x83\x96\x95a*\xC3V[\x01\x80\x92a*\xC3V[\x01\x90V[` \x01\x90V[Q\x90V[_\x80\xFD[\x90a+\x17a+\x10a\x01\xA4V[\x92\x83a\x15\xCFV[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a+7Wa+3` \x91a\x15\xC5V[\x01\x90V[a\x0F\xCAV[\x90\x82_\x93\x92\x827\x01RV[\x90\x92\x91\x92a+\\a+W\x82a+\x19V[a+\x04V[\x93\x81\x85R` \x85\x01\x90\x82\x84\x01\x11a+xWa+v\x92a+<V[V[a+\0V[a+\x88\x916\x91a+GV[\x90V[_\x7Finvalid tee signature\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a+\xBF`\x15` \x92a\x0F<V[a+\xC8\x81a+\x8BV[\x01\x90V[a+\xE1\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra+\xB2V[\x90V[\x15a+\xEBWV[a+\xF3a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a,\t`\x04\x82\x01a+\xCCV[\x03\x90\xFD[_\x7Fappchain block hash unchanged\0\0\0\x91\x01RV[a,A`\x1D` \x92a\x0F<V[a,J\x81a,\rV[\x01\x90V[a,c\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra,4V[\x90V[\x15a,mWV[a,ua\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a,\x8B`\x04\x82\x01a,NV[\x03\x90\xFD[_\x7Fassertion already exists\0\0\0\0\0\0\0\0\x91\x01RV[a,\xC3`\x18` \x92a\x0F<V[a,\xCC\x81a,\x8FV[\x01\x90V[a,\xE5\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra,\xB6V[\x90V[\x15a,\xEFWV[a,\xF7a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a-\r`\x04\x82\x01a,\xD0V[\x03\x90\xFD[\x90V[a-(a-#a--\x92a-\x11V[a\x053V[a\x022V[\x90V[a-<a-A\x91a\x03\xD8V[a\x08\x8EV[\x90V[a-N\x90Ta-0V[\x90V[a-`a-f\x91\x93\x92\x93a\x022V[\x92a\x022V[\x82\x01\x80\x92\x11a-qWV[a\x12jV[\x90a-\x8Ba-\x86a-\x92\x92a\x12\xBEV[a\x12\xDAV[\x82Ta\x17 V[\x90UV[a-\x9F\x90a\x056V[\x90V[a-\xAB\x90a-\x96V[\x90V[a-\xB7\x90a\x05RV[\x90V[a-\xC3\x90a\x05RV[\x90V[\x90P\x90V[a-\xD6_\x80\x92a-\xC6V[\x01\x90V[a-\xE3\x90a-\xCBV[\x90V[\x90a-\xF8a-\xF3\x83a+\x19V[a+\x04V[\x91\x82RV[``\x90V[=_\x14a.\x1DWa.\x12=a-\xE6V[\x90=_` \x84\x01>[V[a.%a-\xFDV[\x90a.\x1BV[_\x7Fpayment failed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a._`\x0E` \x92a\x0F<V[a.h\x81a.+V[\x01\x90V[a.\x81\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra.RV[\x90V[\x15a.\x8BWV[a.\x93a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a.\xA9`\x04\x82\x01a.lV[\x03\x90\xFD[\x92\x90\x93\x91a/]a/Xa/b\x92a.\xE2a.\xC9\x89\x83\x90a!\x85V[a.\xDCa.\xD6`Aa*\x1FV[\x91a\x022V[\x14a*\x94V[a/Ra.\xEE\x88a4\xA2V[\x98a/La/\x04a.\xFF`\x01a*\xBDV[a5\xDAV[a//\x8C\x91a/ a/\x14a\x01\xA4V[\x93\x84\x92` \x84\x01a*\xD8V[` \x82\x01\x81\x03\x82R\x03\x82a\x15\xCFV[a/Aa/;\x82a*\xFCV[\x91a*\xF6V[ \x93`\x0C\x94\x92a+}V[\x90a6yV[\x90a\x06\x0EV[a\"\x1FV[a+\xE4V[a/\x94a/p_\x85\x01a&\tV[a/\x8Da/\x87a/\x82`\x01\x80\x01a\x03\xF4V[a\x01\xB6V[\x91a\x01\xB6V[\x14\x15a,fV[a/\x9D_a\x0F\x11V[[\x80a/\xBAa/\xB4a/\xAF`\x08a\x0B\xAEV[a\x022V[\x91a\x022V[\x10\x15a0\x07Wa0\x02\x90a/\xFD\x86a/\xF6a/\xF0a/\xEBa/\xE6a/\xE0`\x08\x88\x90a\x0B\xBBV[Pa%\xCEV[a5\rV[a\x01\xB6V[\x91a\x01\xB6V[\x14\x15a,\xE8V[a\x0F-V[a/\x9EV[P\x91a0@\x91\x93Pa0\x19`\x08a\x0B\xAEV[a0+a0%_a\x0F\x11V[\x91a\x022V[\x14a1\x1AW[a0;`\x08a%\xD1V[a&xV[a0J`\x08a\x0B\xAEV[a0]a0W`\x02a-\x14V[\x91a\x022V[\x14a0fW[PV[_\x80a0\xE5a0\xE0a1\x14\x94a0\x98a0\x91a0\x82`\x01a\x14\xD5V[a0\x8C`\ta-DV[a-QV[`\ta-vV[a0\xA2`\ta-DV[a0\xD8\x7F7\xE8\xAD\xD6\x94\xC5\x92mVN\x97\x11`\xF5\x97A\x03\xCB\xBB\xC7\xC9\x07G\xC4\xC6\xF8\x02\x03\x1D5g\xA7\x91a0\xCFa\x01\xA4V[\x91\x82\x91\x82a\x08\xD3V[\x03\x90\xA1a-\xA2V[a-\xAEV[a0\xEE0a-\xBAV[1a0\xF7a\x01\xA4V[\x90\x81a1\x02\x81a-\xDAV[\x03\x92Z\xF1a1\x0Ea.\x02V[Pa.\x84V[_a0cV[a1@a19a1)Ba\x16;V[a13`\ra\x1A\x0FV[\x90a\x1A\x1CV[`\ra\x1A\x82V[a01V[a1V\x90a1Qa3\x8FV[a2KV[V[` \x7Fhile assertion is pending\0\0\0\0\0\0\0\x91\x7Fcannot update challenge window w_\x82\x01R\x01RV[a1\xB2`9`@\x92a\x0F<V[a1\xBB\x81a1XV[\x01\x90V[a1\xD4\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra1\xA5V[\x90V[\x15a1\xDEWV[a1\xE6a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a1\xFC`\x04\x82\x01a1\xBFV[\x03\x90\xFD[`@\x1B\x90V[\x90a2!o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\x91a2\0V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a2@a2;a2G\x92a\x1AcV[a\x1A\x7FV[\x82Ta2\x06V[\x90UV[a2{\x90a2ta2\\`\x08a\x0B\xAEV[a2na2h_a\x0F\x11V[\x91a\x022V[\x14a1\xD7V[`\ra2+V[V[a2\x86\x90a1EV[V[a2\x99\x90a2\x94a3\x8FV[a2\x9BV[V[a2\xC0a2\xA8`\x08a\x0B\xAEV[a2\xBAa2\xB4_a\x0F\x11V[\x91a\x022V[\x14a)mV[a2\xCD\x81_`\x01\x01a\x176V[a2\xD9`\x01\x80\x01a\x03\xF4V[\x7F\xC9\x85\xBC\xCB\xD0\xC9\x0E\x19\x7FJss\x02\n3\xBAo\xF8d\xD09\x9F\xD7\xD6\\\\|2\xFF\xB0\x15\xEC\x91a3\x0Fa3\x06a\x01\xA4V[\x92\x83\x92\x83a\x17eV[\x03\x90\xA1V[a3\x1D\x90a2\x88V[V[a30\x90a3+a3\x8FV[a32V[V[\x80a3Ma3Ga3B_a\x15\xB5V[a\x03eV[\x91a\x03eV[\x14a3]Wa3[\x90a4\x18V[V[a3\x80a3i_a\x15\xB5V[_\x91\x82\x91c\x1EO\xBD\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x03~V[\x03\x90\xFD[a3\x8D\x90a3\x1FV[V[a3\x97a%$V[a3\xB0a3\xAAa3\xA5a6\x9BV[a\x03eV[\x91a\x03eV[\x03a3\xB7WV[a3\xD9a3\xC2a6\x9BV[_\x91\x82\x91c\x11\x8C\xDA\xA7`\xE0\x1B\x83R`\x04\x83\x01a\x03~V[\x03\x90\xFD[\x90a3\xEE`\x01\x80`\xA0\x1B\x03\x91a\x12 V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a4\ra4\x08a4\x14\x92a\x06\x02V[a#,V[\x82Ta3\xDDV[\x90UV[a4!_a%\x17V[a4+\x82_a3\xF8V[\x90a4_a4Y\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x93a\x06\x02V[\x91a\x06\x02V[\x91a4ha\x01\xA4V[\x80a4r\x81a\x01\xFAV[\x03\x90\xA3V[` \x93\x92a4\x96\x85\x83a4\x8E\x82\x95a4\x9E\x97a*\xC3V[\x01\x80\x92a*\xC3V[\x01\x80\x92a*\xC3V[\x01\x90V[a4\xAAa\x17\x96V[Pa4\xF7a4\xB9_\x83\x01a&\tV[a4\xE8a4\xD4`@a4\xCD` \x87\x01a&\tV[\x95\x01a&\tV[a4\xDCa\x01\xA4V[\x94\x85\x93` \x85\x01a4wV[` \x82\x01\x81\x03\x82R\x03\x82a\x15\xCFV[a5\ta5\x03\x82a*\xFCV[\x91a*\xF6V[ \x90V[a5\x15a\x17\x96V[Pa5ba5$_\x83\x01a\x03\xF4V[a5Sa5?`\x02a58`\x01\x87\x01a\x03\xF4V[\x95\x01a\x03\xF4V[a5Ga\x01\xA4V[\x94\x85\x93` \x85\x01a4wV[` \x82\x01\x81\x03\x82R\x03\x82a\x15\xCFV[a5ta5n\x82a*\xFCV[\x91a*\xF6V[ \x90V[\x94a5\xC6` \x80\x99\x98\x95\x96a5\xBE\x82\x80\x99a5\xB6\x82a5\xCE\x9Aa5\xAEa5\xD6\x9F\x80a5\xA6\x85\x9E\x92\x86\x93a*\xC3V[\x01\x80\x92a*\xC3V[\x01\x80\x92a*\xC3V[\x01\x80\x92a*\xC3V[\x01\x80\x92a*\xC3V[\x01\x80\x92a*\xC3V[\x01\x80\x92a*\xC3V[\x01\x90V[a5\xE2a\x17\x96V[Pa6ca5\xF1_\x83\x01a\x03\xF4V[a6Ta6\0`\x01\x85\x01a\x03\xF4V[\x93a6\r`\x02\x82\x01a\x03\xF4V[\x90a6\x1A`\x03\x82\x01a\x03\xF4V[a6&`\x04\x83\x01a\x03\xF4V[\x90a6?`\x06a68`\x05\x86\x01a\x03\xF4V[\x94\x01a\x03\xF4V[\x93a6Ha\x01\xA4V[\x98\x89\x97` \x89\x01a5xV[` \x82\x01\x81\x03\x82R\x03\x82a\x15\xCFV[a6ua6o\x82a*\xFCV[\x91a*\xF6V[ \x90V[a6\x98\x91a6\x8F\x91a6\x89a$\xFFV[Pa6\xCCV[\x90\x92\x91\x92a7\xB4V[\x90V[a6\xA3a$\xFFV[P3\x90V[_\x90V[a6\xC0a6\xBBa6\xC5\x92a\x022V[a\x12 V[a\x01\xB6V[\x90V[_\x90V[\x91\x90\x91a6\xD7a$\xFFV[Pa6\xE0a6\xA8V[Pa6\xE9a\x17\x96V[Pa6\xF3\x83a*\xFCV[a7\x06a7\0`Aa*\x1FV[\x91a\x022V[\x14_\x14a7MWa7F\x91\x92a7\x1Aa\x17\x96V[Pa7#a\x17\x96V[Pa7,a6\xC8V[P` \x81\x01Q```@\x83\x01Q\x92\x01Q_\x1A\x90\x91\x92a9\x11V[\x91\x92\x90\x91\x90V[Pa7W_a\x15\xB5V[\x90a7ka7f`\x02\x94a*\xFCV[a6\xACV[\x91\x92\x91\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x04\x11\x15a7\x8FWV[a7qV[\x90a7\x9E\x82a7\x85V[V[a7\xACa7\xB1\x91a\x03\xD8V[a\x12\xBEV[\x90V[\x80a7\xC7a7\xC1_a7\x94V[\x91a7\x94V[\x14_\x14a7\xD2WPPV[\x80a7\xE6a7\xE0`\x01a7\x94V[\x91a7\x94V[\x14_\x14a8\tW_c\xF6E\xEE\xDF`\xE0\x1B\x81R\x80a8\x05`\x04\x82\x01a\x01\xFAV[\x03\x90\xFD[\x80a8\x1Da8\x17`\x02a7\x94V[\x91a7\x94V[\x14_\x14a8KWa8Ga80\x83a7\xA0V[_\x91\x82\x91c\xFC\xE6\x98\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x08\xD3V[\x03\x90\xFD[a8^a8X`\x03a7\x94V[\x91a7\x94V[\x14a8fWPV[a8\x81\x90_\x91\x82\x91c5\xE2\xF3\x83`\xE2\x1B\x83R`\x04\x83\x01a\x07jV[\x03\x90\xFD[\x90V[a8\x9Ca8\x97a8\xA1\x92a8\x85V[a\x053V[a\x022V[\x90V[`\xFF\x16\x90V[a8\xB3\x90a8\xA4V[\x90RV[a8\xECa8\xF3\x94a8\xE2``\x94\x98\x97\x95a8\xD8`\x80\x86\x01\x9A_\x87\x01\x90a\x04^V[` \x85\x01\x90a8\xAAV[`@\x83\x01\x90a\x04^V[\x01\x90a\x04^V[V[a9\ta9\x04a9\x0E\x92a\x0F\x0EV[a\x12 V[a\x01\xB6V[\x90V[\x93\x92\x93a9\x1Ca$\xFFV[Pa9%a6\xA8V[Pa9.a\x17\x96V[Pa98\x85a7\xA0V[a9ja9d\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0a8\x88V[\x91a\x022V[\x11a9\xF7W\x90a9\x8D` \x94\x95_\x94\x93\x92\x93a9\x84a\x01\xA4V[\x94\x85\x94\x85a8\xB7V[\x83\x80R\x03\x90`\x01Z\xFA\x15a9\xF2Wa9\xA5_Qa\x12 V[\x80a9\xC0a9\xBAa9\xB5_a\x15\xB5V[a\x03eV[\x91a\x03eV[\x14a9\xD6W_\x91a9\xD0_a8\xF5V[\x91\x92\x91\x90V[Pa9\xE0_a\x15\xB5V[`\x01\x91a9\xEC_a8\xF5V[\x91\x92\x91\x90V[a\x16+V[PPPa:\x03_a\x15\xB5V[\x90`\x03\x92\x91\x92\x91\x90V",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610015575b36610ef757005b61001f5f3561019e565b80631c12427f1461019957806333339006146101945780633ceaae7d1461018f578063420caf3a1461018a57806347742640146101855780634afffcc9146101805780634bd167c91461017b5780635f70c44114610176578063697b5e62146101715780636c4c20601461016c5780636ef012011461016757806370646ea214610162578063715018a61461015d57806380959721146101585780638da5cb5b146101535780638fed55a31461014e578063a56ec6cd14610149578063c3f2dbd314610144578063e50c61561461013f578063e78cea921461013a578063eb60553a14610135578063ee1c28b814610130578063f223055c1461012b5763f2fde38b0361000e57610ec4565b610e91565b610e5c565b610e1a565b610da4565b610d1b565b610c95565b610c5d565b610b7b565b610b11565b610adc565b610a57565b610a20565b610950565b61091d565b6108e8565b61085b565b610826565b61077f565b610690565b61058c565b6104d3565b610393565b6101ff565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b90565b6101c2816101b6565b036101c957565b5f80fd5b905035906101da826101b9565b565b906020828203126101f5576101f2915f016101cd565b90565b6101ae565b5f0190565b3461022d576102176102123660046101dc565b61115a565b61021f6101a4565b80610229816101fa565b0390f35b6101aa565b90565b61023e81610232565b0361024557565b5f80fd5b9050359061025682610235565b565b9190604083820312610280578061027461027d925f86016101cd565b93602001610249565b90565b6101ae565b61028e906101b6565b90565b9061029b90610285565b5f5260205260405f2090565b634e487b7160e01b5f52603260045260245ffd5b5490565b5f5260205f2090565b6102d1816102bb565b8210156102eb576102e36001916102bf565b910201905f90565b6102a7565b1c90565b60018060a01b031690565b61030f90600861031493026102f0565b6102f4565b90565b9061032291546102ff565b90565b61033090600b610291565b610339816102bb565b821015610356576103539161034d916102c8565b90610317565b90565b5f80fd5b60018060a01b031690565b61036e9061035a565b90565b61037a90610365565b9052565b9190610391905f60208501940190610371565b565b346103c4576103c06103af6103a9366004610258565b90610325565b6103b76101a4565b9182918261037e565b0390f35b6101aa565b5f9103126103d357565b6101ae565b5f1c90565b90565b6103ec6103f1916103d8565b6103dd565b90565b6103fe90546103e0565b90565b600161040e5f82016103f4565b9161041b600183016103f4565b91610428600282016103f4565b91610435600383016103f4565b91610442600482016103f4565b9161045b6006610454600585016103f4565b93016103f4565b90565b610467906101b6565b9052565b949290979695939160e08601985f87016104849161045e565b602086016104919161045e565b6040850161049e9161045e565b606084016104ab9161045e565b608083016104b89161045e565b60a082016104c59161045e565b60c0016104d19161045e565b565b3461050a576104e33660046103c9565b6105066104ee610401565b936104fd9795979391936101a4565b9788978861046b565b0390f35b6101aa565b7f000000000000000000000000000000000000000000000000000000000000000090565b90565b61054a61054561054f9261035a565b610533565b61035a565b90565b61055b90610536565b90565b61056790610552565b90565b6105739061055e565b9052565b919061058a905f6020850194019061056a565b565b346105bc5761059c3660046103c9565b6105b86105a761050f565b6105af6101a4565b91829182610577565b0390f35b6101aa565b6105ca81610365565b036105d157565b5f80fd5b905035906105e2826105c1565b565b906020828203126105fd576105fa915f016105d5565b90565b6101ae565b61060b90610552565b90565b9061061890610602565b5f5260205260405f2090565b60ff1690565b61063a90600861063f93026102f0565b610624565b90565b9061064d915461062a565b90565b61066690610661600c915f9261060e565b610642565b90565b151590565b61067790610669565b9052565b919061068e905f6020850194019061066e565b565b346106c0576106bc6106ab6106a63660046105e4565b610650565b6106b36101a4565b9182918261067b565b0390f35b6101aa565b906020828203126106de576106db915f01610249565b90565b6101ae565b5490565b5f5260205f2090565b6106f9816106e3565b8210156107135761070b6001916106e7565b910201905f90565b6102a7565b61072890600861072d93026102f0565b6103dd565b90565b9061073b9154610718565b90565b600a610749816106e3565b821015610766576107639161075d916106f0565b90610730565b90565b5f80fd5b919061077d905f6020850194019061045e565b565b346107af576107ab61079a6107953660046106c5565b61073e565b6107a26101a4565b9182918261076a565b0390f35b6101aa565b67ffffffffffffffff1690565b6107d19060086107d693026102f0565b6107b4565b90565b906107e491546107c1565b90565b6107f4600d6008906107d9565b90565b67ffffffffffffffff1690565b61080d906107f7565b9052565b9190610824905f60208501940190610804565b565b34610856576108363660046103c9565b6108526108416107e7565b6108496101a4565b91829182610811565b0390f35b6101aa565b346108895761087361086e3660046101dc565b6114c7565b61087b6101a4565b80610885816101fa565b0390f35b6101aa565b90565b6108a19060086108a693026102f0565b61088e565b90565b906108b49154610891565b90565b6108c360095f906108a9565b90565b6108cf90610232565b9052565b91906108e6905f602085019401906108c6565b565b34610918576108f83660046103c9565b6109146109036108b7565b61090b6101a4565b918291826108d3565b0390f35b6101aa565b3461094b5761092d3660046103c9565b610935611aa2565b61093d6101a4565b80610947816101fa565b0390f35b6101aa565b3461097e576109603660046103c9565b61096861217b565b6109706101a4565b8061097a816101fa565b0390f35b6101aa565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156109c95781359167ffffffffffffffff83116109c45760200192600183028401116109bf57565b61098b565b610987565b610983565b91606083830312610a1b576109e5825f85016105d5565b926109f383602083016101cd565b92604082013567ffffffffffffffff8111610a1657610a12920161098f565b9091565b6101b2565b6101ae565b34610a5257610a3c610a333660046109ce565b92919091612386565b610a446101a4565b80610a4e816101fa565b0390f35b6101aa565b34610a8557610a673660046103c9565b610a6f6124f5565b610a776101a4565b80610a81816101fa565b0390f35b6101aa565b7f000000000000000000000000000000000000000000000000000000000000000090565b610ab790610552565b90565b610ac390610aae565b9052565b9190610ada905f60208501940190610aba565b565b34610b0c57610aec3660046103c9565b610b08610af7610a8a565b610aff6101a4565b91829182610ac7565b0390f35b6101aa565b34610b4157610b213660046103c9565b610b3d610b2c612524565b610b346101a4565b9182918261037e565b0390f35b6101aa565b5f80fd5b90816060910312610b585790565b610b46565b90606082820312610b7657610b73915f01610b4a565b90565b6101ae565b34610ba957610b93610b8e366004610b5d565b6128d0565b610b9b6101a4565b80610ba5816101fa565b0390f35b6101aa565b5490565b5f5260205f2090565b610bc481610bae565b821015610bde57610bd6600391610bb2565b910201905f90565b6102a7565b600890610bef82610bae565b811015610c2757610bff91610bbb565b50610c0b5f82016103f4565b91610c246002610c1d600185016103f4565b93016103f4565b90565b5f80fd5b604090610c54610c5b9496959396610c4a60608401985f85019061045e565b602083019061045e565b019061045e565b565b34610c9057610c8c610c78610c733660046106c5565b610be3565b610c839391936101a4565b93849384610c2b565b0390f35b6101aa565b34610cc357610cad610ca83660046101dc565b612a11565b610cb56101a4565b80610cbf816101fa565b0390f35b6101aa565b9060a082820312610d1657610cdf815f8401610b4a565b92606083013567ffffffffffffffff8111610d1157610d0383610d0e92860161098f565b9390946080016105d5565b90565b6101b2565b6101ae565b34610d4d57610d37610d2e366004610cc8565b92919091612ead565b610d3f6101a4565b80610d49816101fa565b0390f35b6101aa565b7f000000000000000000000000000000000000000000000000000000000000000090565b610d7f90610552565b90565b610d8b90610d76565b9052565b9190610da2905f60208501940190610d82565b565b34610dd457610db43660046103c9565b610dd0610dbf610d52565b610dc76101a4565b91829182610d8f565b0390f35b6101aa565b610de2816107f7565b03610de957565b5f80fd5b90503590610dfa82610dd9565b565b90602082820312610e1557610e12915f01610ded565b90565b6101ae565b34610e4857610e32610e2d366004610dfc565b61327d565b610e3a6101a4565b80610e44816101fa565b0390f35b6101aa565b610e59600d5f906107d9565b90565b34610e8c57610e6c3660046103c9565b610e88610e77610e4d565b610e7f6101a4565b91829182610811565b0390f35b6101aa565b34610ebf57610ea9610ea43660046101dc565b613314565b610eb16101a4565b80610ebb816101fa565b0390f35b6101aa565b34610ef257610edc610ed73660046105e4565b613384565b610ee46101a4565b80610eee816101fa565b0390f35b6101aa565b5f80fd5b610f0c90610f0761338f565b61109f565b565b90565b610f25610f20610f2a92610f0e565b610533565b610232565b90565b6001610f399101610232565b90565b60209181520190565b5f7f7465652070726f6772616d20616c726561647920657869737473000000000000910152565b610f79601a602092610f3c565b610f8281610f45565b0190565b610f9b9060208101905f818303910152610f6c565b90565b15610fa557565b610fad6101a4565b62461bcd60e51b815280610fc360048201610f86565b0390fd5b90565b634e487b7160e01b5f52604160045260245ffd5b5f5260205f2090565b5490565b610ff481610fe7565b82101561100e57611006600191610fde565b910201905f90565b6102a7565b1b90565b9190600861103291029161102c5f1984611013565b92611013565b9181191691161790565b611045906103d8565b90565b919061105e61105961106693610285565b61103c565b908354611017565b9055565b908154916801000000000000000083101561109a578261109291600161109895018155610feb565b90611048565b565b610fca565b6110a85f610f11565b5b806110c56110bf6110ba600a6106e3565b610232565b91610232565b101561110a57611105906111006110e76110e1600a84906106f0565b90610730565b6110f96110f3866101b6565b916101b6565b1415610f9e565b610f2d565b6110a9565b5061111f611118600a610fc7565b829061106a565b6111557f9a7a6469c25cf017890607695e4a149cc771f294fd871e2080d24cd109033ab69161114c6101a4565b9182918261076a565b0390a1565b61116390610efb565b565b6111769061117161338f565b6113da565b565b60207f617373657274696f6e2069732070656e64696e67000000000000000000000000917f63616e6e6f742072656d6f7665207465652070726f6772616d207768696c65205f8201520152565b6111d26034604092610f3c565b6111db81611178565b0190565b6111f49060208101905f8183039101526111c5565b90565b156111fe57565b6112066101a4565b62461bcd60e51b81528061121c600482016111df565b0390fd5b5f1b90565b9061123160ff91611220565b9181191691161790565b61124490610669565b90565b90565b9061125f61125a6112669261123b565b611247565b8254611225565b9055565b634e487b7160e01b5f52601160045260245ffd5b61128d61129391939293610232565b92610232565b9161129f838202610232565b9281840414901517156112ae57565b61126a565b600190818003010490565b6112d26112cd6112d792610232565b610533565b610232565b90565b90565b91906112f36112ee6112fb936112be565b6112da565b908354611017565b9055565b5f90565b6113159161130f6112ff565b916112dd565b565b5b818110611323575050565b806113305f600193611303565b01611318565b9091828110611345575b505050565b61136361135d61135761136e956112b3565b926112b3565b926102bf565b918201910190611317565b5f8080611340565b9068010000000000000000811161139f578161139461139d936102bb565b90828155611336565b565b610fca565b5f6113ae91611376565b565b634e487b7160e01b5f525f60045260245ffd5b905f036113d5576113d3906113a4565b565b6113b0565b6113ff6113e76008610bae565b6113f96113f35f610f11565b91610232565b146111f7565b6114085f610f11565b5b8061142f61142961142461141f600b8790610291565b6102bb565b610232565b91610232565b1015611476576114719061146c5f611467600c61146161145b611454600b8a90610291565b87906102c8565b90610317565b9061060e565b61124a565b610f2d565b611409565b5061148c5f611487600b8490610291565b6113c3565b6114c27f2621c61d3315f2a3d26b22d746ba21a96d249f51ada323f7226cce5fe5fc3d64916114b96101a4565b9182918261076a565b0390a1565b6114d090611165565b565b90565b6114e96114e46114ee926114d2565b610533565b610232565b90565b60207f746f6f206d616e7920617373657274696f6e7300000000000000000000000000917f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201520152565b61154b6033604092610f3c565b611554816114f1565b0190565b61156d9060208101905f81830391015261153e565b90565b1561157757565b61157f6101a4565b62461bcd60e51b81528061159560048201611558565b0390fd5b6115ad6115a86115b292610f0e565b610533565b61035a565b90565b6115be90611599565b90565b5f80fd5b601f801991011690565b906115d9906115c5565b810190811067ffffffffffffffff8211176115f357604052565b610fca565b60e01b90565b9050519061160b82610dd9565b565b9060208282031261162657611623915f016115fe565b90565b6101ae565b6116336101a4565b3d5f823e3d90fd5b61164f61164a61165492610232565b610533565b6107f7565b90565b611663611668916103d8565b6107b4565b90565b6116759054611657565b90565b60207f696e73756666696369656e742074696d65206861732070617373656400000000917f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201520152565b6116d2603c604092610f3c565b6116db81611678565b0190565b6116f49060208101905f8183039101526116c5565b90565b156116fe57565b6117066101a4565b62461bcd60e51b81528061171c600482016116df565b0390fd5b9061172c5f1991611220565b9181191691161790565b9061174b61174661175292610285565b61103c565b8254611720565b9055565b5f91031261176057565b6101ae565b91602061178692949361177f60408201965f83019061045e565b019061045e565b565b61179390600361127e565b90565b5f90565b6117ac916117a6611796565b91611048565b565b5f60026117d4926117c18380830161179a565b6117ce836001830161179a565b0161179a565b565b905f036117e8576117e6906117ae565b565b6113b0565b5b8181106117f9575050565b806118065f6003936117d6565b016117ee565b909182811061181b575b505050565b61183961183361182d61184495611788565b92611788565b92610bb2565b9182019101906117ed565b5f8080611816565b90680100000000000000008111611875578161186a61187393610bae565b9082815561180c565b565b610fca565b5f6118849161184c565b565b905f03611898576118969061187a565b565b6113b0565b905051906118aa82610235565b565b906020828203126118c5576118c2915f0161189d565b90565b6101ae565b6118d96118df91939293610232565b92610232565b82039182116118ea57565b61126a565b905051906118fc826101b9565b565b9060208282031261191757611914915f016118ef565b90565b6101ae565b611925906101b6565b9052565b9060c06119d660066119de9461194d6119445f8301546103e0565b5f87019061191c565b61196761195d60018301546103e0565b602087019061191c565b61198161197760028301546103e0565b604087019061191c565b61199b61199160038301546103e0565b606087019061191c565b6119b56119ab60048301546103e0565b608087019061191c565b6119cf6119c560058301546103e0565b60a087019061191c565b01546103e0565b91019061191c565b565b91906119f3905f60e08501940190611929565b565b60401c90565b611a07611a0c916119f5565b6107b4565b90565b611a1990546119fb565b90565b611a28611a2e916107f7565b916107f7565b019067ffffffffffffffff8211611a4157565b61126a565b90611a5967ffffffffffffffff91611220565b9181191691161790565b611a77611a72611a7c926107f7565b610533565b6107f7565b90565b90565b90611a97611a92611a9e92611a63565b611a7f565b8254611a46565b9055565b611ac9611aaf6008610bae565b611ac2611abc60016114d5565b91610232565b1115611570565b611af27f000000000000000000000000000000000000000000000000000000000000000061055e565b611b0c611b06611b015f6115b5565b610365565b91610365565b145f14611f7157611b41611b1f4261163b565b5b611b3b611b35611b30600d61166b565b6107f7565b916107f7565b116116f7565b611b4b6008610bae565b611b5d611b575f610f11565b91610232565b11611e2c575b611b8c7f0000000000000000000000000000000000000000000000000000000000000000610d76565b611bd563d5719dc26020611bbf7f0000000000000000000000000000000000000000000000000000000000000000610d76565b63eca067ad90611bcd6101a4565b9485926115f8565b82528180611be5600482016101fa565b03915afa928315611e2757611c2a611c15611c35956020955f91611dfa575b50611c0f60016114d5565b906118ca565b92611c1e6101a4565b958694859384936115f8565b8352600483016108d3565b03915afa8015611df557611c55915f91611dc7575b506004600101611736565b611c7e7f000000000000000000000000000000000000000000000000000000000000000061055e565b611c98611c92611c8d5f6115b5565b610365565b91610365565b145f14611d2557611cc2611cb643611cb060016114d5565b906118ca565b405b6006600101611736565b6001611cfa7f91092bcf550921e381e81f06693320534b144a7e561c5fc08f1940d508a85cdc91611cf16101a4565b918291826119e0565b0390a1611d23611d1c611d0c4261163b565b611d16600d611a0f565b90611a1c565b600d611a82565b565b611d696020611d537f000000000000000000000000000000000000000000000000000000000000000061055e565b6309bd5a6090611d616101a4565b9384926115f8565b82528180611d79600482016101fa565b03915afa8015611dc257611cc2915f91611d94575b50611cb8565b611db5915060203d8111611dbb575b611dad81836115cf565b8101906118fe565b5f611d8e565b503d611da3565b61162b565b611de8915060203d8111611dee575b611de081836115cf565b8101906118fe565b5f611c4a565b503d611dd6565b61162b565b611e1a9150863d8111611e20575b611e1281836115cf565b8101906118ac565b5f611c04565b503d611e08565b61162b565b611e4f611e465f611e3f60088290610bbb565b50016103f4565b60018001611736565b611e74611e6a6002611e6360085f90610bbb565b50016103f4565b6003600101611736565b611e8e611e8460066001016103f4565b6005600101611736565b611eb77f0000000000000000000000000000000000000000000000000000000000000000610aae565b63daeab412611ed35f611ecc60088290610bbb565b50016103f4565b611eeb6001611ee460085f90610bbb565b50016103f4565b92803b15611f6c57611f105f8094611f1b611f046101a4565b978896879586946115f8565b845260048401611765565b03925af18015611f6757611f3b575b50611f365f6008611886565b611b63565b611f5a905f3d8111611f60575b611f5281836115cf565b810190611756565b5f611f2a565b503d611f48565b61162b565b6115c1565b611fb56020611f9f7f000000000000000000000000000000000000000000000000000000000000000061055e565b63b80777ea90611fad6101a4565b9384926115f8565b82528180611fc5600482016101fa565b03915afa801561200e57611b41915f91611fe0575b50611b20565b612001915060203d8111612007575b611ff981836115cf565b81019061160d565b5f611fda565b503d611fef565b61162b565b61201b61338f565b6120236120e0565b565b600190818003010490565b5b81811061203c575050565b806120495f60019361179a565b01612031565b909182811061205e575b505050565b61207c61207661207061208795612025565b92612025565b926106e7565b918201910190612030565b5f8080612059565b906801000000000000000081116120b857816120ad6120b6936106e3565b9082815561204f565b565b610fca565b5f6120c79161208f565b565b905f036120db576120d9906120bd565b565b6113b0565b6120e95f610f11565b5b806121066121006120fb600a6106e3565b610232565b91610232565b1015612137576121329061212d612128612122600a84906106f0565b90610730565b6114c7565b610f2d565b6120ea565b506121435f600a6120c9565b7feca62e0074a13a90d600f003b7cb8d5bd50100008d3f3915f2554f3f8552c5cc61216c6101a4565b80612176816101fa565b0390a1565b612183612013565b565b5090565b5f7f746f646f3a2076616c6964617465207a6b207a6b50726f6f6600000000000000910152565b6121bd6019602092610f3c565b6121c681612189565b0190565b6121df9060208101905f8183039101526121b0565b90565b156121e957565b6121f16101a4565b62461bcd60e51b815280612207600482016121ca565b0390fd5b61221761221c916103d8565b610624565b90565b612229905461220b565b90565b5f7f6b657920616c7265616479206164646564000000000000000000000000000000910152565b6122606011602092610f3c565b6122698161222c565b0190565b6122829060208101905f818303910152612253565b90565b1561228c57565b6122946101a4565b62461bcd60e51b8152806122aa6004820161226d565b0390fd5b6122b790610232565b5f81146122c5576001900390565b61126a565b90565b5f5260205f2090565b5490565b6122e3816122d6565b8210156122fd576122f56001916122cd565b910201905f90565b6102a7565b9190600861232291029161231c60018060a01b0384611013565b92611013565b9181191691161790565b90565b919061234561234061234d93610602565b61232c565b908354612302565b9055565b9081549168010000000000000000831015612381578261237991600161237f950181556122da565b9061232f565b565b610fca565b92612395906123ae9293612185565b6123a86123a260016114d5565b91610232565b146121e2565b6123d36123ce6123c86123c3600c869061060e565b61221f565b15610669565b612285565b6123e76123e2600b8390610291565b6102bb565b6123f96123f35f610f11565b91610232565b14612433575b9061242c61242761243193612420600161241b600c879061060e565b61124a565b600b610291565b6122ca565b612351565b565b5f9161243f600a6106e3565b5b8061245361244d5f610f11565b91610232565b11156124c45761248161247b600a6124758461246f60016114d5565b906118ca565b906106f0565b90610730565b61249361248d856101b6565b916101b6565b146124a6576124a1906122ae565b612440565b509091506124b660015b15610669565b6124c057906123ff565b5050565b5090916124b6906124b0565b6124d861338f565b6124e06124e2565b565b6124f36124ee5f6115b5565b613418565b565b6124fd6124d0565b565b5f90565b61250f612514916103d8565b6102f4565b90565b6125219054612503565b90565b61252c6124ff565b506125365f612517565b90565b61254a9061254561338f565b612798565b565b5f7f6368616c6c656e676520646f6573206e6f742065786973740000000000000000910152565b6125806018602092610f3c565b6125898161254c565b0190565b6125a29060208101905f818303910152612573565b90565b156125ac57565b6125b46101a4565b62461bcd60e51b8152806125ca6004820161258d565b0390fd5b90565b90565b5f5260205f2090565b5490565b6125ea816125dd565b821015612604576125fc6003916125d4565b910201905f90565b6102a7565b35612613816101b9565b90565b9061265a60406002612660946126395f82016126335f8801612609565b90611736565b6126526001820161264c60208801612609565b90611736565b019201612609565b90611736565b565b91906126735761267191612616565b565b6113b0565b90815491680100000000000000008310156126a857826126a09160016126a6950181556125e1565b90612662565b565b610fca565b6126c16126bc6126c692610f0e565b610533565b6107f7565b90565b506126d89060208101906101cd565b90565b906040612720612728936126fd6126f45f8301836126c9565b5f86019061191c565b61271761270d60208301836126c9565b602086019061191c565b828101906126c9565b91019061191c565b565b919061273d905f606085019401906126db565b565b5f7f617373657274696f6e206e6f7420666f756e6400000000000000000000000000910152565b6127736013602092610f3c565b61277c8161273f565b0190565b6127959060208101905f818303910152612766565b90565b6127be6127a56008610bae565b6127b86127b260016114d5565b91610232565b116125a5565b6127c7816134a2565b906127d15f610f11565b5b806127ee6127e86127e36008610bae565b610232565b91610232565b10156128ae578261282361281d61281861281361280d60088790610bbb565b506125ce565b61350d565b6101b6565b916101b6565b146128365761283190610f2d565b6127d2565b5090506128445f6008611886565b61285861285160086125d1565b8290612678565b61286b6128645f6126ad565b600d611a82565b612873611aa2565b6128a97fe42eaf0737e2478a5f5aed3a0610ae7b09a27cbac9ad6a5cc4d68f78afd1425b916128a06101a4565b9182918261272a565b0390a1565b6128b66101a4565b62461bcd60e51b8152806128cc60048201612780565b0390fd5b6128d990612539565b565b6128ec906128e761338f565b612996565b565b60207f617373657274696f6e73206172652070656e64696e6700000000000000000000917f63616e6e6f742075706461746520636f6e6669672068617368207768696c65205f8201520152565b6129486036604092610f3c565b612951816128ee565b0190565b61296a9060208101905f81830391015261293b565b90565b1561297457565b61297c6101a4565b62461bcd60e51b81528061299260048201612955565b0390fd5b6129bb6129a36008610bae565b6129b56129af5f610f11565b91610232565b1461296d565b6129c9816002600101611736565b6129d660036001016103f4565b7fb9eb20b32fac965884cb58326102257cae604504f0a36cd1008a32845ad5c29b91612a0c612a036101a4565b92839283611765565b0390a1565b612a1a906128db565b565b90565b612a33612a2e612a3892612a1c565b610533565b610232565b90565b5f7f696e76616c6964207369676e6174757265206c656e6774680000000000000000910152565b612a6f6018602092610f3c565b612a7881612a3b565b0190565b612a919060208101905f818303910152612a62565b90565b15612a9b57565b612aa36101a4565b62461bcd60e51b815280612ab960048201612a7c565b0390fd5b90565b90565b612acf612ad4916101b6565b612ac0565b9052565b602081612aea612af293839695612ac3565b018092612ac3565b0190565b60200190565b5190565b5f80fd5b90612b17612b106101a4565b92836115cf565b565b67ffffffffffffffff8111612b3757612b336020916115c5565b0190565b610fca565b90825f939282370152565b90929192612b5c612b5782612b19565b612b04565b93818552602085019082840111612b7857612b7692612b3c565b565b612b00565b612b88913691612b47565b90565b5f7f696e76616c696420746565207369676e61747572650000000000000000000000910152565b612bbf6015602092610f3c565b612bc881612b8b565b0190565b612be19060208101905f818303910152612bb2565b90565b15612beb57565b612bf36101a4565b62461bcd60e51b815280612c0960048201612bcc565b0390fd5b5f7f617070636861696e20626c6f636b206861736820756e6368616e676564000000910152565b612c41601d602092610f3c565b612c4a81612c0d565b0190565b612c639060208101905f818303910152612c34565b90565b15612c6d57565b612c756101a4565b62461bcd60e51b815280612c8b60048201612c4e565b0390fd5b5f7f617373657274696f6e20616c7265616479206578697374730000000000000000910152565b612cc36018602092610f3c565b612ccc81612c8f565b0190565b612ce59060208101905f818303910152612cb6565b90565b15612cef57565b612cf76101a4565b62461bcd60e51b815280612d0d60048201612cd0565b0390fd5b90565b612d28612d23612d2d92612d11565b610533565b610232565b90565b612d3c612d41916103d8565b61088e565b90565b612d4e9054612d30565b90565b612d60612d6691939293610232565b92610232565b8201809211612d7157565b61126a565b90612d8b612d86612d92926112be565b6112da565b8254611720565b9055565b612d9f90610536565b90565b612dab90612d96565b90565b612db790610552565b90565b612dc390610552565b90565b905090565b612dd65f8092612dc6565b0190565b612de390612dcb565b90565b90612df8612df383612b19565b612b04565b918252565b606090565b3d5f14612e1d57612e123d612de6565b903d5f602084013e5b565b612e25612dfd565b90612e1b565b5f7f7061796d656e74206661696c6564000000000000000000000000000000000000910152565b612e5f600e602092610f3c565b612e6881612e2b565b0190565b612e819060208101905f818303910152612e52565b90565b15612e8b57565b612e936101a4565b62461bcd60e51b815280612ea960048201612e6c565b0390fd5b92909391612f5d612f58612f6292612ee2612ec9898390612185565b612edc612ed66041612a1f565b91610232565b14612a94565b612f52612eee886134a2565b98612f4c612f04612eff6001612abd565b6135da565b612f2f8c91612f20612f146101a4565b93849260208401612ad8565b602082018103825203826115cf565b612f41612f3b82612afc565b91612af6565b2093600c9492612b7d565b90613679565b9061060e565b61221f565b612be4565b612f94612f705f8501612609565b612f8d612f87612f82600180016103f4565b6101b6565b916101b6565b1415612c66565b612f9d5f610f11565b5b80612fba612fb4612faf6008610bae565b610232565b91610232565b10156130075761300290612ffd86612ff6612ff0612feb612fe6612fe060088890610bbb565b506125ce565b61350d565b6101b6565b916101b6565b1415612ce8565b610f2d565b612f9e565b50916130409193506130196008610bae565b61302b6130255f610f11565b91610232565b1461311a575b61303b60086125d1565b612678565b61304a6008610bae565b61305d6130576002612d14565b91610232565b14613066575b50565b5f806130e56130e06131149461309861309161308260016114d5565b61308c6009612d44565b612d51565b6009612d76565b6130a26009612d44565b6130d87f37e8add694c5926d564e971160f5974103cbbbc7c90747c4c6f802031d3567a7916130cf6101a4565b918291826108d3565b0390a1612da2565b612dae565b6130ee30612dba565b316130f76101a4565b908161310281612dda565b03925af161310e612e02565b50612e84565b5f613063565b6131406131396131294261163b565b613133600d611a0f565b90611a1c565b600d611a82565b613031565b6131569061315161338f565b61324b565b565b60207f68696c6520617373657274696f6e2069732070656e64696e6700000000000000917f63616e6e6f7420757064617465206368616c6c656e67652077696e646f7720775f8201520152565b6131b26039604092610f3c565b6131bb81613158565b0190565b6131d49060208101905f8183039101526131a5565b90565b156131de57565b6131e66101a4565b62461bcd60e51b8152806131fc600482016131bf565b0390fd5b60401b90565b906132216fffffffffffffffff000000000000000091613200565b9181191691161790565b9061324061323b61324792611a63565b611a7f565b8254613206565b9055565b61327b9061327461325c6008610bae565b61326e6132685f610f11565b91610232565b146131d7565b600d61322b565b565b61328690613145565b565b6132999061329461338f565b61329b565b565b6132c06132a86008610bae565b6132ba6132b45f610f11565b91610232565b1461296d565b6132cd815f600101611736565b6132d9600180016103f4565b7fc985bccbd0c90e197f4a7373020a33ba6ff864d0399fd7d65c5c7c32ffb015ec9161330f6133066101a4565b92839283611765565b0390a1565b61331d90613288565b565b6133309061332b61338f565b613332565b565b8061334d6133476133425f6115b5565b610365565b91610365565b1461335d5761335b90613418565b565b6133806133695f6115b5565b5f918291631e4fbdf760e01b83526004830161037e565b0390fd5b61338d9061331f565b565b613397612524565b6133b06133aa6133a561369b565b610365565b91610365565b036133b757565b6133d96133c261369b565b5f91829163118cdaa760e01b83526004830161037e565b0390fd5b906133ee60018060a01b0391611220565b9181191691161790565b9061340d61340861341492610602565b61232c565b82546133dd565b9055565b6134215f612517565b61342b825f6133f8565b9061345f6134597f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e093610602565b91610602565b916134686101a4565b80613472816101fa565b0390a3565b60209392613496858361348e829561349e97612ac3565b018092612ac3565b018092612ac3565b0190565b6134aa611796565b506134f76134b95f8301612609565b6134e86134d460406134cd60208701612609565b9501612609565b6134dc6101a4565b94859360208501613477565b602082018103825203826115cf565b61350961350382612afc565b91612af6565b2090565b613515611796565b506135626135245f83016103f4565b61355361353f6002613538600187016103f4565b95016103f4565b6135476101a4565b94859360208501613477565b602082018103825203826115cf565b61357461356e82612afc565b91612af6565b2090565b946135c6602080999895966135be8280996135b6826135ce9a6135ae6135d69f806135a6859e928693612ac3565b018092612ac3565b018092612ac3565b018092612ac3565b018092612ac3565b018092612ac3565b018092612ac3565b0190565b6135e2611796565b506136636135f15f83016103f4565b613654613600600185016103f4565b9361360d600282016103f4565b9061361a600382016103f4565b613626600483016103f4565b9061363f6006613638600586016103f4565b94016103f4565b936136486101a4565b98899760208901613578565b602082018103825203826115cf565b61367561366f82612afc565b91612af6565b2090565b6136989161368f916136896124ff565b506136cc565b909291926137b4565b90565b6136a36124ff565b503390565b5f90565b6136c06136bb6136c592610232565b611220565b6101b6565b90565b5f90565b9190916136d76124ff565b506136e06136a8565b506136e9611796565b506136f383612afc565b6137066137006041612a1f565b91610232565b145f1461374d57613746919261371a611796565b50613723611796565b5061372c6136c8565b506020810151606060408301519201515f1a909192613911565b9192909190565b506137575f6115b5565b9061376b613766600294612afc565b6136ac565b91929190565b634e487b7160e01b5f52602160045260245ffd5b6004111561378f57565b613771565b9061379e82613785565b565b6137ac6137b1916103d8565b6112be565b90565b806137c76137c15f613794565b91613794565b145f146137d2575050565b806137e66137e06001613794565b91613794565b145f14613809575f63f645eedf60e01b815280613805600482016101fa565b0390fd5b8061381d6138176002613794565b91613794565b145f1461384b57613847613830836137a0565b5f91829163fce698f760e01b8352600483016108d3565b0390fd5b61385e6138586003613794565b91613794565b146138665750565b613881905f9182916335e2f38360e21b83526004830161076a565b0390fd5b90565b61389c6138976138a192613885565b610533565b610232565b90565b60ff1690565b6138b3906138a4565b9052565b6138ec6138f3946138e26060949897956138d8608086019a5f87019061045e565b60208501906138aa565b604083019061045e565b019061045e565b565b61390961390461390e92610f0e565b611220565b6101b6565b90565b93929361391c6124ff565b506139256136a8565b5061392e611796565b50613938856137a0565b61396a6139647f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0613888565b91610232565b116139f7579061398d602094955f949392936139846101a4565b948594856138b7565b838052039060015afa156139f2576139a55f51611220565b806139c06139ba6139b55f6115b5565b610365565b91610365565b146139d6575f916139d05f6138f5565b91929190565b506139e05f6115b5565b6001916139ec5f6138f5565b91929190565b61162b565b505050613a035f6115b5565b906003929192919056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x15W[6a\x0E\xF7W\0[a\0\x1F_5a\x01\x9EV[\x80c\x1C\x12B\x7F\x14a\x01\x99W\x80c33\x90\x06\x14a\x01\x94W\x80c<\xEA\xAE}\x14a\x01\x8FW\x80cB\x0C\xAF:\x14a\x01\x8AW\x80cGt&@\x14a\x01\x85W\x80cJ\xFF\xFC\xC9\x14a\x01\x80W\x80cK\xD1g\xC9\x14a\x01{W\x80c_p\xC4A\x14a\x01vW\x80ci{^b\x14a\x01qW\x80clL `\x14a\x01lW\x80cn\xF0\x12\x01\x14a\x01gW\x80cpdn\xA2\x14a\x01bW\x80cqP\x18\xA6\x14a\x01]W\x80c\x80\x95\x97!\x14a\x01XW\x80c\x8D\xA5\xCB[\x14a\x01SW\x80c\x8F\xEDU\xA3\x14a\x01NW\x80c\xA5n\xC6\xCD\x14a\x01IW\x80c\xC3\xF2\xDB\xD3\x14a\x01DW\x80c\xE5\x0CaV\x14a\x01?W\x80c\xE7\x8C\xEA\x92\x14a\x01:W\x80c\xEB`U:\x14a\x015W\x80c\xEE\x1C(\xB8\x14a\x010W\x80c\xF2#\x05\\\x14a\x01+Wc\xF2\xFD\xE3\x8B\x03a\0\x0EWa\x0E\xC4V[a\x0E\x91V[a\x0E\\V[a\x0E\x1AV[a\r\xA4V[a\r\x1BV[a\x0C\x95V[a\x0C]V[a\x0B{V[a\x0B\x11V[a\n\xDCV[a\nWV[a\n V[a\tPV[a\t\x1DV[a\x08\xE8V[a\x08[V[a\x08&V[a\x07\x7FV[a\x06\x90V[a\x05\x8CV[a\x04\xD3V[a\x03\x93V[a\x01\xFFV[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90V[a\x01\xC2\x81a\x01\xB6V[\x03a\x01\xC9WV[_\x80\xFD[\x90P5\x90a\x01\xDA\x82a\x01\xB9V[V[\x90` \x82\x82\x03\x12a\x01\xF5Wa\x01\xF2\x91_\x01a\x01\xCDV[\x90V[a\x01\xAEV[_\x01\x90V[4a\x02-Wa\x02\x17a\x02\x126`\x04a\x01\xDCV[a\x11ZV[a\x02\x1Fa\x01\xA4V[\x80a\x02)\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[\x90V[a\x02>\x81a\x022V[\x03a\x02EWV[_\x80\xFD[\x90P5\x90a\x02V\x82a\x025V[V[\x91\x90`@\x83\x82\x03\x12a\x02\x80W\x80a\x02ta\x02}\x92_\x86\x01a\x01\xCDV[\x93` \x01a\x02IV[\x90V[a\x01\xAEV[a\x02\x8E\x90a\x01\xB6V[\x90V[\x90a\x02\x9B\x90a\x02\x85V[_R` R`@_ \x90V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[T\x90V[_R` _ \x90V[a\x02\xD1\x81a\x02\xBBV[\x82\x10\x15a\x02\xEBWa\x02\xE3`\x01\x91a\x02\xBFV[\x91\x02\x01\x90_\x90V[a\x02\xA7V[\x1C\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x03\x0F\x90`\x08a\x03\x14\x93\x02a\x02\xF0V[a\x02\xF4V[\x90V[\x90a\x03\"\x91Ta\x02\xFFV[\x90V[a\x030\x90`\x0Ba\x02\x91V[a\x039\x81a\x02\xBBV[\x82\x10\x15a\x03VWa\x03S\x91a\x03M\x91a\x02\xC8V[\x90a\x03\x17V[\x90V[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x03n\x90a\x03ZV[\x90V[a\x03z\x90a\x03eV[\x90RV[\x91\x90a\x03\x91\x90_` \x85\x01\x94\x01\x90a\x03qV[V[4a\x03\xC4Wa\x03\xC0a\x03\xAFa\x03\xA96`\x04a\x02XV[\x90a\x03%V[a\x03\xB7a\x01\xA4V[\x91\x82\x91\x82a\x03~V[\x03\x90\xF3[a\x01\xAAV[_\x91\x03\x12a\x03\xD3WV[a\x01\xAEV[_\x1C\x90V[\x90V[a\x03\xECa\x03\xF1\x91a\x03\xD8V[a\x03\xDDV[\x90V[a\x03\xFE\x90Ta\x03\xE0V[\x90V[`\x01a\x04\x0E_\x82\x01a\x03\xF4V[\x91a\x04\x1B`\x01\x83\x01a\x03\xF4V[\x91a\x04(`\x02\x82\x01a\x03\xF4V[\x91a\x045`\x03\x83\x01a\x03\xF4V[\x91a\x04B`\x04\x82\x01a\x03\xF4V[\x91a\x04[`\x06a\x04T`\x05\x85\x01a\x03\xF4V[\x93\x01a\x03\xF4V[\x90V[a\x04g\x90a\x01\xB6V[\x90RV[\x94\x92\x90\x97\x96\x95\x93\x91`\xE0\x86\x01\x98_\x87\x01a\x04\x84\x91a\x04^V[` \x86\x01a\x04\x91\x91a\x04^V[`@\x85\x01a\x04\x9E\x91a\x04^V[``\x84\x01a\x04\xAB\x91a\x04^V[`\x80\x83\x01a\x04\xB8\x91a\x04^V[`\xA0\x82\x01a\x04\xC5\x91a\x04^V[`\xC0\x01a\x04\xD1\x91a\x04^V[V[4a\x05\nWa\x04\xE36`\x04a\x03\xC9V[a\x05\x06a\x04\xEEa\x04\x01V[\x93a\x04\xFD\x97\x95\x97\x93\x91\x93a\x01\xA4V[\x97\x88\x97\x88a\x04kV[\x03\x90\xF3[a\x01\xAAV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[\x90V[a\x05Ja\x05Ea\x05O\x92a\x03ZV[a\x053V[a\x03ZV[\x90V[a\x05[\x90a\x056V[\x90V[a\x05g\x90a\x05RV[\x90V[a\x05s\x90a\x05^V[\x90RV[\x91\x90a\x05\x8A\x90_` \x85\x01\x94\x01\x90a\x05jV[V[4a\x05\xBCWa\x05\x9C6`\x04a\x03\xC9V[a\x05\xB8a\x05\xA7a\x05\x0FV[a\x05\xAFa\x01\xA4V[\x91\x82\x91\x82a\x05wV[\x03\x90\xF3[a\x01\xAAV[a\x05\xCA\x81a\x03eV[\x03a\x05\xD1WV[_\x80\xFD[\x90P5\x90a\x05\xE2\x82a\x05\xC1V[V[\x90` \x82\x82\x03\x12a\x05\xFDWa\x05\xFA\x91_\x01a\x05\xD5V[\x90V[a\x01\xAEV[a\x06\x0B\x90a\x05RV[\x90V[\x90a\x06\x18\x90a\x06\x02V[_R` R`@_ \x90V[`\xFF\x16\x90V[a\x06:\x90`\x08a\x06?\x93\x02a\x02\xF0V[a\x06$V[\x90V[\x90a\x06M\x91Ta\x06*V[\x90V[a\x06f\x90a\x06a`\x0C\x91_\x92a\x06\x0EV[a\x06BV[\x90V[\x15\x15\x90V[a\x06w\x90a\x06iV[\x90RV[\x91\x90a\x06\x8E\x90_` \x85\x01\x94\x01\x90a\x06nV[V[4a\x06\xC0Wa\x06\xBCa\x06\xABa\x06\xA66`\x04a\x05\xE4V[a\x06PV[a\x06\xB3a\x01\xA4V[\x91\x82\x91\x82a\x06{V[\x03\x90\xF3[a\x01\xAAV[\x90` \x82\x82\x03\x12a\x06\xDEWa\x06\xDB\x91_\x01a\x02IV[\x90V[a\x01\xAEV[T\x90V[_R` _ \x90V[a\x06\xF9\x81a\x06\xE3V[\x82\x10\x15a\x07\x13Wa\x07\x0B`\x01\x91a\x06\xE7V[\x91\x02\x01\x90_\x90V[a\x02\xA7V[a\x07(\x90`\x08a\x07-\x93\x02a\x02\xF0V[a\x03\xDDV[\x90V[\x90a\x07;\x91Ta\x07\x18V[\x90V[`\na\x07I\x81a\x06\xE3V[\x82\x10\x15a\x07fWa\x07c\x91a\x07]\x91a\x06\xF0V[\x90a\x070V[\x90V[_\x80\xFD[\x91\x90a\x07}\x90_` \x85\x01\x94\x01\x90a\x04^V[V[4a\x07\xAFWa\x07\xABa\x07\x9Aa\x07\x956`\x04a\x06\xC5V[a\x07>V[a\x07\xA2a\x01\xA4V[\x91\x82\x91\x82a\x07jV[\x03\x90\xF3[a\x01\xAAV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x07\xD1\x90`\x08a\x07\xD6\x93\x02a\x02\xF0V[a\x07\xB4V[\x90V[\x90a\x07\xE4\x91Ta\x07\xC1V[\x90V[a\x07\xF4`\r`\x08\x90a\x07\xD9V[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x08\r\x90a\x07\xF7V[\x90RV[\x91\x90a\x08$\x90_` \x85\x01\x94\x01\x90a\x08\x04V[V[4a\x08VWa\x0866`\x04a\x03\xC9V[a\x08Ra\x08Aa\x07\xE7V[a\x08Ia\x01\xA4V[\x91\x82\x91\x82a\x08\x11V[\x03\x90\xF3[a\x01\xAAV[4a\x08\x89Wa\x08sa\x08n6`\x04a\x01\xDCV[a\x14\xC7V[a\x08{a\x01\xA4V[\x80a\x08\x85\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[\x90V[a\x08\xA1\x90`\x08a\x08\xA6\x93\x02a\x02\xF0V[a\x08\x8EV[\x90V[\x90a\x08\xB4\x91Ta\x08\x91V[\x90V[a\x08\xC3`\t_\x90a\x08\xA9V[\x90V[a\x08\xCF\x90a\x022V[\x90RV[\x91\x90a\x08\xE6\x90_` \x85\x01\x94\x01\x90a\x08\xC6V[V[4a\t\x18Wa\x08\xF86`\x04a\x03\xC9V[a\t\x14a\t\x03a\x08\xB7V[a\t\x0Ba\x01\xA4V[\x91\x82\x91\x82a\x08\xD3V[\x03\x90\xF3[a\x01\xAAV[4a\tKWa\t-6`\x04a\x03\xC9V[a\t5a\x1A\xA2V[a\t=a\x01\xA4V[\x80a\tG\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[4a\t~Wa\t`6`\x04a\x03\xC9V[a\tha!{V[a\tpa\x01\xA4V[\x80a\tz\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\t\xC9W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\t\xC4W` \x01\x92`\x01\x83\x02\x84\x01\x11a\t\xBFWV[a\t\x8BV[a\t\x87V[a\t\x83V[\x91``\x83\x83\x03\x12a\n\x1BWa\t\xE5\x82_\x85\x01a\x05\xD5V[\x92a\t\xF3\x83` \x83\x01a\x01\xCDV[\x92`@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\n\x16Wa\n\x12\x92\x01a\t\x8FV[\x90\x91V[a\x01\xB2V[a\x01\xAEV[4a\nRWa\n<a\n36`\x04a\t\xCEV[\x92\x91\x90\x91a#\x86V[a\nDa\x01\xA4V[\x80a\nN\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[4a\n\x85Wa\ng6`\x04a\x03\xC9V[a\noa$\xF5V[a\nwa\x01\xA4V[\x80a\n\x81\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[a\n\xB7\x90a\x05RV[\x90V[a\n\xC3\x90a\n\xAEV[\x90RV[\x91\x90a\n\xDA\x90_` \x85\x01\x94\x01\x90a\n\xBAV[V[4a\x0B\x0CWa\n\xEC6`\x04a\x03\xC9V[a\x0B\x08a\n\xF7a\n\x8AV[a\n\xFFa\x01\xA4V[\x91\x82\x91\x82a\n\xC7V[\x03\x90\xF3[a\x01\xAAV[4a\x0BAWa\x0B!6`\x04a\x03\xC9V[a\x0B=a\x0B,a%$V[a\x0B4a\x01\xA4V[\x91\x82\x91\x82a\x03~V[\x03\x90\xF3[a\x01\xAAV[_\x80\xFD[\x90\x81``\x91\x03\x12a\x0BXW\x90V[a\x0BFV[\x90``\x82\x82\x03\x12a\x0BvWa\x0Bs\x91_\x01a\x0BJV[\x90V[a\x01\xAEV[4a\x0B\xA9Wa\x0B\x93a\x0B\x8E6`\x04a\x0B]V[a(\xD0V[a\x0B\x9Ba\x01\xA4V[\x80a\x0B\xA5\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[T\x90V[_R` _ \x90V[a\x0B\xC4\x81a\x0B\xAEV[\x82\x10\x15a\x0B\xDEWa\x0B\xD6`\x03\x91a\x0B\xB2V[\x91\x02\x01\x90_\x90V[a\x02\xA7V[`\x08\x90a\x0B\xEF\x82a\x0B\xAEV[\x81\x10\x15a\x0C'Wa\x0B\xFF\x91a\x0B\xBBV[Pa\x0C\x0B_\x82\x01a\x03\xF4V[\x91a\x0C$`\x02a\x0C\x1D`\x01\x85\x01a\x03\xF4V[\x93\x01a\x03\xF4V[\x90V[_\x80\xFD[`@\x90a\x0CTa\x0C[\x94\x96\x95\x93\x96a\x0CJ``\x84\x01\x98_\x85\x01\x90a\x04^V[` \x83\x01\x90a\x04^V[\x01\x90a\x04^V[V[4a\x0C\x90Wa\x0C\x8Ca\x0Cxa\x0Cs6`\x04a\x06\xC5V[a\x0B\xE3V[a\x0C\x83\x93\x91\x93a\x01\xA4V[\x93\x84\x93\x84a\x0C+V[\x03\x90\xF3[a\x01\xAAV[4a\x0C\xC3Wa\x0C\xADa\x0C\xA86`\x04a\x01\xDCV[a*\x11V[a\x0C\xB5a\x01\xA4V[\x80a\x0C\xBF\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[\x90`\xA0\x82\x82\x03\x12a\r\x16Wa\x0C\xDF\x81_\x84\x01a\x0BJV[\x92``\x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\r\x11Wa\r\x03\x83a\r\x0E\x92\x86\x01a\t\x8FV[\x93\x90\x94`\x80\x01a\x05\xD5V[\x90V[a\x01\xB2V[a\x01\xAEV[4a\rMWa\r7a\r.6`\x04a\x0C\xC8V[\x92\x91\x90\x91a.\xADV[a\r?a\x01\xA4V[\x80a\rI\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[a\r\x7F\x90a\x05RV[\x90V[a\r\x8B\x90a\rvV[\x90RV[\x91\x90a\r\xA2\x90_` \x85\x01\x94\x01\x90a\r\x82V[V[4a\r\xD4Wa\r\xB46`\x04a\x03\xC9V[a\r\xD0a\r\xBFa\rRV[a\r\xC7a\x01\xA4V[\x91\x82\x91\x82a\r\x8FV[\x03\x90\xF3[a\x01\xAAV[a\r\xE2\x81a\x07\xF7V[\x03a\r\xE9WV[_\x80\xFD[\x90P5\x90a\r\xFA\x82a\r\xD9V[V[\x90` \x82\x82\x03\x12a\x0E\x15Wa\x0E\x12\x91_\x01a\r\xEDV[\x90V[a\x01\xAEV[4a\x0EHWa\x0E2a\x0E-6`\x04a\r\xFCV[a2}V[a\x0E:a\x01\xA4V[\x80a\x0ED\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[a\x0EY`\r_\x90a\x07\xD9V[\x90V[4a\x0E\x8CWa\x0El6`\x04a\x03\xC9V[a\x0E\x88a\x0Ewa\x0EMV[a\x0E\x7Fa\x01\xA4V[\x91\x82\x91\x82a\x08\x11V[\x03\x90\xF3[a\x01\xAAV[4a\x0E\xBFWa\x0E\xA9a\x0E\xA46`\x04a\x01\xDCV[a3\x14V[a\x0E\xB1a\x01\xA4V[\x80a\x0E\xBB\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[4a\x0E\xF2Wa\x0E\xDCa\x0E\xD76`\x04a\x05\xE4V[a3\x84V[a\x0E\xE4a\x01\xA4V[\x80a\x0E\xEE\x81a\x01\xFAV[\x03\x90\xF3[a\x01\xAAV[_\x80\xFD[a\x0F\x0C\x90a\x0F\x07a3\x8FV[a\x10\x9FV[V[\x90V[a\x0F%a\x0F a\x0F*\x92a\x0F\x0EV[a\x053V[a\x022V[\x90V[`\x01a\x0F9\x91\x01a\x022V[\x90V[` \x91\x81R\x01\x90V[_\x7Ftee program already exists\0\0\0\0\0\0\x91\x01RV[a\x0Fy`\x1A` \x92a\x0F<V[a\x0F\x82\x81a\x0FEV[\x01\x90V[a\x0F\x9B\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x0FlV[\x90V[\x15a\x0F\xA5WV[a\x0F\xADa\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x0F\xC3`\x04\x82\x01a\x0F\x86V[\x03\x90\xFD[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_R` _ \x90V[T\x90V[a\x0F\xF4\x81a\x0F\xE7V[\x82\x10\x15a\x10\x0EWa\x10\x06`\x01\x91a\x0F\xDEV[\x91\x02\x01\x90_\x90V[a\x02\xA7V[\x1B\x90V[\x91\x90`\x08a\x102\x91\x02\x91a\x10,_\x19\x84a\x10\x13V[\x92a\x10\x13V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x10E\x90a\x03\xD8V[\x90V[\x91\x90a\x10^a\x10Ya\x10f\x93a\x02\x85V[a\x10<V[\x90\x83Ta\x10\x17V[\x90UV[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a\x10\x9AW\x82a\x10\x92\x91`\x01a\x10\x98\x95\x01\x81Ua\x0F\xEBV[\x90a\x10HV[V[a\x0F\xCAV[a\x10\xA8_a\x0F\x11V[[\x80a\x10\xC5a\x10\xBFa\x10\xBA`\na\x06\xE3V[a\x022V[\x91a\x022V[\x10\x15a\x11\nWa\x11\x05\x90a\x11\0a\x10\xE7a\x10\xE1`\n\x84\x90a\x06\xF0V[\x90a\x070V[a\x10\xF9a\x10\xF3\x86a\x01\xB6V[\x91a\x01\xB6V[\x14\x15a\x0F\x9EV[a\x0F-V[a\x10\xA9V[Pa\x11\x1Fa\x11\x18`\na\x0F\xC7V[\x82\x90a\x10jV[a\x11U\x7F\x9Azdi\xC2\\\xF0\x17\x89\x06\x07i^J\x14\x9C\xC7q\xF2\x94\xFD\x87\x1E \x80\xD2L\xD1\t\x03:\xB6\x91a\x11La\x01\xA4V[\x91\x82\x91\x82a\x07jV[\x03\x90\xA1V[a\x11c\x90a\x0E\xFBV[V[a\x11v\x90a\x11qa3\x8FV[a\x13\xDAV[V[` \x7Fassertion is pending\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7Fcannot remove tee program while _\x82\x01R\x01RV[a\x11\xD2`4`@\x92a\x0F<V[a\x11\xDB\x81a\x11xV[\x01\x90V[a\x11\xF4\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x11\xC5V[\x90V[\x15a\x11\xFEWV[a\x12\x06a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x12\x1C`\x04\x82\x01a\x11\xDFV[\x03\x90\xFD[_\x1B\x90V[\x90a\x121`\xFF\x91a\x12 V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x12D\x90a\x06iV[\x90V[\x90V[\x90a\x12_a\x12Za\x12f\x92a\x12;V[a\x12GV[\x82Ta\x12%V[\x90UV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x12\x8Da\x12\x93\x91\x93\x92\x93a\x022V[\x92a\x022V[\x91a\x12\x9F\x83\x82\x02a\x022V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a\x12\xAEWV[a\x12jV[`\x01\x90\x81\x80\x03\x01\x04\x90V[a\x12\xD2a\x12\xCDa\x12\xD7\x92a\x022V[a\x053V[a\x022V[\x90V[\x90V[\x91\x90a\x12\xF3a\x12\xEEa\x12\xFB\x93a\x12\xBEV[a\x12\xDAV[\x90\x83Ta\x10\x17V[\x90UV[_\x90V[a\x13\x15\x91a\x13\x0Fa\x12\xFFV[\x91a\x12\xDDV[V[[\x81\x81\x10a\x13#WPPV[\x80a\x130_`\x01\x93a\x13\x03V[\x01a\x13\x18V[\x90\x91\x82\x81\x10a\x13EW[PPPV[a\x13ca\x13]a\x13Wa\x13n\x95a\x12\xB3V[\x92a\x12\xB3V[\x92a\x02\xBFV[\x91\x82\x01\x91\x01\x90a\x13\x17V[_\x80\x80a\x13@V[\x90h\x01\0\0\0\0\0\0\0\0\x81\x11a\x13\x9FW\x81a\x13\x94a\x13\x9D\x93a\x02\xBBV[\x90\x82\x81Ua\x136V[V[a\x0F\xCAV[_a\x13\xAE\x91a\x13vV[V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[\x90_\x03a\x13\xD5Wa\x13\xD3\x90a\x13\xA4V[V[a\x13\xB0V[a\x13\xFFa\x13\xE7`\x08a\x0B\xAEV[a\x13\xF9a\x13\xF3_a\x0F\x11V[\x91a\x022V[\x14a\x11\xF7V[a\x14\x08_a\x0F\x11V[[\x80a\x14/a\x14)a\x14$a\x14\x1F`\x0B\x87\x90a\x02\x91V[a\x02\xBBV[a\x022V[\x91a\x022V[\x10\x15a\x14vWa\x14q\x90a\x14l_a\x14g`\x0Ca\x14aa\x14[a\x14T`\x0B\x8A\x90a\x02\x91V[\x87\x90a\x02\xC8V[\x90a\x03\x17V[\x90a\x06\x0EV[a\x12JV[a\x0F-V[a\x14\tV[Pa\x14\x8C_a\x14\x87`\x0B\x84\x90a\x02\x91V[a\x13\xC3V[a\x14\xC2\x7F&!\xC6\x1D3\x15\xF2\xA3\xD2k\"\xD7F\xBA!\xA9m$\x9FQ\xAD\xA3#\xF7\"l\xCE_\xE5\xFC=d\x91a\x14\xB9a\x01\xA4V[\x91\x82\x91\x82a\x07jV[\x03\x90\xA1V[a\x14\xD0\x90a\x11eV[V[\x90V[a\x14\xE9a\x14\xE4a\x14\xEE\x92a\x14\xD2V[a\x053V[a\x022V[\x90V[` \x7Ftoo many assertions\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7Fcannot close challenge window - _\x82\x01R\x01RV[a\x15K`3`@\x92a\x0F<V[a\x15T\x81a\x14\xF1V[\x01\x90V[a\x15m\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x15>V[\x90V[\x15a\x15wWV[a\x15\x7Fa\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x15\x95`\x04\x82\x01a\x15XV[\x03\x90\xFD[a\x15\xADa\x15\xA8a\x15\xB2\x92a\x0F\x0EV[a\x053V[a\x03ZV[\x90V[a\x15\xBE\x90a\x15\x99V[\x90V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[\x90a\x15\xD9\x90a\x15\xC5V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x15\xF3W`@RV[a\x0F\xCAV[`\xE0\x1B\x90V[\x90PQ\x90a\x16\x0B\x82a\r\xD9V[V[\x90` \x82\x82\x03\x12a\x16&Wa\x16#\x91_\x01a\x15\xFEV[\x90V[a\x01\xAEV[a\x163a\x01\xA4V[=_\x82>=\x90\xFD[a\x16Oa\x16Ja\x16T\x92a\x022V[a\x053V[a\x07\xF7V[\x90V[a\x16ca\x16h\x91a\x03\xD8V[a\x07\xB4V[\x90V[a\x16u\x90Ta\x16WV[\x90V[` \x7Finsufficient time has passed\0\0\0\0\x91\x7Fcannot close challenge window - _\x82\x01R\x01RV[a\x16\xD2`<`@\x92a\x0F<V[a\x16\xDB\x81a\x16xV[\x01\x90V[a\x16\xF4\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x16\xC5V[\x90V[\x15a\x16\xFEWV[a\x17\x06a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x17\x1C`\x04\x82\x01a\x16\xDFV[\x03\x90\xFD[\x90a\x17,_\x19\x91a\x12 V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x17Ka\x17Fa\x17R\x92a\x02\x85V[a\x10<V[\x82Ta\x17 V[\x90UV[_\x91\x03\x12a\x17`WV[a\x01\xAEV[\x91` a\x17\x86\x92\x94\x93a\x17\x7F`@\x82\x01\x96_\x83\x01\x90a\x04^V[\x01\x90a\x04^V[V[a\x17\x93\x90`\x03a\x12~V[\x90V[_\x90V[a\x17\xAC\x91a\x17\xA6a\x17\x96V[\x91a\x10HV[V[_`\x02a\x17\xD4\x92a\x17\xC1\x83\x80\x83\x01a\x17\x9AV[a\x17\xCE\x83`\x01\x83\x01a\x17\x9AV[\x01a\x17\x9AV[V[\x90_\x03a\x17\xE8Wa\x17\xE6\x90a\x17\xAEV[V[a\x13\xB0V[[\x81\x81\x10a\x17\xF9WPPV[\x80a\x18\x06_`\x03\x93a\x17\xD6V[\x01a\x17\xEEV[\x90\x91\x82\x81\x10a\x18\x1BW[PPPV[a\x189a\x183a\x18-a\x18D\x95a\x17\x88V[\x92a\x17\x88V[\x92a\x0B\xB2V[\x91\x82\x01\x91\x01\x90a\x17\xEDV[_\x80\x80a\x18\x16V[\x90h\x01\0\0\0\0\0\0\0\0\x81\x11a\x18uW\x81a\x18ja\x18s\x93a\x0B\xAEV[\x90\x82\x81Ua\x18\x0CV[V[a\x0F\xCAV[_a\x18\x84\x91a\x18LV[V[\x90_\x03a\x18\x98Wa\x18\x96\x90a\x18zV[V[a\x13\xB0V[\x90PQ\x90a\x18\xAA\x82a\x025V[V[\x90` \x82\x82\x03\x12a\x18\xC5Wa\x18\xC2\x91_\x01a\x18\x9DV[\x90V[a\x01\xAEV[a\x18\xD9a\x18\xDF\x91\x93\x92\x93a\x022V[\x92a\x022V[\x82\x03\x91\x82\x11a\x18\xEAWV[a\x12jV[\x90PQ\x90a\x18\xFC\x82a\x01\xB9V[V[\x90` \x82\x82\x03\x12a\x19\x17Wa\x19\x14\x91_\x01a\x18\xEFV[\x90V[a\x01\xAEV[a\x19%\x90a\x01\xB6V[\x90RV[\x90`\xC0a\x19\xD6`\x06a\x19\xDE\x94a\x19Ma\x19D_\x83\x01Ta\x03\xE0V[_\x87\x01\x90a\x19\x1CV[a\x19ga\x19]`\x01\x83\x01Ta\x03\xE0V[` \x87\x01\x90a\x19\x1CV[a\x19\x81a\x19w`\x02\x83\x01Ta\x03\xE0V[`@\x87\x01\x90a\x19\x1CV[a\x19\x9Ba\x19\x91`\x03\x83\x01Ta\x03\xE0V[``\x87\x01\x90a\x19\x1CV[a\x19\xB5a\x19\xAB`\x04\x83\x01Ta\x03\xE0V[`\x80\x87\x01\x90a\x19\x1CV[a\x19\xCFa\x19\xC5`\x05\x83\x01Ta\x03\xE0V[`\xA0\x87\x01\x90a\x19\x1CV[\x01Ta\x03\xE0V[\x91\x01\x90a\x19\x1CV[V[\x91\x90a\x19\xF3\x90_`\xE0\x85\x01\x94\x01\x90a\x19)V[V[`@\x1C\x90V[a\x1A\x07a\x1A\x0C\x91a\x19\xF5V[a\x07\xB4V[\x90V[a\x1A\x19\x90Ta\x19\xFBV[\x90V[a\x1A(a\x1A.\x91a\x07\xF7V[\x91a\x07\xF7V[\x01\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x1AAWV[a\x12jV[\x90a\x1AYg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x12 V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1Awa\x1Ara\x1A|\x92a\x07\xF7V[a\x053V[a\x07\xF7V[\x90V[\x90V[\x90a\x1A\x97a\x1A\x92a\x1A\x9E\x92a\x1AcV[a\x1A\x7FV[\x82Ta\x1AFV[\x90UV[a\x1A\xC9a\x1A\xAF`\x08a\x0B\xAEV[a\x1A\xC2a\x1A\xBC`\x01a\x14\xD5V[\x91a\x022V[\x11\x15a\x15pV[a\x1A\xF2\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x05^V[a\x1B\x0Ca\x1B\x06a\x1B\x01_a\x15\xB5V[a\x03eV[\x91a\x03eV[\x14_\x14a\x1FqWa\x1BAa\x1B\x1FBa\x16;V[[a\x1B;a\x1B5a\x1B0`\ra\x16kV[a\x07\xF7V[\x91a\x07\xF7V[\x11a\x16\xF7V[a\x1BK`\x08a\x0B\xAEV[a\x1B]a\x1BW_a\x0F\x11V[\x91a\x022V[\x11a\x1E,W[a\x1B\x8C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\rvV[a\x1B\xD5c\xD5q\x9D\xC2` a\x1B\xBF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\rvV[c\xEC\xA0g\xAD\x90a\x1B\xCDa\x01\xA4V[\x94\x85\x92a\x15\xF8V[\x82R\x81\x80a\x1B\xE5`\x04\x82\x01a\x01\xFAV[\x03\x91Z\xFA\x92\x83\x15a\x1E'Wa\x1C*a\x1C\x15a\x1C5\x95` \x95_\x91a\x1D\xFAW[Pa\x1C\x0F`\x01a\x14\xD5V[\x90a\x18\xCAV[\x92a\x1C\x1Ea\x01\xA4V[\x95\x86\x94\x85\x93\x84\x93a\x15\xF8V[\x83R`\x04\x83\x01a\x08\xD3V[\x03\x91Z\xFA\x80\x15a\x1D\xF5Wa\x1CU\x91_\x91a\x1D\xC7W[P`\x04`\x01\x01a\x176V[a\x1C~\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x05^V[a\x1C\x98a\x1C\x92a\x1C\x8D_a\x15\xB5V[a\x03eV[\x91a\x03eV[\x14_\x14a\x1D%Wa\x1C\xC2a\x1C\xB6Ca\x1C\xB0`\x01a\x14\xD5V[\x90a\x18\xCAV[@[`\x06`\x01\x01a\x176V[`\x01a\x1C\xFA\x7F\x91\t+\xCFU\t!\xE3\x81\xE8\x1F\x06i3 SK\x14J~V\x1C_\xC0\x8F\x19@\xD5\x08\xA8\\\xDC\x91a\x1C\xF1a\x01\xA4V[\x91\x82\x91\x82a\x19\xE0V[\x03\x90\xA1a\x1D#a\x1D\x1Ca\x1D\x0CBa\x16;V[a\x1D\x16`\ra\x1A\x0FV[\x90a\x1A\x1CV[`\ra\x1A\x82V[V[a\x1Di` a\x1DS\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x05^V[c\t\xBDZ`\x90a\x1Daa\x01\xA4V[\x93\x84\x92a\x15\xF8V[\x82R\x81\x80a\x1Dy`\x04\x82\x01a\x01\xFAV[\x03\x91Z\xFA\x80\x15a\x1D\xC2Wa\x1C\xC2\x91_\x91a\x1D\x94W[Pa\x1C\xB8V[a\x1D\xB5\x91P` =\x81\x11a\x1D\xBBW[a\x1D\xAD\x81\x83a\x15\xCFV[\x81\x01\x90a\x18\xFEV[_a\x1D\x8EV[P=a\x1D\xA3V[a\x16+V[a\x1D\xE8\x91P` =\x81\x11a\x1D\xEEW[a\x1D\xE0\x81\x83a\x15\xCFV[\x81\x01\x90a\x18\xFEV[_a\x1CJV[P=a\x1D\xD6V[a\x16+V[a\x1E\x1A\x91P\x86=\x81\x11a\x1E W[a\x1E\x12\x81\x83a\x15\xCFV[\x81\x01\x90a\x18\xACV[_a\x1C\x04V[P=a\x1E\x08V[a\x16+V[a\x1EOa\x1EF_a\x1E?`\x08\x82\x90a\x0B\xBBV[P\x01a\x03\xF4V[`\x01\x80\x01a\x176V[a\x1Eta\x1Ej`\x02a\x1Ec`\x08_\x90a\x0B\xBBV[P\x01a\x03\xF4V[`\x03`\x01\x01a\x176V[a\x1E\x8Ea\x1E\x84`\x06`\x01\x01a\x03\xF4V[`\x05`\x01\x01a\x176V[a\x1E\xB7\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\n\xAEV[c\xDA\xEA\xB4\x12a\x1E\xD3_a\x1E\xCC`\x08\x82\x90a\x0B\xBBV[P\x01a\x03\xF4V[a\x1E\xEB`\x01a\x1E\xE4`\x08_\x90a\x0B\xBBV[P\x01a\x03\xF4V[\x92\x80;\x15a\x1FlWa\x1F\x10_\x80\x94a\x1F\x1Ba\x1F\x04a\x01\xA4V[\x97\x88\x96\x87\x95\x86\x94a\x15\xF8V[\x84R`\x04\x84\x01a\x17eV[\x03\x92Z\xF1\x80\x15a\x1FgWa\x1F;W[Pa\x1F6_`\x08a\x18\x86V[a\x1BcV[a\x1FZ\x90_=\x81\x11a\x1F`W[a\x1FR\x81\x83a\x15\xCFV[\x81\x01\x90a\x17VV[_a\x1F*V[P=a\x1FHV[a\x16+V[a\x15\xC1V[a\x1F\xB5` a\x1F\x9F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x05^V[c\xB8\x07w\xEA\x90a\x1F\xADa\x01\xA4V[\x93\x84\x92a\x15\xF8V[\x82R\x81\x80a\x1F\xC5`\x04\x82\x01a\x01\xFAV[\x03\x91Z\xFA\x80\x15a \x0EWa\x1BA\x91_\x91a\x1F\xE0W[Pa\x1B V[a \x01\x91P` =\x81\x11a \x07W[a\x1F\xF9\x81\x83a\x15\xCFV[\x81\x01\x90a\x16\rV[_a\x1F\xDAV[P=a\x1F\xEFV[a\x16+V[a \x1Ba3\x8FV[a #a \xE0V[V[`\x01\x90\x81\x80\x03\x01\x04\x90V[[\x81\x81\x10a <WPPV[\x80a I_`\x01\x93a\x17\x9AV[\x01a 1V[\x90\x91\x82\x81\x10a ^W[PPPV[a |a va pa \x87\x95a %V[\x92a %V[\x92a\x06\xE7V[\x91\x82\x01\x91\x01\x90a 0V[_\x80\x80a YV[\x90h\x01\0\0\0\0\0\0\0\0\x81\x11a \xB8W\x81a \xADa \xB6\x93a\x06\xE3V[\x90\x82\x81Ua OV[V[a\x0F\xCAV[_a \xC7\x91a \x8FV[V[\x90_\x03a \xDBWa \xD9\x90a \xBDV[V[a\x13\xB0V[a \xE9_a\x0F\x11V[[\x80a!\x06a!\0a \xFB`\na\x06\xE3V[a\x022V[\x91a\x022V[\x10\x15a!7Wa!2\x90a!-a!(a!\"`\n\x84\x90a\x06\xF0V[\x90a\x070V[a\x14\xC7V[a\x0F-V[a \xEAV[Pa!C_`\na \xC9V[\x7F\xEC\xA6.\0t\xA1:\x90\xD6\0\xF0\x03\xB7\xCB\x8D[\xD5\x01\0\0\x8D?9\x15\xF2UO?\x85R\xC5\xCCa!la\x01\xA4V[\x80a!v\x81a\x01\xFAV[\x03\x90\xA1V[a!\x83a \x13V[V[P\x90V[_\x7Ftodo: validate zk zkProof\0\0\0\0\0\0\0\x91\x01RV[a!\xBD`\x19` \x92a\x0F<V[a!\xC6\x81a!\x89V[\x01\x90V[a!\xDF\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra!\xB0V[\x90V[\x15a!\xE9WV[a!\xF1a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\"\x07`\x04\x82\x01a!\xCAV[\x03\x90\xFD[a\"\x17a\"\x1C\x91a\x03\xD8V[a\x06$V[\x90V[a\")\x90Ta\"\x0BV[\x90V[_\x7Fkey already added\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\"``\x11` \x92a\x0F<V[a\"i\x81a\",V[\x01\x90V[a\"\x82\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\"SV[\x90V[\x15a\"\x8CWV[a\"\x94a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\"\xAA`\x04\x82\x01a\"mV[\x03\x90\xFD[a\"\xB7\x90a\x022V[_\x81\x14a\"\xC5W`\x01\x90\x03\x90V[a\x12jV[\x90V[_R` _ \x90V[T\x90V[a\"\xE3\x81a\"\xD6V[\x82\x10\x15a\"\xFDWa\"\xF5`\x01\x91a\"\xCDV[\x91\x02\x01\x90_\x90V[a\x02\xA7V[\x91\x90`\x08a#\"\x91\x02\x91a#\x1C`\x01\x80`\xA0\x1B\x03\x84a\x10\x13V[\x92a\x10\x13V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x91\x90a#Ea#@a#M\x93a\x06\x02V[a#,V[\x90\x83Ta#\x02V[\x90UV[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a#\x81W\x82a#y\x91`\x01a#\x7F\x95\x01\x81Ua\"\xDAV[\x90a#/V[V[a\x0F\xCAV[\x92a#\x95\x90a#\xAE\x92\x93a!\x85V[a#\xA8a#\xA2`\x01a\x14\xD5V[\x91a\x022V[\x14a!\xE2V[a#\xD3a#\xCEa#\xC8a#\xC3`\x0C\x86\x90a\x06\x0EV[a\"\x1FV[\x15a\x06iV[a\"\x85V[a#\xE7a#\xE2`\x0B\x83\x90a\x02\x91V[a\x02\xBBV[a#\xF9a#\xF3_a\x0F\x11V[\x91a\x022V[\x14a$3W[\x90a$,a$'a$1\x93a$ `\x01a$\x1B`\x0C\x87\x90a\x06\x0EV[a\x12JV[`\x0Ba\x02\x91V[a\"\xCAV[a#QV[V[_\x91a$?`\na\x06\xE3V[[\x80a$Sa$M_a\x0F\x11V[\x91a\x022V[\x11\x15a$\xC4Wa$\x81a${`\na$u\x84a$o`\x01a\x14\xD5V[\x90a\x18\xCAV[\x90a\x06\xF0V[\x90a\x070V[a$\x93a$\x8D\x85a\x01\xB6V[\x91a\x01\xB6V[\x14a$\xA6Wa$\xA1\x90a\"\xAEV[a$@V[P\x90\x91Pa$\xB6`\x01[\x15a\x06iV[a$\xC0W\x90a#\xFFV[PPV[P\x90\x91a$\xB6\x90a$\xB0V[a$\xD8a3\x8FV[a$\xE0a$\xE2V[V[a$\xF3a$\xEE_a\x15\xB5V[a4\x18V[V[a$\xFDa$\xD0V[V[_\x90V[a%\x0Fa%\x14\x91a\x03\xD8V[a\x02\xF4V[\x90V[a%!\x90Ta%\x03V[\x90V[a%,a$\xFFV[Pa%6_a%\x17V[\x90V[a%J\x90a%Ea3\x8FV[a'\x98V[V[_\x7Fchallenge does not exist\0\0\0\0\0\0\0\0\x91\x01RV[a%\x80`\x18` \x92a\x0F<V[a%\x89\x81a%LV[\x01\x90V[a%\xA2\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra%sV[\x90V[\x15a%\xACWV[a%\xB4a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a%\xCA`\x04\x82\x01a%\x8DV[\x03\x90\xFD[\x90V[\x90V[_R` _ \x90V[T\x90V[a%\xEA\x81a%\xDDV[\x82\x10\x15a&\x04Wa%\xFC`\x03\x91a%\xD4V[\x91\x02\x01\x90_\x90V[a\x02\xA7V[5a&\x13\x81a\x01\xB9V[\x90V[\x90a&Z`@`\x02a&`\x94a&9_\x82\x01a&3_\x88\x01a&\tV[\x90a\x176V[a&R`\x01\x82\x01a&L` \x88\x01a&\tV[\x90a\x176V[\x01\x92\x01a&\tV[\x90a\x176V[V[\x91\x90a&sWa&q\x91a&\x16V[V[a\x13\xB0V[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a&\xA8W\x82a&\xA0\x91`\x01a&\xA6\x95\x01\x81Ua%\xE1V[\x90a&bV[V[a\x0F\xCAV[a&\xC1a&\xBCa&\xC6\x92a\x0F\x0EV[a\x053V[a\x07\xF7V[\x90V[Pa&\xD8\x90` \x81\x01\x90a\x01\xCDV[\x90V[\x90`@a' a'(\x93a&\xFDa&\xF4_\x83\x01\x83a&\xC9V[_\x86\x01\x90a\x19\x1CV[a'\x17a'\r` \x83\x01\x83a&\xC9V[` \x86\x01\x90a\x19\x1CV[\x82\x81\x01\x90a&\xC9V[\x91\x01\x90a\x19\x1CV[V[\x91\x90a'=\x90_``\x85\x01\x94\x01\x90a&\xDBV[V[_\x7Fassertion not found\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a's`\x13` \x92a\x0F<V[a'|\x81a'?V[\x01\x90V[a'\x95\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra'fV[\x90V[a'\xBEa'\xA5`\x08a\x0B\xAEV[a'\xB8a'\xB2`\x01a\x14\xD5V[\x91a\x022V[\x11a%\xA5V[a'\xC7\x81a4\xA2V[\x90a'\xD1_a\x0F\x11V[[\x80a'\xEEa'\xE8a'\xE3`\x08a\x0B\xAEV[a\x022V[\x91a\x022V[\x10\x15a(\xAEW\x82a(#a(\x1Da(\x18a(\x13a(\r`\x08\x87\x90a\x0B\xBBV[Pa%\xCEV[a5\rV[a\x01\xB6V[\x91a\x01\xB6V[\x14a(6Wa(1\x90a\x0F-V[a'\xD2V[P\x90Pa(D_`\x08a\x18\x86V[a(Xa(Q`\x08a%\xD1V[\x82\x90a&xV[a(ka(d_a&\xADV[`\ra\x1A\x82V[a(sa\x1A\xA2V[a(\xA9\x7F\xE4.\xAF\x077\xE2G\x8A_Z\xED:\x06\x10\xAE{\t\xA2|\xBA\xC9\xADj\\\xC4\xD6\x8Fx\xAF\xD1B[\x91a(\xA0a\x01\xA4V[\x91\x82\x91\x82a'*V[\x03\x90\xA1V[a(\xB6a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a(\xCC`\x04\x82\x01a'\x80V[\x03\x90\xFD[a(\xD9\x90a%9V[V[a(\xEC\x90a(\xE7a3\x8FV[a)\x96V[V[` \x7Fassertions are pending\0\0\0\0\0\0\0\0\0\0\x91\x7Fcannot update config hash while _\x82\x01R\x01RV[a)H`6`@\x92a\x0F<V[a)Q\x81a(\xEEV[\x01\x90V[a)j\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra);V[\x90V[\x15a)tWV[a)|a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a)\x92`\x04\x82\x01a)UV[\x03\x90\xFD[a)\xBBa)\xA3`\x08a\x0B\xAEV[a)\xB5a)\xAF_a\x0F\x11V[\x91a\x022V[\x14a)mV[a)\xC9\x81`\x02`\x01\x01a\x176V[a)\xD6`\x03`\x01\x01a\x03\xF4V[\x7F\xB9\xEB \xB3/\xAC\x96X\x84\xCBX2a\x02%|\xAE`E\x04\xF0\xA3l\xD1\0\x8A2\x84Z\xD5\xC2\x9B\x91a*\x0Ca*\x03a\x01\xA4V[\x92\x83\x92\x83a\x17eV[\x03\x90\xA1V[a*\x1A\x90a(\xDBV[V[\x90V[a*3a*.a*8\x92a*\x1CV[a\x053V[a\x022V[\x90V[_\x7Finvalid signature length\0\0\0\0\0\0\0\0\x91\x01RV[a*o`\x18` \x92a\x0F<V[a*x\x81a*;V[\x01\x90V[a*\x91\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra*bV[\x90V[\x15a*\x9BWV[a*\xA3a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a*\xB9`\x04\x82\x01a*|V[\x03\x90\xFD[\x90V[\x90V[a*\xCFa*\xD4\x91a\x01\xB6V[a*\xC0V[\x90RV[` \x81a*\xEAa*\xF2\x93\x83\x96\x95a*\xC3V[\x01\x80\x92a*\xC3V[\x01\x90V[` \x01\x90V[Q\x90V[_\x80\xFD[\x90a+\x17a+\x10a\x01\xA4V[\x92\x83a\x15\xCFV[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a+7Wa+3` \x91a\x15\xC5V[\x01\x90V[a\x0F\xCAV[\x90\x82_\x93\x92\x827\x01RV[\x90\x92\x91\x92a+\\a+W\x82a+\x19V[a+\x04V[\x93\x81\x85R` \x85\x01\x90\x82\x84\x01\x11a+xWa+v\x92a+<V[V[a+\0V[a+\x88\x916\x91a+GV[\x90V[_\x7Finvalid tee signature\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a+\xBF`\x15` \x92a\x0F<V[a+\xC8\x81a+\x8BV[\x01\x90V[a+\xE1\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra+\xB2V[\x90V[\x15a+\xEBWV[a+\xF3a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a,\t`\x04\x82\x01a+\xCCV[\x03\x90\xFD[_\x7Fappchain block hash unchanged\0\0\0\x91\x01RV[a,A`\x1D` \x92a\x0F<V[a,J\x81a,\rV[\x01\x90V[a,c\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra,4V[\x90V[\x15a,mWV[a,ua\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a,\x8B`\x04\x82\x01a,NV[\x03\x90\xFD[_\x7Fassertion already exists\0\0\0\0\0\0\0\0\x91\x01RV[a,\xC3`\x18` \x92a\x0F<V[a,\xCC\x81a,\x8FV[\x01\x90V[a,\xE5\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra,\xB6V[\x90V[\x15a,\xEFWV[a,\xF7a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a-\r`\x04\x82\x01a,\xD0V[\x03\x90\xFD[\x90V[a-(a-#a--\x92a-\x11V[a\x053V[a\x022V[\x90V[a-<a-A\x91a\x03\xD8V[a\x08\x8EV[\x90V[a-N\x90Ta-0V[\x90V[a-`a-f\x91\x93\x92\x93a\x022V[\x92a\x022V[\x82\x01\x80\x92\x11a-qWV[a\x12jV[\x90a-\x8Ba-\x86a-\x92\x92a\x12\xBEV[a\x12\xDAV[\x82Ta\x17 V[\x90UV[a-\x9F\x90a\x056V[\x90V[a-\xAB\x90a-\x96V[\x90V[a-\xB7\x90a\x05RV[\x90V[a-\xC3\x90a\x05RV[\x90V[\x90P\x90V[a-\xD6_\x80\x92a-\xC6V[\x01\x90V[a-\xE3\x90a-\xCBV[\x90V[\x90a-\xF8a-\xF3\x83a+\x19V[a+\x04V[\x91\x82RV[``\x90V[=_\x14a.\x1DWa.\x12=a-\xE6V[\x90=_` \x84\x01>[V[a.%a-\xFDV[\x90a.\x1BV[_\x7Fpayment failed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a._`\x0E` \x92a\x0F<V[a.h\x81a.+V[\x01\x90V[a.\x81\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra.RV[\x90V[\x15a.\x8BWV[a.\x93a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a.\xA9`\x04\x82\x01a.lV[\x03\x90\xFD[\x92\x90\x93\x91a/]a/Xa/b\x92a.\xE2a.\xC9\x89\x83\x90a!\x85V[a.\xDCa.\xD6`Aa*\x1FV[\x91a\x022V[\x14a*\x94V[a/Ra.\xEE\x88a4\xA2V[\x98a/La/\x04a.\xFF`\x01a*\xBDV[a5\xDAV[a//\x8C\x91a/ a/\x14a\x01\xA4V[\x93\x84\x92` \x84\x01a*\xD8V[` \x82\x01\x81\x03\x82R\x03\x82a\x15\xCFV[a/Aa/;\x82a*\xFCV[\x91a*\xF6V[ \x93`\x0C\x94\x92a+}V[\x90a6yV[\x90a\x06\x0EV[a\"\x1FV[a+\xE4V[a/\x94a/p_\x85\x01a&\tV[a/\x8Da/\x87a/\x82`\x01\x80\x01a\x03\xF4V[a\x01\xB6V[\x91a\x01\xB6V[\x14\x15a,fV[a/\x9D_a\x0F\x11V[[\x80a/\xBAa/\xB4a/\xAF`\x08a\x0B\xAEV[a\x022V[\x91a\x022V[\x10\x15a0\x07Wa0\x02\x90a/\xFD\x86a/\xF6a/\xF0a/\xEBa/\xE6a/\xE0`\x08\x88\x90a\x0B\xBBV[Pa%\xCEV[a5\rV[a\x01\xB6V[\x91a\x01\xB6V[\x14\x15a,\xE8V[a\x0F-V[a/\x9EV[P\x91a0@\x91\x93Pa0\x19`\x08a\x0B\xAEV[a0+a0%_a\x0F\x11V[\x91a\x022V[\x14a1\x1AW[a0;`\x08a%\xD1V[a&xV[a0J`\x08a\x0B\xAEV[a0]a0W`\x02a-\x14V[\x91a\x022V[\x14a0fW[PV[_\x80a0\xE5a0\xE0a1\x14\x94a0\x98a0\x91a0\x82`\x01a\x14\xD5V[a0\x8C`\ta-DV[a-QV[`\ta-vV[a0\xA2`\ta-DV[a0\xD8\x7F7\xE8\xAD\xD6\x94\xC5\x92mVN\x97\x11`\xF5\x97A\x03\xCB\xBB\xC7\xC9\x07G\xC4\xC6\xF8\x02\x03\x1D5g\xA7\x91a0\xCFa\x01\xA4V[\x91\x82\x91\x82a\x08\xD3V[\x03\x90\xA1a-\xA2V[a-\xAEV[a0\xEE0a-\xBAV[1a0\xF7a\x01\xA4V[\x90\x81a1\x02\x81a-\xDAV[\x03\x92Z\xF1a1\x0Ea.\x02V[Pa.\x84V[_a0cV[a1@a19a1)Ba\x16;V[a13`\ra\x1A\x0FV[\x90a\x1A\x1CV[`\ra\x1A\x82V[a01V[a1V\x90a1Qa3\x8FV[a2KV[V[` \x7Fhile assertion is pending\0\0\0\0\0\0\0\x91\x7Fcannot update challenge window w_\x82\x01R\x01RV[a1\xB2`9`@\x92a\x0F<V[a1\xBB\x81a1XV[\x01\x90V[a1\xD4\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra1\xA5V[\x90V[\x15a1\xDEWV[a1\xE6a\x01\xA4V[bF\x1B\xCD`\xE5\x1B\x81R\x80a1\xFC`\x04\x82\x01a1\xBFV[\x03\x90\xFD[`@\x1B\x90V[\x90a2!o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\x91a2\0V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a2@a2;a2G\x92a\x1AcV[a\x1A\x7FV[\x82Ta2\x06V[\x90UV[a2{\x90a2ta2\\`\x08a\x0B\xAEV[a2na2h_a\x0F\x11V[\x91a\x022V[\x14a1\xD7V[`\ra2+V[V[a2\x86\x90a1EV[V[a2\x99\x90a2\x94a3\x8FV[a2\x9BV[V[a2\xC0a2\xA8`\x08a\x0B\xAEV[a2\xBAa2\xB4_a\x0F\x11V[\x91a\x022V[\x14a)mV[a2\xCD\x81_`\x01\x01a\x176V[a2\xD9`\x01\x80\x01a\x03\xF4V[\x7F\xC9\x85\xBC\xCB\xD0\xC9\x0E\x19\x7FJss\x02\n3\xBAo\xF8d\xD09\x9F\xD7\xD6\\\\|2\xFF\xB0\x15\xEC\x91a3\x0Fa3\x06a\x01\xA4V[\x92\x83\x92\x83a\x17eV[\x03\x90\xA1V[a3\x1D\x90a2\x88V[V[a30\x90a3+a3\x8FV[a32V[V[\x80a3Ma3Ga3B_a\x15\xB5V[a\x03eV[\x91a\x03eV[\x14a3]Wa3[\x90a4\x18V[V[a3\x80a3i_a\x15\xB5V[_\x91\x82\x91c\x1EO\xBD\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x03~V[\x03\x90\xFD[a3\x8D\x90a3\x1FV[V[a3\x97a%$V[a3\xB0a3\xAAa3\xA5a6\x9BV[a\x03eV[\x91a\x03eV[\x03a3\xB7WV[a3\xD9a3\xC2a6\x9BV[_\x91\x82\x91c\x11\x8C\xDA\xA7`\xE0\x1B\x83R`\x04\x83\x01a\x03~V[\x03\x90\xFD[\x90a3\xEE`\x01\x80`\xA0\x1B\x03\x91a\x12 V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a4\ra4\x08a4\x14\x92a\x06\x02V[a#,V[\x82Ta3\xDDV[\x90UV[a4!_a%\x17V[a4+\x82_a3\xF8V[\x90a4_a4Y\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x93a\x06\x02V[\x91a\x06\x02V[\x91a4ha\x01\xA4V[\x80a4r\x81a\x01\xFAV[\x03\x90\xA3V[` \x93\x92a4\x96\x85\x83a4\x8E\x82\x95a4\x9E\x97a*\xC3V[\x01\x80\x92a*\xC3V[\x01\x80\x92a*\xC3V[\x01\x90V[a4\xAAa\x17\x96V[Pa4\xF7a4\xB9_\x83\x01a&\tV[a4\xE8a4\xD4`@a4\xCD` \x87\x01a&\tV[\x95\x01a&\tV[a4\xDCa\x01\xA4V[\x94\x85\x93` \x85\x01a4wV[` \x82\x01\x81\x03\x82R\x03\x82a\x15\xCFV[a5\ta5\x03\x82a*\xFCV[\x91a*\xF6V[ \x90V[a5\x15a\x17\x96V[Pa5ba5$_\x83\x01a\x03\xF4V[a5Sa5?`\x02a58`\x01\x87\x01a\x03\xF4V[\x95\x01a\x03\xF4V[a5Ga\x01\xA4V[\x94\x85\x93` \x85\x01a4wV[` \x82\x01\x81\x03\x82R\x03\x82a\x15\xCFV[a5ta5n\x82a*\xFCV[\x91a*\xF6V[ \x90V[\x94a5\xC6` \x80\x99\x98\x95\x96a5\xBE\x82\x80\x99a5\xB6\x82a5\xCE\x9Aa5\xAEa5\xD6\x9F\x80a5\xA6\x85\x9E\x92\x86\x93a*\xC3V[\x01\x80\x92a*\xC3V[\x01\x80\x92a*\xC3V[\x01\x80\x92a*\xC3V[\x01\x80\x92a*\xC3V[\x01\x80\x92a*\xC3V[\x01\x80\x92a*\xC3V[\x01\x90V[a5\xE2a\x17\x96V[Pa6ca5\xF1_\x83\x01a\x03\xF4V[a6Ta6\0`\x01\x85\x01a\x03\xF4V[\x93a6\r`\x02\x82\x01a\x03\xF4V[\x90a6\x1A`\x03\x82\x01a\x03\xF4V[a6&`\x04\x83\x01a\x03\xF4V[\x90a6?`\x06a68`\x05\x86\x01a\x03\xF4V[\x94\x01a\x03\xF4V[\x93a6Ha\x01\xA4V[\x98\x89\x97` \x89\x01a5xV[` \x82\x01\x81\x03\x82R\x03\x82a\x15\xCFV[a6ua6o\x82a*\xFCV[\x91a*\xF6V[ \x90V[a6\x98\x91a6\x8F\x91a6\x89a$\xFFV[Pa6\xCCV[\x90\x92\x91\x92a7\xB4V[\x90V[a6\xA3a$\xFFV[P3\x90V[_\x90V[a6\xC0a6\xBBa6\xC5\x92a\x022V[a\x12 V[a\x01\xB6V[\x90V[_\x90V[\x91\x90\x91a6\xD7a$\xFFV[Pa6\xE0a6\xA8V[Pa6\xE9a\x17\x96V[Pa6\xF3\x83a*\xFCV[a7\x06a7\0`Aa*\x1FV[\x91a\x022V[\x14_\x14a7MWa7F\x91\x92a7\x1Aa\x17\x96V[Pa7#a\x17\x96V[Pa7,a6\xC8V[P` \x81\x01Q```@\x83\x01Q\x92\x01Q_\x1A\x90\x91\x92a9\x11V[\x91\x92\x90\x91\x90V[Pa7W_a\x15\xB5V[\x90a7ka7f`\x02\x94a*\xFCV[a6\xACV[\x91\x92\x91\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x04\x11\x15a7\x8FWV[a7qV[\x90a7\x9E\x82a7\x85V[V[a7\xACa7\xB1\x91a\x03\xD8V[a\x12\xBEV[\x90V[\x80a7\xC7a7\xC1_a7\x94V[\x91a7\x94V[\x14_\x14a7\xD2WPPV[\x80a7\xE6a7\xE0`\x01a7\x94V[\x91a7\x94V[\x14_\x14a8\tW_c\xF6E\xEE\xDF`\xE0\x1B\x81R\x80a8\x05`\x04\x82\x01a\x01\xFAV[\x03\x90\xFD[\x80a8\x1Da8\x17`\x02a7\x94V[\x91a7\x94V[\x14_\x14a8KWa8Ga80\x83a7\xA0V[_\x91\x82\x91c\xFC\xE6\x98\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x08\xD3V[\x03\x90\xFD[a8^a8X`\x03a7\x94V[\x91a7\x94V[\x14a8fWPV[a8\x81\x90_\x91\x82\x91c5\xE2\xF3\x83`\xE2\x1B\x83R`\x04\x83\x01a\x07jV[\x03\x90\xFD[\x90V[a8\x9Ca8\x97a8\xA1\x92a8\x85V[a\x053V[a\x022V[\x90V[`\xFF\x16\x90V[a8\xB3\x90a8\xA4V[\x90RV[a8\xECa8\xF3\x94a8\xE2``\x94\x98\x97\x95a8\xD8`\x80\x86\x01\x9A_\x87\x01\x90a\x04^V[` \x85\x01\x90a8\xAAV[`@\x83\x01\x90a\x04^V[\x01\x90a\x04^V[V[a9\ta9\x04a9\x0E\x92a\x0F\x0EV[a\x12 V[a\x01\xB6V[\x90V[\x93\x92\x93a9\x1Ca$\xFFV[Pa9%a6\xA8V[Pa9.a\x17\x96V[Pa98\x85a7\xA0V[a9ja9d\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0a8\x88V[\x91a\x022V[\x11a9\xF7W\x90a9\x8D` \x94\x95_\x94\x93\x92\x93a9\x84a\x01\xA4V[\x94\x85\x94\x85a8\xB7V[\x83\x80R\x03\x90`\x01Z\xFA\x15a9\xF2Wa9\xA5_Qa\x12 V[\x80a9\xC0a9\xBAa9\xB5_a\x15\xB5V[a\x03eV[\x91a\x03eV[\x14a9\xD6W_\x91a9\xD0_a8\xF5V[\x91\x92\x91\x90V[Pa9\xE0_a\x15\xB5V[`\x01\x91a9\xEC_a8\xF5V[\x91\x92\x91\x90V[a\x16+V[PPPa:\x03_a\x15\xB5V[\x90`\x03\x92\x91\x92\x91\x90V",
    );
    /**```solidity
struct PendingAssertion { bytes32 blockHash; bytes32 sendRoot; bytes32 seqBlockHash; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PendingAssertion {
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sendRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqBlockHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PendingAssertion> for UnderlyingRustTuple<'_> {
            fn from(value: PendingAssertion) -> Self {
                (value.blockHash, value.sendRoot, value.seqBlockHash)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PendingAssertion {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    blockHash: tuple.0,
                    sendRoot: tuple.1,
                    seqBlockHash: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for PendingAssertion {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for PendingAssertion {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.sendRoot),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.seqBlockHash),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for PendingAssertion {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for PendingAssertion {
            const NAME: &'static str = "PendingAssertion";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "PendingAssertion(bytes32 blockHash,bytes32 sendRoot,bytes32 seqBlockHash)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.blockHash)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.sendRoot)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.seqBlockHash)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for PendingAssertion {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.blockHash,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sendRoot,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.seqBlockHash,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.blockHash,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sendRoot,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.seqBlockHash,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct TeeTrustedInput { bytes32 appchainConfigHash; bytes32 appchainStartBlockHash; bytes32 seqConfigHash; bytes32 seqStartBlockHash; bytes32 setDelayedMessageAcc; bytes32 l1StartBlockHash; bytes32 l1EndBlockHash; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TeeTrustedInput {
        #[allow(missing_docs)]
        pub appchainConfigHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub appchainStartBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqConfigHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqStartBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub setDelayedMessageAcc: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1StartBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1EndBlockHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TeeTrustedInput> for UnderlyingRustTuple<'_> {
            fn from(value: TeeTrustedInput) -> Self {
                (
                    value.appchainConfigHash,
                    value.appchainStartBlockHash,
                    value.seqConfigHash,
                    value.seqStartBlockHash,
                    value.setDelayedMessageAcc,
                    value.l1StartBlockHash,
                    value.l1EndBlockHash,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TeeTrustedInput {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    appchainConfigHash: tuple.0,
                    appchainStartBlockHash: tuple.1,
                    seqConfigHash: tuple.2,
                    seqStartBlockHash: tuple.3,
                    setDelayedMessageAcc: tuple.4,
                    l1StartBlockHash: tuple.5,
                    l1EndBlockHash: tuple.6,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for TeeTrustedInput {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for TeeTrustedInput {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainConfigHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.appchainStartBlockHash,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.seqConfigHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.seqStartBlockHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.setDelayedMessageAcc),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.l1StartBlockHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.l1EndBlockHash),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for TeeTrustedInput {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for TeeTrustedInput {
            const NAME: &'static str = "TeeTrustedInput";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "TeeTrustedInput(bytes32 appchainConfigHash,bytes32 appchainStartBlockHash,bytes32 seqConfigHash,bytes32 seqStartBlockHash,bytes32 setDelayedMessageAcc,bytes32 l1StartBlockHash,bytes32 l1EndBlockHash)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.appchainConfigHash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.appchainStartBlockHash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.seqConfigHash)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.seqStartBlockHash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.setDelayedMessageAcc,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.l1StartBlockHash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.l1EndBlockHash,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for TeeTrustedInput {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.appchainConfigHash,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.appchainStartBlockHash,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.seqConfigHash,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.seqStartBlockHash,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.setDelayedMessageAcc,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.l1StartBlockHash,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.l1EndBlockHash,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.appchainConfigHash,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.appchainStartBlockHash,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.seqConfigHash,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.seqStartBlockHash,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.setDelayedMessageAcc,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.l1StartBlockHash,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.l1EndBlockHash,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignature()` and selector `0xf645eedf`.
```solidity
error ECDSAInvalidSignature();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignature {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignature()";
            const SELECTOR: [u8; 4] = [246u8, 69u8, 238u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureLength(uint256)` and selector `0xfce698f7`.
```solidity
error ECDSAInvalidSignatureLength(uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureLength {
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureLength) -> Self {
                (value.length,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ECDSAInvalidSignatureLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { length: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureLength(uint256)";
            const SELECTOR: [u8; 4] = [252u8, 230u8, 152u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureS(bytes32)` and selector `0xd78bce0c`.
```solidity
error ECDSAInvalidSignatureS(bytes32 s);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureS {
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureS> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureS) -> Self {
                (value.s,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignatureS {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { s: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureS {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureS(bytes32)";
            const SELECTOR: [u8; 4] = [215u8, 139u8, 206u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
        }
    };
    /**Custom error with signature `OwnableInvalidOwner(address)` and selector `0x1e4fbdf7`.
```solidity
error OwnableInvalidOwner(address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableInvalidOwner {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableInvalidOwner> for UnderlyingRustTuple<'_> {
            fn from(value: OwnableInvalidOwner) -> Self {
                (value.owner,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OwnableInvalidOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { owner: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableInvalidOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableInvalidOwner(address)";
            const SELECTOR: [u8; 4] = [30u8, 79u8, 189u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `OwnableUnauthorizedAccount(address)` and selector `0x118cdaa7`.
```solidity
error OwnableUnauthorizedAccount(address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: OwnableUnauthorizedAccount) -> Self {
                (value.account,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OwnableUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { account: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableUnauthorizedAccount(address)";
            const SELECTOR: [u8; 4] = [17u8, 140u8, 218u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
        }
    };
    /**Event with signature `ChallengeResolved((bytes32,bytes32,bytes32))` and selector `0xe42eaf0737e2478a5f5aed3a0610ae7b09a27cbac9ad6a5cc4d68f78afd1425b`.
```solidity
event ChallengeResolved(PendingAssertion);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ChallengeResolved {
        #[allow(missing_docs)]
        pub _0: <PendingAssertion as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ChallengeResolved {
            type DataTuple<'a> = (PendingAssertion,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ChallengeResolved((bytes32,bytes32,bytes32))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                228u8,
                46u8,
                175u8,
                7u8,
                55u8,
                226u8,
                71u8,
                138u8,
                95u8,
                90u8,
                237u8,
                58u8,
                6u8,
                16u8,
                174u8,
                123u8,
                9u8,
                162u8,
                124u8,
                186u8,
                201u8,
                173u8,
                106u8,
                92u8,
                196u8,
                214u8,
                143u8,
                120u8,
                175u8,
                209u8,
                66u8,
                91u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { _0: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (<PendingAssertion as alloy_sol_types::SolType>::tokenize(&self._0),)
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ChallengeResolved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ChallengeResolved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ChallengeResolved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeAppchainConfigHash(bytes32,bytes32)` and selector `0xc985bccbd0c90e197f4a7373020a33ba6ff864d0399fd7d65c5c7c32ffb015ec`.
```solidity
event TeeAppchainConfigHash(bytes32 configHash, bytes32 blockHash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeAppchainConfigHash {
        #[allow(missing_docs)]
        pub configHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeAppchainConfigHash {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeAppchainConfigHash(bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                201u8,
                133u8,
                188u8,
                203u8,
                208u8,
                201u8,
                14u8,
                25u8,
                127u8,
                74u8,
                115u8,
                115u8,
                2u8,
                10u8,
                51u8,
                186u8,
                111u8,
                248u8,
                100u8,
                208u8,
                57u8,
                159u8,
                215u8,
                214u8,
                92u8,
                92u8,
                124u8,
                50u8,
                255u8,
                176u8,
                21u8,
                236u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    configHash: data.0,
                    blockHash: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.configHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockHash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeAppchainConfigHash {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeAppchainConfigHash> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeAppchainConfigHash) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeHacked(uint256)` and selector `0x37e8add694c5926d564e971160f5974103cbbbc7c90747c4c6f802031d3567a7`.
```solidity
event TeeHacked(uint256);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeHacked {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeHacked {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeHacked(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                55u8,
                232u8,
                173u8,
                214u8,
                148u8,
                197u8,
                146u8,
                109u8,
                86u8,
                78u8,
                151u8,
                17u8,
                96u8,
                245u8,
                151u8,
                65u8,
                3u8,
                203u8,
                187u8,
                199u8,
                201u8,
                7u8,
                71u8,
                196u8,
                198u8,
                248u8,
                2u8,
                3u8,
                29u8,
                53u8,
                103u8,
                167u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { _0: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeHacked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeHacked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeHacked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeInput((bytes32,bytes32,bytes32,bytes32,bytes32,bytes32,bytes32))` and selector `0x91092bcf550921e381e81f06693320534b144a7e561c5fc08f1940d508a85cdc`.
```solidity
event TeeInput(TeeTrustedInput input);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeInput {
        #[allow(missing_docs)]
        pub input: <TeeTrustedInput as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeInput {
            type DataTuple<'a> = (TeeTrustedInput,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeInput((bytes32,bytes32,bytes32,bytes32,bytes32,bytes32,bytes32))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                145u8,
                9u8,
                43u8,
                207u8,
                85u8,
                9u8,
                33u8,
                227u8,
                129u8,
                232u8,
                31u8,
                6u8,
                105u8,
                51u8,
                32u8,
                83u8,
                75u8,
                20u8,
                74u8,
                126u8,
                86u8,
                28u8,
                95u8,
                192u8,
                143u8,
                25u8,
                64u8,
                213u8,
                8u8,
                168u8,
                92u8,
                220u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { input: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (<TeeTrustedInput as alloy_sol_types::SolType>::tokenize(&self.input),)
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeInput {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeInput> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeInput) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeKeysRevoked()` and selector `0xeca62e0074a13a90d600f003b7cb8d5bd50100008d3f3915f2554f3f8552c5cc`.
```solidity
event TeeKeysRevoked();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeKeysRevoked {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeKeysRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeKeysRevoked()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                236u8,
                166u8,
                46u8,
                0u8,
                116u8,
                161u8,
                58u8,
                144u8,
                214u8,
                0u8,
                240u8,
                3u8,
                183u8,
                203u8,
                141u8,
                91u8,
                213u8,
                1u8,
                0u8,
                0u8,
                141u8,
                63u8,
                57u8,
                21u8,
                242u8,
                85u8,
                79u8,
                63u8,
                133u8,
                82u8,
                197u8,
                204u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeKeysRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeKeysRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeKeysRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeProgramAdded(bytes32)` and selector `0x9a7a6469c25cf017890607695e4a149cc771f294fd871e2080d24cd109033ab6`.
```solidity
event TeeProgramAdded(bytes32 hash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeProgramAdded {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeProgramAdded {
            type DataTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeProgramAdded(bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                154u8,
                122u8,
                100u8,
                105u8,
                194u8,
                92u8,
                240u8,
                23u8,
                137u8,
                6u8,
                7u8,
                105u8,
                94u8,
                74u8,
                20u8,
                156u8,
                199u8,
                113u8,
                242u8,
                148u8,
                253u8,
                135u8,
                30u8,
                32u8,
                128u8,
                210u8,
                76u8,
                209u8,
                9u8,
                3u8,
                58u8,
                182u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { hash: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeProgramAdded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeProgramAdded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeProgramAdded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeProgramRemoved(bytes32)` and selector `0x2621c61d3315f2a3d26b22d746ba21a96d249f51ada323f7226cce5fe5fc3d64`.
```solidity
event TeeProgramRemoved(bytes32 hash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeProgramRemoved {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeProgramRemoved {
            type DataTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeProgramRemoved(bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                38u8,
                33u8,
                198u8,
                29u8,
                51u8,
                21u8,
                242u8,
                163u8,
                210u8,
                107u8,
                34u8,
                215u8,
                70u8,
                186u8,
                33u8,
                169u8,
                109u8,
                36u8,
                159u8,
                81u8,
                173u8,
                163u8,
                35u8,
                247u8,
                34u8,
                108u8,
                206u8,
                95u8,
                229u8,
                252u8,
                61u8,
                100u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { hash: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeProgramRemoved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeProgramRemoved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeProgramRemoved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeSeqConfigHash(bytes32,bytes32)` and selector `0xb9eb20b32fac965884cb58326102257cae604504f0a36cd1008a32845ad5c29b`.
```solidity
event TeeSeqConfigHash(bytes32 configHash, bytes32 blockHash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeSeqConfigHash {
        #[allow(missing_docs)]
        pub configHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeSeqConfigHash {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeSeqConfigHash(bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                185u8,
                235u8,
                32u8,
                179u8,
                47u8,
                172u8,
                150u8,
                88u8,
                132u8,
                203u8,
                88u8,
                50u8,
                97u8,
                2u8,
                37u8,
                124u8,
                174u8,
                96u8,
                69u8,
                4u8,
                240u8,
                163u8,
                108u8,
                209u8,
                0u8,
                138u8,
                50u8,
                132u8,
                90u8,
                213u8,
                194u8,
                155u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    configHash: data.0,
                    blockHash: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.configHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockHash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeSeqConfigHash {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeSeqConfigHash> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeSeqConfigHash) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address poster_, address bridge_, bytes32 appchainConfigHash_, bytes32 appchainStartBlockHash_, bytes32 seqConfigHash_, bytes32 seqStartBlockHash_, bytes32 l1StartBlockHash_, address l1block_, uint64 challengeWindowDuration_, bytes32 teeProgram);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub poster_: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub bridge_: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub appchainStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1StartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1block_: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub challengeWindowDuration_: u64,
        #[allow(missing_docs)]
        pub teeProgram: alloy::sol_types::private::FixedBytes<32>,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
                u64,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value.poster_,
                        value.bridge_,
                        value.appchainConfigHash_,
                        value.appchainStartBlockHash_,
                        value.seqConfigHash_,
                        value.seqStartBlockHash_,
                        value.l1StartBlockHash_,
                        value.l1block_,
                        value.challengeWindowDuration_,
                        value.teeProgram,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        poster_: tuple.0,
                        bridge_: tuple.1,
                        appchainConfigHash_: tuple.2,
                        appchainStartBlockHash_: tuple.3,
                        seqConfigHash_: tuple.4,
                        seqStartBlockHash_: tuple.5,
                        l1StartBlockHash_: tuple.6,
                        l1block_: tuple.7,
                        challengeWindowDuration_: tuple.8,
                        teeProgram: tuple.9,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.poster_,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge_,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainConfigHash_),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.appchainStartBlockHash_,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.seqConfigHash_),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.seqStartBlockHash_),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.l1StartBlockHash_),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.l1block_,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.challengeWindowDuration_,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.teeProgram),
                )
            }
        }
    };
    /**Function with signature `addTeeKey(address,bytes32,bytes)` and selector `0x70646ea2`.
```solidity
function addTeeKey(address publicKey, bytes32 programHash, bytes memory zkProof) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addTeeKeyCall {
        #[allow(missing_docs)]
        pub publicKey: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub programHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub zkProof: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`addTeeKey(address,bytes32,bytes)`](addTeeKeyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addTeeKeyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addTeeKeyCall> for UnderlyingRustTuple<'_> {
                fn from(value: addTeeKeyCall) -> Self {
                    (value.publicKey, value.programHash, value.zkProof)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addTeeKeyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        publicKey: tuple.0,
                        programHash: tuple.1,
                        zkProof: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addTeeKeyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addTeeKeyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addTeeKeyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addTeeKeyCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addTeeKeyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addTeeKey(address,bytes32,bytes)";
            const SELECTOR: [u8; 4] = [112u8, 100u8, 110u8, 162u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.publicKey,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.programHash),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.zkProof,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `addTeeProgram(bytes32)` and selector `0x1c12427f`.
```solidity
function addTeeProgram(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addTeeProgramCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`addTeeProgram(bytes32)`](addTeeProgramCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addTeeProgramReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addTeeProgramCall> for UnderlyingRustTuple<'_> {
                fn from(value: addTeeProgramCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addTeeProgramCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addTeeProgramReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addTeeProgramReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addTeeProgramReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addTeeProgramCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addTeeProgramReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addTeeProgram(bytes32)";
            const SELECTOR: [u8; 4] = [28u8, 18u8, 66u8, 127u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridge()` and selector `0xe78cea92`.
```solidity
function bridge() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeCall {}
    ///Container type for the return parameters of the [`bridge()`](bridgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridge()";
            const SELECTOR: [u8; 4] = [231u8, 140u8, 234u8, 146u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `challengeWindowDuration()` and selector `0x4bd167c9`.
```solidity
function challengeWindowDuration() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowDurationCall {}
    ///Container type for the return parameters of the [`challengeWindowDuration()`](challengeWindowDurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowDurationReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowDurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowDurationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowDurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowDurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowDurationReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowDurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for challengeWindowDurationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = challengeWindowDurationReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "challengeWindowDuration()";
            const SELECTOR: [u8; 4] = [75u8, 209u8, 103u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `challengeWindowEnd()` and selector `0xee1c28b8`.
```solidity
function challengeWindowEnd() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowEndCall {}
    ///Container type for the return parameters of the [`challengeWindowEnd()`](challengeWindowEndCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowEndReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowEndCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowEndCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowEndCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowEndReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowEndReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowEndReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for challengeWindowEndCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = challengeWindowEndReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "challengeWindowEnd()";
            const SELECTOR: [u8; 4] = [238u8, 28u8, 40u8, 184u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `closeChallengeWindow()` and selector `0x6c4c2060`.
```solidity
function closeChallengeWindow() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct closeChallengeWindowCall {}
    ///Container type for the return parameters of the [`closeChallengeWindow()`](closeChallengeWindowCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct closeChallengeWindowReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<closeChallengeWindowCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: closeChallengeWindowCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for closeChallengeWindowCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<closeChallengeWindowReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: closeChallengeWindowReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for closeChallengeWindowReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for closeChallengeWindowCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = closeChallengeWindowReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "closeChallengeWindow()";
            const SELECTOR: [u8; 4] = [108u8, 76u8, 32u8, 96u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isTeeKey(address)` and selector `0x47742640`.
```solidity
function isTeeKey(address) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isTeeKeyCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isTeeKey(address)`](isTeeKeyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isTeeKeyReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isTeeKeyCall> for UnderlyingRustTuple<'_> {
                fn from(value: isTeeKeyCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isTeeKeyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isTeeKeyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isTeeKeyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isTeeKeyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isTeeKeyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isTeeKeyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isTeeKey(address)";
            const SELECTOR: [u8; 4] = [71u8, 116u8, 38u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `l1block()` and selector `0x420caf3a`.
```solidity
function l1block() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct l1blockCall {}
    ///Container type for the return parameters of the [`l1block()`](l1blockCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct l1blockReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<l1blockCall> for UnderlyingRustTuple<'_> {
                fn from(value: l1blockCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for l1blockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<l1blockReturn> for UnderlyingRustTuple<'_> {
                fn from(value: l1blockReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for l1blockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for l1blockCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = l1blockReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "l1block()";
            const SELECTOR: [u8; 4] = [66u8, 12u8, 175u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall {}
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pendingAssertions(uint256)` and selector `0xa56ec6cd`.
```solidity
function pendingAssertions(uint256) external view returns (bytes32 blockHash, bytes32 sendRoot, bytes32 seqBlockHash);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingAssertionsCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`pendingAssertions(uint256)`](pendingAssertionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingAssertionsReturn {
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sendRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqBlockHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingAssertionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: pendingAssertionsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pendingAssertionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingAssertionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: pendingAssertionsReturn) -> Self {
                    (value.blockHash, value.sendRoot, value.seqBlockHash)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pendingAssertionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blockHash: tuple.0,
                        sendRoot: tuple.1,
                        seqBlockHash: tuple.2,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pendingAssertionsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pendingAssertionsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pendingAssertions(uint256)";
            const SELECTOR: [u8; 4] = [165u8, 110u8, 198u8, 205u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `poster()` and selector `0x80959721`.
```solidity
function poster() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct posterCall {}
    ///Container type for the return parameters of the [`poster()`](posterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct posterReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<posterCall> for UnderlyingRustTuple<'_> {
                fn from(value: posterCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for posterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<posterReturn> for UnderlyingRustTuple<'_> {
                fn from(value: posterReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for posterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for posterCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = posterReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "poster()";
            const SELECTOR: [u8; 4] = [128u8, 149u8, 151u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeTeeProgram(bytes32)` and selector `0x5f70c441`.
```solidity
function removeTeeProgram(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeTeeProgramCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`removeTeeProgram(bytes32)`](removeTeeProgramCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeTeeProgramReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeTeeProgramCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeTeeProgramCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeTeeProgramCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeTeeProgramReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeTeeProgramReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeTeeProgramReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeTeeProgramCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeTeeProgramReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeTeeProgram(bytes32)";
            const SELECTOR: [u8; 4] = [95u8, 112u8, 196u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall {}
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `resolveChallenge((bytes32,bytes32,bytes32))` and selector `0x8fed55a3`.
```solidity
function resolveChallenge(PendingAssertion memory assertion) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolveChallengeCall {
        #[allow(missing_docs)]
        pub assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`resolveChallenge((bytes32,bytes32,bytes32))`](resolveChallengeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolveChallengeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (PendingAssertion,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PendingAssertion as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolveChallengeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: resolveChallengeCall) -> Self {
                    (value.assertion,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resolveChallengeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { assertion: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolveChallengeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: resolveChallengeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resolveChallengeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for resolveChallengeCall {
            type Parameters<'a> = (PendingAssertion,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = resolveChallengeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "resolveChallenge((bytes32,bytes32,bytes32))";
            const SELECTOR: [u8; 4] = [143u8, 237u8, 85u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PendingAssertion as alloy_sol_types::SolType>::tokenize(
                        &self.assertion,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeAllTeeKeys()` and selector `0x6ef01201`.
```solidity
function revokeAllTeeKeys() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeAllTeeKeysCall {}
    ///Container type for the return parameters of the [`revokeAllTeeKeys()`](revokeAllTeeKeysCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeAllTeeKeysReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeAllTeeKeysCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: revokeAllTeeKeysCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for revokeAllTeeKeysCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeAllTeeKeysReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: revokeAllTeeKeysReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for revokeAllTeeKeysReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeAllTeeKeysCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeAllTeeKeysReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeAllTeeKeys()";
            const SELECTOR: [u8; 4] = [110u8, 240u8, 18u8, 1u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setAppchainConfigHash(bytes32)` and selector `0xf223055c`.
```solidity
function setAppchainConfigHash(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAppchainConfigHashCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`setAppchainConfigHash(bytes32)`](setAppchainConfigHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAppchainConfigHashReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAppchainConfigHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAppchainConfigHashCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAppchainConfigHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAppchainConfigHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAppchainConfigHashReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAppchainConfigHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setAppchainConfigHashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setAppchainConfigHashReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setAppchainConfigHash(bytes32)";
            const SELECTOR: [u8; 4] = [242u8, 35u8, 5u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setChallengeWindowDuration(uint64)` and selector `0xeb60553a`.
```solidity
function setChallengeWindowDuration(uint64 duration) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setChallengeWindowDurationCall {
        #[allow(missing_docs)]
        pub duration: u64,
    }
    ///Container type for the return parameters of the [`setChallengeWindowDuration(uint64)`](setChallengeWindowDurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setChallengeWindowDurationReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setChallengeWindowDurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setChallengeWindowDurationCall) -> Self {
                    (value.duration,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setChallengeWindowDurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { duration: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setChallengeWindowDurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setChallengeWindowDurationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setChallengeWindowDurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setChallengeWindowDurationCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setChallengeWindowDurationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setChallengeWindowDuration(uint64)";
            const SELECTOR: [u8; 4] = [235u8, 96u8, 85u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.duration),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setSeqConfigHash(bytes32)` and selector `0xc3f2dbd3`.
```solidity
function setSeqConfigHash(bytes32 hash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSeqConfigHashCall {
        #[allow(missing_docs)]
        pub hash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`setSeqConfigHash(bytes32)`](setSeqConfigHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSeqConfigHashReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSeqConfigHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setSeqConfigHashCall) -> Self {
                    (value.hash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setSeqConfigHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { hash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSeqConfigHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setSeqConfigHashReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setSeqConfigHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setSeqConfigHashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setSeqConfigHashReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setSeqConfigHash(bytes32)";
            const SELECTOR: [u8; 4] = [195u8, 242u8, 219u8, 211u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.hash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `submitAssertion((bytes32,bytes32,bytes32),bytes,address)` and selector `0xe50c6156`.
```solidity
function submitAssertion(PendingAssertion memory assertion, bytes memory signature, address rewardAddr) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitAssertionCall {
        #[allow(missing_docs)]
        pub assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub signature: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub rewardAddr: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`submitAssertion((bytes32,bytes32,bytes32),bytes,address)`](submitAssertionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitAssertionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                PendingAssertion,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PendingAssertion as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitAssertionCall> for UnderlyingRustTuple<'_> {
                fn from(value: submitAssertionCall) -> Self {
                    (value.assertion, value.signature, value.rewardAddr)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for submitAssertionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        assertion: tuple.0,
                        signature: tuple.1,
                        rewardAddr: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitAssertionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: submitAssertionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for submitAssertionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for submitAssertionCall {
            type Parameters<'a> = (
                PendingAssertion,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = submitAssertionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "submitAssertion((bytes32,bytes32,bytes32),bytes,address)";
            const SELECTOR: [u8; 4] = [229u8, 12u8, 97u8, 86u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PendingAssertion as alloy_sol_types::SolType>::tokenize(
                        &self.assertion,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.signature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rewardAddr,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teeHackCount()` and selector `0x697b5e62`.
```solidity
function teeHackCount() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeHackCountCall {}
    ///Container type for the return parameters of the [`teeHackCount()`](teeHackCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeHackCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeHackCountCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeHackCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeHackCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeHackCountReturn> for UnderlyingRustTuple<'_> {
                fn from(value: teeHackCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeHackCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeHackCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeHackCountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teeHackCount()";
            const SELECTOR: [u8; 4] = [105u8, 123u8, 94u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teeProgramKeys(bytes32,uint256)` and selector `0x33339006`.
```solidity
function teeProgramKeys(bytes32, uint256) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeProgramKeysCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`teeProgramKeys(bytes32,uint256)`](teeProgramKeysCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeProgramKeysReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeProgramKeysCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeProgramKeysCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeProgramKeysCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeProgramKeysReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: teeProgramKeysReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for teeProgramKeysReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeProgramKeysCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeProgramKeysReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teeProgramKeys(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [51u8, 51u8, 144u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teePrograms(uint256)` and selector `0x4afffcc9`.
```solidity
function teePrograms(uint256) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeProgramsCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`teePrograms(uint256)`](teeProgramsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeProgramsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeProgramsCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeProgramsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeProgramsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeProgramsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: teeProgramsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeProgramsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeProgramsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeProgramsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teePrograms(uint256)";
            const SELECTOR: [u8; 4] = [74u8, 255u8, 252u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teeTrustedInput()` and selector `0x3ceaae7d`.
```solidity
function teeTrustedInput() external view returns (bytes32 appchainConfigHash, bytes32 appchainStartBlockHash, bytes32 seqConfigHash, bytes32 seqStartBlockHash, bytes32 setDelayedMessageAcc, bytes32 l1StartBlockHash, bytes32 l1EndBlockHash);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeTrustedInputCall {}
    ///Container type for the return parameters of the [`teeTrustedInput()`](teeTrustedInputCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeTrustedInputReturn {
        #[allow(missing_docs)]
        pub appchainConfigHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub appchainStartBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqConfigHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqStartBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub setDelayedMessageAcc: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1StartBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1EndBlockHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeTrustedInputCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeTrustedInputCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeTrustedInputCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeTrustedInputReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: teeTrustedInputReturn) -> Self {
                    (
                        value.appchainConfigHash,
                        value.appchainStartBlockHash,
                        value.seqConfigHash,
                        value.seqStartBlockHash,
                        value.setDelayedMessageAcc,
                        value.l1StartBlockHash,
                        value.l1EndBlockHash,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for teeTrustedInputReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        appchainConfigHash: tuple.0,
                        appchainStartBlockHash: tuple.1,
                        seqConfigHash: tuple.2,
                        seqStartBlockHash: tuple.3,
                        setDelayedMessageAcc: tuple.4,
                        l1StartBlockHash: tuple.5,
                        l1EndBlockHash: tuple.6,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeTrustedInputCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeTrustedInputReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teeTrustedInput()";
            const SELECTOR: [u8; 4] = [60u8, 234u8, 174u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`TeeModule`](self) function calls.
    pub enum TeeModuleCalls {
        #[allow(missing_docs)]
        addTeeKey(addTeeKeyCall),
        #[allow(missing_docs)]
        addTeeProgram(addTeeProgramCall),
        #[allow(missing_docs)]
        bridge(bridgeCall),
        #[allow(missing_docs)]
        challengeWindowDuration(challengeWindowDurationCall),
        #[allow(missing_docs)]
        challengeWindowEnd(challengeWindowEndCall),
        #[allow(missing_docs)]
        closeChallengeWindow(closeChallengeWindowCall),
        #[allow(missing_docs)]
        isTeeKey(isTeeKeyCall),
        #[allow(missing_docs)]
        l1block(l1blockCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        pendingAssertions(pendingAssertionsCall),
        #[allow(missing_docs)]
        poster(posterCall),
        #[allow(missing_docs)]
        removeTeeProgram(removeTeeProgramCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        resolveChallenge(resolveChallengeCall),
        #[allow(missing_docs)]
        revokeAllTeeKeys(revokeAllTeeKeysCall),
        #[allow(missing_docs)]
        setAppchainConfigHash(setAppchainConfigHashCall),
        #[allow(missing_docs)]
        setChallengeWindowDuration(setChallengeWindowDurationCall),
        #[allow(missing_docs)]
        setSeqConfigHash(setSeqConfigHashCall),
        #[allow(missing_docs)]
        submitAssertion(submitAssertionCall),
        #[allow(missing_docs)]
        teeHackCount(teeHackCountCall),
        #[allow(missing_docs)]
        teeProgramKeys(teeProgramKeysCall),
        #[allow(missing_docs)]
        teePrograms(teeProgramsCall),
        #[allow(missing_docs)]
        teeTrustedInput(teeTrustedInputCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
    }
    #[automatically_derived]
    impl TeeModuleCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [28u8, 18u8, 66u8, 127u8],
            [51u8, 51u8, 144u8, 6u8],
            [60u8, 234u8, 174u8, 125u8],
            [66u8, 12u8, 175u8, 58u8],
            [71u8, 116u8, 38u8, 64u8],
            [74u8, 255u8, 252u8, 201u8],
            [75u8, 209u8, 103u8, 201u8],
            [95u8, 112u8, 196u8, 65u8],
            [105u8, 123u8, 94u8, 98u8],
            [108u8, 76u8, 32u8, 96u8],
            [110u8, 240u8, 18u8, 1u8],
            [112u8, 100u8, 110u8, 162u8],
            [113u8, 80u8, 24u8, 166u8],
            [128u8, 149u8, 151u8, 33u8],
            [141u8, 165u8, 203u8, 91u8],
            [143u8, 237u8, 85u8, 163u8],
            [165u8, 110u8, 198u8, 205u8],
            [195u8, 242u8, 219u8, 211u8],
            [229u8, 12u8, 97u8, 86u8],
            [231u8, 140u8, 234u8, 146u8],
            [235u8, 96u8, 85u8, 58u8],
            [238u8, 28u8, 40u8, 184u8],
            [242u8, 35u8, 5u8, 92u8],
            [242u8, 253u8, 227u8, 139u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for TeeModuleCalls {
        const NAME: &'static str = "TeeModuleCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 24usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::addTeeKey(_) => {
                    <addTeeKeyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addTeeProgram(_) => {
                    <addTeeProgramCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridge(_) => <bridgeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::challengeWindowDuration(_) => {
                    <challengeWindowDurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::challengeWindowEnd(_) => {
                    <challengeWindowEndCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::closeChallengeWindow(_) => {
                    <closeChallengeWindowCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isTeeKey(_) => <isTeeKeyCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::l1block(_) => <l1blockCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pendingAssertions(_) => {
                    <pendingAssertionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::poster(_) => <posterCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::removeTeeProgram(_) => {
                    <removeTeeProgramCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::resolveChallenge(_) => {
                    <resolveChallengeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeAllTeeKeys(_) => {
                    <revokeAllTeeKeysCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setAppchainConfigHash(_) => {
                    <setAppchainConfigHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setChallengeWindowDuration(_) => {
                    <setChallengeWindowDurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setSeqConfigHash(_) => {
                    <setSeqConfigHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::submitAssertion(_) => {
                    <submitAssertionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::teeHackCount(_) => {
                    <teeHackCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::teeProgramKeys(_) => {
                    <teeProgramKeysCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::teePrograms(_) => {
                    <teeProgramsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::teeTrustedInput(_) => {
                    <teeTrustedInputCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<TeeModuleCalls>] = &[
                {
                    fn addTeeProgram(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <addTeeProgramCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::addTeeProgram)
                    }
                    addTeeProgram
                },
                {
                    fn teeProgramKeys(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeProgramKeysCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teeProgramKeys)
                    }
                    teeProgramKeys
                },
                {
                    fn teeTrustedInput(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeTrustedInputCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teeTrustedInput)
                    }
                    teeTrustedInput
                },
                {
                    fn l1block(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <l1blockCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::l1block)
                    }
                    l1block
                },
                {
                    fn isTeeKey(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <isTeeKeyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::isTeeKey)
                    }
                    isTeeKey
                },
                {
                    fn teePrograms(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeProgramsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teePrograms)
                    }
                    teePrograms
                },
                {
                    fn challengeWindowDuration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <challengeWindowDurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::challengeWindowDuration)
                    }
                    challengeWindowDuration
                },
                {
                    fn removeTeeProgram(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <removeTeeProgramCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::removeTeeProgram)
                    }
                    removeTeeProgram
                },
                {
                    fn teeHackCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeHackCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teeHackCount)
                    }
                    teeHackCount
                },
                {
                    fn closeChallengeWindow(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <closeChallengeWindowCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::closeChallengeWindow)
                    }
                    closeChallengeWindow
                },
                {
                    fn revokeAllTeeKeys(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <revokeAllTeeKeysCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::revokeAllTeeKeys)
                    }
                    revokeAllTeeKeys
                },
                {
                    fn addTeeKey(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <addTeeKeyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::addTeeKey)
                    }
                    addTeeKey
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn poster(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <posterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::poster)
                    }
                    poster
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::owner)
                    }
                    owner
                },
                {
                    fn resolveChallenge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <resolveChallengeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::resolveChallenge)
                    }
                    resolveChallenge
                },
                {
                    fn pendingAssertions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <pendingAssertionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::pendingAssertions)
                    }
                    pendingAssertions
                },
                {
                    fn setSeqConfigHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <setSeqConfigHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::setSeqConfigHash)
                    }
                    setSeqConfigHash
                },
                {
                    fn submitAssertion(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <submitAssertionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::submitAssertion)
                    }
                    submitAssertion
                },
                {
                    fn bridge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <bridgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::bridge)
                    }
                    bridge
                },
                {
                    fn setChallengeWindowDuration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <setChallengeWindowDurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::setChallengeWindowDuration)
                    }
                    setChallengeWindowDuration
                },
                {
                    fn challengeWindowEnd(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <challengeWindowEndCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::challengeWindowEnd)
                    }
                    challengeWindowEnd
                },
                {
                    fn setAppchainConfigHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <setAppchainConfigHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::setAppchainConfigHash)
                    }
                    setAppchainConfigHash
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::transferOwnership)
                    }
                    transferOwnership
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::addTeeKey(inner) => {
                    <addTeeKeyCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::addTeeProgram(inner) => {
                    <addTeeProgramCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridge(inner) => {
                    <bridgeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::challengeWindowDuration(inner) => {
                    <challengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::challengeWindowEnd(inner) => {
                    <challengeWindowEndCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::closeChallengeWindow(inner) => {
                    <closeChallengeWindowCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isTeeKey(inner) => {
                    <isTeeKeyCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::l1block(inner) => {
                    <l1blockCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pendingAssertions(inner) => {
                    <pendingAssertionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::poster(inner) => {
                    <posterCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::removeTeeProgram(inner) => {
                    <removeTeeProgramCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::resolveChallenge(inner) => {
                    <resolveChallengeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeAllTeeKeys(inner) => {
                    <revokeAllTeeKeysCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setAppchainConfigHash(inner) => {
                    <setAppchainConfigHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setChallengeWindowDuration(inner) => {
                    <setChallengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setSeqConfigHash(inner) => {
                    <setSeqConfigHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::submitAssertion(inner) => {
                    <submitAssertionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::teeHackCount(inner) => {
                    <teeHackCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::teeProgramKeys(inner) => {
                    <teeProgramKeysCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::teePrograms(inner) => {
                    <teeProgramsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::teeTrustedInput(inner) => {
                    <teeTrustedInputCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::addTeeKey(inner) => {
                    <addTeeKeyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addTeeProgram(inner) => {
                    <addTeeProgramCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridge(inner) => {
                    <bridgeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::challengeWindowDuration(inner) => {
                    <challengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::challengeWindowEnd(inner) => {
                    <challengeWindowEndCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::closeChallengeWindow(inner) => {
                    <closeChallengeWindowCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isTeeKey(inner) => {
                    <isTeeKeyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::l1block(inner) => {
                    <l1blockCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pendingAssertions(inner) => {
                    <pendingAssertionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::poster(inner) => {
                    <posterCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::removeTeeProgram(inner) => {
                    <removeTeeProgramCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::resolveChallenge(inner) => {
                    <resolveChallengeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeAllTeeKeys(inner) => {
                    <revokeAllTeeKeysCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setAppchainConfigHash(inner) => {
                    <setAppchainConfigHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setChallengeWindowDuration(inner) => {
                    <setChallengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setSeqConfigHash(inner) => {
                    <setSeqConfigHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::submitAssertion(inner) => {
                    <submitAssertionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::teeHackCount(inner) => {
                    <teeHackCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::teeProgramKeys(inner) => {
                    <teeProgramKeysCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::teePrograms(inner) => {
                    <teeProgramsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::teeTrustedInput(inner) => {
                    <teeTrustedInputCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`TeeModule`](self) custom errors.
    pub enum TeeModuleErrors {
        #[allow(missing_docs)]
        ECDSAInvalidSignature(ECDSAInvalidSignature),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureLength(ECDSAInvalidSignatureLength),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureS(ECDSAInvalidSignatureS),
        #[allow(missing_docs)]
        OwnableInvalidOwner(OwnableInvalidOwner),
        #[allow(missing_docs)]
        OwnableUnauthorizedAccount(OwnableUnauthorizedAccount),
    }
    #[automatically_derived]
    impl TeeModuleErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [17u8, 140u8, 218u8, 167u8],
            [30u8, 79u8, 189u8, 247u8],
            [215u8, 139u8, 206u8, 12u8],
            [246u8, 69u8, 238u8, 223u8],
            [252u8, 230u8, 152u8, 247u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for TeeModuleErrors {
        const NAME: &'static str = "TeeModuleErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 5usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ECDSAInvalidSignature(_) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureLength(_) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureS(_) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableInvalidOwner(_) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableUnauthorizedAccount(_) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<TeeModuleErrors>] = &[
                {
                    fn OwnableUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::OwnableUnauthorizedAccount)
                    }
                    OwnableUnauthorizedAccount
                },
                {
                    fn OwnableInvalidOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::OwnableInvalidOwner)
                    }
                    OwnableInvalidOwner
                },
                {
                    fn ECDSAInvalidSignatureS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::ECDSAInvalidSignatureS)
                    }
                    ECDSAInvalidSignatureS
                },
                {
                    fn ECDSAInvalidSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::ECDSAInvalidSignature)
                    }
                    ECDSAInvalidSignature
                },
                {
                    fn ECDSAInvalidSignatureLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::ECDSAInvalidSignatureLength)
                    }
                    ECDSAInvalidSignatureLength
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`TeeModule`](self) events.
    pub enum TeeModuleEvents {
        #[allow(missing_docs)]
        ChallengeResolved(ChallengeResolved),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
        #[allow(missing_docs)]
        TeeAppchainConfigHash(TeeAppchainConfigHash),
        #[allow(missing_docs)]
        TeeHacked(TeeHacked),
        #[allow(missing_docs)]
        TeeInput(TeeInput),
        #[allow(missing_docs)]
        TeeKeysRevoked(TeeKeysRevoked),
        #[allow(missing_docs)]
        TeeProgramAdded(TeeProgramAdded),
        #[allow(missing_docs)]
        TeeProgramRemoved(TeeProgramRemoved),
        #[allow(missing_docs)]
        TeeSeqConfigHash(TeeSeqConfigHash),
    }
    #[automatically_derived]
    impl TeeModuleEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                38u8,
                33u8,
                198u8,
                29u8,
                51u8,
                21u8,
                242u8,
                163u8,
                210u8,
                107u8,
                34u8,
                215u8,
                70u8,
                186u8,
                33u8,
                169u8,
                109u8,
                36u8,
                159u8,
                81u8,
                173u8,
                163u8,
                35u8,
                247u8,
                34u8,
                108u8,
                206u8,
                95u8,
                229u8,
                252u8,
                61u8,
                100u8,
            ],
            [
                55u8,
                232u8,
                173u8,
                214u8,
                148u8,
                197u8,
                146u8,
                109u8,
                86u8,
                78u8,
                151u8,
                17u8,
                96u8,
                245u8,
                151u8,
                65u8,
                3u8,
                203u8,
                187u8,
                199u8,
                201u8,
                7u8,
                71u8,
                196u8,
                198u8,
                248u8,
                2u8,
                3u8,
                29u8,
                53u8,
                103u8,
                167u8,
            ],
            [
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ],
            [
                145u8,
                9u8,
                43u8,
                207u8,
                85u8,
                9u8,
                33u8,
                227u8,
                129u8,
                232u8,
                31u8,
                6u8,
                105u8,
                51u8,
                32u8,
                83u8,
                75u8,
                20u8,
                74u8,
                126u8,
                86u8,
                28u8,
                95u8,
                192u8,
                143u8,
                25u8,
                64u8,
                213u8,
                8u8,
                168u8,
                92u8,
                220u8,
            ],
            [
                154u8,
                122u8,
                100u8,
                105u8,
                194u8,
                92u8,
                240u8,
                23u8,
                137u8,
                6u8,
                7u8,
                105u8,
                94u8,
                74u8,
                20u8,
                156u8,
                199u8,
                113u8,
                242u8,
                148u8,
                253u8,
                135u8,
                30u8,
                32u8,
                128u8,
                210u8,
                76u8,
                209u8,
                9u8,
                3u8,
                58u8,
                182u8,
            ],
            [
                185u8,
                235u8,
                32u8,
                179u8,
                47u8,
                172u8,
                150u8,
                88u8,
                132u8,
                203u8,
                88u8,
                50u8,
                97u8,
                2u8,
                37u8,
                124u8,
                174u8,
                96u8,
                69u8,
                4u8,
                240u8,
                163u8,
                108u8,
                209u8,
                0u8,
                138u8,
                50u8,
                132u8,
                90u8,
                213u8,
                194u8,
                155u8,
            ],
            [
                201u8,
                133u8,
                188u8,
                203u8,
                208u8,
                201u8,
                14u8,
                25u8,
                127u8,
                74u8,
                115u8,
                115u8,
                2u8,
                10u8,
                51u8,
                186u8,
                111u8,
                248u8,
                100u8,
                208u8,
                57u8,
                159u8,
                215u8,
                214u8,
                92u8,
                92u8,
                124u8,
                50u8,
                255u8,
                176u8,
                21u8,
                236u8,
            ],
            [
                228u8,
                46u8,
                175u8,
                7u8,
                55u8,
                226u8,
                71u8,
                138u8,
                95u8,
                90u8,
                237u8,
                58u8,
                6u8,
                16u8,
                174u8,
                123u8,
                9u8,
                162u8,
                124u8,
                186u8,
                201u8,
                173u8,
                106u8,
                92u8,
                196u8,
                214u8,
                143u8,
                120u8,
                175u8,
                209u8,
                66u8,
                91u8,
            ],
            [
                236u8,
                166u8,
                46u8,
                0u8,
                116u8,
                161u8,
                58u8,
                144u8,
                214u8,
                0u8,
                240u8,
                3u8,
                183u8,
                203u8,
                141u8,
                91u8,
                213u8,
                1u8,
                0u8,
                0u8,
                141u8,
                63u8,
                57u8,
                21u8,
                242u8,
                85u8,
                79u8,
                63u8,
                133u8,
                82u8,
                197u8,
                204u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for TeeModuleEvents {
        const NAME: &'static str = "TeeModuleEvents";
        const COUNT: usize = 9usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <ChallengeResolved as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ChallengeResolved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ChallengeResolved)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(
                    <TeeAppchainConfigHash as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <TeeAppchainConfigHash as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeAppchainConfigHash)
                }
                Some(<TeeHacked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TeeHacked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeHacked)
                }
                Some(<TeeInput as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TeeInput as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeInput)
                }
                Some(<TeeKeysRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TeeKeysRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeKeysRevoked)
                }
                Some(<TeeProgramAdded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TeeProgramAdded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeProgramAdded)
                }
                Some(
                    <TeeProgramRemoved as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <TeeProgramRemoved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeProgramRemoved)
                }
                Some(<TeeSeqConfigHash as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TeeSeqConfigHash as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeSeqConfigHash)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for TeeModuleEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChallengeResolved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeAppchainConfigHash(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeHacked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeInput(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeKeysRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeProgramAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeProgramRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeSeqConfigHash(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChallengeResolved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeAppchainConfigHash(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeHacked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeInput(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeKeysRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeProgramAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeProgramRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeSeqConfigHash(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`TeeModule`](self) contract instance.

See the [wrapper's documentation](`TeeModuleInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> TeeModuleInstance<T, P, N> {
        TeeModuleInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        poster_: alloy::sol_types::private::Address,
        bridge_: alloy::sol_types::private::Address,
        appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        appchainStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        seqConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        seqStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        l1StartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        l1block_: alloy::sol_types::private::Address,
        challengeWindowDuration_: u64,
        teeProgram: alloy::sol_types::private::FixedBytes<32>,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<TeeModuleInstance<T, P, N>>,
    > {
        TeeModuleInstance::<
            T,
            P,
            N,
        >::deploy(
            provider,
            poster_,
            bridge_,
            appchainConfigHash_,
            appchainStartBlockHash_,
            seqConfigHash_,
            seqStartBlockHash_,
            l1StartBlockHash_,
            l1block_,
            challengeWindowDuration_,
            teeProgram,
        )
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        poster_: alloy::sol_types::private::Address,
        bridge_: alloy::sol_types::private::Address,
        appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        appchainStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        seqConfigHash_: alloy::sol_types::private::FixedBytes<32>,
        seqStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        l1StartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        l1block_: alloy::sol_types::private::Address,
        challengeWindowDuration_: u64,
        teeProgram: alloy::sol_types::private::FixedBytes<32>,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        TeeModuleInstance::<
            T,
            P,
            N,
        >::deploy_builder(
            provider,
            poster_,
            bridge_,
            appchainConfigHash_,
            appchainStartBlockHash_,
            seqConfigHash_,
            seqStartBlockHash_,
            l1StartBlockHash_,
            l1block_,
            challengeWindowDuration_,
            teeProgram,
        )
    }
    /**A [`TeeModule`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`TeeModule`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct TeeModuleInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for TeeModuleInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("TeeModuleInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TeeModuleInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`TeeModule`](self) contract instance.

See the [wrapper's documentation](`TeeModuleInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            poster_: alloy::sol_types::private::Address,
            bridge_: alloy::sol_types::private::Address,
            appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
            appchainStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            seqConfigHash_: alloy::sol_types::private::FixedBytes<32>,
            seqStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            l1StartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            l1block_: alloy::sol_types::private::Address,
            challengeWindowDuration_: u64,
            teeProgram: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::Result<TeeModuleInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                poster_,
                bridge_,
                appchainConfigHash_,
                appchainStartBlockHash_,
                seqConfigHash_,
                seqStartBlockHash_,
                l1StartBlockHash_,
                l1block_,
                challengeWindowDuration_,
                teeProgram,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            poster_: alloy::sol_types::private::Address,
            bridge_: alloy::sol_types::private::Address,
            appchainConfigHash_: alloy::sol_types::private::FixedBytes<32>,
            appchainStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            seqConfigHash_: alloy::sol_types::private::FixedBytes<32>,
            seqStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            l1StartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            l1block_: alloy::sol_types::private::Address,
            challengeWindowDuration_: u64,
            teeProgram: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            poster_,
                            bridge_,
                            appchainConfigHash_,
                            appchainStartBlockHash_,
                            seqConfigHash_,
                            seqStartBlockHash_,
                            l1StartBlockHash_,
                            l1block_,
                            challengeWindowDuration_,
                            teeProgram,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> TeeModuleInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> TeeModuleInstance<T, P, N> {
            TeeModuleInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TeeModuleInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`addTeeKey`] function.
        pub fn addTeeKey(
            &self,
            publicKey: alloy::sol_types::private::Address,
            programHash: alloy::sol_types::private::FixedBytes<32>,
            zkProof: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, addTeeKeyCall, N> {
            self.call_builder(
                &addTeeKeyCall {
                    publicKey,
                    programHash,
                    zkProof,
                },
            )
        }
        ///Creates a new call builder for the [`addTeeProgram`] function.
        pub fn addTeeProgram(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, addTeeProgramCall, N> {
            self.call_builder(&addTeeProgramCall { hash })
        }
        ///Creates a new call builder for the [`bridge`] function.
        pub fn bridge(&self) -> alloy_contract::SolCallBuilder<T, &P, bridgeCall, N> {
            self.call_builder(&bridgeCall {})
        }
        ///Creates a new call builder for the [`challengeWindowDuration`] function.
        pub fn challengeWindowDuration(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, challengeWindowDurationCall, N> {
            self.call_builder(&challengeWindowDurationCall {})
        }
        ///Creates a new call builder for the [`challengeWindowEnd`] function.
        pub fn challengeWindowEnd(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, challengeWindowEndCall, N> {
            self.call_builder(&challengeWindowEndCall {})
        }
        ///Creates a new call builder for the [`closeChallengeWindow`] function.
        pub fn closeChallengeWindow(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, closeChallengeWindowCall, N> {
            self.call_builder(&closeChallengeWindowCall {})
        }
        ///Creates a new call builder for the [`isTeeKey`] function.
        pub fn isTeeKey(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isTeeKeyCall, N> {
            self.call_builder(&isTeeKeyCall { _0 })
        }
        ///Creates a new call builder for the [`l1block`] function.
        pub fn l1block(&self) -> alloy_contract::SolCallBuilder<T, &P, l1blockCall, N> {
            self.call_builder(&l1blockCall {})
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        ///Creates a new call builder for the [`pendingAssertions`] function.
        pub fn pendingAssertions(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, pendingAssertionsCall, N> {
            self.call_builder(&pendingAssertionsCall { _0 })
        }
        ///Creates a new call builder for the [`poster`] function.
        pub fn poster(&self) -> alloy_contract::SolCallBuilder<T, &P, posterCall, N> {
            self.call_builder(&posterCall {})
        }
        ///Creates a new call builder for the [`removeTeeProgram`] function.
        pub fn removeTeeProgram(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeTeeProgramCall, N> {
            self.call_builder(&removeTeeProgramCall { hash })
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall {})
        }
        ///Creates a new call builder for the [`resolveChallenge`] function.
        pub fn resolveChallenge(
            &self,
            assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, resolveChallengeCall, N> {
            self.call_builder(&resolveChallengeCall { assertion })
        }
        ///Creates a new call builder for the [`revokeAllTeeKeys`] function.
        pub fn revokeAllTeeKeys(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, revokeAllTeeKeysCall, N> {
            self.call_builder(&revokeAllTeeKeysCall {})
        }
        ///Creates a new call builder for the [`setAppchainConfigHash`] function.
        pub fn setAppchainConfigHash(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setAppchainConfigHashCall, N> {
            self.call_builder(&setAppchainConfigHashCall { hash })
        }
        ///Creates a new call builder for the [`setChallengeWindowDuration`] function.
        pub fn setChallengeWindowDuration(
            &self,
            duration: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, setChallengeWindowDurationCall, N> {
            self.call_builder(
                &setChallengeWindowDurationCall {
                    duration,
                },
            )
        }
        ///Creates a new call builder for the [`setSeqConfigHash`] function.
        pub fn setSeqConfigHash(
            &self,
            hash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setSeqConfigHashCall, N> {
            self.call_builder(&setSeqConfigHashCall { hash })
        }
        ///Creates a new call builder for the [`submitAssertion`] function.
        pub fn submitAssertion(
            &self,
            assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
            signature: alloy::sol_types::private::Bytes,
            rewardAddr: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, submitAssertionCall, N> {
            self.call_builder(
                &submitAssertionCall {
                    assertion,
                    signature,
                    rewardAddr,
                },
            )
        }
        ///Creates a new call builder for the [`teeHackCount`] function.
        pub fn teeHackCount(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeHackCountCall, N> {
            self.call_builder(&teeHackCountCall {})
        }
        ///Creates a new call builder for the [`teeProgramKeys`] function.
        pub fn teeProgramKeys(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
            _1: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeProgramKeysCall, N> {
            self.call_builder(&teeProgramKeysCall { _0, _1 })
        }
        ///Creates a new call builder for the [`teePrograms`] function.
        pub fn teePrograms(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeProgramsCall, N> {
            self.call_builder(&teeProgramsCall { _0 })
        }
        ///Creates a new call builder for the [`teeTrustedInput`] function.
        pub fn teeTrustedInput(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeTrustedInputCall, N> {
            self.call_builder(&teeTrustedInputCall {})
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TeeModuleInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`ChallengeResolved`] event.
        pub fn ChallengeResolved_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ChallengeResolved, N> {
            self.event_filter::<ChallengeResolved>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`TeeAppchainConfigHash`] event.
        pub fn TeeAppchainConfigHash_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeAppchainConfigHash, N> {
            self.event_filter::<TeeAppchainConfigHash>()
        }
        ///Creates a new event filter for the [`TeeHacked`] event.
        pub fn TeeHacked_filter(&self) -> alloy_contract::Event<T, &P, TeeHacked, N> {
            self.event_filter::<TeeHacked>()
        }
        ///Creates a new event filter for the [`TeeInput`] event.
        pub fn TeeInput_filter(&self) -> alloy_contract::Event<T, &P, TeeInput, N> {
            self.event_filter::<TeeInput>()
        }
        ///Creates a new event filter for the [`TeeKeysRevoked`] event.
        pub fn TeeKeysRevoked_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeKeysRevoked, N> {
            self.event_filter::<TeeKeysRevoked>()
        }
        ///Creates a new event filter for the [`TeeProgramAdded`] event.
        pub fn TeeProgramAdded_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeProgramAdded, N> {
            self.event_filter::<TeeProgramAdded>()
        }
        ///Creates a new event filter for the [`TeeProgramRemoved`] event.
        pub fn TeeProgramRemoved_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeProgramRemoved, N> {
            self.event_filter::<TeeProgramRemoved>()
        }
        ///Creates a new event filter for the [`TeeSeqConfigHash`] event.
        pub fn TeeSeqConfigHash_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeSeqConfigHash, N> {
            self.event_filter::<TeeSeqConfigHash>()
        }
    }
}
