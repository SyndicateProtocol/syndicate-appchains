/**

Generated by the following Solidity interface...
```solidity
interface TeeModule {
    struct PendingAssertion {
        bytes32 appBlockHash;
        bytes32 appSendRoot;
        bytes32 seqBlockHash;
        bytes32 l1BatchAcc;
    }
    struct TeeTrustedInput {
        bytes32 configHash;
        bytes32 appStartBlockHash;
        bytes32 seqStartBlockHash;
        bytes32 setDelayedMessageAcc;
        bytes32 l1StartBatchAcc;
        bytes32 l1EndHash;
    }

    error ECDSAInvalidSignature();
    error ECDSAInvalidSignatureLength(uint256 length);
    error ECDSAInvalidSignatureS(bytes32 s);
    error OwnableInvalidOwner(address owner);
    error OwnableUnauthorizedAccount(address account);
    error ReentrancyGuardReentrantCall();

    event ChallengeResolved(PendingAssertion);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event TeeConfigHash(bytes32 configHash);
    event TeeHacked(uint256);
    event TeeInput(TeeTrustedInput input);

    constructor(address poster_, address bridge_, bytes32 configHash_, bytes32 appStartBlockHash_, bytes32 seqStartBlockHash_, bytes32 l1StartBatchAcc_, address l1BlockOrBridge_, bool isL1Chain_, uint64 challengeWindowDuration_, address teeKeyManager_);

    receive() external payable;

    function bridge() external view returns (address);
    function challengeWindowDuration() external view returns (uint64);
    function challengeWindowEnd() external view returns (uint64);
    function closeChallengeWindow() external;
    function isL1Chain() external view returns (bool);
    function l1BlockOrBridge() external view returns (address);
    function owner() external view returns (address);
    function pendingAssertions(uint256) external view returns (bytes32 appBlockHash, bytes32 appSendRoot, bytes32 seqBlockHash, bytes32 l1BatchAcc);
    function poster() external view returns (address);
    function renounceOwnership() external;
    function resolveChallenge(PendingAssertion memory assertion) external;
    function submitAssertion(PendingAssertion memory assertion, bytes memory signature, address rewardAddr) external;
    function teeHackCount() external view returns (uint256);
    function teeKeyManager() external view returns (address);
    function teeTrustedInput() external view returns (bytes32 configHash, bytes32 appStartBlockHash, bytes32 seqStartBlockHash, bytes32 setDelayedMessageAcc, bytes32 l1StartBatchAcc, bytes32 l1EndHash);
    function transferOwnership(address newOwner) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "poster_",
        "type": "address",
        "internalType": "contract IAssertionPoster"
      },
      {
        "name": "bridge_",
        "type": "address",
        "internalType": "contract IBridge"
      },
      {
        "name": "configHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "appStartBlockHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "seqStartBlockHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "l1StartBatchAcc_",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "l1BlockOrBridge_",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "isL1Chain_",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "challengeWindowDuration_",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "teeKeyManager_",
        "type": "address",
        "internalType": "contract ITeeKeyManager"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "receive",
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "bridge",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IBridge"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "challengeWindowDuration",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "challengeWindowEnd",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "closeChallengeWindow",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "isL1Chain",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "l1BlockOrBridge",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pendingAssertions",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "appBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "appSendRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "seqBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "l1BatchAcc",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "poster",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IAssertionPoster"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "resolveChallenge",
    "inputs": [
      {
        "name": "assertion",
        "type": "tuple",
        "internalType": "struct PendingAssertion",
        "components": [
          {
            "name": "appBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "appSendRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "seqBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "l1BatchAcc",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "submitAssertion",
    "inputs": [
      {
        "name": "assertion",
        "type": "tuple",
        "internalType": "struct PendingAssertion",
        "components": [
          {
            "name": "appBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "appSendRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "seqBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "l1BatchAcc",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      },
      {
        "name": "signature",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "rewardAddr",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "teeHackCount",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "teeKeyManager",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract ITeeKeyManager"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "teeTrustedInput",
    "inputs": [],
    "outputs": [
      {
        "name": "configHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "appStartBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "seqStartBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "setDelayedMessageAcc",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "l1StartBatchAcc",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "l1EndHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "ChallengeResolved",
    "inputs": [
      {
        "name": "",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct PendingAssertion",
        "components": [
          {
            "name": "appBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "appSendRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "seqBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "l1BatchAcc",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeConfigHash",
    "inputs": [
      {
        "name": "configHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeHacked",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TeeInput",
    "inputs": [
      {
        "name": "input",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct TeeTrustedInput",
        "components": [
          {
            "name": "configHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "appStartBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "seqStartBlockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "setDelayedMessageAcc",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "l1StartBatchAcc",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "l1EndHash",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureLength",
    "inputs": [
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureS",
    "inputs": [
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "OwnableInvalidOwner",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OwnableUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ReentrancyGuardReentrantCall",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod TeeModule {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x610120604052346100b857610027610015610305565b989790979691969592959493946109dc565b61002f6100bd565b612dd3611c7d82396080518181816106e30152612102015260a05181818161094701528181611d080152611d3b015260c05181818161014301528181611e2401528181611e5f01528181611fcd015261220c015260e0518181816104c00152818161146101528181611bd60152611df70152610100518181816102ed01526113ea0152612dd390f35b6100c3565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906100ef906100c7565b810190811060018060401b0382111761010757604052565b6100d1565b9061011f6101186100bd565b92836100e5565b565b5f80fd5b60018060a01b031690565b61013990610125565b90565b61014590610130565b90565b6101518161013c565b0361015857565b5f80fd5b9050519061016982610148565b565b61017490610130565b90565b6101808161016b565b0361018757565b5f80fd5b9050519061019882610177565b565b90565b6101a68161019a565b036101ad57565b5f80fd5b905051906101be8261019d565b565b6101c981610130565b036101d057565b5f80fd5b905051906101e1826101c0565b565b151590565b6101f1816101e3565b036101f857565b5f80fd5b90505190610209826101e8565b565b60018060401b031690565b61021f8161020b565b0361022657565b5f80fd5b9050519061023782610216565b565b61024290610130565b90565b61024e81610239565b0361025557565b5f80fd5b9050519061026682610245565b565b610140818303126103005761027f825f830161015c565b9261028d836020840161018b565b9261029b81604085016101b1565b926102a982606083016101b1565b926102b783608084016101b1565b926102c58160a085016101b1565b926102d38260c083016101d4565b926102fd6102e48460e085016101fc565b936102f381610100860161022a565b9361012001610259565b90565b610121565b610323614a50803803806103188161010c565b928339810190610268565b90919293949596979899565b60401b90565b9061034f68010000000000000000600160801b039161032f565b9181191691161790565b90565b61037061036b6103759261020b565b610359565b61020b565b90565b90565b9061039061038b6103979261035c565b610378565b8254610335565b9055565b5f1b90565b906103ac5f199161039b565b9181191691161790565b6103bf9061019a565b90565b5f1c90565b6103d0906103c2565b90565b906103e86103e36103ef926103b6565b6103c7565b82546103a0565b9055565b6103fc9061019a565b9052565b9190610413905f602085019401906103f3565b565b61041f90516101e3565b90565b61042c9051610130565b90565b60209181520190565b5f7f756e6578706563746564206c3120626c6f636b20616464726573730000000000910152565b61046c601b60209261042f565b61047581610438565b0190565b61048e9060208101905f81830391015261045f565b90565b1561049857565b6104a06100bd565b62461bcd60e51b8152806104b660048201610479565b0390fd5b6104ce6104c96104d392610125565b610359565b610125565b90565b6104df906104ba565b90565b6104eb906104d6565b90565b6104f7906104ba565b90565b610503906104ee565b90565b5f80fd5b60e01b90565b9060208282031261052957610526915f0161022a565b90565b610121565b5f0190565b61053b6100bd565b3d5f823e3d90fd5b90565b61055a61055561055f92610543565b610359565b61020b565b90565b9060208282031261057b57610578915f016101b1565b90565b610121565b61059461058f61059992610543565b61039b565b61019a565b90565b5f7f6c3120626c6f636b20636f6e747261637420696e76616c696400000000000000910152565b6105d0601960209261042f565b6105d98161059c565b0190565b6105f29060208101905f8183039101526105c3565b90565b156105fc57565b6106046100bd565b62461bcd60e51b81528061061a600482016105dd565b0390fd5b5f7f756e657870656374656420736571206272696467652061646472657373000000910152565b610652601d60209261042f565b61065b8161061e565b0190565b6106749060208101905f818303910152610645565b90565b1561067e57565b6106866100bd565b62461bcd60e51b81528061069c6004820161065f565b0390fd5b6106a9906104ba565b90565b6106b5906106a0565b90565b6106c1906104ee565b90565b90565b6106d0816106c4565b036106d757565b5f80fd5b905051906106e8826106c7565b565b9060208282031261070357610700915f016106db565b90565b610121565b61071c61071761072192610543565b610359565b6106c4565b90565b60207f617374206f6e6520626174636800000000000000000000000000000000000000917f73657175656e63696e6720636861696e206d7573742068617665206174206c655f8201520152565b61077e602d60409261042f565b61078781610724565b0190565b6107a09060208101905f818303910152610771565b90565b156107aa57565b6107b26100bd565b62461bcd60e51b8152806107c86004820161078b565b0390fd5b6107d5906104ee565b90565b60207f20636f6465000000000000000000000000000000000000000000000000000000917f706f73746572206164647265737320646f6573206e6f74206861766520616e795f8201520152565b610832602560409261042f565b61083b816107d8565b0190565b6108549060208101905f818303910152610825565b90565b1561085e57565b6108666100bd565b62461bcd60e51b81528061087c6004820161083f565b0390fd5b60207f2062726964676500000000000000000000000000000000000000000000000000917f696e73756666696369656e742064656c61796564206d6573736167657320696e5f8201520152565b6108da602760409261042f565b6108e381610880565b0190565b6108fc9060208101905f8183039101526108cd565b90565b1561090657565b61090e6100bd565b62461bcd60e51b815280610924600482016108e7565b0390fd5b610931906104ee565b90565b60207f61766520616e7920636f64650000000000000000000000000000000000000000917f7465654b65794d616e61676572206164647265737320646f6573206e6f7420685f8201520152565b61098e602c60409261042f565b61099781610934565b0190565b6109b09060208101905f818303910152610981565b90565b156109ba57565b6109c26100bd565b62461bcd60e51b8152806109d86004820161099b565b0390fd5b9691929395909894976109f9906109f233610e5e565b600a61037b565b60c05260e052610a0c815f6002016103d3565b610a427fd266bca6281b20459ae52407bea3d134d9017bf8f3ba803cb7a11d724e2b2da691610a396100bd565b91829182610400565b0390a1610a4f60e0610415565b5f14610c5457610ac493610a93610a6660c0610422565b610a8c610a86734200000000000000000000000000000000000015610130565b91610130565b1415610677565b6020610aaf610aaa610aa560c0610422565b6106ac565b6106b8565b6284120c90610abc6100bd565b97889261050a565b82528180610ad46004820161052e565b03915afa948515610c4f57610b5195610b07915f91610c21575b50610b01610afb5f610708565b916106c4565b116107a3565b5b610b2d610b14826107cc565b3b610b27610b215f610708565b916106c4565b11610857565b6080526020610b3b876106b8565b63eca067ad90610b496100bd565b96879261050a565b82528180610b616004820161052e565b03915afa918215610c1c57610be496610b9b610bd194610bda975f91610bee575b50610b95610b8f5f610708565b916106c4565b116108ff565b60a052610bc3610baa82610928565b3b610bbd610bb75f610708565b916106c4565b116109b3565b6101005260016002016103d3565b600280016103d3565b60046002016103d3565b610bec611ae1565b565b610c0f915060203d8111610c15575b610c0781836100e5565b8101906106ea565b5f610b82565b503d610bfd565b610533565b610c42915060203d8111610c48575b610c3a81836100e5565b8101906106ea565b5f610aee565b503d610c30565b610533565b610c8d610c6160c0610422565b610c87610c81734200000000000000000000000000000000000015610130565b91610130565b14610491565b610cc26020610cac610ca7610ca260c0610422565b6104e2565b6104fa565b63b80777ea90610cba6100bd565b93849261050a565b82528180610cd26004820161052e565b03915afa908115610dee575f91610dc0575b50610cf7610cf15f610546565b9161020b565b119384610d10575b610d0b610b51956105f5565b610b08565b610d4794506020610d31610d2c610d2760c0610422565b6104e2565b6104fa565b6309bd5a6090610d3f6100bd565b97889261050a565b82528180610d576004820161052e565b03915afa948515610dbb57610b5195610d0b915f91610d8d575b50610d84610d7e5f610580565b9161019a565b11955050610cff565b610dae915060203d8111610db4575b610da681836100e5565b810190610562565b5f610d71565b503d610d9c565b610533565b610de1915060203d8111610de7575b610dd981836100e5565b810190610510565b5f610ce4565b503d610dcf565b610533565b90565b610e0a610e05610e0f92610df3565b610359565b6106c4565b90565b610e1c6001610df6565b90565b610e33610e2e610e38926106c4565b610359565b6106c4565b90565b90565b90610e53610e4e610e5a92610e1f565b610e3b565b82546103a0565b9055565b610e6790610ec5565b610e79610e72610e12565b6001610e3e565b565b610e8f610e8a610e9492610543565b610359565b610125565b90565b610ea090610e7b565b90565b610eac90610130565b9052565b9190610ec3905f60208501940190610ea3565b565b80610ee0610eda610ed55f610e97565b610130565b91610130565b14610ef057610eee90611b61565b565b610f13610efc5f610e97565b5f918291631e4fbdf760e01b835260048301610eb0565b0390fd5b610f1f611c10565b610f276114db565b610f2f611c68565b565b610f45610f40610f4a926106c4565b610359565b61020b565b90565b60018060401b031690565b610f64610f69916103c2565b610f4d565b90565b610f769054610f58565b90565b60207f696e73756666696369656e742074696d65206861732070617373656400000000917f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201520152565b610fd3603c60409261042f565b610fdc81610f79565b0190565b610ff59060208101905f818303910152610fc6565b90565b15610fff57565b6110076100bd565b62461bcd60e51b81528061101d60048201610fe0565b0390fd5b60401c90565b61103361103891611021565b610f4d565b90565b6110459054611027565b90565b634e487b7160e01b5f52601160045260245ffd5b61106861106e9161020b565b9161020b565b019060018060401b03821161107f57565b611048565b9061109560018060401b039161039b565b9181191691161790565b906110b46110af6110bb9261035c565b610378565b8254611084565b9055565b5490565b60207f746f6f206d616e7920617373657274696f6e7300000000000000000000000000917f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201520152565b61111d603360409261042f565b611126816110c3565b0190565b61113f9060208101905f818303910152611110565b90565b1561114957565b6111516100bd565b62461bcd60e51b8152806111676004820161112a565b0390fd5b634e487b7160e01b5f52603260045260245ffd5b5f5260205f2090565b611191816110bf565b8210156111ab576111a360049161117f565b910201905f90565b61116b565b90565b6111bf6111c4916103c2565b6111b0565b90565b6111d190546111b3565b90565b6111de905161013c565b90565b5f9103126111eb57565b610121565b91602061121192949361120a60408201965f8301906103f3565b01906103f3565b565b611222611228919392936106c4565b926106c4565b916112348382026106c4565b92818404149015171561124357565b611048565b611253906004611213565b90565b1b90565b9190600861127591029161126f5f1984611256565b92611256565b9181191691161790565b919061129561129061129d936103b6565b6103c7565b90835461125a565b9055565b5f90565b6112b7916112b16112a1565b9161127f565b565b5f60036112ec926112cc838083016112a5565b6112d983600183016112a5565b6112e683600283016112a5565b016112a5565b565b634e487b7160e01b5f525f60045260245ffd5b905f0361131357611311906112b9565b565b6112ee565b5b818110611324575050565b806113315f600493611301565b01611319565b9091828110611346575b505050565b61136461135e61135861136f95611248565b92611248565b9261117f565b918201910190611318565b5f8080611341565b906801000000000000000081116113a0578161139561139e936110bf565b90828155611337565b565b6100d1565b5f6113af91611377565b565b905f036113c3576113c1906113a5565b565b6112ee565b6113d2905161016b565b90565b6113e46113ea919392936106c4565b926106c4565b82039182116113f557565b611048565b611403906106c4565b9052565b919061141a905f602085019401906113fa565b565b6114259061019a565b9052565b9060a06114bc60056114c49461144d6114445f8301546111b3565b5f87019061141c565b61146761145d60018301546111b3565b602087019061141c565b61148161147760028301546111b3565b604087019061141c565b61149b61149160038301546111b3565b606087019061141c565b6114b56114ab60048301546111b3565b608087019061141c565b01546111b3565b91019061141c565b565b91906114d9905f60c08501940190611429565b565b6114e560e0610415565b5f14611a4e576115196114f742610f31565b5b61151361150d611508600a610f6c565b61020b565b9161020b565b11610ff8565b61153f61153861152842610f31565b611532600a61103b565b9061105c565b600a61109f565b61154960086110bf565b61155c6115566001610df6565b916106c4565b145f14611a245761158861157e600361157760085f90611188565b50016111c7565b60046002016103d3565b6115ac6115a3600261159c60085f90611188565b50016111c7565b600280016103d3565b6115b960016002016111c7565b6115e16115db6115d65f6115cf60088290611188565b50016111c7565b61019a565b9161019a565b0361193f575b6115f25f60086113b1565b5b61160561160060a06113c8565b6106b8565b61163763d5719dc2602061162161161c60a06113c8565b6106b8565b63eca067ad9061162f6100bd565b94859261050a565b825281806116476004820161052e565b03915afa92831561193a5761168c611677611697956020955f9161190d575b506116716001610df6565b906113d5565b926116806100bd565b9586948593849361050a565b835260048301611407565b03915afa8015611908576116b7915f916118da575b5060036002016103d3565b6116c160e0610415565b5f1461183d576116e16116dc6116d760c0610422565b6106ac565b6106b8565b61171a6316bf557960206117056117006116fb60c0610422565b6106ac565b6106b8565b6284120c906117126100bd565b94859261050a565b8252818061172a6004820161052e565b03915afa9283156118385761176f61175a61177a956020955f9161180b575b506117546001610df6565b906113d5565b926117636100bd565b9586948593849361050a565b835260048301611407565b03915afa80156118065761179a915f916117d8575b5060056002016103d3565b5b60026117d37f55232299d83faf4dc2c32e228af37632bca7fa6dbc03b41224c100c6c9dca349916117ca6100bd565b918291826114c6565b0390a1565b6117f9915060203d81116117ff575b6117f181836100e5565b810190610562565b5f61178f565b503d6117e7565b610533565b61182b9150863d8111611831575b61182381836100e5565b8101906106ea565b5f611749565b503d611819565b610533565b611872602061185c61185761185260c0610422565b6104e2565b6104fa565b6309bd5a609061186a6100bd565b93849261050a565b825281806118826004820161052e565b03915afa80156118d5576118a2915f916118a7575b5060056002016103d3565b61179b565b6118c8915060203d81116118ce575b6118c081836100e5565b810190610562565b5f611897565b503d6118b6565b610533565b6118fb915060203d8111611901575b6118f381836100e5565b810190610562565b5f6116ac565b503d6118e9565b610533565b61192d9150863d8111611933575b61192581836100e5565b8101906106ea565b5f611666565b503d61191b565b610533565b6119636119595f61195260088290611188565b50016111c7565b60016002016103d3565b61197561197060806111d4565b6107cc565b63daeab4126119915f61198a60088290611188565b50016111c7565b6119a960016119a260085f90611188565b50016111c7565b92803b15611a1f576119ce5f80946119d96119c26100bd565b9788968795869461050a565b8452600484016111f0565b03925af18015611a1a576119ee575b506115e7565b611a0d905f3d8111611a13575b611a0581836100e5565b8101906111e1565b5f6119e8565b503d6119fb565b610533565b610506565b611a49611a3160086110bf565b611a43611a3d5f610708565b916106c4565b14611142565b6115f3565b611a836020611a6d611a68611a6360c0610422565b6104e2565b6104fa565b63b80777ea90611a7b6100bd565b93849261050a565b82528180611a936004820161052e565b03915afa8015611adc57611519915f91611aae575b506114f8565b611acf915060203d8111611ad5575b611ac781836100e5565b810190610510565b5f611aa8565b503d611abd565b610533565b611ae9610f17565b565b60018060a01b031690565b611b02611b07916103c2565b611aeb565b90565b611b149054611af6565b90565b90611b2860018060a01b039161039b565b9181191691161790565b611b3b906104ee565b90565b90565b90611b56611b51611b5d92611b32565b611b3e565b8254611b17565b9055565b611b6a5f611b0a565b611b74825f611b41565b90611ba8611ba27f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e093611b32565b91611b32565b91611bb16100bd565b80611bbb8161052e565b0390a3565b90565b611bcf611bd4916103c2565b611bc0565b90565b611be19054611bc3565b90565b90565b611bfb611bf6611c0092611be4565b610359565b6106c4565b90565b611c0d6002611be7565b90565b611c1a6001611bd7565b611c33611c2d611c28611c03565b6106c4565b916106c4565b14611c4c57611c4a611c43611c03565b6001610e3e565b565b5f633ee5aeb560e01b815280611c646004820161052e565b0390fd5b611c7a611c73610e12565b6001610e3e565b56fe60806040526004361015610015575b36610a6157005b61001f5f3561011e565b806327d40299146101195780633183baac146101145780633a009a061461010f5780633ceaae7d1461010a578063470b9b1a146101055780634bd167c914610100578063697b5e62146100fb5780636c4c2060146100f6578063715018a6146100f157806380959721146100ec5780638da5cb5b146100e7578063a56ec6cd146100e2578063dc68cdfe146100dd578063e78cea92146100d8578063ee1c28b8146100d35763f2fde38b0361000e57610a2e565b6109db565b610997565b610912565b6108bb565b610768565b610733565b6106ae565b61067b565b610646565b6105b4565b610509565b610482565b610368565b6102b4565b61019e565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f91031261013c57565b61012e565b7f000000000000000000000000000000000000000000000000000000000000000090565b60018060a01b031690565b61017990610165565b90565b61018590610170565b9052565b919061019c905f6020850194019061017c565b565b346101ce576101ae366004610132565b6101ca6101b9610141565b6101c1610124565b91829182610189565b0390f35b61012a565b5f80fd5b5f80fd5b908160809103126101e95790565b6101d7565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156102345781359167ffffffffffffffff831161022f57602001926001830284011161022a57565b6101f6565b6101f2565b6101ee565b61024281610170565b0361024957565b5f80fd5b9050359061025a82610239565b565b9060c0828203126102aa57610273815f84016101db565b92608083013567ffffffffffffffff81116102a557610297836102a29286016101fa565b93909460a00161024d565b90565b6101d3565b61012e565b5f0190565b346102e6576102d06102c736600461025c565b929190916116b0565b6102d8610124565b806102e2816102af565b0390f35b61012a565b7f000000000000000000000000000000000000000000000000000000000000000090565b90565b61032661032161032b92610165565b61030f565b610165565b90565b61033790610312565b90565b6103439061032e565b90565b61034f9061033a565b9052565b9190610366905f60208501940190610346565b565b3461039857610378366004610132565b6103946103836102eb565b61038b610124565b91829182610353565b0390f35b61012a565b5f1c90565b90565b6103b16103b69161039d565b6103a2565b90565b6103c390546103a5565b90565b6002906103d45f83016103b9565b916103e1600182016103b9565b916103ee600283016103b9565b916103fb600382016103b9565b91610414600561040d600485016103b9565b93016103b9565b90565b90565b61042390610417565b9052565b919461046f6104799298979561046560a09661045b6104809a61045160c08a019e5f8b019061041a565b602089019061041a565b604087019061041a565b606085019061041a565b608083019061041a565b019061041a565b565b346104b957610492366004610132565b6104b561049d6103c6565b926104ac969496929192610124565b96879687610427565b0390f35b61012a565b7f000000000000000000000000000000000000000000000000000000000000000090565b151590565b6104f0906104e2565b9052565b9190610507905f602085019401906104e7565b565b3461053957610519366004610132565b6105356105246104be565b61052c610124565b918291826104f4565b0390f35b61012a565b1c90565b67ffffffffffffffff1690565b61055f906008610564930261053e565b610542565b90565b90610572915461054f565b90565b610582600a600890610567565b90565b67ffffffffffffffff1690565b61059b90610585565b9052565b91906105b2905f60208501940190610592565b565b346105e4576105c4366004610132565b6105e06105cf610575565b6105d7610124565b9182918261059f565b0390f35b61012a565b90565b6105fc906008610601930261053e565b6105e9565b90565b9061060f91546105ec565b90565b61061e60095f90610604565b90565b90565b61062d90610621565b9052565b9190610644905f60208501940190610624565b565b3461067657610656366004610132565b610672610661610612565b610669610124565b91829182610631565b0390f35b61012a565b346106a95761068b366004610132565b6106936122a9565b61069b610124565b806106a5816102af565b0390f35b61012a565b346106dc576106be366004610132565b6106c66122d8565b6106ce610124565b806106d8816102af565b0390f35b61012a565b7f000000000000000000000000000000000000000000000000000000000000000090565b61070e9061032e565b90565b61071a90610705565b9052565b9190610731905f60208501940190610711565b565b3461076357610743366004610132565b61075f61074e6106e1565b610756610124565b9182918261071e565b0390f35b61012a565b3461079857610778366004610132565b610794610783612312565b61078b610124565b91829182610189565b0390f35b61012a565b6107a681610621565b036107ad57565b5f80fd5b905035906107be8261079d565b565b906020828203126107d9576107d6915f016107b1565b90565b61012e565b634e487b7160e01b5f52603260045260245ffd5b5490565b5f5260205f2090565b610808816107f2565b8210156108225761081a6004916107f6565b910201905f90565b6107de565b600890610833826107f2565b81101561087957610843916107ff565b50906108505f83016103b9565b9161085d600182016103b9565b91610876600361086f600285016103b9565b93016103b9565b90565b5f80fd5b6108b26108b9946108a860609498979561089e608086019a5f87019061041a565b602085019061041a565b604083019061041a565b019061041a565b565b346108ef576108eb6108d66108d13660046107c0565b610827565b906108e2949294610124565b9485948561087d565b0390f35b61012a565b9060808282031261090d5761090a915f016101db565b90565b61012e565b346109405761092a6109253660046108f4565b612623565b610932610124565b8061093c816102af565b0390f35b61012a565b7f000000000000000000000000000000000000000000000000000000000000000090565b6109729061032e565b90565b61097e90610969565b9052565b9190610995905f60208501940190610975565b565b346109c7576109a7366004610132565b6109c36109b2610945565b6109ba610124565b91829182610982565b0390f35b61012a565b6109d8600a5f90610567565b90565b34610a0b576109eb366004610132565b610a076109f66109cc565b6109fe610124565b9182918261059f565b0390f35b61012a565b90602082820312610a2957610a26915f0161024d565b90565b61012e565b34610a5c57610a46610a41366004610a10565b612693565b610a4e610124565b80610a58816102af565b0390f35b61012a565b5f80fd5b90610a79939291610a746126ab565b61132c565b610a81612710565b565b90565b610a9a610a95610a9f92610a83565b61030f565b610165565b90565b610aab90610a86565b90565b60209181520190565b5f7f72657761726420616464726573732063616e6e6f74206265207a65726f000000910152565b610aeb601d602092610aae565b610af481610ab7565b0190565b610b0d9060208101905f818303910152610ade565b90565b15610b1757565b610b1f610124565b62461bcd60e51b815280610b3560048201610af8565b0390fd5b5090565b90565b610b54610b4f610b5992610b3d565b61030f565b610621565b90565b5f7f696e76616c6964207369676e6174757265206c656e6774680000000000000000910152565b610b906018602092610aae565b610b9981610b5c565b0190565b610bb29060208101905f818303910152610b83565b90565b15610bbc57565b610bc4610124565b62461bcd60e51b815280610bda60048201610b9d565b0390fd5b90565b90565b610bf0610bf591610417565b610be1565b9052565b602081610c0b610c1393839695610be4565b018092610be4565b0190565b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b90610c3f90610c17565b810190811067ffffffffffffffff821117610c5957604052565b610c21565b60200190565b5190565b5f80fd5b90610c7f610c78610124565b9283610c35565b565b67ffffffffffffffff8111610c9f57610c9b602091610c17565b0190565b610c21565b90825f939282370152565b90929192610cc4610cbf82610c81565b610c6c565b93818552602085019082840111610ce057610cde92610ca4565b565b610c68565b610cf0913691610caf565b90565b5f80fd5b60e01b90565b610d06816104e2565b03610d0d57565b5f80fd5b90505190610d1e82610cfd565b565b90602082820312610d3957610d36915f01610d11565b90565b61012e565b610d46610124565b3d5f823e3d90fd5b5f7f696e76616c696420746565207369676e61747572650000000000000000000000910152565b610d826015602092610aae565b610d8b81610d4e565b0190565b610da49060208101905f818303910152610d75565b90565b15610dae57565b610db6610124565b62461bcd60e51b815280610dcc60048201610d8f565b0390fd5b610dd981610417565b03610de057565b5f80fd5b35610dee81610dd0565b90565b5f7f756e6578706563746564206c3120656e64206261746368206163630000000000910152565b610e25601b602092610aae565b610e2e81610df1565b0190565b610e479060208101905f818303910152610e18565b90565b15610e5157565b610e59610124565b62461bcd60e51b815280610e6f60048201610e32565b0390fd5b610e87610e82610e8c92610a83565b61030f565b610621565b90565b6001610e9b9101610621565b90565b90565b5f7f617373657274696f6e20616c7265616479206578697374730000000000000000910152565b610ed56018602092610aae565b610ede81610ea1565b0190565b610ef79060208101905f818303910152610ec8565b90565b15610f0157565b610f09610124565b62461bcd60e51b815280610f1f60048201610ee2565b0390fd5b610f37610f32610f3c92610621565b61030f565b610585565b90565b60401c90565b610f51610f5691610f3f565b610542565b90565b610f639054610f45565b90565b634e487b7160e01b5f52601160045260245ffd5b610f86610f8c91610585565b91610585565b019067ffffffffffffffff8211610f9f57565b610f66565b5f1b90565b90610fbc67ffffffffffffffff91610fa4565b9181191691161790565b610fda610fd5610fdf92610585565b61030f565b610585565b90565b90565b90610ffa610ff561100192610fc6565b610fe2565b8254610fa9565b9055565b90565b5f5260205f2090565b5490565b61101e81611011565b82101561103857611030600491611008565b910201905f90565b6107de565b634e487b7160e01b5f525f60045260245ffd5b9061105c5f1991610fa4565b9181191691161790565b61106f90610417565b90565b61107b9061039d565b90565b9061109361108e61109a92611066565b611072565b8254611050565b9055565b906110fb60606003611101946110c15f82016110bb5f8801610de4565b9061107e565b6110da600182016110d460208801610de4565b9061107e565b6110f3600282016110ed60408801610de4565b9061107e565b019201610de4565b9061107e565b565b9190611114576111129161109e565b565b61103d565b1b90565b908154916801000000000000000083101561114d578261114591600161114b95018155611015565b90611103565b565b610c21565b90565b61116961116461116e92611152565b61030f565b610621565b90565b90565b61118861118361118d92611171565b61030f565b610621565b90565b61119c6111a19161039d565b6105e9565b90565b6111ae9054611190565b90565b6111c06111c691939293610621565b92610621565b82018092116111d157565b610f66565b6111ea6111e56111ef92610621565b61030f565b610621565b90565b90565b9061120a611205611211926111d6565b6111f2565b8254611050565b9055565b61121e90610312565b90565b61122a90611215565b90565b6112369061032e565b90565b6112429061032e565b90565b905090565b6112555f8092611245565b0190565b6112629061124a565b90565b9061127761127283610c81565b610c6c565b918252565b606090565b3d5f1461129c576112913d611265565b903d5f602084013e5b565b6112a461127c565b9061129a565b5f7f7061796d656e74206661696c6564000000000000000000000000000000000000910152565b6112de600e602092610aae565b6112e7816112aa565b0190565b6113009060208101905f8183039101526112d1565b90565b1561130a57565b611312610124565b62461bcd60e51b815280611328600482016112eb565b0390fd5b929060206114419195939561135c8461135561134f61134a5f610aa2565b610170565b91610170565b1415610b10565b61138361136a828990610b39565b61137d6113776041610b40565b91610621565b14610bb5565b61138c8661275c565b966114366114216113a56113a06002610bde565b612828565b6113ce8b916113c06113b5610124565b9384928a8401610bf9565b888201810382520382610c35565b6113e06113da82610c64565b91610c5e565b209361141b61140e7f000000000000000000000000000000000000000000000000000000000000000061033a565b94637217efcd9692610ce5565b906128ba565b9261142a610124565b95869485938493610cf7565b835260048301610189565b03915afa80156116ab5761145c915f9161167d575b50610da7565b6114867f0000000000000000000000000000000000000000000000000000000000000000156104e2565b8015611647575b61149690610e4a565b61149f5f610e73565b5b806114bc6114b66114b160086107f2565b610621565b91610621565b101561150957611504906114ff866114f86114f26114ed6114e86114e2600888906107ff565b50610e9e565b6128dc565b610417565b91610417565b1415610efa565b610e8f565b6114a0565b509161154291935061151b60086107f2565b61152d6115275f610e73565b91610621565b1461161c575b61153d6008611005565b61111d565b61154c60086107f2565b61155f6115596002611155565b91610621565b14611568575b50565b5f806115e76115e26116169461159a6115936115846001611174565b61158e60096111a4565b6111b1565b60096111f5565b6115a460096111a4565b6115da7f37e8add694c5926d564e971160f5974103cbbbc7c90747c4c6f802031d3567a7916115d1610124565b91829182610631565b0390a1611221565b61122d565b6115f030611239565b316115f9610124565b908161160481611259565b03925af1611610611281565b50611303565b5f611565565b61164261163b61162b42610f23565b611635600a610f59565b90610f7a565b600a610fe5565b611533565b5061149661165760608501610de4565b61167561166f61166a60056002016103b9565b610417565b91610417565b14905061148d565b61169e915060203d81116116a4575b6116968183610c35565b810190610d20565b5f611456565b503d61168c565b610d3e565b906116bc939291610a65565b565b6116c66126ab565b6116ce611bd4565b6116d6612710565b565b6116e190610312565b90565b6116ed906116d8565b90565b6116f99061032e565b90565b61170581610585565b0361170c57565b5f80fd5b9050519061171d826116fc565b565b9060208282031261173857611735915f01611710565b90565b61012e565b61174961174e9161039d565b610542565b90565b61175b905461173d565b90565b60207f696e73756666696369656e742074696d65206861732070617373656400000000917f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201520152565b6117b8603c604092610aae565b6117c18161175e565b0190565b6117da9060208101905f8183039101526117ab565b90565b156117e457565b6117ec610124565b62461bcd60e51b815280611802600482016117c5565b0390fd5b60207f746f6f206d616e7920617373657274696f6e7300000000000000000000000000917f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201520152565b6118606033604092610aae565b61186981611806565b0190565b6118829060208101905f818303910152611853565b90565b1561188c57565b611894610124565b62461bcd60e51b8152806118aa6004820161186d565b0390fd5b5f9103126118b857565b61012e565b9160206118de9294936118d760408201965f83019061041a565b019061041a565b565b6118ef6118f591939293610621565b92610621565b91611901838202610621565b92818404149015171561191057565b610f66565b6119209060046118e0565b90565b9190600861193e9102916119385f1984611119565b92611119565b9181191691161790565b919061195e61195961196693611066565b611072565b908354611923565b9055565b5f90565b6119809161197a61196a565b91611948565b565b5f60036119b5926119958380830161196e565b6119a2836001830161196e565b6119af836002830161196e565b0161196e565b565b905f036119c9576119c790611982565b565b61103d565b5b8181106119da575050565b806119e75f6004936119b7565b016119cf565b90918281106119fc575b505050565b611a1a611a14611a0e611a2595611915565b92611915565b926107f6565b9182019101906119ce565b5f80806119f7565b90680100000000000000008111611a565781611a4b611a54936107f2565b908281556119ed565b565b610c21565b5f611a6591611a2d565b565b905f03611a7957611a7790611a5b565b565b61103d565b90505190611a8b8261079d565b565b90602082820312611aa657611aa3915f01611a7e565b90565b61012e565b611aba611ac091939293610621565b92610621565b8203918211611acb57565b610f66565b90505190611add82610dd0565b565b90602082820312611af857611af5915f01611ad0565b90565b61012e565b611b0690610312565b90565b611b1290611afd565b90565b611b1e90610417565b9052565b9060a0611bb56005611bbd94611b46611b3d5f8301546103a5565b5f870190611b15565b611b60611b5660018301546103a5565b6020870190611b15565b611b7a611b7060028301546103a5565b6040870190611b15565b611b94611b8a60038301546103a5565b6060870190611b15565b611bae611ba460048301546103a5565b6080870190611b15565b01546103a5565b910190611b15565b565b9190611bd2905f60c08501940190611b22565b565b7f00000000000000000000000000000000000000000000000000000000000000005f146121ff57611c29611c0742610f23565b5b611c23611c1d611c18600a611751565b610585565b91610585565b116117dd565b611c4f611c48611c3842610f23565b611c42600a610f59565b90610f7a565b600a610fe5565b611c5960086107f2565b611c6c611c666001611174565b91610621565b145f146121d557611c98611c8e6003611c8760085f906107ff565b50016103b9565b600460020161107e565b611cbc611cb36002611cac60085f906107ff565b50016103b9565b6002800161107e565b611cc960016002016103b9565b611cf1611ceb611ce65f611cdf600882906107ff565b50016103b9565b610417565b91610417565b036120d9575b611d025f6008611a67565b5b611d2c7f0000000000000000000000000000000000000000000000000000000000000000610969565b611d7563d5719dc26020611d5f7f0000000000000000000000000000000000000000000000000000000000000000610969565b63eca067ad90611d6d610124565b948592610cf7565b82528180611d85600482016102af565b03915afa9283156120d457611dca611db5611dd5956020955f916120a7575b50611daf6001611174565b90611aab565b92611dbe610124565b95869485938493610cf7565b835260048301610631565b03915afa80156120a257611df5915f91612074575b50600360020161107e565b7f00000000000000000000000000000000000000000000000000000000000000005f14611fc057611e4d611e487f0000000000000000000000000000000000000000000000000000000000000000611b09565b610969565b611e9d6316bf55796020611e88611e837f0000000000000000000000000000000000000000000000000000000000000000611b09565b610969565b6284120c90611e95610124565b948592610cf7565b82528180611ead600482016102af565b03915afa928315611fbb57611ef2611edd611efd956020955f91611f8e575b50611ed76001611174565b90611aab565b92611ee6610124565b95869485938493610cf7565b835260048301610631565b03915afa8015611f8957611f1d915f91611f5b575b50600560020161107e565b5b6002611f567f55232299d83faf4dc2c32e228af37632bca7fa6dbc03b41224c100c6c9dca34991611f4d610124565b91829182611bbf565b0390a1565b611f7c915060203d8111611f82575b611f748183610c35565b810190611adf565b5f611f12565b503d611f6a565b610d3e565b611fae9150863d8111611fb4575b611fa68183610c35565b810190611a8d565b5f611ecc565b503d611f9c565b610d3e565b61200c6020611ff6611ff17f00000000000000000000000000000000000000000000000000000000000000006116e4565b6116f0565b6309bd5a6090612004610124565b938492610cf7565b8252818061201c600482016102af565b03915afa801561206f5761203c915f91612041575b50600560020161107e565b611f1e565b612062915060203d8111612068575b61205a8183610c35565b810190611adf565b5f612031565b503d612050565b610d3e565b612095915060203d811161209b575b61208d8183610c35565b810190611adf565b5f611dea565b503d612083565b610d3e565b6120c79150863d81116120cd575b6120bf8183610c35565b810190611a8d565b5f611da4565b503d6120b5565b610d3e565b6120fd6120f35f6120ec600882906107ff565b50016103b9565b600160020161107e565b6121267f0000000000000000000000000000000000000000000000000000000000000000610705565b63daeab4126121425f61213b600882906107ff565b50016103b9565b61215a600161215360085f906107ff565b50016103b9565b92803b156121d05761217f5f809461218a612173610124565b97889687958694610cf7565b8452600484016118bd565b03925af180156121cb5761219f575b50611cf7565b6121be905f3d81116121c4575b6121b68183610c35565b8101906118ae565b5f612199565b503d6121ac565b610d3e565b610cf3565b6121fa6121e260086107f2565b6121f46121ee5f610e73565b91610621565b14611885565b611d03565b61224b60206122356122307f00000000000000000000000000000000000000000000000000000000000000006116e4565b6116f0565b63b80777ea90612243610124565b938492610cf7565b8252818061225b600482016102af565b03915afa80156122a457611c29915f91612276575b50611c08565b612297915060203d811161229d575b61228f8183610c35565b81019061171f565b5f612270565b503d612285565b610d3e565b6122b16116be565b565b6122bb612955565b6122c36122c5565b565b6122d66122d15f610aa2565b6129ed565b565b6122e06122b3565b565b5f90565b60018060a01b031690565b6122fd6123029161039d565b6122e6565b90565b61230f90546122f1565b90565b61231a6122e2565b506123245f612305565b90565b61233890612333612955565b61233a565b565b61234b906123466126ab565b6124eb565b612353612710565b565b5f7f6368616c6c656e676520646f6573206e6f742065786973740000000000000000910152565b6123896018602092610aae565b61239281612355565b0190565b6123ab9060208101905f81830391015261237c565b90565b156123b557565b6123bd610124565b62461bcd60e51b8152806123d360048201612396565b0390fd5b6123eb6123e66123f092610a83565b61030f565b610585565b90565b9050359061240082610dd0565b565b506124119060208101906123f3565b90565b90606061247361247b9361243661242d5f830183612402565b5f860190611b15565b6124506124466020830183612402565b6020860190611b15565b61246a6124606040830183612402565b6040860190611b15565b82810190612402565b910190611b15565b565b9190612490905f60808501940190612414565b565b5f7f617373657274696f6e206e6f7420666f756e6400000000000000000000000000910152565b6124c66013602092610aae565b6124cf81612492565b0190565b6124e89060208101905f8183039101526124b9565b90565b6125116124f860086107f2565b61250b6125056001611174565b91610621565b116123ae565b61251a8161275c565b906125245f610e73565b5b8061254161253b61253660086107f2565b610621565b91610621565b1015612601578261257661257061256b612566612560600887906107ff565b50610e9e565b6128dc565b610417565b91610417565b146125895761258490610e8f565b612525565b5090506125975f6008611a67565b6125ab6125a46008611005565b829061111d565b6125be6125b75f6123d7565b600a610fe5565b6125c66122a9565b6125fc7f2020542b6e6b951d4c0736eed2a4d762d20bb1ba579f99feffae9b1dea240883916125f3610124565b9182918261247d565b0390a1565b612609610124565b62461bcd60e51b81528061261f600482016124d3565b0390fd5b61262c90612327565b565b61263f9061263a612955565b612641565b565b8061265c6126566126515f610aa2565b610170565b91610170565b1461266c5761266a906129ed565b565b61268f6126785f610aa2565b5f918291631e4fbdf760e01b835260048301610189565b0390fd5b61269c9061262e565b565b6126a86002611155565b90565b6126b560016111a4565b6126ce6126c86126c361269e565b610621565b91610621565b146126e7576126e56126de61269e565b60016111f5565b565b5f633ee5aeb560e01b8152806126ff600482016102af565b0390fd5b61270d6001611174565b90565b61272261271b612703565b60016111f5565b565b926127506020612758946127488288612740829b9a8399610be4565b018092610be4565b018092610be4565b018092610be4565b0190565b61276461196a565b506127bf6127735f8301610de4565b6127b061278260208501610de4565b9361279b606061279460408401610de4565b9201610de4565b906127a4610124565b95869460208601612724565b60208201810382520382610c35565b6127d16127cb82610c64565b91610c5e565b2090565b612824946128146020809998959661280c82809961280482896127fc829b61281c9d610be4565b018092610be4565b018092610be4565b018092610be4565b018092610be4565b018092610be4565b0190565b61283061196a565b506128a461283f5f83016103b9565b61289561284e600185016103b9565b9361285b600282016103b9565b90612868600382016103b9565b6128806005612879600485016103b9565b93016103b9565b92612889610124565b978896602088016127d5565b60208201810382520382610c35565b6128b66128b082610c64565b91610c5e565b2090565b6128d9916128d0916128ca6122e2565b50612a70565b90929192612b6d565b90565b6128e461196a565b5061293f6128f35f83016103b9565b612930612902600185016103b9565b9361291b6003612914600284016103b9565b92016103b9565b90612924610124565b95869460208601612724565b60208201810382520382610c35565b61295161294b82610c64565b91610c5e565b2090565b61295d612312565b61297661297061296b612c3e565b610170565b91610170565b0361297d57565b61299f612988612c3e565b5f91829163118cdaa760e01b835260048301610189565b0390fd5b906129b460018060a01b0391610fa4565b9181191691161790565b6129c79061032e565b90565b90565b906129e26129dd6129e9926129be565b6129ca565b82546129a3565b9055565b6129f65f612305565b612a00825f6129cd565b90612a34612a2e7f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0936129be565b916129be565b91612a3d610124565b80612a47816102af565b0390a3565b5f90565b612a64612a5f612a6992610621565b610fa4565b610417565b90565b5f90565b919091612a7b6122e2565b50612a84612a4c565b50612a8d61196a565b50612a9783610c64565b612aaa612aa46041610b40565b91610621565b145f14612af157612aea9192612abe61196a565b50612ac761196a565b50612ad0612a6c565b506020810151606060408301519201515f1a909192612cd7565b9192909190565b50612afb5f610aa2565b90612b0f612b0a600294610c64565b612a50565b91929190565b634e487b7160e01b5f52602160045260245ffd5b60041115612b3357565b612b15565b90612b4282612b29565b565b9190612b57905f6020850194019061041a565b565b612b65612b6a9161039d565b6111d6565b90565b80612b80612b7a5f612b38565b91612b38565b145f14612b8b575050565b80612b9f612b996001612b38565b91612b38565b145f14612bc2575f63f645eedf60e01b815280612bbe600482016102af565b0390fd5b80612bd6612bd06002612b38565b91612b38565b145f14612c0457612c00612be983612b59565b5f91829163fce698f760e01b835260048301610631565b0390fd5b612c17612c116003612b38565b91612b38565b14612c1f5750565b612c3a905f9182916335e2f38360e21b835260048301612b44565b0390fd5b612c466122e2565b503390565b90565b612c62612c5d612c6792612c4b565b61030f565b610621565b90565b60ff1690565b612c7990612c6a565b9052565b612cb2612cb994612ca8606094989795612c9e608086019a5f87019061041a565b6020850190612c70565b604083019061041a565b019061041a565b565b612ccf612cca612cd492610a83565b610fa4565b610417565b90565b939293612ce26122e2565b50612ceb612a4c565b50612cf461196a565b50612cfe85612b59565b612d30612d2a7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0612c4e565b91610621565b11612dbd5790612d53602094955f94939293612d4a610124565b94859485612c7d565b838052039060015afa15612db857612d6b5f51610fa4565b80612d86612d80612d7b5f610aa2565b610170565b91610170565b14612d9c575f91612d965f612cbb565b91929190565b50612da65f610aa2565b600191612db25f612cbb565b91929190565b610d3e565b505050612dc95f610aa2565b906003929192919056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x01 `@R4a\0\xB8Wa\0'a\0\x15a\x03\x05V[\x98\x97\x90\x97\x96\x91\x96\x95\x92\x95\x94\x93\x94a\t\xDCV[a\0/a\0\xBDV[a-\xD3a\x1C}\x829`\x80Q\x81\x81\x81a\x06\xE3\x01Ra!\x02\x01R`\xA0Q\x81\x81\x81a\tG\x01R\x81\x81a\x1D\x08\x01Ra\x1D;\x01R`\xC0Q\x81\x81\x81a\x01C\x01R\x81\x81a\x1E$\x01R\x81\x81a\x1E_\x01R\x81\x81a\x1F\xCD\x01Ra\"\x0C\x01R`\xE0Q\x81\x81\x81a\x04\xC0\x01R\x81\x81a\x14a\x01R\x81\x81a\x1B\xD6\x01Ra\x1D\xF7\x01Ra\x01\0Q\x81\x81\x81a\x02\xED\x01Ra\x13\xEA\x01Ra-\xD3\x90\xF3[a\0\xC3V[`@Q\x90V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\0\xEF\x90a\0\xC7V[\x81\x01\x90\x81\x10`\x01\x80`@\x1B\x03\x82\x11\x17a\x01\x07W`@RV[a\0\xD1V[\x90a\x01\x1Fa\x01\x18a\0\xBDV[\x92\x83a\0\xE5V[V[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x019\x90a\x01%V[\x90V[a\x01E\x90a\x010V[\x90V[a\x01Q\x81a\x01<V[\x03a\x01XWV[_\x80\xFD[\x90PQ\x90a\x01i\x82a\x01HV[V[a\x01t\x90a\x010V[\x90V[a\x01\x80\x81a\x01kV[\x03a\x01\x87WV[_\x80\xFD[\x90PQ\x90a\x01\x98\x82a\x01wV[V[\x90V[a\x01\xA6\x81a\x01\x9AV[\x03a\x01\xADWV[_\x80\xFD[\x90PQ\x90a\x01\xBE\x82a\x01\x9DV[V[a\x01\xC9\x81a\x010V[\x03a\x01\xD0WV[_\x80\xFD[\x90PQ\x90a\x01\xE1\x82a\x01\xC0V[V[\x15\x15\x90V[a\x01\xF1\x81a\x01\xE3V[\x03a\x01\xF8WV[_\x80\xFD[\x90PQ\x90a\x02\t\x82a\x01\xE8V[V[`\x01\x80`@\x1B\x03\x16\x90V[a\x02\x1F\x81a\x02\x0BV[\x03a\x02&WV[_\x80\xFD[\x90PQ\x90a\x027\x82a\x02\x16V[V[a\x02B\x90a\x010V[\x90V[a\x02N\x81a\x029V[\x03a\x02UWV[_\x80\xFD[\x90PQ\x90a\x02f\x82a\x02EV[V[a\x01@\x81\x83\x03\x12a\x03\0Wa\x02\x7F\x82_\x83\x01a\x01\\V[\x92a\x02\x8D\x83` \x84\x01a\x01\x8BV[\x92a\x02\x9B\x81`@\x85\x01a\x01\xB1V[\x92a\x02\xA9\x82``\x83\x01a\x01\xB1V[\x92a\x02\xB7\x83`\x80\x84\x01a\x01\xB1V[\x92a\x02\xC5\x81`\xA0\x85\x01a\x01\xB1V[\x92a\x02\xD3\x82`\xC0\x83\x01a\x01\xD4V[\x92a\x02\xFDa\x02\xE4\x84`\xE0\x85\x01a\x01\xFCV[\x93a\x02\xF3\x81a\x01\0\x86\x01a\x02*V[\x93a\x01 \x01a\x02YV[\x90V[a\x01!V[a\x03#aJP\x808\x03\x80a\x03\x18\x81a\x01\x0CV[\x92\x839\x81\x01\x90a\x02hV[\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99V[`@\x1B\x90V[\x90a\x03Oh\x01\0\0\0\0\0\0\0\0`\x01`\x80\x1B\x03\x91a\x03/V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[a\x03pa\x03ka\x03u\x92a\x02\x0BV[a\x03YV[a\x02\x0BV[\x90V[\x90V[\x90a\x03\x90a\x03\x8Ba\x03\x97\x92a\x03\\V[a\x03xV[\x82Ta\x035V[\x90UV[_\x1B\x90V[\x90a\x03\xAC_\x19\x91a\x03\x9BV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x03\xBF\x90a\x01\x9AV[\x90V[_\x1C\x90V[a\x03\xD0\x90a\x03\xC2V[\x90V[\x90a\x03\xE8a\x03\xE3a\x03\xEF\x92a\x03\xB6V[a\x03\xC7V[\x82Ta\x03\xA0V[\x90UV[a\x03\xFC\x90a\x01\x9AV[\x90RV[\x91\x90a\x04\x13\x90_` \x85\x01\x94\x01\x90a\x03\xF3V[V[a\x04\x1F\x90Qa\x01\xE3V[\x90V[a\x04,\x90Qa\x010V[\x90V[` \x91\x81R\x01\x90V[_\x7Funexpected l1 block address\0\0\0\0\0\x91\x01RV[a\x04l`\x1B` \x92a\x04/V[a\x04u\x81a\x048V[\x01\x90V[a\x04\x8E\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x04_V[\x90V[\x15a\x04\x98WV[a\x04\xA0a\0\xBDV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x04\xB6`\x04\x82\x01a\x04yV[\x03\x90\xFD[a\x04\xCEa\x04\xC9a\x04\xD3\x92a\x01%V[a\x03YV[a\x01%V[\x90V[a\x04\xDF\x90a\x04\xBAV[\x90V[a\x04\xEB\x90a\x04\xD6V[\x90V[a\x04\xF7\x90a\x04\xBAV[\x90V[a\x05\x03\x90a\x04\xEEV[\x90V[_\x80\xFD[`\xE0\x1B\x90V[\x90` \x82\x82\x03\x12a\x05)Wa\x05&\x91_\x01a\x02*V[\x90V[a\x01!V[_\x01\x90V[a\x05;a\0\xBDV[=_\x82>=\x90\xFD[\x90V[a\x05Za\x05Ua\x05_\x92a\x05CV[a\x03YV[a\x02\x0BV[\x90V[\x90` \x82\x82\x03\x12a\x05{Wa\x05x\x91_\x01a\x01\xB1V[\x90V[a\x01!V[a\x05\x94a\x05\x8Fa\x05\x99\x92a\x05CV[a\x03\x9BV[a\x01\x9AV[\x90V[_\x7Fl1 block contract invalid\0\0\0\0\0\0\0\x91\x01RV[a\x05\xD0`\x19` \x92a\x04/V[a\x05\xD9\x81a\x05\x9CV[\x01\x90V[a\x05\xF2\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x05\xC3V[\x90V[\x15a\x05\xFCWV[a\x06\x04a\0\xBDV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x06\x1A`\x04\x82\x01a\x05\xDDV[\x03\x90\xFD[_\x7Funexpected seq bridge address\0\0\0\x91\x01RV[a\x06R`\x1D` \x92a\x04/V[a\x06[\x81a\x06\x1EV[\x01\x90V[a\x06t\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x06EV[\x90V[\x15a\x06~WV[a\x06\x86a\0\xBDV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x06\x9C`\x04\x82\x01a\x06_V[\x03\x90\xFD[a\x06\xA9\x90a\x04\xBAV[\x90V[a\x06\xB5\x90a\x06\xA0V[\x90V[a\x06\xC1\x90a\x04\xEEV[\x90V[\x90V[a\x06\xD0\x81a\x06\xC4V[\x03a\x06\xD7WV[_\x80\xFD[\x90PQ\x90a\x06\xE8\x82a\x06\xC7V[V[\x90` \x82\x82\x03\x12a\x07\x03Wa\x07\0\x91_\x01a\x06\xDBV[\x90V[a\x01!V[a\x07\x1Ca\x07\x17a\x07!\x92a\x05CV[a\x03YV[a\x06\xC4V[\x90V[` \x7Fast one batch\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7Fsequencing chain must have at le_\x82\x01R\x01RV[a\x07~`-`@\x92a\x04/V[a\x07\x87\x81a\x07$V[\x01\x90V[a\x07\xA0\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x07qV[\x90V[\x15a\x07\xAAWV[a\x07\xB2a\0\xBDV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x07\xC8`\x04\x82\x01a\x07\x8BV[\x03\x90\xFD[a\x07\xD5\x90a\x04\xEEV[\x90V[` \x7F code\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7Fposter address does not have any_\x82\x01R\x01RV[a\x082`%`@\x92a\x04/V[a\x08;\x81a\x07\xD8V[\x01\x90V[a\x08T\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x08%V[\x90V[\x15a\x08^WV[a\x08fa\0\xBDV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x08|`\x04\x82\x01a\x08?V[\x03\x90\xFD[` \x7F bridge\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7Finsufficient delayed messages in_\x82\x01R\x01RV[a\x08\xDA`'`@\x92a\x04/V[a\x08\xE3\x81a\x08\x80V[\x01\x90V[a\x08\xFC\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x08\xCDV[\x90V[\x15a\t\x06WV[a\t\x0Ea\0\xBDV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\t$`\x04\x82\x01a\x08\xE7V[\x03\x90\xFD[a\t1\x90a\x04\xEEV[\x90V[` \x7Fave any code\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FteeKeyManager address does not h_\x82\x01R\x01RV[a\t\x8E`,`@\x92a\x04/V[a\t\x97\x81a\t4V[\x01\x90V[a\t\xB0\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\t\x81V[\x90V[\x15a\t\xBAWV[a\t\xC2a\0\xBDV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\t\xD8`\x04\x82\x01a\t\x9BV[\x03\x90\xFD[\x96\x91\x92\x93\x95\x90\x98\x94\x97a\t\xF9\x90a\t\xF23a\x0E^V[`\na\x03{V[`\xC0R`\xE0Ra\n\x0C\x81_`\x02\x01a\x03\xD3V[a\nB\x7F\xD2f\xBC\xA6(\x1B E\x9A\xE5$\x07\xBE\xA3\xD14\xD9\x01{\xF8\xF3\xBA\x80<\xB7\xA1\x1DrN+-\xA6\x91a\n9a\0\xBDV[\x91\x82\x91\x82a\x04\0V[\x03\x90\xA1a\nO`\xE0a\x04\x15V[_\x14a\x0CTWa\n\xC4\x93a\n\x93a\nf`\xC0a\x04\"V[a\n\x8Ca\n\x86sB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15a\x010V[\x91a\x010V[\x14\x15a\x06wV[` a\n\xAFa\n\xAAa\n\xA5`\xC0a\x04\"V[a\x06\xACV[a\x06\xB8V[b\x84\x12\x0C\x90a\n\xBCa\0\xBDV[\x97\x88\x92a\x05\nV[\x82R\x81\x80a\n\xD4`\x04\x82\x01a\x05.V[\x03\x91Z\xFA\x94\x85\x15a\x0COWa\x0BQ\x95a\x0B\x07\x91_\x91a\x0C!W[Pa\x0B\x01a\n\xFB_a\x07\x08V[\x91a\x06\xC4V[\x11a\x07\xA3V[[a\x0B-a\x0B\x14\x82a\x07\xCCV[;a\x0B'a\x0B!_a\x07\x08V[\x91a\x06\xC4V[\x11a\x08WV[`\x80R` a\x0B;\x87a\x06\xB8V[c\xEC\xA0g\xAD\x90a\x0BIa\0\xBDV[\x96\x87\x92a\x05\nV[\x82R\x81\x80a\x0Ba`\x04\x82\x01a\x05.V[\x03\x91Z\xFA\x91\x82\x15a\x0C\x1CWa\x0B\xE4\x96a\x0B\x9Ba\x0B\xD1\x94a\x0B\xDA\x97_\x91a\x0B\xEEW[Pa\x0B\x95a\x0B\x8F_a\x07\x08V[\x91a\x06\xC4V[\x11a\x08\xFFV[`\xA0Ra\x0B\xC3a\x0B\xAA\x82a\t(V[;a\x0B\xBDa\x0B\xB7_a\x07\x08V[\x91a\x06\xC4V[\x11a\t\xB3V[a\x01\0R`\x01`\x02\x01a\x03\xD3V[`\x02\x80\x01a\x03\xD3V[`\x04`\x02\x01a\x03\xD3V[a\x0B\xECa\x1A\xE1V[V[a\x0C\x0F\x91P` =\x81\x11a\x0C\x15W[a\x0C\x07\x81\x83a\0\xE5V[\x81\x01\x90a\x06\xEAV[_a\x0B\x82V[P=a\x0B\xFDV[a\x053V[a\x0CB\x91P` =\x81\x11a\x0CHW[a\x0C:\x81\x83a\0\xE5V[\x81\x01\x90a\x06\xEAV[_a\n\xEEV[P=a\x0C0V[a\x053V[a\x0C\x8Da\x0Ca`\xC0a\x04\"V[a\x0C\x87a\x0C\x81sB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15a\x010V[\x91a\x010V[\x14a\x04\x91V[a\x0C\xC2` a\x0C\xACa\x0C\xA7a\x0C\xA2`\xC0a\x04\"V[a\x04\xE2V[a\x04\xFAV[c\xB8\x07w\xEA\x90a\x0C\xBAa\0\xBDV[\x93\x84\x92a\x05\nV[\x82R\x81\x80a\x0C\xD2`\x04\x82\x01a\x05.V[\x03\x91Z\xFA\x90\x81\x15a\r\xEEW_\x91a\r\xC0W[Pa\x0C\xF7a\x0C\xF1_a\x05FV[\x91a\x02\x0BV[\x11\x93\x84a\r\x10W[a\r\x0Ba\x0BQ\x95a\x05\xF5V[a\x0B\x08V[a\rG\x94P` a\r1a\r,a\r'`\xC0a\x04\"V[a\x04\xE2V[a\x04\xFAV[c\t\xBDZ`\x90a\r?a\0\xBDV[\x97\x88\x92a\x05\nV[\x82R\x81\x80a\rW`\x04\x82\x01a\x05.V[\x03\x91Z\xFA\x94\x85\x15a\r\xBBWa\x0BQ\x95a\r\x0B\x91_\x91a\r\x8DW[Pa\r\x84a\r~_a\x05\x80V[\x91a\x01\x9AV[\x11\x95PPa\x0C\xFFV[a\r\xAE\x91P` =\x81\x11a\r\xB4W[a\r\xA6\x81\x83a\0\xE5V[\x81\x01\x90a\x05bV[_a\rqV[P=a\r\x9CV[a\x053V[a\r\xE1\x91P` =\x81\x11a\r\xE7W[a\r\xD9\x81\x83a\0\xE5V[\x81\x01\x90a\x05\x10V[_a\x0C\xE4V[P=a\r\xCFV[a\x053V[\x90V[a\x0E\na\x0E\x05a\x0E\x0F\x92a\r\xF3V[a\x03YV[a\x06\xC4V[\x90V[a\x0E\x1C`\x01a\r\xF6V[\x90V[a\x0E3a\x0E.a\x0E8\x92a\x06\xC4V[a\x03YV[a\x06\xC4V[\x90V[\x90V[\x90a\x0ESa\x0ENa\x0EZ\x92a\x0E\x1FV[a\x0E;V[\x82Ta\x03\xA0V[\x90UV[a\x0Eg\x90a\x0E\xC5V[a\x0Eya\x0Era\x0E\x12V[`\x01a\x0E>V[V[a\x0E\x8Fa\x0E\x8Aa\x0E\x94\x92a\x05CV[a\x03YV[a\x01%V[\x90V[a\x0E\xA0\x90a\x0E{V[\x90V[a\x0E\xAC\x90a\x010V[\x90RV[\x91\x90a\x0E\xC3\x90_` \x85\x01\x94\x01\x90a\x0E\xA3V[V[\x80a\x0E\xE0a\x0E\xDAa\x0E\xD5_a\x0E\x97V[a\x010V[\x91a\x010V[\x14a\x0E\xF0Wa\x0E\xEE\x90a\x1BaV[V[a\x0F\x13a\x0E\xFC_a\x0E\x97V[_\x91\x82\x91c\x1EO\xBD\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x0E\xB0V[\x03\x90\xFD[a\x0F\x1Fa\x1C\x10V[a\x0F'a\x14\xDBV[a\x0F/a\x1ChV[V[a\x0FEa\x0F@a\x0FJ\x92a\x06\xC4V[a\x03YV[a\x02\x0BV[\x90V[`\x01\x80`@\x1B\x03\x16\x90V[a\x0Fda\x0Fi\x91a\x03\xC2V[a\x0FMV[\x90V[a\x0Fv\x90Ta\x0FXV[\x90V[` \x7Finsufficient time has passed\0\0\0\0\x91\x7Fcannot close challenge window - _\x82\x01R\x01RV[a\x0F\xD3`<`@\x92a\x04/V[a\x0F\xDC\x81a\x0FyV[\x01\x90V[a\x0F\xF5\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x0F\xC6V[\x90V[\x15a\x0F\xFFWV[a\x10\x07a\0\xBDV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x10\x1D`\x04\x82\x01a\x0F\xE0V[\x03\x90\xFD[`@\x1C\x90V[a\x103a\x108\x91a\x10!V[a\x0FMV[\x90V[a\x10E\x90Ta\x10'V[\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x10ha\x10n\x91a\x02\x0BV[\x91a\x02\x0BV[\x01\x90`\x01\x80`@\x1B\x03\x82\x11a\x10\x7FWV[a\x10HV[\x90a\x10\x95`\x01\x80`@\x1B\x03\x91a\x03\x9BV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x10\xB4a\x10\xAFa\x10\xBB\x92a\x03\\V[a\x03xV[\x82Ta\x10\x84V[\x90UV[T\x90V[` \x7Ftoo many assertions\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7Fcannot close challenge window - _\x82\x01R\x01RV[a\x11\x1D`3`@\x92a\x04/V[a\x11&\x81a\x10\xC3V[\x01\x90V[a\x11?\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x11\x10V[\x90V[\x15a\x11IWV[a\x11Qa\0\xBDV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x11g`\x04\x82\x01a\x11*V[\x03\x90\xFD[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[_R` _ \x90V[a\x11\x91\x81a\x10\xBFV[\x82\x10\x15a\x11\xABWa\x11\xA3`\x04\x91a\x11\x7FV[\x91\x02\x01\x90_\x90V[a\x11kV[\x90V[a\x11\xBFa\x11\xC4\x91a\x03\xC2V[a\x11\xB0V[\x90V[a\x11\xD1\x90Ta\x11\xB3V[\x90V[a\x11\xDE\x90Qa\x01<V[\x90V[_\x91\x03\x12a\x11\xEBWV[a\x01!V[\x91` a\x12\x11\x92\x94\x93a\x12\n`@\x82\x01\x96_\x83\x01\x90a\x03\xF3V[\x01\x90a\x03\xF3V[V[a\x12\"a\x12(\x91\x93\x92\x93a\x06\xC4V[\x92a\x06\xC4V[\x91a\x124\x83\x82\x02a\x06\xC4V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a\x12CWV[a\x10HV[a\x12S\x90`\x04a\x12\x13V[\x90V[\x1B\x90V[\x91\x90`\x08a\x12u\x91\x02\x91a\x12o_\x19\x84a\x12VV[\x92a\x12VV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\x12\x95a\x12\x90a\x12\x9D\x93a\x03\xB6V[a\x03\xC7V[\x90\x83Ta\x12ZV[\x90UV[_\x90V[a\x12\xB7\x91a\x12\xB1a\x12\xA1V[\x91a\x12\x7FV[V[_`\x03a\x12\xEC\x92a\x12\xCC\x83\x80\x83\x01a\x12\xA5V[a\x12\xD9\x83`\x01\x83\x01a\x12\xA5V[a\x12\xE6\x83`\x02\x83\x01a\x12\xA5V[\x01a\x12\xA5V[V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[\x90_\x03a\x13\x13Wa\x13\x11\x90a\x12\xB9V[V[a\x12\xEEV[[\x81\x81\x10a\x13$WPPV[\x80a\x131_`\x04\x93a\x13\x01V[\x01a\x13\x19V[\x90\x91\x82\x81\x10a\x13FW[PPPV[a\x13da\x13^a\x13Xa\x13o\x95a\x12HV[\x92a\x12HV[\x92a\x11\x7FV[\x91\x82\x01\x91\x01\x90a\x13\x18V[_\x80\x80a\x13AV[\x90h\x01\0\0\0\0\0\0\0\0\x81\x11a\x13\xA0W\x81a\x13\x95a\x13\x9E\x93a\x10\xBFV[\x90\x82\x81Ua\x137V[V[a\0\xD1V[_a\x13\xAF\x91a\x13wV[V[\x90_\x03a\x13\xC3Wa\x13\xC1\x90a\x13\xA5V[V[a\x12\xEEV[a\x13\xD2\x90Qa\x01kV[\x90V[a\x13\xE4a\x13\xEA\x91\x93\x92\x93a\x06\xC4V[\x92a\x06\xC4V[\x82\x03\x91\x82\x11a\x13\xF5WV[a\x10HV[a\x14\x03\x90a\x06\xC4V[\x90RV[\x91\x90a\x14\x1A\x90_` \x85\x01\x94\x01\x90a\x13\xFAV[V[a\x14%\x90a\x01\x9AV[\x90RV[\x90`\xA0a\x14\xBC`\x05a\x14\xC4\x94a\x14Ma\x14D_\x83\x01Ta\x11\xB3V[_\x87\x01\x90a\x14\x1CV[a\x14ga\x14]`\x01\x83\x01Ta\x11\xB3V[` \x87\x01\x90a\x14\x1CV[a\x14\x81a\x14w`\x02\x83\x01Ta\x11\xB3V[`@\x87\x01\x90a\x14\x1CV[a\x14\x9Ba\x14\x91`\x03\x83\x01Ta\x11\xB3V[``\x87\x01\x90a\x14\x1CV[a\x14\xB5a\x14\xAB`\x04\x83\x01Ta\x11\xB3V[`\x80\x87\x01\x90a\x14\x1CV[\x01Ta\x11\xB3V[\x91\x01\x90a\x14\x1CV[V[\x91\x90a\x14\xD9\x90_`\xC0\x85\x01\x94\x01\x90a\x14)V[V[a\x14\xE5`\xE0a\x04\x15V[_\x14a\x1ANWa\x15\x19a\x14\xF7Ba\x0F1V[[a\x15\x13a\x15\ra\x15\x08`\na\x0FlV[a\x02\x0BV[\x91a\x02\x0BV[\x11a\x0F\xF8V[a\x15?a\x158a\x15(Ba\x0F1V[a\x152`\na\x10;V[\x90a\x10\\V[`\na\x10\x9FV[a\x15I`\x08a\x10\xBFV[a\x15\\a\x15V`\x01a\r\xF6V[\x91a\x06\xC4V[\x14_\x14a\x1A$Wa\x15\x88a\x15~`\x03a\x15w`\x08_\x90a\x11\x88V[P\x01a\x11\xC7V[`\x04`\x02\x01a\x03\xD3V[a\x15\xACa\x15\xA3`\x02a\x15\x9C`\x08_\x90a\x11\x88V[P\x01a\x11\xC7V[`\x02\x80\x01a\x03\xD3V[a\x15\xB9`\x01`\x02\x01a\x11\xC7V[a\x15\xE1a\x15\xDBa\x15\xD6_a\x15\xCF`\x08\x82\x90a\x11\x88V[P\x01a\x11\xC7V[a\x01\x9AV[\x91a\x01\x9AV[\x03a\x19?W[a\x15\xF2_`\x08a\x13\xB1V[[a\x16\x05a\x16\0`\xA0a\x13\xC8V[a\x06\xB8V[a\x167c\xD5q\x9D\xC2` a\x16!a\x16\x1C`\xA0a\x13\xC8V[a\x06\xB8V[c\xEC\xA0g\xAD\x90a\x16/a\0\xBDV[\x94\x85\x92a\x05\nV[\x82R\x81\x80a\x16G`\x04\x82\x01a\x05.V[\x03\x91Z\xFA\x92\x83\x15a\x19:Wa\x16\x8Ca\x16wa\x16\x97\x95` \x95_\x91a\x19\rW[Pa\x16q`\x01a\r\xF6V[\x90a\x13\xD5V[\x92a\x16\x80a\0\xBDV[\x95\x86\x94\x85\x93\x84\x93a\x05\nV[\x83R`\x04\x83\x01a\x14\x07V[\x03\x91Z\xFA\x80\x15a\x19\x08Wa\x16\xB7\x91_\x91a\x18\xDAW[P`\x03`\x02\x01a\x03\xD3V[a\x16\xC1`\xE0a\x04\x15V[_\x14a\x18=Wa\x16\xE1a\x16\xDCa\x16\xD7`\xC0a\x04\"V[a\x06\xACV[a\x06\xB8V[a\x17\x1Ac\x16\xBFUy` a\x17\x05a\x17\0a\x16\xFB`\xC0a\x04\"V[a\x06\xACV[a\x06\xB8V[b\x84\x12\x0C\x90a\x17\x12a\0\xBDV[\x94\x85\x92a\x05\nV[\x82R\x81\x80a\x17*`\x04\x82\x01a\x05.V[\x03\x91Z\xFA\x92\x83\x15a\x188Wa\x17oa\x17Za\x17z\x95` \x95_\x91a\x18\x0BW[Pa\x17T`\x01a\r\xF6V[\x90a\x13\xD5V[\x92a\x17ca\0\xBDV[\x95\x86\x94\x85\x93\x84\x93a\x05\nV[\x83R`\x04\x83\x01a\x14\x07V[\x03\x91Z\xFA\x80\x15a\x18\x06Wa\x17\x9A\x91_\x91a\x17\xD8W[P`\x05`\x02\x01a\x03\xD3V[[`\x02a\x17\xD3\x7FU#\"\x99\xD8?\xAFM\xC2\xC3.\"\x8A\xF3v2\xBC\xA7\xFAm\xBC\x03\xB4\x12$\xC1\0\xC6\xC9\xDC\xA3I\x91a\x17\xCAa\0\xBDV[\x91\x82\x91\x82a\x14\xC6V[\x03\x90\xA1V[a\x17\xF9\x91P` =\x81\x11a\x17\xFFW[a\x17\xF1\x81\x83a\0\xE5V[\x81\x01\x90a\x05bV[_a\x17\x8FV[P=a\x17\xE7V[a\x053V[a\x18+\x91P\x86=\x81\x11a\x181W[a\x18#\x81\x83a\0\xE5V[\x81\x01\x90a\x06\xEAV[_a\x17IV[P=a\x18\x19V[a\x053V[a\x18r` a\x18\\a\x18Wa\x18R`\xC0a\x04\"V[a\x04\xE2V[a\x04\xFAV[c\t\xBDZ`\x90a\x18ja\0\xBDV[\x93\x84\x92a\x05\nV[\x82R\x81\x80a\x18\x82`\x04\x82\x01a\x05.V[\x03\x91Z\xFA\x80\x15a\x18\xD5Wa\x18\xA2\x91_\x91a\x18\xA7W[P`\x05`\x02\x01a\x03\xD3V[a\x17\x9BV[a\x18\xC8\x91P` =\x81\x11a\x18\xCEW[a\x18\xC0\x81\x83a\0\xE5V[\x81\x01\x90a\x05bV[_a\x18\x97V[P=a\x18\xB6V[a\x053V[a\x18\xFB\x91P` =\x81\x11a\x19\x01W[a\x18\xF3\x81\x83a\0\xE5V[\x81\x01\x90a\x05bV[_a\x16\xACV[P=a\x18\xE9V[a\x053V[a\x19-\x91P\x86=\x81\x11a\x193W[a\x19%\x81\x83a\0\xE5V[\x81\x01\x90a\x06\xEAV[_a\x16fV[P=a\x19\x1BV[a\x053V[a\x19ca\x19Y_a\x19R`\x08\x82\x90a\x11\x88V[P\x01a\x11\xC7V[`\x01`\x02\x01a\x03\xD3V[a\x19ua\x19p`\x80a\x11\xD4V[a\x07\xCCV[c\xDA\xEA\xB4\x12a\x19\x91_a\x19\x8A`\x08\x82\x90a\x11\x88V[P\x01a\x11\xC7V[a\x19\xA9`\x01a\x19\xA2`\x08_\x90a\x11\x88V[P\x01a\x11\xC7V[\x92\x80;\x15a\x1A\x1FWa\x19\xCE_\x80\x94a\x19\xD9a\x19\xC2a\0\xBDV[\x97\x88\x96\x87\x95\x86\x94a\x05\nV[\x84R`\x04\x84\x01a\x11\xF0V[\x03\x92Z\xF1\x80\x15a\x1A\x1AWa\x19\xEEW[Pa\x15\xE7V[a\x1A\r\x90_=\x81\x11a\x1A\x13W[a\x1A\x05\x81\x83a\0\xE5V[\x81\x01\x90a\x11\xE1V[_a\x19\xE8V[P=a\x19\xFBV[a\x053V[a\x05\x06V[a\x1AIa\x1A1`\x08a\x10\xBFV[a\x1ACa\x1A=_a\x07\x08V[\x91a\x06\xC4V[\x14a\x11BV[a\x15\xF3V[a\x1A\x83` a\x1Ama\x1Aha\x1Ac`\xC0a\x04\"V[a\x04\xE2V[a\x04\xFAV[c\xB8\x07w\xEA\x90a\x1A{a\0\xBDV[\x93\x84\x92a\x05\nV[\x82R\x81\x80a\x1A\x93`\x04\x82\x01a\x05.V[\x03\x91Z\xFA\x80\x15a\x1A\xDCWa\x15\x19\x91_\x91a\x1A\xAEW[Pa\x14\xF8V[a\x1A\xCF\x91P` =\x81\x11a\x1A\xD5W[a\x1A\xC7\x81\x83a\0\xE5V[\x81\x01\x90a\x05\x10V[_a\x1A\xA8V[P=a\x1A\xBDV[a\x053V[a\x1A\xE9a\x0F\x17V[V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x1B\x02a\x1B\x07\x91a\x03\xC2V[a\x1A\xEBV[\x90V[a\x1B\x14\x90Ta\x1A\xF6V[\x90V[\x90a\x1B(`\x01\x80`\xA0\x1B\x03\x91a\x03\x9BV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1B;\x90a\x04\xEEV[\x90V[\x90V[\x90a\x1BVa\x1BQa\x1B]\x92a\x1B2V[a\x1B>V[\x82Ta\x1B\x17V[\x90UV[a\x1Bj_a\x1B\nV[a\x1Bt\x82_a\x1BAV[\x90a\x1B\xA8a\x1B\xA2\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x93a\x1B2V[\x91a\x1B2V[\x91a\x1B\xB1a\0\xBDV[\x80a\x1B\xBB\x81a\x05.V[\x03\x90\xA3V[\x90V[a\x1B\xCFa\x1B\xD4\x91a\x03\xC2V[a\x1B\xC0V[\x90V[a\x1B\xE1\x90Ta\x1B\xC3V[\x90V[\x90V[a\x1B\xFBa\x1B\xF6a\x1C\0\x92a\x1B\xE4V[a\x03YV[a\x06\xC4V[\x90V[a\x1C\r`\x02a\x1B\xE7V[\x90V[a\x1C\x1A`\x01a\x1B\xD7V[a\x1C3a\x1C-a\x1C(a\x1C\x03V[a\x06\xC4V[\x91a\x06\xC4V[\x14a\x1CLWa\x1CJa\x1CCa\x1C\x03V[`\x01a\x0E>V[V[_c>\xE5\xAE\xB5`\xE0\x1B\x81R\x80a\x1Cd`\x04\x82\x01a\x05.V[\x03\x90\xFD[a\x1Cza\x1Csa\x0E\x12V[`\x01a\x0E>V[V\xFE`\x80`@R`\x046\x10\x15a\0\x15W[6a\naW\0[a\0\x1F_5a\x01\x1EV[\x80c'\xD4\x02\x99\x14a\x01\x19W\x80c1\x83\xBA\xAC\x14a\x01\x14W\x80c:\0\x9A\x06\x14a\x01\x0FW\x80c<\xEA\xAE}\x14a\x01\nW\x80cG\x0B\x9B\x1A\x14a\x01\x05W\x80cK\xD1g\xC9\x14a\x01\0W\x80ci{^b\x14a\0\xFBW\x80clL `\x14a\0\xF6W\x80cqP\x18\xA6\x14a\0\xF1W\x80c\x80\x95\x97!\x14a\0\xECW\x80c\x8D\xA5\xCB[\x14a\0\xE7W\x80c\xA5n\xC6\xCD\x14a\0\xE2W\x80c\xDCh\xCD\xFE\x14a\0\xDDW\x80c\xE7\x8C\xEA\x92\x14a\0\xD8W\x80c\xEE\x1C(\xB8\x14a\0\xD3Wc\xF2\xFD\xE3\x8B\x03a\0\x0EWa\n.V[a\t\xDBV[a\t\x97V[a\t\x12V[a\x08\xBBV[a\x07hV[a\x073V[a\x06\xAEV[a\x06{V[a\x06FV[a\x05\xB4V[a\x05\tV[a\x04\x82V[a\x03hV[a\x02\xB4V[a\x01\x9EV[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x91\x03\x12a\x01<WV[a\x01.V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x01y\x90a\x01eV[\x90V[a\x01\x85\x90a\x01pV[\x90RV[\x91\x90a\x01\x9C\x90_` \x85\x01\x94\x01\x90a\x01|V[V[4a\x01\xCEWa\x01\xAE6`\x04a\x012V[a\x01\xCAa\x01\xB9a\x01AV[a\x01\xC1a\x01$V[\x91\x82\x91\x82a\x01\x89V[\x03\x90\xF3[a\x01*V[_\x80\xFD[_\x80\xFD[\x90\x81`\x80\x91\x03\x12a\x01\xE9W\x90V[a\x01\xD7V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x024W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x02/W` \x01\x92`\x01\x83\x02\x84\x01\x11a\x02*WV[a\x01\xF6V[a\x01\xF2V[a\x01\xEEV[a\x02B\x81a\x01pV[\x03a\x02IWV[_\x80\xFD[\x90P5\x90a\x02Z\x82a\x029V[V[\x90`\xC0\x82\x82\x03\x12a\x02\xAAWa\x02s\x81_\x84\x01a\x01\xDBV[\x92`\x80\x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02\xA5Wa\x02\x97\x83a\x02\xA2\x92\x86\x01a\x01\xFAV[\x93\x90\x94`\xA0\x01a\x02MV[\x90V[a\x01\xD3V[a\x01.V[_\x01\x90V[4a\x02\xE6Wa\x02\xD0a\x02\xC76`\x04a\x02\\V[\x92\x91\x90\x91a\x16\xB0V[a\x02\xD8a\x01$V[\x80a\x02\xE2\x81a\x02\xAFV[\x03\x90\xF3[a\x01*V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[\x90V[a\x03&a\x03!a\x03+\x92a\x01eV[a\x03\x0FV[a\x01eV[\x90V[a\x037\x90a\x03\x12V[\x90V[a\x03C\x90a\x03.V[\x90V[a\x03O\x90a\x03:V[\x90RV[\x91\x90a\x03f\x90_` \x85\x01\x94\x01\x90a\x03FV[V[4a\x03\x98Wa\x03x6`\x04a\x012V[a\x03\x94a\x03\x83a\x02\xEBV[a\x03\x8Ba\x01$V[\x91\x82\x91\x82a\x03SV[\x03\x90\xF3[a\x01*V[_\x1C\x90V[\x90V[a\x03\xB1a\x03\xB6\x91a\x03\x9DV[a\x03\xA2V[\x90V[a\x03\xC3\x90Ta\x03\xA5V[\x90V[`\x02\x90a\x03\xD4_\x83\x01a\x03\xB9V[\x91a\x03\xE1`\x01\x82\x01a\x03\xB9V[\x91a\x03\xEE`\x02\x83\x01a\x03\xB9V[\x91a\x03\xFB`\x03\x82\x01a\x03\xB9V[\x91a\x04\x14`\x05a\x04\r`\x04\x85\x01a\x03\xB9V[\x93\x01a\x03\xB9V[\x90V[\x90V[a\x04#\x90a\x04\x17V[\x90RV[\x91\x94a\x04oa\x04y\x92\x98\x97\x95a\x04e`\xA0\x96a\x04[a\x04\x80\x9Aa\x04Q`\xC0\x8A\x01\x9E_\x8B\x01\x90a\x04\x1AV[` \x89\x01\x90a\x04\x1AV[`@\x87\x01\x90a\x04\x1AV[``\x85\x01\x90a\x04\x1AV[`\x80\x83\x01\x90a\x04\x1AV[\x01\x90a\x04\x1AV[V[4a\x04\xB9Wa\x04\x926`\x04a\x012V[a\x04\xB5a\x04\x9Da\x03\xC6V[\x92a\x04\xAC\x96\x94\x96\x92\x91\x92a\x01$V[\x96\x87\x96\x87a\x04'V[\x03\x90\xF3[a\x01*V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[\x15\x15\x90V[a\x04\xF0\x90a\x04\xE2V[\x90RV[\x91\x90a\x05\x07\x90_` \x85\x01\x94\x01\x90a\x04\xE7V[V[4a\x059Wa\x05\x196`\x04a\x012V[a\x055a\x05$a\x04\xBEV[a\x05,a\x01$V[\x91\x82\x91\x82a\x04\xF4V[\x03\x90\xF3[a\x01*V[\x1C\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x05_\x90`\x08a\x05d\x93\x02a\x05>V[a\x05BV[\x90V[\x90a\x05r\x91Ta\x05OV[\x90V[a\x05\x82`\n`\x08\x90a\x05gV[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x05\x9B\x90a\x05\x85V[\x90RV[\x91\x90a\x05\xB2\x90_` \x85\x01\x94\x01\x90a\x05\x92V[V[4a\x05\xE4Wa\x05\xC46`\x04a\x012V[a\x05\xE0a\x05\xCFa\x05uV[a\x05\xD7a\x01$V[\x91\x82\x91\x82a\x05\x9FV[\x03\x90\xF3[a\x01*V[\x90V[a\x05\xFC\x90`\x08a\x06\x01\x93\x02a\x05>V[a\x05\xE9V[\x90V[\x90a\x06\x0F\x91Ta\x05\xECV[\x90V[a\x06\x1E`\t_\x90a\x06\x04V[\x90V[\x90V[a\x06-\x90a\x06!V[\x90RV[\x91\x90a\x06D\x90_` \x85\x01\x94\x01\x90a\x06$V[V[4a\x06vWa\x06V6`\x04a\x012V[a\x06ra\x06aa\x06\x12V[a\x06ia\x01$V[\x91\x82\x91\x82a\x061V[\x03\x90\xF3[a\x01*V[4a\x06\xA9Wa\x06\x8B6`\x04a\x012V[a\x06\x93a\"\xA9V[a\x06\x9Ba\x01$V[\x80a\x06\xA5\x81a\x02\xAFV[\x03\x90\xF3[a\x01*V[4a\x06\xDCWa\x06\xBE6`\x04a\x012V[a\x06\xC6a\"\xD8V[a\x06\xCEa\x01$V[\x80a\x06\xD8\x81a\x02\xAFV[\x03\x90\xF3[a\x01*V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[a\x07\x0E\x90a\x03.V[\x90V[a\x07\x1A\x90a\x07\x05V[\x90RV[\x91\x90a\x071\x90_` \x85\x01\x94\x01\x90a\x07\x11V[V[4a\x07cWa\x07C6`\x04a\x012V[a\x07_a\x07Na\x06\xE1V[a\x07Va\x01$V[\x91\x82\x91\x82a\x07\x1EV[\x03\x90\xF3[a\x01*V[4a\x07\x98Wa\x07x6`\x04a\x012V[a\x07\x94a\x07\x83a#\x12V[a\x07\x8Ba\x01$V[\x91\x82\x91\x82a\x01\x89V[\x03\x90\xF3[a\x01*V[a\x07\xA6\x81a\x06!V[\x03a\x07\xADWV[_\x80\xFD[\x90P5\x90a\x07\xBE\x82a\x07\x9DV[V[\x90` \x82\x82\x03\x12a\x07\xD9Wa\x07\xD6\x91_\x01a\x07\xB1V[\x90V[a\x01.V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[T\x90V[_R` _ \x90V[a\x08\x08\x81a\x07\xF2V[\x82\x10\x15a\x08\"Wa\x08\x1A`\x04\x91a\x07\xF6V[\x91\x02\x01\x90_\x90V[a\x07\xDEV[`\x08\x90a\x083\x82a\x07\xF2V[\x81\x10\x15a\x08yWa\x08C\x91a\x07\xFFV[P\x90a\x08P_\x83\x01a\x03\xB9V[\x91a\x08]`\x01\x82\x01a\x03\xB9V[\x91a\x08v`\x03a\x08o`\x02\x85\x01a\x03\xB9V[\x93\x01a\x03\xB9V[\x90V[_\x80\xFD[a\x08\xB2a\x08\xB9\x94a\x08\xA8``\x94\x98\x97\x95a\x08\x9E`\x80\x86\x01\x9A_\x87\x01\x90a\x04\x1AV[` \x85\x01\x90a\x04\x1AV[`@\x83\x01\x90a\x04\x1AV[\x01\x90a\x04\x1AV[V[4a\x08\xEFWa\x08\xEBa\x08\xD6a\x08\xD16`\x04a\x07\xC0V[a\x08'V[\x90a\x08\xE2\x94\x92\x94a\x01$V[\x94\x85\x94\x85a\x08}V[\x03\x90\xF3[a\x01*V[\x90`\x80\x82\x82\x03\x12a\t\rWa\t\n\x91_\x01a\x01\xDBV[\x90V[a\x01.V[4a\t@Wa\t*a\t%6`\x04a\x08\xF4V[a&#V[a\t2a\x01$V[\x80a\t<\x81a\x02\xAFV[\x03\x90\xF3[a\x01*V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[a\tr\x90a\x03.V[\x90V[a\t~\x90a\tiV[\x90RV[\x91\x90a\t\x95\x90_` \x85\x01\x94\x01\x90a\tuV[V[4a\t\xC7Wa\t\xA76`\x04a\x012V[a\t\xC3a\t\xB2a\tEV[a\t\xBAa\x01$V[\x91\x82\x91\x82a\t\x82V[\x03\x90\xF3[a\x01*V[a\t\xD8`\n_\x90a\x05gV[\x90V[4a\n\x0BWa\t\xEB6`\x04a\x012V[a\n\x07a\t\xF6a\t\xCCV[a\t\xFEa\x01$V[\x91\x82\x91\x82a\x05\x9FV[\x03\x90\xF3[a\x01*V[\x90` \x82\x82\x03\x12a\n)Wa\n&\x91_\x01a\x02MV[\x90V[a\x01.V[4a\n\\Wa\nFa\nA6`\x04a\n\x10V[a&\x93V[a\nNa\x01$V[\x80a\nX\x81a\x02\xAFV[\x03\x90\xF3[a\x01*V[_\x80\xFD[\x90a\ny\x93\x92\x91a\nta&\xABV[a\x13,V[a\n\x81a'\x10V[V[\x90V[a\n\x9Aa\n\x95a\n\x9F\x92a\n\x83V[a\x03\x0FV[a\x01eV[\x90V[a\n\xAB\x90a\n\x86V[\x90V[` \x91\x81R\x01\x90V[_\x7Freward address cannot be zero\0\0\0\x91\x01RV[a\n\xEB`\x1D` \x92a\n\xAEV[a\n\xF4\x81a\n\xB7V[\x01\x90V[a\x0B\r\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\n\xDEV[\x90V[\x15a\x0B\x17WV[a\x0B\x1Fa\x01$V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x0B5`\x04\x82\x01a\n\xF8V[\x03\x90\xFD[P\x90V[\x90V[a\x0BTa\x0BOa\x0BY\x92a\x0B=V[a\x03\x0FV[a\x06!V[\x90V[_\x7Finvalid signature length\0\0\0\0\0\0\0\0\x91\x01RV[a\x0B\x90`\x18` \x92a\n\xAEV[a\x0B\x99\x81a\x0B\\V[\x01\x90V[a\x0B\xB2\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x0B\x83V[\x90V[\x15a\x0B\xBCWV[a\x0B\xC4a\x01$V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x0B\xDA`\x04\x82\x01a\x0B\x9DV[\x03\x90\xFD[\x90V[\x90V[a\x0B\xF0a\x0B\xF5\x91a\x04\x17V[a\x0B\xE1V[\x90RV[` \x81a\x0C\x0Ba\x0C\x13\x93\x83\x96\x95a\x0B\xE4V[\x01\x80\x92a\x0B\xE4V[\x01\x90V[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x0C?\x90a\x0C\x17V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x0CYW`@RV[a\x0C!V[` \x01\x90V[Q\x90V[_\x80\xFD[\x90a\x0C\x7Fa\x0Cxa\x01$V[\x92\x83a\x0C5V[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x0C\x9FWa\x0C\x9B` \x91a\x0C\x17V[\x01\x90V[a\x0C!V[\x90\x82_\x93\x92\x827\x01RV[\x90\x92\x91\x92a\x0C\xC4a\x0C\xBF\x82a\x0C\x81V[a\x0ClV[\x93\x81\x85R` \x85\x01\x90\x82\x84\x01\x11a\x0C\xE0Wa\x0C\xDE\x92a\x0C\xA4V[V[a\x0ChV[a\x0C\xF0\x916\x91a\x0C\xAFV[\x90V[_\x80\xFD[`\xE0\x1B\x90V[a\r\x06\x81a\x04\xE2V[\x03a\r\rWV[_\x80\xFD[\x90PQ\x90a\r\x1E\x82a\x0C\xFDV[V[\x90` \x82\x82\x03\x12a\r9Wa\r6\x91_\x01a\r\x11V[\x90V[a\x01.V[a\rFa\x01$V[=_\x82>=\x90\xFD[_\x7Finvalid tee signature\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\r\x82`\x15` \x92a\n\xAEV[a\r\x8B\x81a\rNV[\x01\x90V[a\r\xA4\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\ruV[\x90V[\x15a\r\xAEWV[a\r\xB6a\x01$V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\r\xCC`\x04\x82\x01a\r\x8FV[\x03\x90\xFD[a\r\xD9\x81a\x04\x17V[\x03a\r\xE0WV[_\x80\xFD[5a\r\xEE\x81a\r\xD0V[\x90V[_\x7Funexpected l1 end batch acc\0\0\0\0\0\x91\x01RV[a\x0E%`\x1B` \x92a\n\xAEV[a\x0E.\x81a\r\xF1V[\x01\x90V[a\x0EG\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x0E\x18V[\x90V[\x15a\x0EQWV[a\x0EYa\x01$V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x0Eo`\x04\x82\x01a\x0E2V[\x03\x90\xFD[a\x0E\x87a\x0E\x82a\x0E\x8C\x92a\n\x83V[a\x03\x0FV[a\x06!V[\x90V[`\x01a\x0E\x9B\x91\x01a\x06!V[\x90V[\x90V[_\x7Fassertion already exists\0\0\0\0\0\0\0\0\x91\x01RV[a\x0E\xD5`\x18` \x92a\n\xAEV[a\x0E\xDE\x81a\x0E\xA1V[\x01\x90V[a\x0E\xF7\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x0E\xC8V[\x90V[\x15a\x0F\x01WV[a\x0F\ta\x01$V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x0F\x1F`\x04\x82\x01a\x0E\xE2V[\x03\x90\xFD[a\x0F7a\x0F2a\x0F<\x92a\x06!V[a\x03\x0FV[a\x05\x85V[\x90V[`@\x1C\x90V[a\x0FQa\x0FV\x91a\x0F?V[a\x05BV[\x90V[a\x0Fc\x90Ta\x0FEV[\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x0F\x86a\x0F\x8C\x91a\x05\x85V[\x91a\x05\x85V[\x01\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x0F\x9FWV[a\x0FfV[_\x1B\x90V[\x90a\x0F\xBCg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x0F\xA4V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x0F\xDAa\x0F\xD5a\x0F\xDF\x92a\x05\x85V[a\x03\x0FV[a\x05\x85V[\x90V[\x90V[\x90a\x0F\xFAa\x0F\xF5a\x10\x01\x92a\x0F\xC6V[a\x0F\xE2V[\x82Ta\x0F\xA9V[\x90UV[\x90V[_R` _ \x90V[T\x90V[a\x10\x1E\x81a\x10\x11V[\x82\x10\x15a\x108Wa\x100`\x04\x91a\x10\x08V[\x91\x02\x01\x90_\x90V[a\x07\xDEV[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[\x90a\x10\\_\x19\x91a\x0F\xA4V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x10o\x90a\x04\x17V[\x90V[a\x10{\x90a\x03\x9DV[\x90V[\x90a\x10\x93a\x10\x8Ea\x10\x9A\x92a\x10fV[a\x10rV[\x82Ta\x10PV[\x90UV[\x90a\x10\xFB```\x03a\x11\x01\x94a\x10\xC1_\x82\x01a\x10\xBB_\x88\x01a\r\xE4V[\x90a\x10~V[a\x10\xDA`\x01\x82\x01a\x10\xD4` \x88\x01a\r\xE4V[\x90a\x10~V[a\x10\xF3`\x02\x82\x01a\x10\xED`@\x88\x01a\r\xE4V[\x90a\x10~V[\x01\x92\x01a\r\xE4V[\x90a\x10~V[V[\x91\x90a\x11\x14Wa\x11\x12\x91a\x10\x9EV[V[a\x10=V[\x1B\x90V[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a\x11MW\x82a\x11E\x91`\x01a\x11K\x95\x01\x81Ua\x10\x15V[\x90a\x11\x03V[V[a\x0C!V[\x90V[a\x11ia\x11da\x11n\x92a\x11RV[a\x03\x0FV[a\x06!V[\x90V[\x90V[a\x11\x88a\x11\x83a\x11\x8D\x92a\x11qV[a\x03\x0FV[a\x06!V[\x90V[a\x11\x9Ca\x11\xA1\x91a\x03\x9DV[a\x05\xE9V[\x90V[a\x11\xAE\x90Ta\x11\x90V[\x90V[a\x11\xC0a\x11\xC6\x91\x93\x92\x93a\x06!V[\x92a\x06!V[\x82\x01\x80\x92\x11a\x11\xD1WV[a\x0FfV[a\x11\xEAa\x11\xE5a\x11\xEF\x92a\x06!V[a\x03\x0FV[a\x06!V[\x90V[\x90V[\x90a\x12\na\x12\x05a\x12\x11\x92a\x11\xD6V[a\x11\xF2V[\x82Ta\x10PV[\x90UV[a\x12\x1E\x90a\x03\x12V[\x90V[a\x12*\x90a\x12\x15V[\x90V[a\x126\x90a\x03.V[\x90V[a\x12B\x90a\x03.V[\x90V[\x90P\x90V[a\x12U_\x80\x92a\x12EV[\x01\x90V[a\x12b\x90a\x12JV[\x90V[\x90a\x12wa\x12r\x83a\x0C\x81V[a\x0ClV[\x91\x82RV[``\x90V[=_\x14a\x12\x9CWa\x12\x91=a\x12eV[\x90=_` \x84\x01>[V[a\x12\xA4a\x12|V[\x90a\x12\x9AV[_\x7Fpayment failed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x12\xDE`\x0E` \x92a\n\xAEV[a\x12\xE7\x81a\x12\xAAV[\x01\x90V[a\x13\0\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x12\xD1V[\x90V[\x15a\x13\nWV[a\x13\x12a\x01$V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x13(`\x04\x82\x01a\x12\xEBV[\x03\x90\xFD[\x92\x90` a\x14A\x91\x95\x93\x95a\x13\\\x84a\x13Ua\x13Oa\x13J_a\n\xA2V[a\x01pV[\x91a\x01pV[\x14\x15a\x0B\x10V[a\x13\x83a\x13j\x82\x89\x90a\x0B9V[a\x13}a\x13w`Aa\x0B@V[\x91a\x06!V[\x14a\x0B\xB5V[a\x13\x8C\x86a'\\V[\x96a\x146a\x14!a\x13\xA5a\x13\xA0`\x02a\x0B\xDEV[a((V[a\x13\xCE\x8B\x91a\x13\xC0a\x13\xB5a\x01$V[\x93\x84\x92\x8A\x84\x01a\x0B\xF9V[\x88\x82\x01\x81\x03\x82R\x03\x82a\x0C5V[a\x13\xE0a\x13\xDA\x82a\x0CdV[\x91a\x0C^V[ \x93a\x14\x1Ba\x14\x0E\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x03:V[\x94cr\x17\xEF\xCD\x96\x92a\x0C\xE5V[\x90a(\xBAV[\x92a\x14*a\x01$V[\x95\x86\x94\x85\x93\x84\x93a\x0C\xF7V[\x83R`\x04\x83\x01a\x01\x89V[\x03\x91Z\xFA\x80\x15a\x16\xABWa\x14\\\x91_\x91a\x16}W[Pa\r\xA7V[a\x14\x86\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15a\x04\xE2V[\x80\x15a\x16GW[a\x14\x96\x90a\x0EJV[a\x14\x9F_a\x0EsV[[\x80a\x14\xBCa\x14\xB6a\x14\xB1`\x08a\x07\xF2V[a\x06!V[\x91a\x06!V[\x10\x15a\x15\tWa\x15\x04\x90a\x14\xFF\x86a\x14\xF8a\x14\xF2a\x14\xEDa\x14\xE8a\x14\xE2`\x08\x88\x90a\x07\xFFV[Pa\x0E\x9EV[a(\xDCV[a\x04\x17V[\x91a\x04\x17V[\x14\x15a\x0E\xFAV[a\x0E\x8FV[a\x14\xA0V[P\x91a\x15B\x91\x93Pa\x15\x1B`\x08a\x07\xF2V[a\x15-a\x15'_a\x0EsV[\x91a\x06!V[\x14a\x16\x1CW[a\x15=`\x08a\x10\x05V[a\x11\x1DV[a\x15L`\x08a\x07\xF2V[a\x15_a\x15Y`\x02a\x11UV[\x91a\x06!V[\x14a\x15hW[PV[_\x80a\x15\xE7a\x15\xE2a\x16\x16\x94a\x15\x9Aa\x15\x93a\x15\x84`\x01a\x11tV[a\x15\x8E`\ta\x11\xA4V[a\x11\xB1V[`\ta\x11\xF5V[a\x15\xA4`\ta\x11\xA4V[a\x15\xDA\x7F7\xE8\xAD\xD6\x94\xC5\x92mVN\x97\x11`\xF5\x97A\x03\xCB\xBB\xC7\xC9\x07G\xC4\xC6\xF8\x02\x03\x1D5g\xA7\x91a\x15\xD1a\x01$V[\x91\x82\x91\x82a\x061V[\x03\x90\xA1a\x12!V[a\x12-V[a\x15\xF00a\x129V[1a\x15\xF9a\x01$V[\x90\x81a\x16\x04\x81a\x12YV[\x03\x92Z\xF1a\x16\x10a\x12\x81V[Pa\x13\x03V[_a\x15eV[a\x16Ba\x16;a\x16+Ba\x0F#V[a\x165`\na\x0FYV[\x90a\x0FzV[`\na\x0F\xE5V[a\x153V[Pa\x14\x96a\x16W``\x85\x01a\r\xE4V[a\x16ua\x16oa\x16j`\x05`\x02\x01a\x03\xB9V[a\x04\x17V[\x91a\x04\x17V[\x14\x90Pa\x14\x8DV[a\x16\x9E\x91P` =\x81\x11a\x16\xA4W[a\x16\x96\x81\x83a\x0C5V[\x81\x01\x90a\r V[_a\x14VV[P=a\x16\x8CV[a\r>V[\x90a\x16\xBC\x93\x92\x91a\neV[V[a\x16\xC6a&\xABV[a\x16\xCEa\x1B\xD4V[a\x16\xD6a'\x10V[V[a\x16\xE1\x90a\x03\x12V[\x90V[a\x16\xED\x90a\x16\xD8V[\x90V[a\x16\xF9\x90a\x03.V[\x90V[a\x17\x05\x81a\x05\x85V[\x03a\x17\x0CWV[_\x80\xFD[\x90PQ\x90a\x17\x1D\x82a\x16\xFCV[V[\x90` \x82\x82\x03\x12a\x178Wa\x175\x91_\x01a\x17\x10V[\x90V[a\x01.V[a\x17Ia\x17N\x91a\x03\x9DV[a\x05BV[\x90V[a\x17[\x90Ta\x17=V[\x90V[` \x7Finsufficient time has passed\0\0\0\0\x91\x7Fcannot close challenge window - _\x82\x01R\x01RV[a\x17\xB8`<`@\x92a\n\xAEV[a\x17\xC1\x81a\x17^V[\x01\x90V[a\x17\xDA\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x17\xABV[\x90V[\x15a\x17\xE4WV[a\x17\xECa\x01$V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x18\x02`\x04\x82\x01a\x17\xC5V[\x03\x90\xFD[` \x7Ftoo many assertions\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7Fcannot close challenge window - _\x82\x01R\x01RV[a\x18``3`@\x92a\n\xAEV[a\x18i\x81a\x18\x06V[\x01\x90V[a\x18\x82\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x18SV[\x90V[\x15a\x18\x8CWV[a\x18\x94a\x01$V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x18\xAA`\x04\x82\x01a\x18mV[\x03\x90\xFD[_\x91\x03\x12a\x18\xB8WV[a\x01.V[\x91` a\x18\xDE\x92\x94\x93a\x18\xD7`@\x82\x01\x96_\x83\x01\x90a\x04\x1AV[\x01\x90a\x04\x1AV[V[a\x18\xEFa\x18\xF5\x91\x93\x92\x93a\x06!V[\x92a\x06!V[\x91a\x19\x01\x83\x82\x02a\x06!V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a\x19\x10WV[a\x0FfV[a\x19 \x90`\x04a\x18\xE0V[\x90V[\x91\x90`\x08a\x19>\x91\x02\x91a\x198_\x19\x84a\x11\x19V[\x92a\x11\x19V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\x19^a\x19Ya\x19f\x93a\x10fV[a\x10rV[\x90\x83Ta\x19#V[\x90UV[_\x90V[a\x19\x80\x91a\x19za\x19jV[\x91a\x19HV[V[_`\x03a\x19\xB5\x92a\x19\x95\x83\x80\x83\x01a\x19nV[a\x19\xA2\x83`\x01\x83\x01a\x19nV[a\x19\xAF\x83`\x02\x83\x01a\x19nV[\x01a\x19nV[V[\x90_\x03a\x19\xC9Wa\x19\xC7\x90a\x19\x82V[V[a\x10=V[[\x81\x81\x10a\x19\xDAWPPV[\x80a\x19\xE7_`\x04\x93a\x19\xB7V[\x01a\x19\xCFV[\x90\x91\x82\x81\x10a\x19\xFCW[PPPV[a\x1A\x1Aa\x1A\x14a\x1A\x0Ea\x1A%\x95a\x19\x15V[\x92a\x19\x15V[\x92a\x07\xF6V[\x91\x82\x01\x91\x01\x90a\x19\xCEV[_\x80\x80a\x19\xF7V[\x90h\x01\0\0\0\0\0\0\0\0\x81\x11a\x1AVW\x81a\x1AKa\x1AT\x93a\x07\xF2V[\x90\x82\x81Ua\x19\xEDV[V[a\x0C!V[_a\x1Ae\x91a\x1A-V[V[\x90_\x03a\x1AyWa\x1Aw\x90a\x1A[V[V[a\x10=V[\x90PQ\x90a\x1A\x8B\x82a\x07\x9DV[V[\x90` \x82\x82\x03\x12a\x1A\xA6Wa\x1A\xA3\x91_\x01a\x1A~V[\x90V[a\x01.V[a\x1A\xBAa\x1A\xC0\x91\x93\x92\x93a\x06!V[\x92a\x06!V[\x82\x03\x91\x82\x11a\x1A\xCBWV[a\x0FfV[\x90PQ\x90a\x1A\xDD\x82a\r\xD0V[V[\x90` \x82\x82\x03\x12a\x1A\xF8Wa\x1A\xF5\x91_\x01a\x1A\xD0V[\x90V[a\x01.V[a\x1B\x06\x90a\x03\x12V[\x90V[a\x1B\x12\x90a\x1A\xFDV[\x90V[a\x1B\x1E\x90a\x04\x17V[\x90RV[\x90`\xA0a\x1B\xB5`\x05a\x1B\xBD\x94a\x1BFa\x1B=_\x83\x01Ta\x03\xA5V[_\x87\x01\x90a\x1B\x15V[a\x1B`a\x1BV`\x01\x83\x01Ta\x03\xA5V[` \x87\x01\x90a\x1B\x15V[a\x1Bza\x1Bp`\x02\x83\x01Ta\x03\xA5V[`@\x87\x01\x90a\x1B\x15V[a\x1B\x94a\x1B\x8A`\x03\x83\x01Ta\x03\xA5V[``\x87\x01\x90a\x1B\x15V[a\x1B\xAEa\x1B\xA4`\x04\x83\x01Ta\x03\xA5V[`\x80\x87\x01\x90a\x1B\x15V[\x01Ta\x03\xA5V[\x91\x01\x90a\x1B\x15V[V[\x91\x90a\x1B\xD2\x90_`\xC0\x85\x01\x94\x01\x90a\x1B\"V[V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x14a!\xFFWa\x1C)a\x1C\x07Ba\x0F#V[[a\x1C#a\x1C\x1Da\x1C\x18`\na\x17QV[a\x05\x85V[\x91a\x05\x85V[\x11a\x17\xDDV[a\x1COa\x1CHa\x1C8Ba\x0F#V[a\x1CB`\na\x0FYV[\x90a\x0FzV[`\na\x0F\xE5V[a\x1CY`\x08a\x07\xF2V[a\x1Cla\x1Cf`\x01a\x11tV[\x91a\x06!V[\x14_\x14a!\xD5Wa\x1C\x98a\x1C\x8E`\x03a\x1C\x87`\x08_\x90a\x07\xFFV[P\x01a\x03\xB9V[`\x04`\x02\x01a\x10~V[a\x1C\xBCa\x1C\xB3`\x02a\x1C\xAC`\x08_\x90a\x07\xFFV[P\x01a\x03\xB9V[`\x02\x80\x01a\x10~V[a\x1C\xC9`\x01`\x02\x01a\x03\xB9V[a\x1C\xF1a\x1C\xEBa\x1C\xE6_a\x1C\xDF`\x08\x82\x90a\x07\xFFV[P\x01a\x03\xB9V[a\x04\x17V[\x91a\x04\x17V[\x03a \xD9W[a\x1D\x02_`\x08a\x1AgV[[a\x1D,\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\tiV[a\x1Duc\xD5q\x9D\xC2` a\x1D_\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\tiV[c\xEC\xA0g\xAD\x90a\x1Dma\x01$V[\x94\x85\x92a\x0C\xF7V[\x82R\x81\x80a\x1D\x85`\x04\x82\x01a\x02\xAFV[\x03\x91Z\xFA\x92\x83\x15a \xD4Wa\x1D\xCAa\x1D\xB5a\x1D\xD5\x95` \x95_\x91a \xA7W[Pa\x1D\xAF`\x01a\x11tV[\x90a\x1A\xABV[\x92a\x1D\xBEa\x01$V[\x95\x86\x94\x85\x93\x84\x93a\x0C\xF7V[\x83R`\x04\x83\x01a\x061V[\x03\x91Z\xFA\x80\x15a \xA2Wa\x1D\xF5\x91_\x91a tW[P`\x03`\x02\x01a\x10~V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x14a\x1F\xC0Wa\x1EMa\x1EH\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x1B\tV[a\tiV[a\x1E\x9Dc\x16\xBFUy` a\x1E\x88a\x1E\x83\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x1B\tV[a\tiV[b\x84\x12\x0C\x90a\x1E\x95a\x01$V[\x94\x85\x92a\x0C\xF7V[\x82R\x81\x80a\x1E\xAD`\x04\x82\x01a\x02\xAFV[\x03\x91Z\xFA\x92\x83\x15a\x1F\xBBWa\x1E\xF2a\x1E\xDDa\x1E\xFD\x95` \x95_\x91a\x1F\x8EW[Pa\x1E\xD7`\x01a\x11tV[\x90a\x1A\xABV[\x92a\x1E\xE6a\x01$V[\x95\x86\x94\x85\x93\x84\x93a\x0C\xF7V[\x83R`\x04\x83\x01a\x061V[\x03\x91Z\xFA\x80\x15a\x1F\x89Wa\x1F\x1D\x91_\x91a\x1F[W[P`\x05`\x02\x01a\x10~V[[`\x02a\x1FV\x7FU#\"\x99\xD8?\xAFM\xC2\xC3.\"\x8A\xF3v2\xBC\xA7\xFAm\xBC\x03\xB4\x12$\xC1\0\xC6\xC9\xDC\xA3I\x91a\x1FMa\x01$V[\x91\x82\x91\x82a\x1B\xBFV[\x03\x90\xA1V[a\x1F|\x91P` =\x81\x11a\x1F\x82W[a\x1Ft\x81\x83a\x0C5V[\x81\x01\x90a\x1A\xDFV[_a\x1F\x12V[P=a\x1FjV[a\r>V[a\x1F\xAE\x91P\x86=\x81\x11a\x1F\xB4W[a\x1F\xA6\x81\x83a\x0C5V[\x81\x01\x90a\x1A\x8DV[_a\x1E\xCCV[P=a\x1F\x9CV[a\r>V[a \x0C` a\x1F\xF6a\x1F\xF1\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x16\xE4V[a\x16\xF0V[c\t\xBDZ`\x90a \x04a\x01$V[\x93\x84\x92a\x0C\xF7V[\x82R\x81\x80a \x1C`\x04\x82\x01a\x02\xAFV[\x03\x91Z\xFA\x80\x15a oWa <\x91_\x91a AW[P`\x05`\x02\x01a\x10~V[a\x1F\x1EV[a b\x91P` =\x81\x11a hW[a Z\x81\x83a\x0C5V[\x81\x01\x90a\x1A\xDFV[_a 1V[P=a PV[a\r>V[a \x95\x91P` =\x81\x11a \x9BW[a \x8D\x81\x83a\x0C5V[\x81\x01\x90a\x1A\xDFV[_a\x1D\xEAV[P=a \x83V[a\r>V[a \xC7\x91P\x86=\x81\x11a \xCDW[a \xBF\x81\x83a\x0C5V[\x81\x01\x90a\x1A\x8DV[_a\x1D\xA4V[P=a \xB5V[a\r>V[a \xFDa \xF3_a \xEC`\x08\x82\x90a\x07\xFFV[P\x01a\x03\xB9V[`\x01`\x02\x01a\x10~V[a!&\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x07\x05V[c\xDA\xEA\xB4\x12a!B_a!;`\x08\x82\x90a\x07\xFFV[P\x01a\x03\xB9V[a!Z`\x01a!S`\x08_\x90a\x07\xFFV[P\x01a\x03\xB9V[\x92\x80;\x15a!\xD0Wa!\x7F_\x80\x94a!\x8Aa!sa\x01$V[\x97\x88\x96\x87\x95\x86\x94a\x0C\xF7V[\x84R`\x04\x84\x01a\x18\xBDV[\x03\x92Z\xF1\x80\x15a!\xCBWa!\x9FW[Pa\x1C\xF7V[a!\xBE\x90_=\x81\x11a!\xC4W[a!\xB6\x81\x83a\x0C5V[\x81\x01\x90a\x18\xAEV[_a!\x99V[P=a!\xACV[a\r>V[a\x0C\xF3V[a!\xFAa!\xE2`\x08a\x07\xF2V[a!\xF4a!\xEE_a\x0EsV[\x91a\x06!V[\x14a\x18\x85V[a\x1D\x03V[a\"K` a\"5a\"0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x16\xE4V[a\x16\xF0V[c\xB8\x07w\xEA\x90a\"Ca\x01$V[\x93\x84\x92a\x0C\xF7V[\x82R\x81\x80a\"[`\x04\x82\x01a\x02\xAFV[\x03\x91Z\xFA\x80\x15a\"\xA4Wa\x1C)\x91_\x91a\"vW[Pa\x1C\x08V[a\"\x97\x91P` =\x81\x11a\"\x9DW[a\"\x8F\x81\x83a\x0C5V[\x81\x01\x90a\x17\x1FV[_a\"pV[P=a\"\x85V[a\r>V[a\"\xB1a\x16\xBEV[V[a\"\xBBa)UV[a\"\xC3a\"\xC5V[V[a\"\xD6a\"\xD1_a\n\xA2V[a)\xEDV[V[a\"\xE0a\"\xB3V[V[_\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\"\xFDa#\x02\x91a\x03\x9DV[a\"\xE6V[\x90V[a#\x0F\x90Ta\"\xF1V[\x90V[a#\x1Aa\"\xE2V[Pa#$_a#\x05V[\x90V[a#8\x90a#3a)UV[a#:V[V[a#K\x90a#Fa&\xABV[a$\xEBV[a#Sa'\x10V[V[_\x7Fchallenge does not exist\0\0\0\0\0\0\0\0\x91\x01RV[a#\x89`\x18` \x92a\n\xAEV[a#\x92\x81a#UV[\x01\x90V[a#\xAB\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra#|V[\x90V[\x15a#\xB5WV[a#\xBDa\x01$V[bF\x1B\xCD`\xE5\x1B\x81R\x80a#\xD3`\x04\x82\x01a#\x96V[\x03\x90\xFD[a#\xEBa#\xE6a#\xF0\x92a\n\x83V[a\x03\x0FV[a\x05\x85V[\x90V[\x90P5\x90a$\0\x82a\r\xD0V[V[Pa$\x11\x90` \x81\x01\x90a#\xF3V[\x90V[\x90``a$sa${\x93a$6a$-_\x83\x01\x83a$\x02V[_\x86\x01\x90a\x1B\x15V[a$Pa$F` \x83\x01\x83a$\x02V[` \x86\x01\x90a\x1B\x15V[a$ja$``@\x83\x01\x83a$\x02V[`@\x86\x01\x90a\x1B\x15V[\x82\x81\x01\x90a$\x02V[\x91\x01\x90a\x1B\x15V[V[\x91\x90a$\x90\x90_`\x80\x85\x01\x94\x01\x90a$\x14V[V[_\x7Fassertion not found\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a$\xC6`\x13` \x92a\n\xAEV[a$\xCF\x81a$\x92V[\x01\x90V[a$\xE8\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra$\xB9V[\x90V[a%\x11a$\xF8`\x08a\x07\xF2V[a%\x0Ba%\x05`\x01a\x11tV[\x91a\x06!V[\x11a#\xAEV[a%\x1A\x81a'\\V[\x90a%$_a\x0EsV[[\x80a%Aa%;a%6`\x08a\x07\xF2V[a\x06!V[\x91a\x06!V[\x10\x15a&\x01W\x82a%va%pa%ka%fa%``\x08\x87\x90a\x07\xFFV[Pa\x0E\x9EV[a(\xDCV[a\x04\x17V[\x91a\x04\x17V[\x14a%\x89Wa%\x84\x90a\x0E\x8FV[a%%V[P\x90Pa%\x97_`\x08a\x1AgV[a%\xABa%\xA4`\x08a\x10\x05V[\x82\x90a\x11\x1DV[a%\xBEa%\xB7_a#\xD7V[`\na\x0F\xE5V[a%\xC6a\"\xA9V[a%\xFC\x7F  T+nk\x95\x1DL\x076\xEE\xD2\xA4\xD7b\xD2\x0B\xB1\xBAW\x9F\x99\xFE\xFF\xAE\x9B\x1D\xEA$\x08\x83\x91a%\xF3a\x01$V[\x91\x82\x91\x82a$}V[\x03\x90\xA1V[a&\ta\x01$V[bF\x1B\xCD`\xE5\x1B\x81R\x80a&\x1F`\x04\x82\x01a$\xD3V[\x03\x90\xFD[a&,\x90a#'V[V[a&?\x90a&:a)UV[a&AV[V[\x80a&\\a&Va&Q_a\n\xA2V[a\x01pV[\x91a\x01pV[\x14a&lWa&j\x90a)\xEDV[V[a&\x8Fa&x_a\n\xA2V[_\x91\x82\x91c\x1EO\xBD\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x01\x89V[\x03\x90\xFD[a&\x9C\x90a&.V[V[a&\xA8`\x02a\x11UV[\x90V[a&\xB5`\x01a\x11\xA4V[a&\xCEa&\xC8a&\xC3a&\x9EV[a\x06!V[\x91a\x06!V[\x14a&\xE7Wa&\xE5a&\xDEa&\x9EV[`\x01a\x11\xF5V[V[_c>\xE5\xAE\xB5`\xE0\x1B\x81R\x80a&\xFF`\x04\x82\x01a\x02\xAFV[\x03\x90\xFD[a'\r`\x01a\x11tV[\x90V[a'\"a'\x1Ba'\x03V[`\x01a\x11\xF5V[V[\x92a'P` a'X\x94a'H\x82\x88a'@\x82\x9B\x9A\x83\x99a\x0B\xE4V[\x01\x80\x92a\x0B\xE4V[\x01\x80\x92a\x0B\xE4V[\x01\x80\x92a\x0B\xE4V[\x01\x90V[a'da\x19jV[Pa'\xBFa's_\x83\x01a\r\xE4V[a'\xB0a'\x82` \x85\x01a\r\xE4V[\x93a'\x9B``a'\x94`@\x84\x01a\r\xE4V[\x92\x01a\r\xE4V[\x90a'\xA4a\x01$V[\x95\x86\x94` \x86\x01a'$V[` \x82\x01\x81\x03\x82R\x03\x82a\x0C5V[a'\xD1a'\xCB\x82a\x0CdV[\x91a\x0C^V[ \x90V[a($\x94a(\x14` \x80\x99\x98\x95\x96a(\x0C\x82\x80\x99a(\x04\x82\x89a'\xFC\x82\x9Ba(\x1C\x9Da\x0B\xE4V[\x01\x80\x92a\x0B\xE4V[\x01\x80\x92a\x0B\xE4V[\x01\x80\x92a\x0B\xE4V[\x01\x80\x92a\x0B\xE4V[\x01\x80\x92a\x0B\xE4V[\x01\x90V[a(0a\x19jV[Pa(\xA4a(?_\x83\x01a\x03\xB9V[a(\x95a(N`\x01\x85\x01a\x03\xB9V[\x93a([`\x02\x82\x01a\x03\xB9V[\x90a(h`\x03\x82\x01a\x03\xB9V[a(\x80`\x05a(y`\x04\x85\x01a\x03\xB9V[\x93\x01a\x03\xB9V[\x92a(\x89a\x01$V[\x97\x88\x96` \x88\x01a'\xD5V[` \x82\x01\x81\x03\x82R\x03\x82a\x0C5V[a(\xB6a(\xB0\x82a\x0CdV[\x91a\x0C^V[ \x90V[a(\xD9\x91a(\xD0\x91a(\xCAa\"\xE2V[Pa*pV[\x90\x92\x91\x92a+mV[\x90V[a(\xE4a\x19jV[Pa)?a(\xF3_\x83\x01a\x03\xB9V[a)0a)\x02`\x01\x85\x01a\x03\xB9V[\x93a)\x1B`\x03a)\x14`\x02\x84\x01a\x03\xB9V[\x92\x01a\x03\xB9V[\x90a)$a\x01$V[\x95\x86\x94` \x86\x01a'$V[` \x82\x01\x81\x03\x82R\x03\x82a\x0C5V[a)Qa)K\x82a\x0CdV[\x91a\x0C^V[ \x90V[a)]a#\x12V[a)va)pa)ka,>V[a\x01pV[\x91a\x01pV[\x03a)}WV[a)\x9Fa)\x88a,>V[_\x91\x82\x91c\x11\x8C\xDA\xA7`\xE0\x1B\x83R`\x04\x83\x01a\x01\x89V[\x03\x90\xFD[\x90a)\xB4`\x01\x80`\xA0\x1B\x03\x91a\x0F\xA4V[\x91\x81\x19\x16\x91\x16\x17\x90V[a)\xC7\x90a\x03.V[\x90V[\x90V[\x90a)\xE2a)\xDDa)\xE9\x92a)\xBEV[a)\xCAV[\x82Ta)\xA3V[\x90UV[a)\xF6_a#\x05V[a*\0\x82_a)\xCDV[\x90a*4a*.\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x93a)\xBEV[\x91a)\xBEV[\x91a*=a\x01$V[\x80a*G\x81a\x02\xAFV[\x03\x90\xA3V[_\x90V[a*da*_a*i\x92a\x06!V[a\x0F\xA4V[a\x04\x17V[\x90V[_\x90V[\x91\x90\x91a*{a\"\xE2V[Pa*\x84a*LV[Pa*\x8Da\x19jV[Pa*\x97\x83a\x0CdV[a*\xAAa*\xA4`Aa\x0B@V[\x91a\x06!V[\x14_\x14a*\xF1Wa*\xEA\x91\x92a*\xBEa\x19jV[Pa*\xC7a\x19jV[Pa*\xD0a*lV[P` \x81\x01Q```@\x83\x01Q\x92\x01Q_\x1A\x90\x91\x92a,\xD7V[\x91\x92\x90\x91\x90V[Pa*\xFB_a\n\xA2V[\x90a+\x0Fa+\n`\x02\x94a\x0CdV[a*PV[\x91\x92\x91\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x04\x11\x15a+3WV[a+\x15V[\x90a+B\x82a+)V[V[\x91\x90a+W\x90_` \x85\x01\x94\x01\x90a\x04\x1AV[V[a+ea+j\x91a\x03\x9DV[a\x11\xD6V[\x90V[\x80a+\x80a+z_a+8V[\x91a+8V[\x14_\x14a+\x8BWPPV[\x80a+\x9Fa+\x99`\x01a+8V[\x91a+8V[\x14_\x14a+\xC2W_c\xF6E\xEE\xDF`\xE0\x1B\x81R\x80a+\xBE`\x04\x82\x01a\x02\xAFV[\x03\x90\xFD[\x80a+\xD6a+\xD0`\x02a+8V[\x91a+8V[\x14_\x14a,\x04Wa,\0a+\xE9\x83a+YV[_\x91\x82\x91c\xFC\xE6\x98\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x061V[\x03\x90\xFD[a,\x17a,\x11`\x03a+8V[\x91a+8V[\x14a,\x1FWPV[a,:\x90_\x91\x82\x91c5\xE2\xF3\x83`\xE2\x1B\x83R`\x04\x83\x01a+DV[\x03\x90\xFD[a,Fa\"\xE2V[P3\x90V[\x90V[a,ba,]a,g\x92a,KV[a\x03\x0FV[a\x06!V[\x90V[`\xFF\x16\x90V[a,y\x90a,jV[\x90RV[a,\xB2a,\xB9\x94a,\xA8``\x94\x98\x97\x95a,\x9E`\x80\x86\x01\x9A_\x87\x01\x90a\x04\x1AV[` \x85\x01\x90a,pV[`@\x83\x01\x90a\x04\x1AV[\x01\x90a\x04\x1AV[V[a,\xCFa,\xCAa,\xD4\x92a\n\x83V[a\x0F\xA4V[a\x04\x17V[\x90V[\x93\x92\x93a,\xE2a\"\xE2V[Pa,\xEBa*LV[Pa,\xF4a\x19jV[Pa,\xFE\x85a+YV[a-0a-*\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0a,NV[\x91a\x06!V[\x11a-\xBDW\x90a-S` \x94\x95_\x94\x93\x92\x93a-Ja\x01$V[\x94\x85\x94\x85a,}V[\x83\x80R\x03\x90`\x01Z\xFA\x15a-\xB8Wa-k_Qa\x0F\xA4V[\x80a-\x86a-\x80a-{_a\n\xA2V[a\x01pV[\x91a\x01pV[\x14a-\x9CW_\x91a-\x96_a,\xBBV[\x91\x92\x91\x90V[Pa-\xA6_a\n\xA2V[`\x01\x91a-\xB2_a,\xBBV[\x91\x92\x91\x90V[a\r>V[PPPa-\xC9_a\n\xA2V[\x90`\x03\x92\x91\x92\x91\x90V",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610015575b36610a6157005b61001f5f3561011e565b806327d40299146101195780633183baac146101145780633a009a061461010f5780633ceaae7d1461010a578063470b9b1a146101055780634bd167c914610100578063697b5e62146100fb5780636c4c2060146100f6578063715018a6146100f157806380959721146100ec5780638da5cb5b146100e7578063a56ec6cd146100e2578063dc68cdfe146100dd578063e78cea92146100d8578063ee1c28b8146100d35763f2fde38b0361000e57610a2e565b6109db565b610997565b610912565b6108bb565b610768565b610733565b6106ae565b61067b565b610646565b6105b4565b610509565b610482565b610368565b6102b4565b61019e565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f91031261013c57565b61012e565b7f000000000000000000000000000000000000000000000000000000000000000090565b60018060a01b031690565b61017990610165565b90565b61018590610170565b9052565b919061019c905f6020850194019061017c565b565b346101ce576101ae366004610132565b6101ca6101b9610141565b6101c1610124565b91829182610189565b0390f35b61012a565b5f80fd5b5f80fd5b908160809103126101e95790565b6101d7565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156102345781359167ffffffffffffffff831161022f57602001926001830284011161022a57565b6101f6565b6101f2565b6101ee565b61024281610170565b0361024957565b5f80fd5b9050359061025a82610239565b565b9060c0828203126102aa57610273815f84016101db565b92608083013567ffffffffffffffff81116102a557610297836102a29286016101fa565b93909460a00161024d565b90565b6101d3565b61012e565b5f0190565b346102e6576102d06102c736600461025c565b929190916116b0565b6102d8610124565b806102e2816102af565b0390f35b61012a565b7f000000000000000000000000000000000000000000000000000000000000000090565b90565b61032661032161032b92610165565b61030f565b610165565b90565b61033790610312565b90565b6103439061032e565b90565b61034f9061033a565b9052565b9190610366905f60208501940190610346565b565b3461039857610378366004610132565b6103946103836102eb565b61038b610124565b91829182610353565b0390f35b61012a565b5f1c90565b90565b6103b16103b69161039d565b6103a2565b90565b6103c390546103a5565b90565b6002906103d45f83016103b9565b916103e1600182016103b9565b916103ee600283016103b9565b916103fb600382016103b9565b91610414600561040d600485016103b9565b93016103b9565b90565b90565b61042390610417565b9052565b919461046f6104799298979561046560a09661045b6104809a61045160c08a019e5f8b019061041a565b602089019061041a565b604087019061041a565b606085019061041a565b608083019061041a565b019061041a565b565b346104b957610492366004610132565b6104b561049d6103c6565b926104ac969496929192610124565b96879687610427565b0390f35b61012a565b7f000000000000000000000000000000000000000000000000000000000000000090565b151590565b6104f0906104e2565b9052565b9190610507905f602085019401906104e7565b565b3461053957610519366004610132565b6105356105246104be565b61052c610124565b918291826104f4565b0390f35b61012a565b1c90565b67ffffffffffffffff1690565b61055f906008610564930261053e565b610542565b90565b90610572915461054f565b90565b610582600a600890610567565b90565b67ffffffffffffffff1690565b61059b90610585565b9052565b91906105b2905f60208501940190610592565b565b346105e4576105c4366004610132565b6105e06105cf610575565b6105d7610124565b9182918261059f565b0390f35b61012a565b90565b6105fc906008610601930261053e565b6105e9565b90565b9061060f91546105ec565b90565b61061e60095f90610604565b90565b90565b61062d90610621565b9052565b9190610644905f60208501940190610624565b565b3461067657610656366004610132565b610672610661610612565b610669610124565b91829182610631565b0390f35b61012a565b346106a95761068b366004610132565b6106936122a9565b61069b610124565b806106a5816102af565b0390f35b61012a565b346106dc576106be366004610132565b6106c66122d8565b6106ce610124565b806106d8816102af565b0390f35b61012a565b7f000000000000000000000000000000000000000000000000000000000000000090565b61070e9061032e565b90565b61071a90610705565b9052565b9190610731905f60208501940190610711565b565b3461076357610743366004610132565b61075f61074e6106e1565b610756610124565b9182918261071e565b0390f35b61012a565b3461079857610778366004610132565b610794610783612312565b61078b610124565b91829182610189565b0390f35b61012a565b6107a681610621565b036107ad57565b5f80fd5b905035906107be8261079d565b565b906020828203126107d9576107d6915f016107b1565b90565b61012e565b634e487b7160e01b5f52603260045260245ffd5b5490565b5f5260205f2090565b610808816107f2565b8210156108225761081a6004916107f6565b910201905f90565b6107de565b600890610833826107f2565b81101561087957610843916107ff565b50906108505f83016103b9565b9161085d600182016103b9565b91610876600361086f600285016103b9565b93016103b9565b90565b5f80fd5b6108b26108b9946108a860609498979561089e608086019a5f87019061041a565b602085019061041a565b604083019061041a565b019061041a565b565b346108ef576108eb6108d66108d13660046107c0565b610827565b906108e2949294610124565b9485948561087d565b0390f35b61012a565b9060808282031261090d5761090a915f016101db565b90565b61012e565b346109405761092a6109253660046108f4565b612623565b610932610124565b8061093c816102af565b0390f35b61012a565b7f000000000000000000000000000000000000000000000000000000000000000090565b6109729061032e565b90565b61097e90610969565b9052565b9190610995905f60208501940190610975565b565b346109c7576109a7366004610132565b6109c36109b2610945565b6109ba610124565b91829182610982565b0390f35b61012a565b6109d8600a5f90610567565b90565b34610a0b576109eb366004610132565b610a076109f66109cc565b6109fe610124565b9182918261059f565b0390f35b61012a565b90602082820312610a2957610a26915f0161024d565b90565b61012e565b34610a5c57610a46610a41366004610a10565b612693565b610a4e610124565b80610a58816102af565b0390f35b61012a565b5f80fd5b90610a79939291610a746126ab565b61132c565b610a81612710565b565b90565b610a9a610a95610a9f92610a83565b61030f565b610165565b90565b610aab90610a86565b90565b60209181520190565b5f7f72657761726420616464726573732063616e6e6f74206265207a65726f000000910152565b610aeb601d602092610aae565b610af481610ab7565b0190565b610b0d9060208101905f818303910152610ade565b90565b15610b1757565b610b1f610124565b62461bcd60e51b815280610b3560048201610af8565b0390fd5b5090565b90565b610b54610b4f610b5992610b3d565b61030f565b610621565b90565b5f7f696e76616c6964207369676e6174757265206c656e6774680000000000000000910152565b610b906018602092610aae565b610b9981610b5c565b0190565b610bb29060208101905f818303910152610b83565b90565b15610bbc57565b610bc4610124565b62461bcd60e51b815280610bda60048201610b9d565b0390fd5b90565b90565b610bf0610bf591610417565b610be1565b9052565b602081610c0b610c1393839695610be4565b018092610be4565b0190565b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b90610c3f90610c17565b810190811067ffffffffffffffff821117610c5957604052565b610c21565b60200190565b5190565b5f80fd5b90610c7f610c78610124565b9283610c35565b565b67ffffffffffffffff8111610c9f57610c9b602091610c17565b0190565b610c21565b90825f939282370152565b90929192610cc4610cbf82610c81565b610c6c565b93818552602085019082840111610ce057610cde92610ca4565b565b610c68565b610cf0913691610caf565b90565b5f80fd5b60e01b90565b610d06816104e2565b03610d0d57565b5f80fd5b90505190610d1e82610cfd565b565b90602082820312610d3957610d36915f01610d11565b90565b61012e565b610d46610124565b3d5f823e3d90fd5b5f7f696e76616c696420746565207369676e61747572650000000000000000000000910152565b610d826015602092610aae565b610d8b81610d4e565b0190565b610da49060208101905f818303910152610d75565b90565b15610dae57565b610db6610124565b62461bcd60e51b815280610dcc60048201610d8f565b0390fd5b610dd981610417565b03610de057565b5f80fd5b35610dee81610dd0565b90565b5f7f756e6578706563746564206c3120656e64206261746368206163630000000000910152565b610e25601b602092610aae565b610e2e81610df1565b0190565b610e479060208101905f818303910152610e18565b90565b15610e5157565b610e59610124565b62461bcd60e51b815280610e6f60048201610e32565b0390fd5b610e87610e82610e8c92610a83565b61030f565b610621565b90565b6001610e9b9101610621565b90565b90565b5f7f617373657274696f6e20616c7265616479206578697374730000000000000000910152565b610ed56018602092610aae565b610ede81610ea1565b0190565b610ef79060208101905f818303910152610ec8565b90565b15610f0157565b610f09610124565b62461bcd60e51b815280610f1f60048201610ee2565b0390fd5b610f37610f32610f3c92610621565b61030f565b610585565b90565b60401c90565b610f51610f5691610f3f565b610542565b90565b610f639054610f45565b90565b634e487b7160e01b5f52601160045260245ffd5b610f86610f8c91610585565b91610585565b019067ffffffffffffffff8211610f9f57565b610f66565b5f1b90565b90610fbc67ffffffffffffffff91610fa4565b9181191691161790565b610fda610fd5610fdf92610585565b61030f565b610585565b90565b90565b90610ffa610ff561100192610fc6565b610fe2565b8254610fa9565b9055565b90565b5f5260205f2090565b5490565b61101e81611011565b82101561103857611030600491611008565b910201905f90565b6107de565b634e487b7160e01b5f525f60045260245ffd5b9061105c5f1991610fa4565b9181191691161790565b61106f90610417565b90565b61107b9061039d565b90565b9061109361108e61109a92611066565b611072565b8254611050565b9055565b906110fb60606003611101946110c15f82016110bb5f8801610de4565b9061107e565b6110da600182016110d460208801610de4565b9061107e565b6110f3600282016110ed60408801610de4565b9061107e565b019201610de4565b9061107e565b565b9190611114576111129161109e565b565b61103d565b1b90565b908154916801000000000000000083101561114d578261114591600161114b95018155611015565b90611103565b565b610c21565b90565b61116961116461116e92611152565b61030f565b610621565b90565b90565b61118861118361118d92611171565b61030f565b610621565b90565b61119c6111a19161039d565b6105e9565b90565b6111ae9054611190565b90565b6111c06111c691939293610621565b92610621565b82018092116111d157565b610f66565b6111ea6111e56111ef92610621565b61030f565b610621565b90565b90565b9061120a611205611211926111d6565b6111f2565b8254611050565b9055565b61121e90610312565b90565b61122a90611215565b90565b6112369061032e565b90565b6112429061032e565b90565b905090565b6112555f8092611245565b0190565b6112629061124a565b90565b9061127761127283610c81565b610c6c565b918252565b606090565b3d5f1461129c576112913d611265565b903d5f602084013e5b565b6112a461127c565b9061129a565b5f7f7061796d656e74206661696c6564000000000000000000000000000000000000910152565b6112de600e602092610aae565b6112e7816112aa565b0190565b6113009060208101905f8183039101526112d1565b90565b1561130a57565b611312610124565b62461bcd60e51b815280611328600482016112eb565b0390fd5b929060206114419195939561135c8461135561134f61134a5f610aa2565b610170565b91610170565b1415610b10565b61138361136a828990610b39565b61137d6113776041610b40565b91610621565b14610bb5565b61138c8661275c565b966114366114216113a56113a06002610bde565b612828565b6113ce8b916113c06113b5610124565b9384928a8401610bf9565b888201810382520382610c35565b6113e06113da82610c64565b91610c5e565b209361141b61140e7f000000000000000000000000000000000000000000000000000000000000000061033a565b94637217efcd9692610ce5565b906128ba565b9261142a610124565b95869485938493610cf7565b835260048301610189565b03915afa80156116ab5761145c915f9161167d575b50610da7565b6114867f0000000000000000000000000000000000000000000000000000000000000000156104e2565b8015611647575b61149690610e4a565b61149f5f610e73565b5b806114bc6114b66114b160086107f2565b610621565b91610621565b101561150957611504906114ff866114f86114f26114ed6114e86114e2600888906107ff565b50610e9e565b6128dc565b610417565b91610417565b1415610efa565b610e8f565b6114a0565b509161154291935061151b60086107f2565b61152d6115275f610e73565b91610621565b1461161c575b61153d6008611005565b61111d565b61154c60086107f2565b61155f6115596002611155565b91610621565b14611568575b50565b5f806115e76115e26116169461159a6115936115846001611174565b61158e60096111a4565b6111b1565b60096111f5565b6115a460096111a4565b6115da7f37e8add694c5926d564e971160f5974103cbbbc7c90747c4c6f802031d3567a7916115d1610124565b91829182610631565b0390a1611221565b61122d565b6115f030611239565b316115f9610124565b908161160481611259565b03925af1611610611281565b50611303565b5f611565565b61164261163b61162b42610f23565b611635600a610f59565b90610f7a565b600a610fe5565b611533565b5061149661165760608501610de4565b61167561166f61166a60056002016103b9565b610417565b91610417565b14905061148d565b61169e915060203d81116116a4575b6116968183610c35565b810190610d20565b5f611456565b503d61168c565b610d3e565b906116bc939291610a65565b565b6116c66126ab565b6116ce611bd4565b6116d6612710565b565b6116e190610312565b90565b6116ed906116d8565b90565b6116f99061032e565b90565b61170581610585565b0361170c57565b5f80fd5b9050519061171d826116fc565b565b9060208282031261173857611735915f01611710565b90565b61012e565b61174961174e9161039d565b610542565b90565b61175b905461173d565b90565b60207f696e73756666696369656e742074696d65206861732070617373656400000000917f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201520152565b6117b8603c604092610aae565b6117c18161175e565b0190565b6117da9060208101905f8183039101526117ab565b90565b156117e457565b6117ec610124565b62461bcd60e51b815280611802600482016117c5565b0390fd5b60207f746f6f206d616e7920617373657274696f6e7300000000000000000000000000917f63616e6e6f7420636c6f7365206368616c6c656e67652077696e646f77202d205f8201520152565b6118606033604092610aae565b61186981611806565b0190565b6118829060208101905f818303910152611853565b90565b1561188c57565b611894610124565b62461bcd60e51b8152806118aa6004820161186d565b0390fd5b5f9103126118b857565b61012e565b9160206118de9294936118d760408201965f83019061041a565b019061041a565b565b6118ef6118f591939293610621565b92610621565b91611901838202610621565b92818404149015171561191057565b610f66565b6119209060046118e0565b90565b9190600861193e9102916119385f1984611119565b92611119565b9181191691161790565b919061195e61195961196693611066565b611072565b908354611923565b9055565b5f90565b6119809161197a61196a565b91611948565b565b5f60036119b5926119958380830161196e565b6119a2836001830161196e565b6119af836002830161196e565b0161196e565b565b905f036119c9576119c790611982565b565b61103d565b5b8181106119da575050565b806119e75f6004936119b7565b016119cf565b90918281106119fc575b505050565b611a1a611a14611a0e611a2595611915565b92611915565b926107f6565b9182019101906119ce565b5f80806119f7565b90680100000000000000008111611a565781611a4b611a54936107f2565b908281556119ed565b565b610c21565b5f611a6591611a2d565b565b905f03611a7957611a7790611a5b565b565b61103d565b90505190611a8b8261079d565b565b90602082820312611aa657611aa3915f01611a7e565b90565b61012e565b611aba611ac091939293610621565b92610621565b8203918211611acb57565b610f66565b90505190611add82610dd0565b565b90602082820312611af857611af5915f01611ad0565b90565b61012e565b611b0690610312565b90565b611b1290611afd565b90565b611b1e90610417565b9052565b9060a0611bb56005611bbd94611b46611b3d5f8301546103a5565b5f870190611b15565b611b60611b5660018301546103a5565b6020870190611b15565b611b7a611b7060028301546103a5565b6040870190611b15565b611b94611b8a60038301546103a5565b6060870190611b15565b611bae611ba460048301546103a5565b6080870190611b15565b01546103a5565b910190611b15565b565b9190611bd2905f60c08501940190611b22565b565b7f00000000000000000000000000000000000000000000000000000000000000005f146121ff57611c29611c0742610f23565b5b611c23611c1d611c18600a611751565b610585565b91610585565b116117dd565b611c4f611c48611c3842610f23565b611c42600a610f59565b90610f7a565b600a610fe5565b611c5960086107f2565b611c6c611c666001611174565b91610621565b145f146121d557611c98611c8e6003611c8760085f906107ff565b50016103b9565b600460020161107e565b611cbc611cb36002611cac60085f906107ff565b50016103b9565b6002800161107e565b611cc960016002016103b9565b611cf1611ceb611ce65f611cdf600882906107ff565b50016103b9565b610417565b91610417565b036120d9575b611d025f6008611a67565b5b611d2c7f0000000000000000000000000000000000000000000000000000000000000000610969565b611d7563d5719dc26020611d5f7f0000000000000000000000000000000000000000000000000000000000000000610969565b63eca067ad90611d6d610124565b948592610cf7565b82528180611d85600482016102af565b03915afa9283156120d457611dca611db5611dd5956020955f916120a7575b50611daf6001611174565b90611aab565b92611dbe610124565b95869485938493610cf7565b835260048301610631565b03915afa80156120a257611df5915f91612074575b50600360020161107e565b7f00000000000000000000000000000000000000000000000000000000000000005f14611fc057611e4d611e487f0000000000000000000000000000000000000000000000000000000000000000611b09565b610969565b611e9d6316bf55796020611e88611e837f0000000000000000000000000000000000000000000000000000000000000000611b09565b610969565b6284120c90611e95610124565b948592610cf7565b82528180611ead600482016102af565b03915afa928315611fbb57611ef2611edd611efd956020955f91611f8e575b50611ed76001611174565b90611aab565b92611ee6610124565b95869485938493610cf7565b835260048301610631565b03915afa8015611f8957611f1d915f91611f5b575b50600560020161107e565b5b6002611f567f55232299d83faf4dc2c32e228af37632bca7fa6dbc03b41224c100c6c9dca34991611f4d610124565b91829182611bbf565b0390a1565b611f7c915060203d8111611f82575b611f748183610c35565b810190611adf565b5f611f12565b503d611f6a565b610d3e565b611fae9150863d8111611fb4575b611fa68183610c35565b810190611a8d565b5f611ecc565b503d611f9c565b610d3e565b61200c6020611ff6611ff17f00000000000000000000000000000000000000000000000000000000000000006116e4565b6116f0565b6309bd5a6090612004610124565b938492610cf7565b8252818061201c600482016102af565b03915afa801561206f5761203c915f91612041575b50600560020161107e565b611f1e565b612062915060203d8111612068575b61205a8183610c35565b810190611adf565b5f612031565b503d612050565b610d3e565b612095915060203d811161209b575b61208d8183610c35565b810190611adf565b5f611dea565b503d612083565b610d3e565b6120c79150863d81116120cd575b6120bf8183610c35565b810190611a8d565b5f611da4565b503d6120b5565b610d3e565b6120fd6120f35f6120ec600882906107ff565b50016103b9565b600160020161107e565b6121267f0000000000000000000000000000000000000000000000000000000000000000610705565b63daeab4126121425f61213b600882906107ff565b50016103b9565b61215a600161215360085f906107ff565b50016103b9565b92803b156121d05761217f5f809461218a612173610124565b97889687958694610cf7565b8452600484016118bd565b03925af180156121cb5761219f575b50611cf7565b6121be905f3d81116121c4575b6121b68183610c35565b8101906118ae565b5f612199565b503d6121ac565b610d3e565b610cf3565b6121fa6121e260086107f2565b6121f46121ee5f610e73565b91610621565b14611885565b611d03565b61224b60206122356122307f00000000000000000000000000000000000000000000000000000000000000006116e4565b6116f0565b63b80777ea90612243610124565b938492610cf7565b8252818061225b600482016102af565b03915afa80156122a457611c29915f91612276575b50611c08565b612297915060203d811161229d575b61228f8183610c35565b81019061171f565b5f612270565b503d612285565b610d3e565b6122b16116be565b565b6122bb612955565b6122c36122c5565b565b6122d66122d15f610aa2565b6129ed565b565b6122e06122b3565b565b5f90565b60018060a01b031690565b6122fd6123029161039d565b6122e6565b90565b61230f90546122f1565b90565b61231a6122e2565b506123245f612305565b90565b61233890612333612955565b61233a565b565b61234b906123466126ab565b6124eb565b612353612710565b565b5f7f6368616c6c656e676520646f6573206e6f742065786973740000000000000000910152565b6123896018602092610aae565b61239281612355565b0190565b6123ab9060208101905f81830391015261237c565b90565b156123b557565b6123bd610124565b62461bcd60e51b8152806123d360048201612396565b0390fd5b6123eb6123e66123f092610a83565b61030f565b610585565b90565b9050359061240082610dd0565b565b506124119060208101906123f3565b90565b90606061247361247b9361243661242d5f830183612402565b5f860190611b15565b6124506124466020830183612402565b6020860190611b15565b61246a6124606040830183612402565b6040860190611b15565b82810190612402565b910190611b15565b565b9190612490905f60808501940190612414565b565b5f7f617373657274696f6e206e6f7420666f756e6400000000000000000000000000910152565b6124c66013602092610aae565b6124cf81612492565b0190565b6124e89060208101905f8183039101526124b9565b90565b6125116124f860086107f2565b61250b6125056001611174565b91610621565b116123ae565b61251a8161275c565b906125245f610e73565b5b8061254161253b61253660086107f2565b610621565b91610621565b1015612601578261257661257061256b612566612560600887906107ff565b50610e9e565b6128dc565b610417565b91610417565b146125895761258490610e8f565b612525565b5090506125975f6008611a67565b6125ab6125a46008611005565b829061111d565b6125be6125b75f6123d7565b600a610fe5565b6125c66122a9565b6125fc7f2020542b6e6b951d4c0736eed2a4d762d20bb1ba579f99feffae9b1dea240883916125f3610124565b9182918261247d565b0390a1565b612609610124565b62461bcd60e51b81528061261f600482016124d3565b0390fd5b61262c90612327565b565b61263f9061263a612955565b612641565b565b8061265c6126566126515f610aa2565b610170565b91610170565b1461266c5761266a906129ed565b565b61268f6126785f610aa2565b5f918291631e4fbdf760e01b835260048301610189565b0390fd5b61269c9061262e565b565b6126a86002611155565b90565b6126b560016111a4565b6126ce6126c86126c361269e565b610621565b91610621565b146126e7576126e56126de61269e565b60016111f5565b565b5f633ee5aeb560e01b8152806126ff600482016102af565b0390fd5b61270d6001611174565b90565b61272261271b612703565b60016111f5565b565b926127506020612758946127488288612740829b9a8399610be4565b018092610be4565b018092610be4565b018092610be4565b0190565b61276461196a565b506127bf6127735f8301610de4565b6127b061278260208501610de4565b9361279b606061279460408401610de4565b9201610de4565b906127a4610124565b95869460208601612724565b60208201810382520382610c35565b6127d16127cb82610c64565b91610c5e565b2090565b612824946128146020809998959661280c82809961280482896127fc829b61281c9d610be4565b018092610be4565b018092610be4565b018092610be4565b018092610be4565b018092610be4565b0190565b61283061196a565b506128a461283f5f83016103b9565b61289561284e600185016103b9565b9361285b600282016103b9565b90612868600382016103b9565b6128806005612879600485016103b9565b93016103b9565b92612889610124565b978896602088016127d5565b60208201810382520382610c35565b6128b66128b082610c64565b91610c5e565b2090565b6128d9916128d0916128ca6122e2565b50612a70565b90929192612b6d565b90565b6128e461196a565b5061293f6128f35f83016103b9565b612930612902600185016103b9565b9361291b6003612914600284016103b9565b92016103b9565b90612924610124565b95869460208601612724565b60208201810382520382610c35565b61295161294b82610c64565b91610c5e565b2090565b61295d612312565b61297661297061296b612c3e565b610170565b91610170565b0361297d57565b61299f612988612c3e565b5f91829163118cdaa760e01b835260048301610189565b0390fd5b906129b460018060a01b0391610fa4565b9181191691161790565b6129c79061032e565b90565b90565b906129e26129dd6129e9926129be565b6129ca565b82546129a3565b9055565b6129f65f612305565b612a00825f6129cd565b90612a34612a2e7f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0936129be565b916129be565b91612a3d610124565b80612a47816102af565b0390a3565b5f90565b612a64612a5f612a6992610621565b610fa4565b610417565b90565b5f90565b919091612a7b6122e2565b50612a84612a4c565b50612a8d61196a565b50612a9783610c64565b612aaa612aa46041610b40565b91610621565b145f14612af157612aea9192612abe61196a565b50612ac761196a565b50612ad0612a6c565b506020810151606060408301519201515f1a909192612cd7565b9192909190565b50612afb5f610aa2565b90612b0f612b0a600294610c64565b612a50565b91929190565b634e487b7160e01b5f52602160045260245ffd5b60041115612b3357565b612b15565b90612b4282612b29565b565b9190612b57905f6020850194019061041a565b565b612b65612b6a9161039d565b6111d6565b90565b80612b80612b7a5f612b38565b91612b38565b145f14612b8b575050565b80612b9f612b996001612b38565b91612b38565b145f14612bc2575f63f645eedf60e01b815280612bbe600482016102af565b0390fd5b80612bd6612bd06002612b38565b91612b38565b145f14612c0457612c00612be983612b59565b5f91829163fce698f760e01b835260048301610631565b0390fd5b612c17612c116003612b38565b91612b38565b14612c1f5750565b612c3a905f9182916335e2f38360e21b835260048301612b44565b0390fd5b612c466122e2565b503390565b90565b612c62612c5d612c6792612c4b565b61030f565b610621565b90565b60ff1690565b612c7990612c6a565b9052565b612cb2612cb994612ca8606094989795612c9e608086019a5f87019061041a565b6020850190612c70565b604083019061041a565b019061041a565b565b612ccf612cca612cd492610a83565b610fa4565b610417565b90565b939293612ce26122e2565b50612ceb612a4c565b50612cf461196a565b50612cfe85612b59565b612d30612d2a7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0612c4e565b91610621565b11612dbd5790612d53602094955f94939293612d4a610124565b94859485612c7d565b838052039060015afa15612db857612d6b5f51610fa4565b80612d86612d80612d7b5f610aa2565b610170565b91610170565b14612d9c575f91612d965f612cbb565b91929190565b50612da65f610aa2565b600191612db25f612cbb565b91929190565b610d3e565b505050612dc95f610aa2565b906003929192919056
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x15W[6a\naW\0[a\0\x1F_5a\x01\x1EV[\x80c'\xD4\x02\x99\x14a\x01\x19W\x80c1\x83\xBA\xAC\x14a\x01\x14W\x80c:\0\x9A\x06\x14a\x01\x0FW\x80c<\xEA\xAE}\x14a\x01\nW\x80cG\x0B\x9B\x1A\x14a\x01\x05W\x80cK\xD1g\xC9\x14a\x01\0W\x80ci{^b\x14a\0\xFBW\x80clL `\x14a\0\xF6W\x80cqP\x18\xA6\x14a\0\xF1W\x80c\x80\x95\x97!\x14a\0\xECW\x80c\x8D\xA5\xCB[\x14a\0\xE7W\x80c\xA5n\xC6\xCD\x14a\0\xE2W\x80c\xDCh\xCD\xFE\x14a\0\xDDW\x80c\xE7\x8C\xEA\x92\x14a\0\xD8W\x80c\xEE\x1C(\xB8\x14a\0\xD3Wc\xF2\xFD\xE3\x8B\x03a\0\x0EWa\n.V[a\t\xDBV[a\t\x97V[a\t\x12V[a\x08\xBBV[a\x07hV[a\x073V[a\x06\xAEV[a\x06{V[a\x06FV[a\x05\xB4V[a\x05\tV[a\x04\x82V[a\x03hV[a\x02\xB4V[a\x01\x9EV[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x91\x03\x12a\x01<WV[a\x01.V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x01y\x90a\x01eV[\x90V[a\x01\x85\x90a\x01pV[\x90RV[\x91\x90a\x01\x9C\x90_` \x85\x01\x94\x01\x90a\x01|V[V[4a\x01\xCEWa\x01\xAE6`\x04a\x012V[a\x01\xCAa\x01\xB9a\x01AV[a\x01\xC1a\x01$V[\x91\x82\x91\x82a\x01\x89V[\x03\x90\xF3[a\x01*V[_\x80\xFD[_\x80\xFD[\x90\x81`\x80\x91\x03\x12a\x01\xE9W\x90V[a\x01\xD7V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x024W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x02/W` \x01\x92`\x01\x83\x02\x84\x01\x11a\x02*WV[a\x01\xF6V[a\x01\xF2V[a\x01\xEEV[a\x02B\x81a\x01pV[\x03a\x02IWV[_\x80\xFD[\x90P5\x90a\x02Z\x82a\x029V[V[\x90`\xC0\x82\x82\x03\x12a\x02\xAAWa\x02s\x81_\x84\x01a\x01\xDBV[\x92`\x80\x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02\xA5Wa\x02\x97\x83a\x02\xA2\x92\x86\x01a\x01\xFAV[\x93\x90\x94`\xA0\x01a\x02MV[\x90V[a\x01\xD3V[a\x01.V[_\x01\x90V[4a\x02\xE6Wa\x02\xD0a\x02\xC76`\x04a\x02\\V[\x92\x91\x90\x91a\x16\xB0V[a\x02\xD8a\x01$V[\x80a\x02\xE2\x81a\x02\xAFV[\x03\x90\xF3[a\x01*V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[\x90V[a\x03&a\x03!a\x03+\x92a\x01eV[a\x03\x0FV[a\x01eV[\x90V[a\x037\x90a\x03\x12V[\x90V[a\x03C\x90a\x03.V[\x90V[a\x03O\x90a\x03:V[\x90RV[\x91\x90a\x03f\x90_` \x85\x01\x94\x01\x90a\x03FV[V[4a\x03\x98Wa\x03x6`\x04a\x012V[a\x03\x94a\x03\x83a\x02\xEBV[a\x03\x8Ba\x01$V[\x91\x82\x91\x82a\x03SV[\x03\x90\xF3[a\x01*V[_\x1C\x90V[\x90V[a\x03\xB1a\x03\xB6\x91a\x03\x9DV[a\x03\xA2V[\x90V[a\x03\xC3\x90Ta\x03\xA5V[\x90V[`\x02\x90a\x03\xD4_\x83\x01a\x03\xB9V[\x91a\x03\xE1`\x01\x82\x01a\x03\xB9V[\x91a\x03\xEE`\x02\x83\x01a\x03\xB9V[\x91a\x03\xFB`\x03\x82\x01a\x03\xB9V[\x91a\x04\x14`\x05a\x04\r`\x04\x85\x01a\x03\xB9V[\x93\x01a\x03\xB9V[\x90V[\x90V[a\x04#\x90a\x04\x17V[\x90RV[\x91\x94a\x04oa\x04y\x92\x98\x97\x95a\x04e`\xA0\x96a\x04[a\x04\x80\x9Aa\x04Q`\xC0\x8A\x01\x9E_\x8B\x01\x90a\x04\x1AV[` \x89\x01\x90a\x04\x1AV[`@\x87\x01\x90a\x04\x1AV[``\x85\x01\x90a\x04\x1AV[`\x80\x83\x01\x90a\x04\x1AV[\x01\x90a\x04\x1AV[V[4a\x04\xB9Wa\x04\x926`\x04a\x012V[a\x04\xB5a\x04\x9Da\x03\xC6V[\x92a\x04\xAC\x96\x94\x96\x92\x91\x92a\x01$V[\x96\x87\x96\x87a\x04'V[\x03\x90\xF3[a\x01*V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[\x15\x15\x90V[a\x04\xF0\x90a\x04\xE2V[\x90RV[\x91\x90a\x05\x07\x90_` \x85\x01\x94\x01\x90a\x04\xE7V[V[4a\x059Wa\x05\x196`\x04a\x012V[a\x055a\x05$a\x04\xBEV[a\x05,a\x01$V[\x91\x82\x91\x82a\x04\xF4V[\x03\x90\xF3[a\x01*V[\x1C\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x05_\x90`\x08a\x05d\x93\x02a\x05>V[a\x05BV[\x90V[\x90a\x05r\x91Ta\x05OV[\x90V[a\x05\x82`\n`\x08\x90a\x05gV[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x05\x9B\x90a\x05\x85V[\x90RV[\x91\x90a\x05\xB2\x90_` \x85\x01\x94\x01\x90a\x05\x92V[V[4a\x05\xE4Wa\x05\xC46`\x04a\x012V[a\x05\xE0a\x05\xCFa\x05uV[a\x05\xD7a\x01$V[\x91\x82\x91\x82a\x05\x9FV[\x03\x90\xF3[a\x01*V[\x90V[a\x05\xFC\x90`\x08a\x06\x01\x93\x02a\x05>V[a\x05\xE9V[\x90V[\x90a\x06\x0F\x91Ta\x05\xECV[\x90V[a\x06\x1E`\t_\x90a\x06\x04V[\x90V[\x90V[a\x06-\x90a\x06!V[\x90RV[\x91\x90a\x06D\x90_` \x85\x01\x94\x01\x90a\x06$V[V[4a\x06vWa\x06V6`\x04a\x012V[a\x06ra\x06aa\x06\x12V[a\x06ia\x01$V[\x91\x82\x91\x82a\x061V[\x03\x90\xF3[a\x01*V[4a\x06\xA9Wa\x06\x8B6`\x04a\x012V[a\x06\x93a\"\xA9V[a\x06\x9Ba\x01$V[\x80a\x06\xA5\x81a\x02\xAFV[\x03\x90\xF3[a\x01*V[4a\x06\xDCWa\x06\xBE6`\x04a\x012V[a\x06\xC6a\"\xD8V[a\x06\xCEa\x01$V[\x80a\x06\xD8\x81a\x02\xAFV[\x03\x90\xF3[a\x01*V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[a\x07\x0E\x90a\x03.V[\x90V[a\x07\x1A\x90a\x07\x05V[\x90RV[\x91\x90a\x071\x90_` \x85\x01\x94\x01\x90a\x07\x11V[V[4a\x07cWa\x07C6`\x04a\x012V[a\x07_a\x07Na\x06\xE1V[a\x07Va\x01$V[\x91\x82\x91\x82a\x07\x1EV[\x03\x90\xF3[a\x01*V[4a\x07\x98Wa\x07x6`\x04a\x012V[a\x07\x94a\x07\x83a#\x12V[a\x07\x8Ba\x01$V[\x91\x82\x91\x82a\x01\x89V[\x03\x90\xF3[a\x01*V[a\x07\xA6\x81a\x06!V[\x03a\x07\xADWV[_\x80\xFD[\x90P5\x90a\x07\xBE\x82a\x07\x9DV[V[\x90` \x82\x82\x03\x12a\x07\xD9Wa\x07\xD6\x91_\x01a\x07\xB1V[\x90V[a\x01.V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[T\x90V[_R` _ \x90V[a\x08\x08\x81a\x07\xF2V[\x82\x10\x15a\x08\"Wa\x08\x1A`\x04\x91a\x07\xF6V[\x91\x02\x01\x90_\x90V[a\x07\xDEV[`\x08\x90a\x083\x82a\x07\xF2V[\x81\x10\x15a\x08yWa\x08C\x91a\x07\xFFV[P\x90a\x08P_\x83\x01a\x03\xB9V[\x91a\x08]`\x01\x82\x01a\x03\xB9V[\x91a\x08v`\x03a\x08o`\x02\x85\x01a\x03\xB9V[\x93\x01a\x03\xB9V[\x90V[_\x80\xFD[a\x08\xB2a\x08\xB9\x94a\x08\xA8``\x94\x98\x97\x95a\x08\x9E`\x80\x86\x01\x9A_\x87\x01\x90a\x04\x1AV[` \x85\x01\x90a\x04\x1AV[`@\x83\x01\x90a\x04\x1AV[\x01\x90a\x04\x1AV[V[4a\x08\xEFWa\x08\xEBa\x08\xD6a\x08\xD16`\x04a\x07\xC0V[a\x08'V[\x90a\x08\xE2\x94\x92\x94a\x01$V[\x94\x85\x94\x85a\x08}V[\x03\x90\xF3[a\x01*V[\x90`\x80\x82\x82\x03\x12a\t\rWa\t\n\x91_\x01a\x01\xDBV[\x90V[a\x01.V[4a\t@Wa\t*a\t%6`\x04a\x08\xF4V[a&#V[a\t2a\x01$V[\x80a\t<\x81a\x02\xAFV[\x03\x90\xF3[a\x01*V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[a\tr\x90a\x03.V[\x90V[a\t~\x90a\tiV[\x90RV[\x91\x90a\t\x95\x90_` \x85\x01\x94\x01\x90a\tuV[V[4a\t\xC7Wa\t\xA76`\x04a\x012V[a\t\xC3a\t\xB2a\tEV[a\t\xBAa\x01$V[\x91\x82\x91\x82a\t\x82V[\x03\x90\xF3[a\x01*V[a\t\xD8`\n_\x90a\x05gV[\x90V[4a\n\x0BWa\t\xEB6`\x04a\x012V[a\n\x07a\t\xF6a\t\xCCV[a\t\xFEa\x01$V[\x91\x82\x91\x82a\x05\x9FV[\x03\x90\xF3[a\x01*V[\x90` \x82\x82\x03\x12a\n)Wa\n&\x91_\x01a\x02MV[\x90V[a\x01.V[4a\n\\Wa\nFa\nA6`\x04a\n\x10V[a&\x93V[a\nNa\x01$V[\x80a\nX\x81a\x02\xAFV[\x03\x90\xF3[a\x01*V[_\x80\xFD[\x90a\ny\x93\x92\x91a\nta&\xABV[a\x13,V[a\n\x81a'\x10V[V[\x90V[a\n\x9Aa\n\x95a\n\x9F\x92a\n\x83V[a\x03\x0FV[a\x01eV[\x90V[a\n\xAB\x90a\n\x86V[\x90V[` \x91\x81R\x01\x90V[_\x7Freward address cannot be zero\0\0\0\x91\x01RV[a\n\xEB`\x1D` \x92a\n\xAEV[a\n\xF4\x81a\n\xB7V[\x01\x90V[a\x0B\r\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\n\xDEV[\x90V[\x15a\x0B\x17WV[a\x0B\x1Fa\x01$V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x0B5`\x04\x82\x01a\n\xF8V[\x03\x90\xFD[P\x90V[\x90V[a\x0BTa\x0BOa\x0BY\x92a\x0B=V[a\x03\x0FV[a\x06!V[\x90V[_\x7Finvalid signature length\0\0\0\0\0\0\0\0\x91\x01RV[a\x0B\x90`\x18` \x92a\n\xAEV[a\x0B\x99\x81a\x0B\\V[\x01\x90V[a\x0B\xB2\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x0B\x83V[\x90V[\x15a\x0B\xBCWV[a\x0B\xC4a\x01$V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x0B\xDA`\x04\x82\x01a\x0B\x9DV[\x03\x90\xFD[\x90V[\x90V[a\x0B\xF0a\x0B\xF5\x91a\x04\x17V[a\x0B\xE1V[\x90RV[` \x81a\x0C\x0Ba\x0C\x13\x93\x83\x96\x95a\x0B\xE4V[\x01\x80\x92a\x0B\xE4V[\x01\x90V[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x0C?\x90a\x0C\x17V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x0CYW`@RV[a\x0C!V[` \x01\x90V[Q\x90V[_\x80\xFD[\x90a\x0C\x7Fa\x0Cxa\x01$V[\x92\x83a\x0C5V[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x0C\x9FWa\x0C\x9B` \x91a\x0C\x17V[\x01\x90V[a\x0C!V[\x90\x82_\x93\x92\x827\x01RV[\x90\x92\x91\x92a\x0C\xC4a\x0C\xBF\x82a\x0C\x81V[a\x0ClV[\x93\x81\x85R` \x85\x01\x90\x82\x84\x01\x11a\x0C\xE0Wa\x0C\xDE\x92a\x0C\xA4V[V[a\x0ChV[a\x0C\xF0\x916\x91a\x0C\xAFV[\x90V[_\x80\xFD[`\xE0\x1B\x90V[a\r\x06\x81a\x04\xE2V[\x03a\r\rWV[_\x80\xFD[\x90PQ\x90a\r\x1E\x82a\x0C\xFDV[V[\x90` \x82\x82\x03\x12a\r9Wa\r6\x91_\x01a\r\x11V[\x90V[a\x01.V[a\rFa\x01$V[=_\x82>=\x90\xFD[_\x7Finvalid tee signature\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\r\x82`\x15` \x92a\n\xAEV[a\r\x8B\x81a\rNV[\x01\x90V[a\r\xA4\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\ruV[\x90V[\x15a\r\xAEWV[a\r\xB6a\x01$V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\r\xCC`\x04\x82\x01a\r\x8FV[\x03\x90\xFD[a\r\xD9\x81a\x04\x17V[\x03a\r\xE0WV[_\x80\xFD[5a\r\xEE\x81a\r\xD0V[\x90V[_\x7Funexpected l1 end batch acc\0\0\0\0\0\x91\x01RV[a\x0E%`\x1B` \x92a\n\xAEV[a\x0E.\x81a\r\xF1V[\x01\x90V[a\x0EG\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x0E\x18V[\x90V[\x15a\x0EQWV[a\x0EYa\x01$V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x0Eo`\x04\x82\x01a\x0E2V[\x03\x90\xFD[a\x0E\x87a\x0E\x82a\x0E\x8C\x92a\n\x83V[a\x03\x0FV[a\x06!V[\x90V[`\x01a\x0E\x9B\x91\x01a\x06!V[\x90V[\x90V[_\x7Fassertion already exists\0\0\0\0\0\0\0\0\x91\x01RV[a\x0E\xD5`\x18` \x92a\n\xAEV[a\x0E\xDE\x81a\x0E\xA1V[\x01\x90V[a\x0E\xF7\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x0E\xC8V[\x90V[\x15a\x0F\x01WV[a\x0F\ta\x01$V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x0F\x1F`\x04\x82\x01a\x0E\xE2V[\x03\x90\xFD[a\x0F7a\x0F2a\x0F<\x92a\x06!V[a\x03\x0FV[a\x05\x85V[\x90V[`@\x1C\x90V[a\x0FQa\x0FV\x91a\x0F?V[a\x05BV[\x90V[a\x0Fc\x90Ta\x0FEV[\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x0F\x86a\x0F\x8C\x91a\x05\x85V[\x91a\x05\x85V[\x01\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x0F\x9FWV[a\x0FfV[_\x1B\x90V[\x90a\x0F\xBCg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x0F\xA4V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x0F\xDAa\x0F\xD5a\x0F\xDF\x92a\x05\x85V[a\x03\x0FV[a\x05\x85V[\x90V[\x90V[\x90a\x0F\xFAa\x0F\xF5a\x10\x01\x92a\x0F\xC6V[a\x0F\xE2V[\x82Ta\x0F\xA9V[\x90UV[\x90V[_R` _ \x90V[T\x90V[a\x10\x1E\x81a\x10\x11V[\x82\x10\x15a\x108Wa\x100`\x04\x91a\x10\x08V[\x91\x02\x01\x90_\x90V[a\x07\xDEV[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[\x90a\x10\\_\x19\x91a\x0F\xA4V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x10o\x90a\x04\x17V[\x90V[a\x10{\x90a\x03\x9DV[\x90V[\x90a\x10\x93a\x10\x8Ea\x10\x9A\x92a\x10fV[a\x10rV[\x82Ta\x10PV[\x90UV[\x90a\x10\xFB```\x03a\x11\x01\x94a\x10\xC1_\x82\x01a\x10\xBB_\x88\x01a\r\xE4V[\x90a\x10~V[a\x10\xDA`\x01\x82\x01a\x10\xD4` \x88\x01a\r\xE4V[\x90a\x10~V[a\x10\xF3`\x02\x82\x01a\x10\xED`@\x88\x01a\r\xE4V[\x90a\x10~V[\x01\x92\x01a\r\xE4V[\x90a\x10~V[V[\x91\x90a\x11\x14Wa\x11\x12\x91a\x10\x9EV[V[a\x10=V[\x1B\x90V[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a\x11MW\x82a\x11E\x91`\x01a\x11K\x95\x01\x81Ua\x10\x15V[\x90a\x11\x03V[V[a\x0C!V[\x90V[a\x11ia\x11da\x11n\x92a\x11RV[a\x03\x0FV[a\x06!V[\x90V[\x90V[a\x11\x88a\x11\x83a\x11\x8D\x92a\x11qV[a\x03\x0FV[a\x06!V[\x90V[a\x11\x9Ca\x11\xA1\x91a\x03\x9DV[a\x05\xE9V[\x90V[a\x11\xAE\x90Ta\x11\x90V[\x90V[a\x11\xC0a\x11\xC6\x91\x93\x92\x93a\x06!V[\x92a\x06!V[\x82\x01\x80\x92\x11a\x11\xD1WV[a\x0FfV[a\x11\xEAa\x11\xE5a\x11\xEF\x92a\x06!V[a\x03\x0FV[a\x06!V[\x90V[\x90V[\x90a\x12\na\x12\x05a\x12\x11\x92a\x11\xD6V[a\x11\xF2V[\x82Ta\x10PV[\x90UV[a\x12\x1E\x90a\x03\x12V[\x90V[a\x12*\x90a\x12\x15V[\x90V[a\x126\x90a\x03.V[\x90V[a\x12B\x90a\x03.V[\x90V[\x90P\x90V[a\x12U_\x80\x92a\x12EV[\x01\x90V[a\x12b\x90a\x12JV[\x90V[\x90a\x12wa\x12r\x83a\x0C\x81V[a\x0ClV[\x91\x82RV[``\x90V[=_\x14a\x12\x9CWa\x12\x91=a\x12eV[\x90=_` \x84\x01>[V[a\x12\xA4a\x12|V[\x90a\x12\x9AV[_\x7Fpayment failed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x12\xDE`\x0E` \x92a\n\xAEV[a\x12\xE7\x81a\x12\xAAV[\x01\x90V[a\x13\0\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x12\xD1V[\x90V[\x15a\x13\nWV[a\x13\x12a\x01$V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x13(`\x04\x82\x01a\x12\xEBV[\x03\x90\xFD[\x92\x90` a\x14A\x91\x95\x93\x95a\x13\\\x84a\x13Ua\x13Oa\x13J_a\n\xA2V[a\x01pV[\x91a\x01pV[\x14\x15a\x0B\x10V[a\x13\x83a\x13j\x82\x89\x90a\x0B9V[a\x13}a\x13w`Aa\x0B@V[\x91a\x06!V[\x14a\x0B\xB5V[a\x13\x8C\x86a'\\V[\x96a\x146a\x14!a\x13\xA5a\x13\xA0`\x02a\x0B\xDEV[a((V[a\x13\xCE\x8B\x91a\x13\xC0a\x13\xB5a\x01$V[\x93\x84\x92\x8A\x84\x01a\x0B\xF9V[\x88\x82\x01\x81\x03\x82R\x03\x82a\x0C5V[a\x13\xE0a\x13\xDA\x82a\x0CdV[\x91a\x0C^V[ \x93a\x14\x1Ba\x14\x0E\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x03:V[\x94cr\x17\xEF\xCD\x96\x92a\x0C\xE5V[\x90a(\xBAV[\x92a\x14*a\x01$V[\x95\x86\x94\x85\x93\x84\x93a\x0C\xF7V[\x83R`\x04\x83\x01a\x01\x89V[\x03\x91Z\xFA\x80\x15a\x16\xABWa\x14\\\x91_\x91a\x16}W[Pa\r\xA7V[a\x14\x86\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15a\x04\xE2V[\x80\x15a\x16GW[a\x14\x96\x90a\x0EJV[a\x14\x9F_a\x0EsV[[\x80a\x14\xBCa\x14\xB6a\x14\xB1`\x08a\x07\xF2V[a\x06!V[\x91a\x06!V[\x10\x15a\x15\tWa\x15\x04\x90a\x14\xFF\x86a\x14\xF8a\x14\xF2a\x14\xEDa\x14\xE8a\x14\xE2`\x08\x88\x90a\x07\xFFV[Pa\x0E\x9EV[a(\xDCV[a\x04\x17V[\x91a\x04\x17V[\x14\x15a\x0E\xFAV[a\x0E\x8FV[a\x14\xA0V[P\x91a\x15B\x91\x93Pa\x15\x1B`\x08a\x07\xF2V[a\x15-a\x15'_a\x0EsV[\x91a\x06!V[\x14a\x16\x1CW[a\x15=`\x08a\x10\x05V[a\x11\x1DV[a\x15L`\x08a\x07\xF2V[a\x15_a\x15Y`\x02a\x11UV[\x91a\x06!V[\x14a\x15hW[PV[_\x80a\x15\xE7a\x15\xE2a\x16\x16\x94a\x15\x9Aa\x15\x93a\x15\x84`\x01a\x11tV[a\x15\x8E`\ta\x11\xA4V[a\x11\xB1V[`\ta\x11\xF5V[a\x15\xA4`\ta\x11\xA4V[a\x15\xDA\x7F7\xE8\xAD\xD6\x94\xC5\x92mVN\x97\x11`\xF5\x97A\x03\xCB\xBB\xC7\xC9\x07G\xC4\xC6\xF8\x02\x03\x1D5g\xA7\x91a\x15\xD1a\x01$V[\x91\x82\x91\x82a\x061V[\x03\x90\xA1a\x12!V[a\x12-V[a\x15\xF00a\x129V[1a\x15\xF9a\x01$V[\x90\x81a\x16\x04\x81a\x12YV[\x03\x92Z\xF1a\x16\x10a\x12\x81V[Pa\x13\x03V[_a\x15eV[a\x16Ba\x16;a\x16+Ba\x0F#V[a\x165`\na\x0FYV[\x90a\x0FzV[`\na\x0F\xE5V[a\x153V[Pa\x14\x96a\x16W``\x85\x01a\r\xE4V[a\x16ua\x16oa\x16j`\x05`\x02\x01a\x03\xB9V[a\x04\x17V[\x91a\x04\x17V[\x14\x90Pa\x14\x8DV[a\x16\x9E\x91P` =\x81\x11a\x16\xA4W[a\x16\x96\x81\x83a\x0C5V[\x81\x01\x90a\r V[_a\x14VV[P=a\x16\x8CV[a\r>V[\x90a\x16\xBC\x93\x92\x91a\neV[V[a\x16\xC6a&\xABV[a\x16\xCEa\x1B\xD4V[a\x16\xD6a'\x10V[V[a\x16\xE1\x90a\x03\x12V[\x90V[a\x16\xED\x90a\x16\xD8V[\x90V[a\x16\xF9\x90a\x03.V[\x90V[a\x17\x05\x81a\x05\x85V[\x03a\x17\x0CWV[_\x80\xFD[\x90PQ\x90a\x17\x1D\x82a\x16\xFCV[V[\x90` \x82\x82\x03\x12a\x178Wa\x175\x91_\x01a\x17\x10V[\x90V[a\x01.V[a\x17Ia\x17N\x91a\x03\x9DV[a\x05BV[\x90V[a\x17[\x90Ta\x17=V[\x90V[` \x7Finsufficient time has passed\0\0\0\0\x91\x7Fcannot close challenge window - _\x82\x01R\x01RV[a\x17\xB8`<`@\x92a\n\xAEV[a\x17\xC1\x81a\x17^V[\x01\x90V[a\x17\xDA\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x17\xABV[\x90V[\x15a\x17\xE4WV[a\x17\xECa\x01$V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x18\x02`\x04\x82\x01a\x17\xC5V[\x03\x90\xFD[` \x7Ftoo many assertions\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7Fcannot close challenge window - _\x82\x01R\x01RV[a\x18``3`@\x92a\n\xAEV[a\x18i\x81a\x18\x06V[\x01\x90V[a\x18\x82\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x18SV[\x90V[\x15a\x18\x8CWV[a\x18\x94a\x01$V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x18\xAA`\x04\x82\x01a\x18mV[\x03\x90\xFD[_\x91\x03\x12a\x18\xB8WV[a\x01.V[\x91` a\x18\xDE\x92\x94\x93a\x18\xD7`@\x82\x01\x96_\x83\x01\x90a\x04\x1AV[\x01\x90a\x04\x1AV[V[a\x18\xEFa\x18\xF5\x91\x93\x92\x93a\x06!V[\x92a\x06!V[\x91a\x19\x01\x83\x82\x02a\x06!V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a\x19\x10WV[a\x0FfV[a\x19 \x90`\x04a\x18\xE0V[\x90V[\x91\x90`\x08a\x19>\x91\x02\x91a\x198_\x19\x84a\x11\x19V[\x92a\x11\x19V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\x19^a\x19Ya\x19f\x93a\x10fV[a\x10rV[\x90\x83Ta\x19#V[\x90UV[_\x90V[a\x19\x80\x91a\x19za\x19jV[\x91a\x19HV[V[_`\x03a\x19\xB5\x92a\x19\x95\x83\x80\x83\x01a\x19nV[a\x19\xA2\x83`\x01\x83\x01a\x19nV[a\x19\xAF\x83`\x02\x83\x01a\x19nV[\x01a\x19nV[V[\x90_\x03a\x19\xC9Wa\x19\xC7\x90a\x19\x82V[V[a\x10=V[[\x81\x81\x10a\x19\xDAWPPV[\x80a\x19\xE7_`\x04\x93a\x19\xB7V[\x01a\x19\xCFV[\x90\x91\x82\x81\x10a\x19\xFCW[PPPV[a\x1A\x1Aa\x1A\x14a\x1A\x0Ea\x1A%\x95a\x19\x15V[\x92a\x19\x15V[\x92a\x07\xF6V[\x91\x82\x01\x91\x01\x90a\x19\xCEV[_\x80\x80a\x19\xF7V[\x90h\x01\0\0\0\0\0\0\0\0\x81\x11a\x1AVW\x81a\x1AKa\x1AT\x93a\x07\xF2V[\x90\x82\x81Ua\x19\xEDV[V[a\x0C!V[_a\x1Ae\x91a\x1A-V[V[\x90_\x03a\x1AyWa\x1Aw\x90a\x1A[V[V[a\x10=V[\x90PQ\x90a\x1A\x8B\x82a\x07\x9DV[V[\x90` \x82\x82\x03\x12a\x1A\xA6Wa\x1A\xA3\x91_\x01a\x1A~V[\x90V[a\x01.V[a\x1A\xBAa\x1A\xC0\x91\x93\x92\x93a\x06!V[\x92a\x06!V[\x82\x03\x91\x82\x11a\x1A\xCBWV[a\x0FfV[\x90PQ\x90a\x1A\xDD\x82a\r\xD0V[V[\x90` \x82\x82\x03\x12a\x1A\xF8Wa\x1A\xF5\x91_\x01a\x1A\xD0V[\x90V[a\x01.V[a\x1B\x06\x90a\x03\x12V[\x90V[a\x1B\x12\x90a\x1A\xFDV[\x90V[a\x1B\x1E\x90a\x04\x17V[\x90RV[\x90`\xA0a\x1B\xB5`\x05a\x1B\xBD\x94a\x1BFa\x1B=_\x83\x01Ta\x03\xA5V[_\x87\x01\x90a\x1B\x15V[a\x1B`a\x1BV`\x01\x83\x01Ta\x03\xA5V[` \x87\x01\x90a\x1B\x15V[a\x1Bza\x1Bp`\x02\x83\x01Ta\x03\xA5V[`@\x87\x01\x90a\x1B\x15V[a\x1B\x94a\x1B\x8A`\x03\x83\x01Ta\x03\xA5V[``\x87\x01\x90a\x1B\x15V[a\x1B\xAEa\x1B\xA4`\x04\x83\x01Ta\x03\xA5V[`\x80\x87\x01\x90a\x1B\x15V[\x01Ta\x03\xA5V[\x91\x01\x90a\x1B\x15V[V[\x91\x90a\x1B\xD2\x90_`\xC0\x85\x01\x94\x01\x90a\x1B\"V[V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x14a!\xFFWa\x1C)a\x1C\x07Ba\x0F#V[[a\x1C#a\x1C\x1Da\x1C\x18`\na\x17QV[a\x05\x85V[\x91a\x05\x85V[\x11a\x17\xDDV[a\x1COa\x1CHa\x1C8Ba\x0F#V[a\x1CB`\na\x0FYV[\x90a\x0FzV[`\na\x0F\xE5V[a\x1CY`\x08a\x07\xF2V[a\x1Cla\x1Cf`\x01a\x11tV[\x91a\x06!V[\x14_\x14a!\xD5Wa\x1C\x98a\x1C\x8E`\x03a\x1C\x87`\x08_\x90a\x07\xFFV[P\x01a\x03\xB9V[`\x04`\x02\x01a\x10~V[a\x1C\xBCa\x1C\xB3`\x02a\x1C\xAC`\x08_\x90a\x07\xFFV[P\x01a\x03\xB9V[`\x02\x80\x01a\x10~V[a\x1C\xC9`\x01`\x02\x01a\x03\xB9V[a\x1C\xF1a\x1C\xEBa\x1C\xE6_a\x1C\xDF`\x08\x82\x90a\x07\xFFV[P\x01a\x03\xB9V[a\x04\x17V[\x91a\x04\x17V[\x03a \xD9W[a\x1D\x02_`\x08a\x1AgV[[a\x1D,\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\tiV[a\x1Duc\xD5q\x9D\xC2` a\x1D_\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\tiV[c\xEC\xA0g\xAD\x90a\x1Dma\x01$V[\x94\x85\x92a\x0C\xF7V[\x82R\x81\x80a\x1D\x85`\x04\x82\x01a\x02\xAFV[\x03\x91Z\xFA\x92\x83\x15a \xD4Wa\x1D\xCAa\x1D\xB5a\x1D\xD5\x95` \x95_\x91a \xA7W[Pa\x1D\xAF`\x01a\x11tV[\x90a\x1A\xABV[\x92a\x1D\xBEa\x01$V[\x95\x86\x94\x85\x93\x84\x93a\x0C\xF7V[\x83R`\x04\x83\x01a\x061V[\x03\x91Z\xFA\x80\x15a \xA2Wa\x1D\xF5\x91_\x91a tW[P`\x03`\x02\x01a\x10~V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x14a\x1F\xC0Wa\x1EMa\x1EH\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x1B\tV[a\tiV[a\x1E\x9Dc\x16\xBFUy` a\x1E\x88a\x1E\x83\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x1B\tV[a\tiV[b\x84\x12\x0C\x90a\x1E\x95a\x01$V[\x94\x85\x92a\x0C\xF7V[\x82R\x81\x80a\x1E\xAD`\x04\x82\x01a\x02\xAFV[\x03\x91Z\xFA\x92\x83\x15a\x1F\xBBWa\x1E\xF2a\x1E\xDDa\x1E\xFD\x95` \x95_\x91a\x1F\x8EW[Pa\x1E\xD7`\x01a\x11tV[\x90a\x1A\xABV[\x92a\x1E\xE6a\x01$V[\x95\x86\x94\x85\x93\x84\x93a\x0C\xF7V[\x83R`\x04\x83\x01a\x061V[\x03\x91Z\xFA\x80\x15a\x1F\x89Wa\x1F\x1D\x91_\x91a\x1F[W[P`\x05`\x02\x01a\x10~V[[`\x02a\x1FV\x7FU#\"\x99\xD8?\xAFM\xC2\xC3.\"\x8A\xF3v2\xBC\xA7\xFAm\xBC\x03\xB4\x12$\xC1\0\xC6\xC9\xDC\xA3I\x91a\x1FMa\x01$V[\x91\x82\x91\x82a\x1B\xBFV[\x03\x90\xA1V[a\x1F|\x91P` =\x81\x11a\x1F\x82W[a\x1Ft\x81\x83a\x0C5V[\x81\x01\x90a\x1A\xDFV[_a\x1F\x12V[P=a\x1FjV[a\r>V[a\x1F\xAE\x91P\x86=\x81\x11a\x1F\xB4W[a\x1F\xA6\x81\x83a\x0C5V[\x81\x01\x90a\x1A\x8DV[_a\x1E\xCCV[P=a\x1F\x9CV[a\r>V[a \x0C` a\x1F\xF6a\x1F\xF1\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x16\xE4V[a\x16\xF0V[c\t\xBDZ`\x90a \x04a\x01$V[\x93\x84\x92a\x0C\xF7V[\x82R\x81\x80a \x1C`\x04\x82\x01a\x02\xAFV[\x03\x91Z\xFA\x80\x15a oWa <\x91_\x91a AW[P`\x05`\x02\x01a\x10~V[a\x1F\x1EV[a b\x91P` =\x81\x11a hW[a Z\x81\x83a\x0C5V[\x81\x01\x90a\x1A\xDFV[_a 1V[P=a PV[a\r>V[a \x95\x91P` =\x81\x11a \x9BW[a \x8D\x81\x83a\x0C5V[\x81\x01\x90a\x1A\xDFV[_a\x1D\xEAV[P=a \x83V[a\r>V[a \xC7\x91P\x86=\x81\x11a \xCDW[a \xBF\x81\x83a\x0C5V[\x81\x01\x90a\x1A\x8DV[_a\x1D\xA4V[P=a \xB5V[a\r>V[a \xFDa \xF3_a \xEC`\x08\x82\x90a\x07\xFFV[P\x01a\x03\xB9V[`\x01`\x02\x01a\x10~V[a!&\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x07\x05V[c\xDA\xEA\xB4\x12a!B_a!;`\x08\x82\x90a\x07\xFFV[P\x01a\x03\xB9V[a!Z`\x01a!S`\x08_\x90a\x07\xFFV[P\x01a\x03\xB9V[\x92\x80;\x15a!\xD0Wa!\x7F_\x80\x94a!\x8Aa!sa\x01$V[\x97\x88\x96\x87\x95\x86\x94a\x0C\xF7V[\x84R`\x04\x84\x01a\x18\xBDV[\x03\x92Z\xF1\x80\x15a!\xCBWa!\x9FW[Pa\x1C\xF7V[a!\xBE\x90_=\x81\x11a!\xC4W[a!\xB6\x81\x83a\x0C5V[\x81\x01\x90a\x18\xAEV[_a!\x99V[P=a!\xACV[a\r>V[a\x0C\xF3V[a!\xFAa!\xE2`\x08a\x07\xF2V[a!\xF4a!\xEE_a\x0EsV[\x91a\x06!V[\x14a\x18\x85V[a\x1D\x03V[a\"K` a\"5a\"0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x16\xE4V[a\x16\xF0V[c\xB8\x07w\xEA\x90a\"Ca\x01$V[\x93\x84\x92a\x0C\xF7V[\x82R\x81\x80a\"[`\x04\x82\x01a\x02\xAFV[\x03\x91Z\xFA\x80\x15a\"\xA4Wa\x1C)\x91_\x91a\"vW[Pa\x1C\x08V[a\"\x97\x91P` =\x81\x11a\"\x9DW[a\"\x8F\x81\x83a\x0C5V[\x81\x01\x90a\x17\x1FV[_a\"pV[P=a\"\x85V[a\r>V[a\"\xB1a\x16\xBEV[V[a\"\xBBa)UV[a\"\xC3a\"\xC5V[V[a\"\xD6a\"\xD1_a\n\xA2V[a)\xEDV[V[a\"\xE0a\"\xB3V[V[_\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\"\xFDa#\x02\x91a\x03\x9DV[a\"\xE6V[\x90V[a#\x0F\x90Ta\"\xF1V[\x90V[a#\x1Aa\"\xE2V[Pa#$_a#\x05V[\x90V[a#8\x90a#3a)UV[a#:V[V[a#K\x90a#Fa&\xABV[a$\xEBV[a#Sa'\x10V[V[_\x7Fchallenge does not exist\0\0\0\0\0\0\0\0\x91\x01RV[a#\x89`\x18` \x92a\n\xAEV[a#\x92\x81a#UV[\x01\x90V[a#\xAB\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra#|V[\x90V[\x15a#\xB5WV[a#\xBDa\x01$V[bF\x1B\xCD`\xE5\x1B\x81R\x80a#\xD3`\x04\x82\x01a#\x96V[\x03\x90\xFD[a#\xEBa#\xE6a#\xF0\x92a\n\x83V[a\x03\x0FV[a\x05\x85V[\x90V[\x90P5\x90a$\0\x82a\r\xD0V[V[Pa$\x11\x90` \x81\x01\x90a#\xF3V[\x90V[\x90``a$sa${\x93a$6a$-_\x83\x01\x83a$\x02V[_\x86\x01\x90a\x1B\x15V[a$Pa$F` \x83\x01\x83a$\x02V[` \x86\x01\x90a\x1B\x15V[a$ja$``@\x83\x01\x83a$\x02V[`@\x86\x01\x90a\x1B\x15V[\x82\x81\x01\x90a$\x02V[\x91\x01\x90a\x1B\x15V[V[\x91\x90a$\x90\x90_`\x80\x85\x01\x94\x01\x90a$\x14V[V[_\x7Fassertion not found\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a$\xC6`\x13` \x92a\n\xAEV[a$\xCF\x81a$\x92V[\x01\x90V[a$\xE8\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra$\xB9V[\x90V[a%\x11a$\xF8`\x08a\x07\xF2V[a%\x0Ba%\x05`\x01a\x11tV[\x91a\x06!V[\x11a#\xAEV[a%\x1A\x81a'\\V[\x90a%$_a\x0EsV[[\x80a%Aa%;a%6`\x08a\x07\xF2V[a\x06!V[\x91a\x06!V[\x10\x15a&\x01W\x82a%va%pa%ka%fa%``\x08\x87\x90a\x07\xFFV[Pa\x0E\x9EV[a(\xDCV[a\x04\x17V[\x91a\x04\x17V[\x14a%\x89Wa%\x84\x90a\x0E\x8FV[a%%V[P\x90Pa%\x97_`\x08a\x1AgV[a%\xABa%\xA4`\x08a\x10\x05V[\x82\x90a\x11\x1DV[a%\xBEa%\xB7_a#\xD7V[`\na\x0F\xE5V[a%\xC6a\"\xA9V[a%\xFC\x7F  T+nk\x95\x1DL\x076\xEE\xD2\xA4\xD7b\xD2\x0B\xB1\xBAW\x9F\x99\xFE\xFF\xAE\x9B\x1D\xEA$\x08\x83\x91a%\xF3a\x01$V[\x91\x82\x91\x82a$}V[\x03\x90\xA1V[a&\ta\x01$V[bF\x1B\xCD`\xE5\x1B\x81R\x80a&\x1F`\x04\x82\x01a$\xD3V[\x03\x90\xFD[a&,\x90a#'V[V[a&?\x90a&:a)UV[a&AV[V[\x80a&\\a&Va&Q_a\n\xA2V[a\x01pV[\x91a\x01pV[\x14a&lWa&j\x90a)\xEDV[V[a&\x8Fa&x_a\n\xA2V[_\x91\x82\x91c\x1EO\xBD\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x01\x89V[\x03\x90\xFD[a&\x9C\x90a&.V[V[a&\xA8`\x02a\x11UV[\x90V[a&\xB5`\x01a\x11\xA4V[a&\xCEa&\xC8a&\xC3a&\x9EV[a\x06!V[\x91a\x06!V[\x14a&\xE7Wa&\xE5a&\xDEa&\x9EV[`\x01a\x11\xF5V[V[_c>\xE5\xAE\xB5`\xE0\x1B\x81R\x80a&\xFF`\x04\x82\x01a\x02\xAFV[\x03\x90\xFD[a'\r`\x01a\x11tV[\x90V[a'\"a'\x1Ba'\x03V[`\x01a\x11\xF5V[V[\x92a'P` a'X\x94a'H\x82\x88a'@\x82\x9B\x9A\x83\x99a\x0B\xE4V[\x01\x80\x92a\x0B\xE4V[\x01\x80\x92a\x0B\xE4V[\x01\x80\x92a\x0B\xE4V[\x01\x90V[a'da\x19jV[Pa'\xBFa's_\x83\x01a\r\xE4V[a'\xB0a'\x82` \x85\x01a\r\xE4V[\x93a'\x9B``a'\x94`@\x84\x01a\r\xE4V[\x92\x01a\r\xE4V[\x90a'\xA4a\x01$V[\x95\x86\x94` \x86\x01a'$V[` \x82\x01\x81\x03\x82R\x03\x82a\x0C5V[a'\xD1a'\xCB\x82a\x0CdV[\x91a\x0C^V[ \x90V[a($\x94a(\x14` \x80\x99\x98\x95\x96a(\x0C\x82\x80\x99a(\x04\x82\x89a'\xFC\x82\x9Ba(\x1C\x9Da\x0B\xE4V[\x01\x80\x92a\x0B\xE4V[\x01\x80\x92a\x0B\xE4V[\x01\x80\x92a\x0B\xE4V[\x01\x80\x92a\x0B\xE4V[\x01\x80\x92a\x0B\xE4V[\x01\x90V[a(0a\x19jV[Pa(\xA4a(?_\x83\x01a\x03\xB9V[a(\x95a(N`\x01\x85\x01a\x03\xB9V[\x93a([`\x02\x82\x01a\x03\xB9V[\x90a(h`\x03\x82\x01a\x03\xB9V[a(\x80`\x05a(y`\x04\x85\x01a\x03\xB9V[\x93\x01a\x03\xB9V[\x92a(\x89a\x01$V[\x97\x88\x96` \x88\x01a'\xD5V[` \x82\x01\x81\x03\x82R\x03\x82a\x0C5V[a(\xB6a(\xB0\x82a\x0CdV[\x91a\x0C^V[ \x90V[a(\xD9\x91a(\xD0\x91a(\xCAa\"\xE2V[Pa*pV[\x90\x92\x91\x92a+mV[\x90V[a(\xE4a\x19jV[Pa)?a(\xF3_\x83\x01a\x03\xB9V[a)0a)\x02`\x01\x85\x01a\x03\xB9V[\x93a)\x1B`\x03a)\x14`\x02\x84\x01a\x03\xB9V[\x92\x01a\x03\xB9V[\x90a)$a\x01$V[\x95\x86\x94` \x86\x01a'$V[` \x82\x01\x81\x03\x82R\x03\x82a\x0C5V[a)Qa)K\x82a\x0CdV[\x91a\x0C^V[ \x90V[a)]a#\x12V[a)va)pa)ka,>V[a\x01pV[\x91a\x01pV[\x03a)}WV[a)\x9Fa)\x88a,>V[_\x91\x82\x91c\x11\x8C\xDA\xA7`\xE0\x1B\x83R`\x04\x83\x01a\x01\x89V[\x03\x90\xFD[\x90a)\xB4`\x01\x80`\xA0\x1B\x03\x91a\x0F\xA4V[\x91\x81\x19\x16\x91\x16\x17\x90V[a)\xC7\x90a\x03.V[\x90V[\x90V[\x90a)\xE2a)\xDDa)\xE9\x92a)\xBEV[a)\xCAV[\x82Ta)\xA3V[\x90UV[a)\xF6_a#\x05V[a*\0\x82_a)\xCDV[\x90a*4a*.\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x93a)\xBEV[\x91a)\xBEV[\x91a*=a\x01$V[\x80a*G\x81a\x02\xAFV[\x03\x90\xA3V[_\x90V[a*da*_a*i\x92a\x06!V[a\x0F\xA4V[a\x04\x17V[\x90V[_\x90V[\x91\x90\x91a*{a\"\xE2V[Pa*\x84a*LV[Pa*\x8Da\x19jV[Pa*\x97\x83a\x0CdV[a*\xAAa*\xA4`Aa\x0B@V[\x91a\x06!V[\x14_\x14a*\xF1Wa*\xEA\x91\x92a*\xBEa\x19jV[Pa*\xC7a\x19jV[Pa*\xD0a*lV[P` \x81\x01Q```@\x83\x01Q\x92\x01Q_\x1A\x90\x91\x92a,\xD7V[\x91\x92\x90\x91\x90V[Pa*\xFB_a\n\xA2V[\x90a+\x0Fa+\n`\x02\x94a\x0CdV[a*PV[\x91\x92\x91\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x04\x11\x15a+3WV[a+\x15V[\x90a+B\x82a+)V[V[\x91\x90a+W\x90_` \x85\x01\x94\x01\x90a\x04\x1AV[V[a+ea+j\x91a\x03\x9DV[a\x11\xD6V[\x90V[\x80a+\x80a+z_a+8V[\x91a+8V[\x14_\x14a+\x8BWPPV[\x80a+\x9Fa+\x99`\x01a+8V[\x91a+8V[\x14_\x14a+\xC2W_c\xF6E\xEE\xDF`\xE0\x1B\x81R\x80a+\xBE`\x04\x82\x01a\x02\xAFV[\x03\x90\xFD[\x80a+\xD6a+\xD0`\x02a+8V[\x91a+8V[\x14_\x14a,\x04Wa,\0a+\xE9\x83a+YV[_\x91\x82\x91c\xFC\xE6\x98\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x061V[\x03\x90\xFD[a,\x17a,\x11`\x03a+8V[\x91a+8V[\x14a,\x1FWPV[a,:\x90_\x91\x82\x91c5\xE2\xF3\x83`\xE2\x1B\x83R`\x04\x83\x01a+DV[\x03\x90\xFD[a,Fa\"\xE2V[P3\x90V[\x90V[a,ba,]a,g\x92a,KV[a\x03\x0FV[a\x06!V[\x90V[`\xFF\x16\x90V[a,y\x90a,jV[\x90RV[a,\xB2a,\xB9\x94a,\xA8``\x94\x98\x97\x95a,\x9E`\x80\x86\x01\x9A_\x87\x01\x90a\x04\x1AV[` \x85\x01\x90a,pV[`@\x83\x01\x90a\x04\x1AV[\x01\x90a\x04\x1AV[V[a,\xCFa,\xCAa,\xD4\x92a\n\x83V[a\x0F\xA4V[a\x04\x17V[\x90V[\x93\x92\x93a,\xE2a\"\xE2V[Pa,\xEBa*LV[Pa,\xF4a\x19jV[Pa,\xFE\x85a+YV[a-0a-*\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0a,NV[\x91a\x06!V[\x11a-\xBDW\x90a-S` \x94\x95_\x94\x93\x92\x93a-Ja\x01$V[\x94\x85\x94\x85a,}V[\x83\x80R\x03\x90`\x01Z\xFA\x15a-\xB8Wa-k_Qa\x0F\xA4V[\x80a-\x86a-\x80a-{_a\n\xA2V[a\x01pV[\x91a\x01pV[\x14a-\x9CW_\x91a-\x96_a,\xBBV[\x91\x92\x91\x90V[Pa-\xA6_a\n\xA2V[`\x01\x91a-\xB2_a,\xBBV[\x91\x92\x91\x90V[a\r>V[PPPa-\xC9_a\n\xA2V[\x90`\x03\x92\x91\x92\x91\x90V",
    );
    /**```solidity
struct PendingAssertion { bytes32 appBlockHash; bytes32 appSendRoot; bytes32 seqBlockHash; bytes32 l1BatchAcc; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PendingAssertion {
        #[allow(missing_docs)]
        pub appBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub appSendRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1BatchAcc: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PendingAssertion> for UnderlyingRustTuple<'_> {
            fn from(value: PendingAssertion) -> Self {
                (
                    value.appBlockHash,
                    value.appSendRoot,
                    value.seqBlockHash,
                    value.l1BatchAcc,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PendingAssertion {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    appBlockHash: tuple.0,
                    appSendRoot: tuple.1,
                    seqBlockHash: tuple.2,
                    l1BatchAcc: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for PendingAssertion {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for PendingAssertion {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.appBlockHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.appSendRoot),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.seqBlockHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.l1BatchAcc),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for PendingAssertion {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for PendingAssertion {
            const NAME: &'static str = "PendingAssertion";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "PendingAssertion(bytes32 appBlockHash,bytes32 appSendRoot,bytes32 seqBlockHash,bytes32 l1BatchAcc)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.appBlockHash)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.appSendRoot)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.seqBlockHash)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.l1BatchAcc)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for PendingAssertion {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.appBlockHash,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.appSendRoot,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.seqBlockHash,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.l1BatchAcc,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.appBlockHash,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.appSendRoot,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.seqBlockHash,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.l1BatchAcc,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct TeeTrustedInput { bytes32 configHash; bytes32 appStartBlockHash; bytes32 seqStartBlockHash; bytes32 setDelayedMessageAcc; bytes32 l1StartBatchAcc; bytes32 l1EndHash; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TeeTrustedInput {
        #[allow(missing_docs)]
        pub configHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub appStartBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqStartBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub setDelayedMessageAcc: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1StartBatchAcc: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1EndHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TeeTrustedInput> for UnderlyingRustTuple<'_> {
            fn from(value: TeeTrustedInput) -> Self {
                (
                    value.configHash,
                    value.appStartBlockHash,
                    value.seqStartBlockHash,
                    value.setDelayedMessageAcc,
                    value.l1StartBatchAcc,
                    value.l1EndHash,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TeeTrustedInput {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    configHash: tuple.0,
                    appStartBlockHash: tuple.1,
                    seqStartBlockHash: tuple.2,
                    setDelayedMessageAcc: tuple.3,
                    l1StartBatchAcc: tuple.4,
                    l1EndHash: tuple.5,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for TeeTrustedInput {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for TeeTrustedInput {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.configHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.appStartBlockHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.seqStartBlockHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.setDelayedMessageAcc),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.l1StartBatchAcc),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.l1EndHash),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for TeeTrustedInput {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for TeeTrustedInput {
            const NAME: &'static str = "TeeTrustedInput";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "TeeTrustedInput(bytes32 configHash,bytes32 appStartBlockHash,bytes32 seqStartBlockHash,bytes32 setDelayedMessageAcc,bytes32 l1StartBatchAcc,bytes32 l1EndHash)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.configHash)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.appStartBlockHash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.seqStartBlockHash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.setDelayedMessageAcc,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.l1StartBatchAcc,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.l1EndHash)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for TeeTrustedInput {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.configHash,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.appStartBlockHash,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.seqStartBlockHash,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.setDelayedMessageAcc,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.l1StartBatchAcc,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.l1EndHash,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.configHash,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.appStartBlockHash,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.seqStartBlockHash,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.setDelayedMessageAcc,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.l1StartBatchAcc,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.l1EndHash,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignature()` and selector `0xf645eedf`.
```solidity
error ECDSAInvalidSignature();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignature {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignature()";
            const SELECTOR: [u8; 4] = [246u8, 69u8, 238u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureLength(uint256)` and selector `0xfce698f7`.
```solidity
error ECDSAInvalidSignatureLength(uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureLength {
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureLength) -> Self {
                (value.length,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ECDSAInvalidSignatureLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { length: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureLength(uint256)";
            const SELECTOR: [u8; 4] = [252u8, 230u8, 152u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureS(bytes32)` and selector `0xd78bce0c`.
```solidity
error ECDSAInvalidSignatureS(bytes32 s);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureS {
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureS> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureS) -> Self {
                (value.s,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignatureS {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { s: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureS {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureS(bytes32)";
            const SELECTOR: [u8; 4] = [215u8, 139u8, 206u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
        }
    };
    /**Custom error with signature `OwnableInvalidOwner(address)` and selector `0x1e4fbdf7`.
```solidity
error OwnableInvalidOwner(address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableInvalidOwner {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableInvalidOwner> for UnderlyingRustTuple<'_> {
            fn from(value: OwnableInvalidOwner) -> Self {
                (value.owner,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OwnableInvalidOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { owner: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableInvalidOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableInvalidOwner(address)";
            const SELECTOR: [u8; 4] = [30u8, 79u8, 189u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `OwnableUnauthorizedAccount(address)` and selector `0x118cdaa7`.
```solidity
error OwnableUnauthorizedAccount(address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: OwnableUnauthorizedAccount) -> Self {
                (value.account,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OwnableUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { account: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableUnauthorizedAccount(address)";
            const SELECTOR: [u8; 4] = [17u8, 140u8, 218u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ReentrancyGuardReentrantCall()` and selector `0x3ee5aeb5`.
```solidity
error ReentrancyGuardReentrantCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ReentrancyGuardReentrantCall {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ReentrancyGuardReentrantCall>
        for UnderlyingRustTuple<'_> {
            fn from(value: ReentrancyGuardReentrantCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ReentrancyGuardReentrantCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ReentrancyGuardReentrantCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ReentrancyGuardReentrantCall()";
            const SELECTOR: [u8; 4] = [62u8, 229u8, 174u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Event with signature `ChallengeResolved((bytes32,bytes32,bytes32,bytes32))` and selector `0x2020542b6e6b951d4c0736eed2a4d762d20bb1ba579f99feffae9b1dea240883`.
```solidity
event ChallengeResolved(PendingAssertion);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ChallengeResolved {
        #[allow(missing_docs)]
        pub _0: <PendingAssertion as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ChallengeResolved {
            type DataTuple<'a> = (PendingAssertion,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ChallengeResolved((bytes32,bytes32,bytes32,bytes32))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                32u8,
                32u8,
                84u8,
                43u8,
                110u8,
                107u8,
                149u8,
                29u8,
                76u8,
                7u8,
                54u8,
                238u8,
                210u8,
                164u8,
                215u8,
                98u8,
                210u8,
                11u8,
                177u8,
                186u8,
                87u8,
                159u8,
                153u8,
                254u8,
                255u8,
                174u8,
                155u8,
                29u8,
                234u8,
                36u8,
                8u8,
                131u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { _0: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (<PendingAssertion as alloy_sol_types::SolType>::tokenize(&self._0),)
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ChallengeResolved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ChallengeResolved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ChallengeResolved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeConfigHash(bytes32)` and selector `0xd266bca6281b20459ae52407bea3d134d9017bf8f3ba803cb7a11d724e2b2da6`.
```solidity
event TeeConfigHash(bytes32 configHash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeConfigHash {
        #[allow(missing_docs)]
        pub configHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeConfigHash {
            type DataTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeConfigHash(bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                210u8,
                102u8,
                188u8,
                166u8,
                40u8,
                27u8,
                32u8,
                69u8,
                154u8,
                229u8,
                36u8,
                7u8,
                190u8,
                163u8,
                209u8,
                52u8,
                217u8,
                1u8,
                123u8,
                248u8,
                243u8,
                186u8,
                128u8,
                60u8,
                183u8,
                161u8,
                29u8,
                114u8,
                78u8,
                43u8,
                45u8,
                166u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { configHash: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.configHash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeConfigHash {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeConfigHash> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeConfigHash) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeHacked(uint256)` and selector `0x37e8add694c5926d564e971160f5974103cbbbc7c90747c4c6f802031d3567a7`.
```solidity
event TeeHacked(uint256);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeHacked {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeHacked {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeHacked(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                55u8,
                232u8,
                173u8,
                214u8,
                148u8,
                197u8,
                146u8,
                109u8,
                86u8,
                78u8,
                151u8,
                17u8,
                96u8,
                245u8,
                151u8,
                65u8,
                3u8,
                203u8,
                187u8,
                199u8,
                201u8,
                7u8,
                71u8,
                196u8,
                198u8,
                248u8,
                2u8,
                3u8,
                29u8,
                53u8,
                103u8,
                167u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { _0: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeHacked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeHacked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeHacked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TeeInput((bytes32,bytes32,bytes32,bytes32,bytes32,bytes32))` and selector `0x55232299d83faf4dc2c32e228af37632bca7fa6dbc03b41224c100c6c9dca349`.
```solidity
event TeeInput(TeeTrustedInput input);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TeeInput {
        #[allow(missing_docs)]
        pub input: <TeeTrustedInput as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TeeInput {
            type DataTuple<'a> = (TeeTrustedInput,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TeeInput((bytes32,bytes32,bytes32,bytes32,bytes32,bytes32))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                85u8,
                35u8,
                34u8,
                153u8,
                216u8,
                63u8,
                175u8,
                77u8,
                194u8,
                195u8,
                46u8,
                34u8,
                138u8,
                243u8,
                118u8,
                50u8,
                188u8,
                167u8,
                250u8,
                109u8,
                188u8,
                3u8,
                180u8,
                18u8,
                36u8,
                193u8,
                0u8,
                198u8,
                201u8,
                220u8,
                163u8,
                73u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { input: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (<TeeTrustedInput as alloy_sol_types::SolType>::tokenize(&self.input),)
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TeeInput {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TeeInput> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TeeInput) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address poster_, address bridge_, bytes32 configHash_, bytes32 appStartBlockHash_, bytes32 seqStartBlockHash_, bytes32 l1StartBatchAcc_, address l1BlockOrBridge_, bool isL1Chain_, uint64 challengeWindowDuration_, address teeKeyManager_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub poster_: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub bridge_: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub configHash_: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub appStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1StartBatchAcc_: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1BlockOrBridge_: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub isL1Chain_: bool,
        #[allow(missing_docs)]
        pub challengeWindowDuration_: u64,
        #[allow(missing_docs)]
        pub teeKeyManager_: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
                bool,
                u64,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value.poster_,
                        value.bridge_,
                        value.configHash_,
                        value.appStartBlockHash_,
                        value.seqStartBlockHash_,
                        value.l1StartBatchAcc_,
                        value.l1BlockOrBridge_,
                        value.isL1Chain_,
                        value.challengeWindowDuration_,
                        value.teeKeyManager_,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        poster_: tuple.0,
                        bridge_: tuple.1,
                        configHash_: tuple.2,
                        appStartBlockHash_: tuple.3,
                        seqStartBlockHash_: tuple.4,
                        l1StartBatchAcc_: tuple.5,
                        l1BlockOrBridge_: tuple.6,
                        isL1Chain_: tuple.7,
                        challengeWindowDuration_: tuple.8,
                        teeKeyManager_: tuple.9,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.poster_,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge_,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.configHash_),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.appStartBlockHash_),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.seqStartBlockHash_),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.l1StartBatchAcc_),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.l1BlockOrBridge_,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isL1Chain_,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.challengeWindowDuration_,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.teeKeyManager_,
                    ),
                )
            }
        }
    };
    /**Function with signature `bridge()` and selector `0xe78cea92`.
```solidity
function bridge() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeCall {}
    ///Container type for the return parameters of the [`bridge()`](bridgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridge()";
            const SELECTOR: [u8; 4] = [231u8, 140u8, 234u8, 146u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `challengeWindowDuration()` and selector `0x4bd167c9`.
```solidity
function challengeWindowDuration() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowDurationCall {}
    ///Container type for the return parameters of the [`challengeWindowDuration()`](challengeWindowDurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowDurationReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowDurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowDurationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowDurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowDurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowDurationReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowDurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for challengeWindowDurationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = challengeWindowDurationReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "challengeWindowDuration()";
            const SELECTOR: [u8; 4] = [75u8, 209u8, 103u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `challengeWindowEnd()` and selector `0xee1c28b8`.
```solidity
function challengeWindowEnd() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowEndCall {}
    ///Container type for the return parameters of the [`challengeWindowEnd()`](challengeWindowEndCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengeWindowEndReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowEndCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowEndCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowEndCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengeWindowEndReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengeWindowEndReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengeWindowEndReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for challengeWindowEndCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = challengeWindowEndReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "challengeWindowEnd()";
            const SELECTOR: [u8; 4] = [238u8, 28u8, 40u8, 184u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `closeChallengeWindow()` and selector `0x6c4c2060`.
```solidity
function closeChallengeWindow() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct closeChallengeWindowCall {}
    ///Container type for the return parameters of the [`closeChallengeWindow()`](closeChallengeWindowCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct closeChallengeWindowReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<closeChallengeWindowCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: closeChallengeWindowCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for closeChallengeWindowCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<closeChallengeWindowReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: closeChallengeWindowReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for closeChallengeWindowReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for closeChallengeWindowCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = closeChallengeWindowReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "closeChallengeWindow()";
            const SELECTOR: [u8; 4] = [108u8, 76u8, 32u8, 96u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isL1Chain()` and selector `0x470b9b1a`.
```solidity
function isL1Chain() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isL1ChainCall {}
    ///Container type for the return parameters of the [`isL1Chain()`](isL1ChainCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isL1ChainReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isL1ChainCall> for UnderlyingRustTuple<'_> {
                fn from(value: isL1ChainCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isL1ChainCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isL1ChainReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isL1ChainReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isL1ChainReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isL1ChainCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isL1ChainReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isL1Chain()";
            const SELECTOR: [u8; 4] = [71u8, 11u8, 155u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `l1BlockOrBridge()` and selector `0x27d40299`.
```solidity
function l1BlockOrBridge() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct l1BlockOrBridgeCall {}
    ///Container type for the return parameters of the [`l1BlockOrBridge()`](l1BlockOrBridgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct l1BlockOrBridgeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<l1BlockOrBridgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: l1BlockOrBridgeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for l1BlockOrBridgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<l1BlockOrBridgeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: l1BlockOrBridgeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for l1BlockOrBridgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for l1BlockOrBridgeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = l1BlockOrBridgeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "l1BlockOrBridge()";
            const SELECTOR: [u8; 4] = [39u8, 212u8, 2u8, 153u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall {}
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pendingAssertions(uint256)` and selector `0xa56ec6cd`.
```solidity
function pendingAssertions(uint256) external view returns (bytes32 appBlockHash, bytes32 appSendRoot, bytes32 seqBlockHash, bytes32 l1BatchAcc);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingAssertionsCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`pendingAssertions(uint256)`](pendingAssertionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingAssertionsReturn {
        #[allow(missing_docs)]
        pub appBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub appSendRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1BatchAcc: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingAssertionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: pendingAssertionsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pendingAssertionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingAssertionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: pendingAssertionsReturn) -> Self {
                    (
                        value.appBlockHash,
                        value.appSendRoot,
                        value.seqBlockHash,
                        value.l1BatchAcc,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pendingAssertionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        appBlockHash: tuple.0,
                        appSendRoot: tuple.1,
                        seqBlockHash: tuple.2,
                        l1BatchAcc: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pendingAssertionsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pendingAssertionsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pendingAssertions(uint256)";
            const SELECTOR: [u8; 4] = [165u8, 110u8, 198u8, 205u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `poster()` and selector `0x80959721`.
```solidity
function poster() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct posterCall {}
    ///Container type for the return parameters of the [`poster()`](posterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct posterReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<posterCall> for UnderlyingRustTuple<'_> {
                fn from(value: posterCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for posterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<posterReturn> for UnderlyingRustTuple<'_> {
                fn from(value: posterReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for posterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for posterCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = posterReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "poster()";
            const SELECTOR: [u8; 4] = [128u8, 149u8, 151u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall {}
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `resolveChallenge((bytes32,bytes32,bytes32,bytes32))` and selector `0xdc68cdfe`.
```solidity
function resolveChallenge(PendingAssertion memory assertion) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolveChallengeCall {
        #[allow(missing_docs)]
        pub assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`resolveChallenge((bytes32,bytes32,bytes32,bytes32))`](resolveChallengeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolveChallengeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (PendingAssertion,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PendingAssertion as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolveChallengeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: resolveChallengeCall) -> Self {
                    (value.assertion,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resolveChallengeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { assertion: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolveChallengeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: resolveChallengeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resolveChallengeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for resolveChallengeCall {
            type Parameters<'a> = (PendingAssertion,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = resolveChallengeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "resolveChallenge((bytes32,bytes32,bytes32,bytes32))";
            const SELECTOR: [u8; 4] = [220u8, 104u8, 205u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PendingAssertion as alloy_sol_types::SolType>::tokenize(
                        &self.assertion,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `submitAssertion((bytes32,bytes32,bytes32,bytes32),bytes,address)` and selector `0x3183baac`.
```solidity
function submitAssertion(PendingAssertion memory assertion, bytes memory signature, address rewardAddr) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitAssertionCall {
        #[allow(missing_docs)]
        pub assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub signature: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub rewardAddr: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`submitAssertion((bytes32,bytes32,bytes32,bytes32),bytes,address)`](submitAssertionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitAssertionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                PendingAssertion,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PendingAssertion as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitAssertionCall> for UnderlyingRustTuple<'_> {
                fn from(value: submitAssertionCall) -> Self {
                    (value.assertion, value.signature, value.rewardAddr)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for submitAssertionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        assertion: tuple.0,
                        signature: tuple.1,
                        rewardAddr: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitAssertionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: submitAssertionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for submitAssertionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for submitAssertionCall {
            type Parameters<'a> = (
                PendingAssertion,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = submitAssertionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "submitAssertion((bytes32,bytes32,bytes32,bytes32),bytes,address)";
            const SELECTOR: [u8; 4] = [49u8, 131u8, 186u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PendingAssertion as alloy_sol_types::SolType>::tokenize(
                        &self.assertion,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.signature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rewardAddr,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teeHackCount()` and selector `0x697b5e62`.
```solidity
function teeHackCount() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeHackCountCall {}
    ///Container type for the return parameters of the [`teeHackCount()`](teeHackCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeHackCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeHackCountCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeHackCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeHackCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeHackCountReturn> for UnderlyingRustTuple<'_> {
                fn from(value: teeHackCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeHackCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeHackCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeHackCountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teeHackCount()";
            const SELECTOR: [u8; 4] = [105u8, 123u8, 94u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teeKeyManager()` and selector `0x3a009a06`.
```solidity
function teeKeyManager() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeKeyManagerCall {}
    ///Container type for the return parameters of the [`teeKeyManager()`](teeKeyManagerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeKeyManagerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeKeyManagerCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeKeyManagerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeKeyManagerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeKeyManagerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: teeKeyManagerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeKeyManagerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeKeyManagerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeKeyManagerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teeKeyManager()";
            const SELECTOR: [u8; 4] = [58u8, 0u8, 154u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `teeTrustedInput()` and selector `0x3ceaae7d`.
```solidity
function teeTrustedInput() external view returns (bytes32 configHash, bytes32 appStartBlockHash, bytes32 seqStartBlockHash, bytes32 setDelayedMessageAcc, bytes32 l1StartBatchAcc, bytes32 l1EndHash);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeTrustedInputCall {}
    ///Container type for the return parameters of the [`teeTrustedInput()`](teeTrustedInputCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct teeTrustedInputReturn {
        #[allow(missing_docs)]
        pub configHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub appStartBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub seqStartBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub setDelayedMessageAcc: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1StartBatchAcc: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub l1EndHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeTrustedInputCall> for UnderlyingRustTuple<'_> {
                fn from(value: teeTrustedInputCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for teeTrustedInputCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<teeTrustedInputReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: teeTrustedInputReturn) -> Self {
                    (
                        value.configHash,
                        value.appStartBlockHash,
                        value.seqStartBlockHash,
                        value.setDelayedMessageAcc,
                        value.l1StartBatchAcc,
                        value.l1EndHash,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for teeTrustedInputReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        configHash: tuple.0,
                        appStartBlockHash: tuple.1,
                        seqStartBlockHash: tuple.2,
                        setDelayedMessageAcc: tuple.3,
                        l1StartBatchAcc: tuple.4,
                        l1EndHash: tuple.5,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for teeTrustedInputCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = teeTrustedInputReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "teeTrustedInput()";
            const SELECTOR: [u8; 4] = [60u8, 234u8, 174u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`TeeModule`](self) function calls.
    pub enum TeeModuleCalls {
        #[allow(missing_docs)]
        bridge(bridgeCall),
        #[allow(missing_docs)]
        challengeWindowDuration(challengeWindowDurationCall),
        #[allow(missing_docs)]
        challengeWindowEnd(challengeWindowEndCall),
        #[allow(missing_docs)]
        closeChallengeWindow(closeChallengeWindowCall),
        #[allow(missing_docs)]
        isL1Chain(isL1ChainCall),
        #[allow(missing_docs)]
        l1BlockOrBridge(l1BlockOrBridgeCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        pendingAssertions(pendingAssertionsCall),
        #[allow(missing_docs)]
        poster(posterCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        resolveChallenge(resolveChallengeCall),
        #[allow(missing_docs)]
        submitAssertion(submitAssertionCall),
        #[allow(missing_docs)]
        teeHackCount(teeHackCountCall),
        #[allow(missing_docs)]
        teeKeyManager(teeKeyManagerCall),
        #[allow(missing_docs)]
        teeTrustedInput(teeTrustedInputCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
    }
    #[automatically_derived]
    impl TeeModuleCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [39u8, 212u8, 2u8, 153u8],
            [49u8, 131u8, 186u8, 172u8],
            [58u8, 0u8, 154u8, 6u8],
            [60u8, 234u8, 174u8, 125u8],
            [71u8, 11u8, 155u8, 26u8],
            [75u8, 209u8, 103u8, 201u8],
            [105u8, 123u8, 94u8, 98u8],
            [108u8, 76u8, 32u8, 96u8],
            [113u8, 80u8, 24u8, 166u8],
            [128u8, 149u8, 151u8, 33u8],
            [141u8, 165u8, 203u8, 91u8],
            [165u8, 110u8, 198u8, 205u8],
            [220u8, 104u8, 205u8, 254u8],
            [231u8, 140u8, 234u8, 146u8],
            [238u8, 28u8, 40u8, 184u8],
            [242u8, 253u8, 227u8, 139u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for TeeModuleCalls {
        const NAME: &'static str = "TeeModuleCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 16usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::bridge(_) => <bridgeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::challengeWindowDuration(_) => {
                    <challengeWindowDurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::challengeWindowEnd(_) => {
                    <challengeWindowEndCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::closeChallengeWindow(_) => {
                    <closeChallengeWindowCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isL1Chain(_) => {
                    <isL1ChainCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::l1BlockOrBridge(_) => {
                    <l1BlockOrBridgeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pendingAssertions(_) => {
                    <pendingAssertionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::poster(_) => <posterCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::resolveChallenge(_) => {
                    <resolveChallengeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::submitAssertion(_) => {
                    <submitAssertionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::teeHackCount(_) => {
                    <teeHackCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::teeKeyManager(_) => {
                    <teeKeyManagerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::teeTrustedInput(_) => {
                    <teeTrustedInputCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<TeeModuleCalls>] = &[
                {
                    fn l1BlockOrBridge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <l1BlockOrBridgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::l1BlockOrBridge)
                    }
                    l1BlockOrBridge
                },
                {
                    fn submitAssertion(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <submitAssertionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::submitAssertion)
                    }
                    submitAssertion
                },
                {
                    fn teeKeyManager(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeKeyManagerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teeKeyManager)
                    }
                    teeKeyManager
                },
                {
                    fn teeTrustedInput(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeTrustedInputCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teeTrustedInput)
                    }
                    teeTrustedInput
                },
                {
                    fn isL1Chain(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <isL1ChainCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::isL1Chain)
                    }
                    isL1Chain
                },
                {
                    fn challengeWindowDuration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <challengeWindowDurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::challengeWindowDuration)
                    }
                    challengeWindowDuration
                },
                {
                    fn teeHackCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <teeHackCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::teeHackCount)
                    }
                    teeHackCount
                },
                {
                    fn closeChallengeWindow(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <closeChallengeWindowCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::closeChallengeWindow)
                    }
                    closeChallengeWindow
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn poster(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <posterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::poster)
                    }
                    poster
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::owner)
                    }
                    owner
                },
                {
                    fn pendingAssertions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <pendingAssertionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::pendingAssertions)
                    }
                    pendingAssertions
                },
                {
                    fn resolveChallenge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <resolveChallengeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::resolveChallenge)
                    }
                    resolveChallenge
                },
                {
                    fn bridge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <bridgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::bridge)
                    }
                    bridge
                },
                {
                    fn challengeWindowEnd(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <challengeWindowEndCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::challengeWindowEnd)
                    }
                    challengeWindowEnd
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleCalls::transferOwnership)
                    }
                    transferOwnership
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::bridge(inner) => {
                    <bridgeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::challengeWindowDuration(inner) => {
                    <challengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::challengeWindowEnd(inner) => {
                    <challengeWindowEndCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::closeChallengeWindow(inner) => {
                    <closeChallengeWindowCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isL1Chain(inner) => {
                    <isL1ChainCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::l1BlockOrBridge(inner) => {
                    <l1BlockOrBridgeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pendingAssertions(inner) => {
                    <pendingAssertionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::poster(inner) => {
                    <posterCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::resolveChallenge(inner) => {
                    <resolveChallengeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::submitAssertion(inner) => {
                    <submitAssertionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::teeHackCount(inner) => {
                    <teeHackCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::teeKeyManager(inner) => {
                    <teeKeyManagerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::teeTrustedInput(inner) => {
                    <teeTrustedInputCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::bridge(inner) => {
                    <bridgeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::challengeWindowDuration(inner) => {
                    <challengeWindowDurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::challengeWindowEnd(inner) => {
                    <challengeWindowEndCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::closeChallengeWindow(inner) => {
                    <closeChallengeWindowCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isL1Chain(inner) => {
                    <isL1ChainCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::l1BlockOrBridge(inner) => {
                    <l1BlockOrBridgeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pendingAssertions(inner) => {
                    <pendingAssertionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::poster(inner) => {
                    <posterCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::resolveChallenge(inner) => {
                    <resolveChallengeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::submitAssertion(inner) => {
                    <submitAssertionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::teeHackCount(inner) => {
                    <teeHackCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::teeKeyManager(inner) => {
                    <teeKeyManagerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::teeTrustedInput(inner) => {
                    <teeTrustedInputCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`TeeModule`](self) custom errors.
    pub enum TeeModuleErrors {
        #[allow(missing_docs)]
        ECDSAInvalidSignature(ECDSAInvalidSignature),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureLength(ECDSAInvalidSignatureLength),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureS(ECDSAInvalidSignatureS),
        #[allow(missing_docs)]
        OwnableInvalidOwner(OwnableInvalidOwner),
        #[allow(missing_docs)]
        OwnableUnauthorizedAccount(OwnableUnauthorizedAccount),
        #[allow(missing_docs)]
        ReentrancyGuardReentrantCall(ReentrancyGuardReentrantCall),
    }
    #[automatically_derived]
    impl TeeModuleErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [17u8, 140u8, 218u8, 167u8],
            [30u8, 79u8, 189u8, 247u8],
            [62u8, 229u8, 174u8, 181u8],
            [215u8, 139u8, 206u8, 12u8],
            [246u8, 69u8, 238u8, 223u8],
            [252u8, 230u8, 152u8, 247u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for TeeModuleErrors {
        const NAME: &'static str = "TeeModuleErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 6usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ECDSAInvalidSignature(_) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureLength(_) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureS(_) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableInvalidOwner(_) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableUnauthorizedAccount(_) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ReentrancyGuardReentrantCall(_) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<TeeModuleErrors>] = &[
                {
                    fn OwnableUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::OwnableUnauthorizedAccount)
                    }
                    OwnableUnauthorizedAccount
                },
                {
                    fn OwnableInvalidOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::OwnableInvalidOwner)
                    }
                    OwnableInvalidOwner
                },
                {
                    fn ReentrancyGuardReentrantCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::ReentrancyGuardReentrantCall)
                    }
                    ReentrancyGuardReentrantCall
                },
                {
                    fn ECDSAInvalidSignatureS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::ECDSAInvalidSignatureS)
                    }
                    ECDSAInvalidSignatureS
                },
                {
                    fn ECDSAInvalidSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::ECDSAInvalidSignature)
                    }
                    ECDSAInvalidSignature
                },
                {
                    fn ECDSAInvalidSignatureLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TeeModuleErrors> {
                        <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TeeModuleErrors::ECDSAInvalidSignatureLength)
                    }
                    ECDSAInvalidSignatureLength
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`TeeModule`](self) events.
    pub enum TeeModuleEvents {
        #[allow(missing_docs)]
        ChallengeResolved(ChallengeResolved),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
        #[allow(missing_docs)]
        TeeConfigHash(TeeConfigHash),
        #[allow(missing_docs)]
        TeeHacked(TeeHacked),
        #[allow(missing_docs)]
        TeeInput(TeeInput),
    }
    #[automatically_derived]
    impl TeeModuleEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                32u8,
                32u8,
                84u8,
                43u8,
                110u8,
                107u8,
                149u8,
                29u8,
                76u8,
                7u8,
                54u8,
                238u8,
                210u8,
                164u8,
                215u8,
                98u8,
                210u8,
                11u8,
                177u8,
                186u8,
                87u8,
                159u8,
                153u8,
                254u8,
                255u8,
                174u8,
                155u8,
                29u8,
                234u8,
                36u8,
                8u8,
                131u8,
            ],
            [
                55u8,
                232u8,
                173u8,
                214u8,
                148u8,
                197u8,
                146u8,
                109u8,
                86u8,
                78u8,
                151u8,
                17u8,
                96u8,
                245u8,
                151u8,
                65u8,
                3u8,
                203u8,
                187u8,
                199u8,
                201u8,
                7u8,
                71u8,
                196u8,
                198u8,
                248u8,
                2u8,
                3u8,
                29u8,
                53u8,
                103u8,
                167u8,
            ],
            [
                85u8,
                35u8,
                34u8,
                153u8,
                216u8,
                63u8,
                175u8,
                77u8,
                194u8,
                195u8,
                46u8,
                34u8,
                138u8,
                243u8,
                118u8,
                50u8,
                188u8,
                167u8,
                250u8,
                109u8,
                188u8,
                3u8,
                180u8,
                18u8,
                36u8,
                193u8,
                0u8,
                198u8,
                201u8,
                220u8,
                163u8,
                73u8,
            ],
            [
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ],
            [
                210u8,
                102u8,
                188u8,
                166u8,
                40u8,
                27u8,
                32u8,
                69u8,
                154u8,
                229u8,
                36u8,
                7u8,
                190u8,
                163u8,
                209u8,
                52u8,
                217u8,
                1u8,
                123u8,
                248u8,
                243u8,
                186u8,
                128u8,
                60u8,
                183u8,
                161u8,
                29u8,
                114u8,
                78u8,
                43u8,
                45u8,
                166u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for TeeModuleEvents {
        const NAME: &'static str = "TeeModuleEvents";
        const COUNT: usize = 5usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <ChallengeResolved as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ChallengeResolved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ChallengeResolved)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(<TeeConfigHash as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TeeConfigHash as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeConfigHash)
                }
                Some(<TeeHacked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TeeHacked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeHacked)
                }
                Some(<TeeInput as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TeeInput as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TeeInput)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for TeeModuleEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChallengeResolved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeConfigHash(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeHacked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TeeInput(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChallengeResolved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeConfigHash(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeHacked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TeeInput(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`TeeModule`](self) contract instance.

See the [wrapper's documentation](`TeeModuleInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> TeeModuleInstance<T, P, N> {
        TeeModuleInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        poster_: alloy::sol_types::private::Address,
        bridge_: alloy::sol_types::private::Address,
        configHash_: alloy::sol_types::private::FixedBytes<32>,
        appStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        seqStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        l1StartBatchAcc_: alloy::sol_types::private::FixedBytes<32>,
        l1BlockOrBridge_: alloy::sol_types::private::Address,
        isL1Chain_: bool,
        challengeWindowDuration_: u64,
        teeKeyManager_: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<TeeModuleInstance<T, P, N>>,
    > {
        TeeModuleInstance::<
            T,
            P,
            N,
        >::deploy(
            provider,
            poster_,
            bridge_,
            configHash_,
            appStartBlockHash_,
            seqStartBlockHash_,
            l1StartBatchAcc_,
            l1BlockOrBridge_,
            isL1Chain_,
            challengeWindowDuration_,
            teeKeyManager_,
        )
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        poster_: alloy::sol_types::private::Address,
        bridge_: alloy::sol_types::private::Address,
        configHash_: alloy::sol_types::private::FixedBytes<32>,
        appStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        seqStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
        l1StartBatchAcc_: alloy::sol_types::private::FixedBytes<32>,
        l1BlockOrBridge_: alloy::sol_types::private::Address,
        isL1Chain_: bool,
        challengeWindowDuration_: u64,
        teeKeyManager_: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        TeeModuleInstance::<
            T,
            P,
            N,
        >::deploy_builder(
            provider,
            poster_,
            bridge_,
            configHash_,
            appStartBlockHash_,
            seqStartBlockHash_,
            l1StartBatchAcc_,
            l1BlockOrBridge_,
            isL1Chain_,
            challengeWindowDuration_,
            teeKeyManager_,
        )
    }
    /**A [`TeeModule`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`TeeModule`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct TeeModuleInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for TeeModuleInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("TeeModuleInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TeeModuleInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`TeeModule`](self) contract instance.

See the [wrapper's documentation](`TeeModuleInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            poster_: alloy::sol_types::private::Address,
            bridge_: alloy::sol_types::private::Address,
            configHash_: alloy::sol_types::private::FixedBytes<32>,
            appStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            seqStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            l1StartBatchAcc_: alloy::sol_types::private::FixedBytes<32>,
            l1BlockOrBridge_: alloy::sol_types::private::Address,
            isL1Chain_: bool,
            challengeWindowDuration_: u64,
            teeKeyManager_: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<TeeModuleInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                poster_,
                bridge_,
                configHash_,
                appStartBlockHash_,
                seqStartBlockHash_,
                l1StartBatchAcc_,
                l1BlockOrBridge_,
                isL1Chain_,
                challengeWindowDuration_,
                teeKeyManager_,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            poster_: alloy::sol_types::private::Address,
            bridge_: alloy::sol_types::private::Address,
            configHash_: alloy::sol_types::private::FixedBytes<32>,
            appStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            seqStartBlockHash_: alloy::sol_types::private::FixedBytes<32>,
            l1StartBatchAcc_: alloy::sol_types::private::FixedBytes<32>,
            l1BlockOrBridge_: alloy::sol_types::private::Address,
            isL1Chain_: bool,
            challengeWindowDuration_: u64,
            teeKeyManager_: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            poster_,
                            bridge_,
                            configHash_,
                            appStartBlockHash_,
                            seqStartBlockHash_,
                            l1StartBatchAcc_,
                            l1BlockOrBridge_,
                            isL1Chain_,
                            challengeWindowDuration_,
                            teeKeyManager_,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> TeeModuleInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> TeeModuleInstance<T, P, N> {
            TeeModuleInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TeeModuleInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`bridge`] function.
        pub fn bridge(&self) -> alloy_contract::SolCallBuilder<T, &P, bridgeCall, N> {
            self.call_builder(&bridgeCall {})
        }
        ///Creates a new call builder for the [`challengeWindowDuration`] function.
        pub fn challengeWindowDuration(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, challengeWindowDurationCall, N> {
            self.call_builder(&challengeWindowDurationCall {})
        }
        ///Creates a new call builder for the [`challengeWindowEnd`] function.
        pub fn challengeWindowEnd(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, challengeWindowEndCall, N> {
            self.call_builder(&challengeWindowEndCall {})
        }
        ///Creates a new call builder for the [`closeChallengeWindow`] function.
        pub fn closeChallengeWindow(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, closeChallengeWindowCall, N> {
            self.call_builder(&closeChallengeWindowCall {})
        }
        ///Creates a new call builder for the [`isL1Chain`] function.
        pub fn isL1Chain(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, isL1ChainCall, N> {
            self.call_builder(&isL1ChainCall {})
        }
        ///Creates a new call builder for the [`l1BlockOrBridge`] function.
        pub fn l1BlockOrBridge(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, l1BlockOrBridgeCall, N> {
            self.call_builder(&l1BlockOrBridgeCall {})
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        ///Creates a new call builder for the [`pendingAssertions`] function.
        pub fn pendingAssertions(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, pendingAssertionsCall, N> {
            self.call_builder(&pendingAssertionsCall { _0 })
        }
        ///Creates a new call builder for the [`poster`] function.
        pub fn poster(&self) -> alloy_contract::SolCallBuilder<T, &P, posterCall, N> {
            self.call_builder(&posterCall {})
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall {})
        }
        ///Creates a new call builder for the [`resolveChallenge`] function.
        pub fn resolveChallenge(
            &self,
            assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, resolveChallengeCall, N> {
            self.call_builder(&resolveChallengeCall { assertion })
        }
        ///Creates a new call builder for the [`submitAssertion`] function.
        pub fn submitAssertion(
            &self,
            assertion: <PendingAssertion as alloy::sol_types::SolType>::RustType,
            signature: alloy::sol_types::private::Bytes,
            rewardAddr: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, submitAssertionCall, N> {
            self.call_builder(
                &submitAssertionCall {
                    assertion,
                    signature,
                    rewardAddr,
                },
            )
        }
        ///Creates a new call builder for the [`teeHackCount`] function.
        pub fn teeHackCount(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeHackCountCall, N> {
            self.call_builder(&teeHackCountCall {})
        }
        ///Creates a new call builder for the [`teeKeyManager`] function.
        pub fn teeKeyManager(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeKeyManagerCall, N> {
            self.call_builder(&teeKeyManagerCall {})
        }
        ///Creates a new call builder for the [`teeTrustedInput`] function.
        pub fn teeTrustedInput(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, teeTrustedInputCall, N> {
            self.call_builder(&teeTrustedInputCall {})
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TeeModuleInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`ChallengeResolved`] event.
        pub fn ChallengeResolved_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ChallengeResolved, N> {
            self.event_filter::<ChallengeResolved>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`TeeConfigHash`] event.
        pub fn TeeConfigHash_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TeeConfigHash, N> {
            self.event_filter::<TeeConfigHash>()
        }
        ///Creates a new event filter for the [`TeeHacked`] event.
        pub fn TeeHacked_filter(&self) -> alloy_contract::Event<T, &P, TeeHacked, N> {
            self.event_filter::<TeeHacked>()
        }
        ///Creates a new event filter for the [`TeeInput`] event.
        pub fn TeeInput_filter(&self) -> alloy_contract::Event<T, &P, TeeInput, N> {
            self.event_filter::<TeeInput>()
        }
    }
}
