/**

Generated by the following Solidity interface...
```solidity
interface EmissionsCalculator {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error CannotModifyPastEpoch();
    error EmissionsCompleted();
    error InvalidDecayFactor();
    error InvalidEpoch();
    error ZeroAddress();

    event DecayFactorSet(uint256 indexed epoch, uint256 decayFactor, address indexed setter);
    event EmissionMinted(uint256 indexed epoch, uint256 amount, uint256 remainingSupply, address indexed to);
    event EmissionsInitialized(uint256 defaultDecayFactor);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    constructor(address _syndicateToken, address defaultAdmin, address decayManager);

    function DECAY_MANAGER_ROLE() external view returns (bytes32);
    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function EMISSIONS_CAP() external view returns (uint256);
    function EMISSIONS_ROLE() external view returns (bytes32);
    function SCALE() external view returns (uint256);
    function TOTAL_EPOCHS() external view returns (uint256);
    function calculateAndMintEmission(address to) external returns (uint256);
    function calculateCumulativeProduct(uint256 fromEpoch) external view returns (uint256);
    function currentEpoch() external view returns (uint256);
    function decayFactors(uint256) external view returns (uint256);
    function getDecayFactor(uint256 epoch) external view returns (uint256);
    function getEmissionsInfo() external view returns (uint256 current, uint256 total, uint256 emitted, uint256 remaining, bool completed);
    function getRemainingSupply() external view returns (uint256);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function initializeEmissions(uint256 defaultDecayFactor) external;
    function initialized() external view returns (bool);
    function isCompleted() external view returns (bool);
    function previewCurrentEmission() external view returns (uint256);
    function renounceRole(bytes32 role, address callerConfirmation) external;
    function revokeRole(bytes32 role, address account) external;
    function setDecayFactor(uint256 epoch, uint256 decayFactor) external;
    function setDecayFactors(uint256 startEpoch, uint256[] memory decayFactorArray) external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function syndicateToken() external view returns (address);
    function totalEmitted() external view returns (uint256);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_syndicateToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "defaultAdmin",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "decayManager",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "DECAY_MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSIONS_CAP",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSIONS_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SCALE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TOTAL_EPOCHS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "calculateAndMintEmission",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "calculateCumulativeProduct",
    "inputs": [
      {
        "name": "fromEpoch",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "currentEpoch",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "decayFactors",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getDecayFactor",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getEmissionsInfo",
    "inputs": [],
    "outputs": [
      {
        "name": "current",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "emitted",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "remaining",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "completed",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRemainingSupply",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initializeEmissions",
    "inputs": [
      {
        "name": "defaultDecayFactor",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "initialized",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isCompleted",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "previewCurrentEmission",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "callerConfirmation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setDecayFactor",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decayFactor",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setDecayFactors",
    "inputs": [
      {
        "name": "startEpoch",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decayFactorArray",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "syndicateToken",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract ISyndicateTokenMintable"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "totalEmitted",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "DecayFactorSet",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "decayFactor",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "setter",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionMinted",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "remainingSupply",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionsInitialized",
    "inputs": [
      {
        "name": "defaultDecayFactor",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccessControlBadConfirmation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AccessControlUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "neededRole",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "CannotModifyPastEpoch",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionsCompleted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidDecayFactor",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidEpoch",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod EmissionsCalculator {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a06040523461004e5761001a61001461012f565b91610231565b610022610053565b611fb76104d9823960805181818161057d015281816119a901528181611bdd0152611c440152611fb790f35b610059565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906100859061005d565b810190811060018060401b0382111761009d57604052565b610067565b906100b56100ae610053565b928361007b565b565b5f80fd5b60018060a01b031690565b6100cf906100bb565b90565b6100db816100c6565b036100e257565b5f80fd5b905051906100f3826100d2565b565b909160608284031261012a57610127610110845f85016100e6565b9361011e81602086016100e6565b936040016100e6565b90565b6100b7565b61014d61249080380380610142816100a2565b9283398101906100f5565b909192565b90565b90565b61016c61016761017192610152565b610155565b6100bb565b90565b61017d90610158565b90565b5f0190565b61019961019461019e926100bb565b610155565b6100bb565b90565b6101aa90610185565b90565b6101b6906101a1565b90565b90565b5f1b90565b6101d56101d06101da92610152565b6101bc565b6101b9565b90565b6101e65f6101c1565b90565b7f397a4cbece64093f6309c34380bd980191b5f32c77f583bacd4d51044e68a10390565b7f076eb8b875b6ea839b087c4c0c1a4661b089d3b6ee2c1ef1b9cfa7fe1066d20690565b8061024c6102466102415f610174565b6100c6565b916100c6565b1461030d578161026c6102666102615f610174565b6100c6565b916100c6565b146102f1578261028c6102866102815f610174565b6100c6565b916100c6565b146102d5576102d2926102a16102c4926101ad565b6080526102b66102af6101dd565b84906103c7565b506102bf6101e9565b6103c7565b506102cd61020d565b6103c7565b50565b5f63d92e233d60e01b8152806102ed60048201610180565b0390fd5b5f63d92e233d60e01b81528061030960048201610180565b0390fd5b5f63d92e233d60e01b81528061032560048201610180565b0390fd5b5f90565b151590565b61033b906101b9565b90565b9061034890610332565b5f5260205260405f2090565b61035d90610185565b90565b61036990610354565b90565b9061037690610360565b5f5260205260405f2090565b9061038e60ff916101bc565b9181191691161790565b6103a19061032d565b90565b90565b906103bc6103b76103c392610398565b6103a4565b8254610382565b9055565b6103cf610329565b506103e46103de82849061049e565b1561032d565b5f1461046c5761040b60016104065f6103fe81869061033e565b01859061036c565b6103a7565b906104146104cb565b9061045161044b6104457f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d95610332565b92610360565b92610360565b9261045a610053565b8061046481610180565b0390a4600190565b50505f90565b5f1c90565b60ff1690565b61048961048e91610472565b610477565b90565b61049b905461047d565b90565b6104c4915f6104b96104bf936104b2610329565b508261033e565b0161036c565b610491565b90565b5f90565b6104d36104c7565b50339056fe60806040526004361015610013575b610cfa565b61001d5f356101cc565b806301ffc9a7146101c7578063158ef93e146101c2578063236640b9146101bd578063248a9ca3146101b85780632f2ff15d146101b357806336568abe146101ae5780635880f49e146101a95780635bdf6ca1146101a45780635f15c3c91461019f578063766718081461019a57806380572f181461019557806391d1485414610190578063a088787d1461018b578063a217fddf14610186578063afca740514610181578063b198d0281461017c578063c63a094414610177578063d2bcc9ff14610172578063d547741f1461016d578063dca504b614610168578063debe4f1f14610163578063df0244b11461015e578063e0f5147414610159578063e1f27eb814610154578063e4b7fb731461014f578063eced55261461014a5763fa391c640361000e57610cc5565b610c90565b610c1d565b610be8565b610b95565b610b60565b610b1c565b610ab8565b610a55565b610a21565b61095d565b610928565b6108b2565b610832565b6107be565b61073b565b610706565b6106d1565b610664565b6105f8565b610547565b6104e6565b6104b2565b610411565b610376565b6102db565b610258565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b6101f9816101e4565b0361020057565b5f80fd5b90503590610211826101f0565b565b9060208282031261022c57610229915f01610204565b90565b6101dc565b151590565b61023f90610231565b9052565b9190610256905f60208501940190610236565b565b346102885761028461027361026e366004610213565b610d02565b61027b6101d2565b91829182610243565b0390f35b6101d8565b5f91031261029757565b6101dc565b1c90565b60ff1690565b6102b69060086102bb930261029c565b6102a0565b90565b906102c991546102a6565b90565b6102d860045f906102be565b90565b3461030b576102eb36600461028d565b6103076102f66102cc565b6102fe6101d2565b91829182610243565b0390f35b6101d8565b90565b61031c81610310565b0361032357565b5f80fd5b9050359061033482610313565b565b9060208282031261034f5761034c915f01610327565b90565b6101dc565b61035d90610310565b9052565b9190610374905f60208501940190610354565b565b346103a6576103a261039161038c366004610336565b610dfa565b6103996101d2565b91829182610361565b0390f35b6101d8565b90565b6103b7816103ab565b036103be57565b5f80fd5b905035906103cf826103ae565b565b906020828203126103ea576103e7915f016103c2565b90565b6101dc565b6103f8906103ab565b9052565b919061040f905f602085019401906103ef565b565b346104415761043d61042c6104273660046103d1565b610ee5565b6104346101d2565b918291826103fc565b0390f35b6101d8565b60018060a01b031690565b61045a90610446565b90565b61046681610451565b0361046d57565b5f80fd5b9050359061047e8261045d565b565b91906040838203126104a8578061049c6104a5925f86016103c2565b93602001610471565b90565b6101dc565b5f0190565b346104e1576104cb6104c5366004610480565b90610f30565b6104d36101d2565b806104dd816104ad565b0390f35b6101d8565b34610515576104ff6104f9366004610480565b90610f3c565b6105076101d2565b80610511816104ad565b0390f35b6101d8565b9190604083820312610542578061053661053f925f8601610327565b93602001610327565b90565b6101dc565b346105765761056061055a36600461051a565b9061113b565b6105686101d2565b80610572816104ad565b0390f35b6101d8565b7f000000000000000000000000000000000000000000000000000000000000000090565b90565b6105b66105b16105bb92610446565b61059f565b610446565b90565b6105c7906105a2565b90565b6105d3906105be565b90565b6105df906105ca565b9052565b91906105f6905f602085019401906105d6565b565b346106285761060836600461028d565b61062461061361057b565b61061b6101d2565b918291826105e3565b0390f35b6101d8565b90565b61064461063f6106499261062d565b61059f565b610310565b90565b6106566030610630565b90565b61066161064c565b90565b346106945761067436600461028d565b61069061067f610659565b6106876101d2565b91829182610361565b0390f35b6101d8565b90565b6106ac9060086106b1930261029c565b610699565b90565b906106bf915461069c565b90565b6106ce60025f906106b4565b90565b34610701576106e136600461028d565b6106fd6106ec6106c2565b6106f46101d2565b91829182610361565b0390f35b6101d8565b346107365761071636600461028d565b6107326107216111ac565b6107296101d2565b91829182610361565b0390f35b6101d8565b3461076c57610768610757610751366004610480565b906112ce565b61075f6101d2565b91829182610243565b0390f35b6101d8565b909594926107bc946107ab6107b5926107a160809661079760a088019c5f890190610354565b6020870190610354565b6040850190610354565b6060830190610354565b0190610236565b565b346107f2576107ce36600461028d565b6107ee6107d96112f7565b916107e59593956101d2565b95869586610771565b0390f35b6101d8565b90565b5f1b90565b61081361080e610818926107f7565b6107fa565b6103ab565b90565b6108245f6107ff565b90565b61082f61081b565b90565b346108625761084236600461028d565b61085e61084d610827565b6108556101d2565b918291826103fc565b0390f35b6101d8565b61087b61087661088092610310565b61059f565b610310565b90565b9061088d90610867565b5f5260205260405f2090565b6108af906108aa6001915f92610883565b6106b4565b90565b346108e2576108de6108cd6108c8366004610336565b610899565b6108d56101d2565b91829182610361565b0390f35b6101d8565b90565b6108fe6108f9610903926108e7565b61059f565b610310565b90565b61091a6a52b7d2dcc80cd2e40000006108ea565b90565b610925610906565b90565b346109585761093836600461028d565b61095461094361091d565b61094b6101d2565b91829182610361565b0390f35b6101d8565b3461098b57610975610970366004610336565b6114f4565b61097d6101d2565b80610987816104ad565b0390f35b6101d8565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156109d65781359167ffffffffffffffff83116109d15760200192602083028401116109cc57565b610998565b610994565b610990565b919091604081840312610a1c576109f4835f8301610327565b92602082013567ffffffffffffffff8111610a1757610a13920161099c565b9091565b6101e0565b6101dc565b34610a5057610a3a610a343660046109db565b91611713565b610a426101d2565b80610a4c816104ad565b0390f35b6101d8565b34610a8457610a6e610a68366004610480565b9061174a565b610a766101d2565b80610a80816104ad565b0390f35b6101d8565b7f397a4cbece64093f6309c34380bd980191b5f32c77f583bacd4d51044e68a10390565b610ab5610a89565b90565b34610ae857610ac836600461028d565b610ae4610ad3610aad565b610adb6101d2565b918291826103fc565b0390f35b6101d8565b7f076eb8b875b6ea839b087c4c0c1a4661b089d3b6ee2c1ef1b9cfa7fe1066d20690565b610b19610aed565b90565b34610b4c57610b2c36600461028d565b610b48610b37610b11565b610b3f6101d2565b918291826103fc565b0390f35b6101d8565b610b5d60035f906106b4565b90565b34610b9057610b7036600461028d565b610b8c610b7b610b51565b610b836101d2565b91829182610361565b0390f35b6101d8565b34610bc557610bc1610bb0610bab366004610336565b611756565b610bb86101d2565b91829182610361565b0390f35b6101d8565b90602082820312610be357610be0915f01610471565b90565b6101dc565b34610c1857610c14610c03610bfe366004610bca565b611b89565b610c0b6101d2565b91829182610361565b0390f35b6101d8565b34610c4d57610c2d36600461028d565b610c49610c38611bca565b610c406101d2565b91829182610361565b0390f35b6101d8565b90565b610c69610c64610c6e92610c52565b61059f565b610310565b90565b610c82670de0b6b3a7640000610c55565b90565b610c8d610c71565b90565b34610cc057610ca036600461028d565b610cbc610cab610c85565b610cb36101d2565b91829182610361565b0390f35b6101d8565b34610cf557610cd536600461028d565b610cf1610ce0611d91565b610ce86101d2565b91829182610243565b0390f35b6101d8565b5f80fd5b5f90565b610d0a610cfe565b5080610d25610d1f637965db0b60e01b6101e4565b916101e4565b14908115610d32575b5090565b610d3c9150611dc2565b5f610d2e565b5f90565b6001610d529101610310565b90565b5f1c90565b610d66610d6b91610d55565b610699565b90565b610d789054610d5a565b90565b634e487b7160e01b5f52601160045260245ffd5b610d9e610da491939293610310565b92610310565b91610db0838202610310565b928184041490151715610dbf57565b610d7b565b634e487b7160e01b5f52601260045260245ffd5b610de4610dea91610310565b91610310565b908115610df5570490565b610dc4565b610e02610d42565b5080610e1d610e17610e1261064c565b610310565b91610310565b1015610e8f57610e2b610c71565b5b81610e46610e40610e3b61064c565b610310565b91610310565b1015610e8a57610e7e610e70610e8492610e6a610e6560018790610883565b610d6e565b90610d8f565b610e78610c71565b90610dd8565b91610d46565b90610e2c565b905090565b50610e98610c71565b90565b5f90565b610ea8906103ab565b90565b90610eb590610e9f565b5f5260205260405f2090565b90565b610ed0610ed591610d55565b610ec1565b90565b610ee29054610ec4565b90565b6001610efd610f0392610ef6610e9b565b505f610eab565b01610ed8565b90565b90610f2191610f1c610f1782610ee5565b611de8565b610f23565b565b90610f2d91611dfc565b50565b90610f3a91610f06565b565b9080610f57610f51610f4c611eab565b610451565b91610451565b03610f6857610f6591611eb8565b50565b5f63334bd91960e11b815280610f80600482016104ad565b0390fd5b90610f9e91610f99610f94610a89565b611de8565b611001565b565b610fb4610faf610fb9926107f7565b61059f565b610310565b90565b90610fc85f19916107fa565b9181191691161790565b90565b90610fea610fe5610ff192610867565b610fd2565b8254610fbc565b9055565b610ffe906105be565b90565b8061101b61101561101061064c565b610310565b91610310565b101561111f578061103d6110376110326002610d6e565b610310565b91610310565b10611103578161105561104f5f610fa0565b91610310565b1480156110e1575b6110c5576110768261107160018490610883565b610fd5565b33906110c06110ae6110a87f4b9b5002d7834864c4d8ae87f7bf0ec4b1752abf7e0703b5b32ff11e337989bc93610867565b93610ff5565b936110b76101d2565b91829182610361565b0390a3565b5f635ae6162f60e01b8152806110dd600482016104ad565b0390fd5b50816110fc6110f66110f1610c71565b610310565b91610310565b101561105d565b5f6365cb6dcb60e01b81528061111b600482016104ad565b0390fd5b5f63d5b25b6360e01b815280611137600482016104ad565b0390fd5b9061114591610f84565b565b61115361115891610d55565b6102a0565b90565b6111659054611147565b90565b90565b61117f61117a61118492611168565b61059f565b610310565b90565b61119661119c91939293610310565b92610310565b82039182116111a757565b610d7b565b6111b4610d42565b506111c86111c2600461115b565b15610231565b801561128d575b611281576111db611bca565b6111e56002610d6e565b61121161120b6112066111f661064c565b611200600161116b565b90611187565b610310565b91610310565b1461127e5761127b9061127561126761123d61123860016112326002610d6e565b90610883565b610d6e565b61126161125261124d6002610d6e565b610dfa565b949161125c610c71565b611187565b90610d8f565b91611270610c71565b611187565b90610dd8565b90565b90565b61128a5f610fa0565b90565b506112986002610d6e565b6112b16112ab6112a661064c565b610310565b91610310565b10156111cf565b906112c290610ff5565b5f5260205260405f2090565b6112f4915f6112e96112ef936112e2610cfe565b5082610eab565b016112b8565b61115b565b90565b6112ff610d42565b50611308610d42565b50611311610d42565b5061131a610d42565b50611323610cfe565b5061132e6002610d6e565b61133661064c565b916113416003610d6e565b9161134a611bca565b916113556002610d6e565b61136e61136861136361064c565b610310565b91610310565b1015919493929190565b6113919061138c61138761081b565b611de8565b6113d8565b565b9061139f60ff916107fa565b9181191691161790565b6113b290610231565b90565b90565b906113cd6113c86113d4926113a9565b6113b5565b8254611393565b9055565b6113e2600461115b565b6114d857806113f96113f35f610fa0565b91610310565b1480156114b6575b61149a57611411600160046113b8565b61141a5f610fa0565b5b8061143561142f61142a61064c565b610310565b91610310565b101561145e57611459906114548361144f60018490610883565b610fd5565b610d46565b61141b565b506114957fc12c60abc216286ef25e34b1805a0c3dda73e4c2fd6cf360e807a7a9e73167399161148c6101d2565b91829182610361565b0390a1565b5f635ae6162f60e01b8152806114b2600482016104ad565b0390fd5b50806114d16114cb6114c6610c71565b610310565b91610310565b1015611401565b5f639e91c9e760e01b8152806114f0600482016104ad565b0390fd5b6114fd90611378565b565b9061151a9291611515611510610a89565b611de8565b61157b565b565b5090565b61152f61153591939293610310565b92610310565b820180921161154057565b610d7b565b634e487b7160e01b5f52603260045260245ffd5b9190811015611569576020020190565b611545565b3561157881610313565b90565b916115855f610fa0565b5b806115a361159d61159886869061151c565b610310565b91610310565b101561170a576115b4848290611520565b90816115cf6115c96115c461064c565b610310565b91610310565b101561170257816116bc926115f56115ef6115ea6002610d6e565b610310565b91610310565b106116fc5761160e61160986868591611559565b61156e565b61162061161a5f610fa0565b91610310565b1480156116c7575b6116c15761165461164361163e87878691611559565b61156e565b61164f60018490610883565b610fd5565b61166861166386868591611559565b61156e565b9033906116b36116a161169b7f4b9b5002d7834864c4d8ae87f7bf0ec4b1752abf7e0703b5b32ff11e337989bc93610867565b93610ff5565b936116aa6101d2565b91829182610361565b0390a35b610d46565b611586565b506116b7565b506116dc6116d786868591611559565b61156e565b6116f56116ef6116ea610c71565b610310565b91610310565b1015611628565b506116b7565b50505050505b565b50505050611708565b9061171e92916114ff565b565b9061173b9161173661173182610ee5565b611de8565b61173d565b565b9061174791611eb8565b50565b9061175491611720565b565b61175e610d42565b508061177961177361176e61064c565b610310565b91610310565b10156117955761178d611792916001610883565b610d6e565b90565b5f63d5b25b6360e01b8152806117ad600482016104ad565b0390fd5b906117cb916117c66117c1610aed565b611de8565b6118d5565b90565b6117e26117dd6117e7926107f7565b61059f565b610446565b90565b6117f3906117ce565b90565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b90611822906117fa565b810190811067ffffffffffffffff82111761183c57604052565b611804565b60e01b90565b5f91031261185157565b6101dc565b61185f90610451565b9052565b91602061188492949361187d60408201965f830190611856565b0190610354565b565b61188e6101d2565b3d5f823e3d90fd5b9160206118b79294936118b060408201965f830190610354565b0190610354565b565b6118c290610310565b5f1981146118d05760010190565b610d7b565b506118e96118e3600461115b565b15610231565b611b6d576118f76002610d6e565b61191061190a61190561064c565b610310565b91610310565b1015611b51578061193161192b6119265f6117ea565b610451565b91610451565b14611b355761193e611bca565b611946610d42565b506119516002610d6e565b61197d61197761197261196261064c565b61196c600161116b565b90611187565b610310565b91610310565b145f14611aca5780915b6119a461199d846119986003610d6e565b611520565b6003610fd5565b6119cd7f00000000000000000000000000000000000000000000000000000000000000006105ca565b6340c10f19828592803b15611ac5576119f95f8094611a046119ed6101d2565b97889687958694611841565b845260048401611863565b03925af18015611ac057611a94575b50611a1e6002610d6e565b611a2a84938590611187565b611a5d611a577f160fc195d6e53691d30d804ce190dc09471891677e43433b91a7a6131c12a59a93610867565b93610ff5565b93611a72611a696101d2565b92839283611896565b0390a3611a91611a8a611a856002610d6e565b6118b9565b6002610fd5565b90565b611ab3905f3d8111611ab9575b611aab8183611818565b810190611847565b5f611a13565b503d611aa1565b611886565b6117f6565b611b2f611aea611ae56001611adf6002610d6e565b90610883565b610d6e565b611b29611b1b611b02611afd6002610d6e565b610dfa565b92611b158691611b10610c71565b611187565b90610d8f565b91611b24610c71565b611187565b90610dd8565b91611987565b5f63d92e233d60e01b815280611b4d600482016104ad565b0390fd5b5f639e91c9e760e01b815280611b69600482016104ad565b0390fd5b5f639e91c9e760e01b815280611b85600482016104ad565b0390fd5b611b9a90611b95610d42565b6117b1565b90565b90505190611baa82610313565b565b90602082820312611bc557611bc2915f01611b9d565b90565b6101dc565b611bd2610d42565b50611c176020611c017f00000000000000000000000000000000000000000000000000000000000000006105ca565b6318160ddd90611c0f6101d2565b938492611841565b82528180611c27600482016104ad565b03915afa908115611d8c575f91611d5e575b50611c7e6020611c687f00000000000000000000000000000000000000000000000000000000000000006105ca565b63902d55a590611c766101d2565b938492611841565b82528180611c8e600482016104ad565b03915afa8015611d5957611cb2915f91611d2b575b50611cac610906565b90611187565b81611cc5611cbf83610310565b91610310565b115f14611d1b57611cd591611187565b5b611cde610906565b611cf0611cea83610310565b91610310565b115f14611d0c57611d0890611d03610906565b611187565b5b90565b50611d165f610fa0565b611d09565b5050611d265f610fa0565b611cd6565b611d4c915060203d8111611d52575b611d448183611818565b810190611bac565b5f611ca3565b503d611d3a565b611886565b611d7f915060203d8111611d85575b611d778183611818565b810190611bac565b5f611c39565b503d611d6d565b611886565b611d99610cfe565b50611da46002610d6e565b611dbd611db7611db261064c565b610310565b91610310565b101590565b611dca610cfe565b50611de4611dde6301ffc9a760e01b6101e4565b916101e4565b1490565b611dfa90611df4611eab565b90611f7c565b565b611e04610cfe565b50611e19611e138284906112ce565b15610231565b5f14611ea157611e406001611e3b5f611e33818690610eab565b0185906112b8565b6113b8565b90611e49611eab565b90611e86611e80611e7a7f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d95610e9f565b92610ff5565b92610ff5565b92611e8f6101d2565b80611e99816104ad565b0390a4600190565b50505f90565b5f90565b611eb3611ea7565b503390565b611ec0610cfe565b50611ecc8183906112ce565b5f14611f5357611ef25f611eed5f611ee5818690610eab565b0185906112b8565b6113b8565b90611efb611eab565b90611f38611f32611f2c7ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b95610e9f565b92610ff5565b92610ff5565b92611f416101d2565b80611f4b816104ad565b0390a4600190565b50505f90565b916020611f7a929493611f7360408201965f830190611856565b01906103ef565b565b90611f91611f8b8383906112ce565b15610231565b611f99575050565b611fb35f92839263e2517d3f60e01b845260048401611f59565b0390fd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R4a\0NWa\0\x1Aa\0\x14a\x01/V[\x91a\x021V[a\0\"a\0SV[a\x1F\xB7a\x04\xD9\x829`\x80Q\x81\x81\x81a\x05}\x01R\x81\x81a\x19\xA9\x01R\x81\x81a\x1B\xDD\x01Ra\x1CD\x01Ra\x1F\xB7\x90\xF3[a\0YV[`@Q\x90V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\0\x85\x90a\0]V[\x81\x01\x90\x81\x10`\x01\x80`@\x1B\x03\x82\x11\x17a\0\x9DW`@RV[a\0gV[\x90a\0\xB5a\0\xAEa\0SV[\x92\x83a\0{V[V[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\0\xCF\x90a\0\xBBV[\x90V[a\0\xDB\x81a\0\xC6V[\x03a\0\xE2WV[_\x80\xFD[\x90PQ\x90a\0\xF3\x82a\0\xD2V[V[\x90\x91``\x82\x84\x03\x12a\x01*Wa\x01'a\x01\x10\x84_\x85\x01a\0\xE6V[\x93a\x01\x1E\x81` \x86\x01a\0\xE6V[\x93`@\x01a\0\xE6V[\x90V[a\0\xB7V[a\x01Ma$\x90\x808\x03\x80a\x01B\x81a\0\xA2V[\x92\x839\x81\x01\x90a\0\xF5V[\x90\x91\x92V[\x90V[\x90V[a\x01la\x01ga\x01q\x92a\x01RV[a\x01UV[a\0\xBBV[\x90V[a\x01}\x90a\x01XV[\x90V[_\x01\x90V[a\x01\x99a\x01\x94a\x01\x9E\x92a\0\xBBV[a\x01UV[a\0\xBBV[\x90V[a\x01\xAA\x90a\x01\x85V[\x90V[a\x01\xB6\x90a\x01\xA1V[\x90V[\x90V[_\x1B\x90V[a\x01\xD5a\x01\xD0a\x01\xDA\x92a\x01RV[a\x01\xBCV[a\x01\xB9V[\x90V[a\x01\xE6_a\x01\xC1V[\x90V[\x7F9zL\xBE\xCEd\t?c\t\xC3C\x80\xBD\x98\x01\x91\xB5\xF3,w\xF5\x83\xBA\xCDMQ\x04Nh\xA1\x03\x90V[\x7F\x07n\xB8\xB8u\xB6\xEA\x83\x9B\x08|L\x0C\x1AFa\xB0\x89\xD3\xB6\xEE,\x1E\xF1\xB9\xCF\xA7\xFE\x10f\xD2\x06\x90V[\x80a\x02La\x02Fa\x02A_a\x01tV[a\0\xC6V[\x91a\0\xC6V[\x14a\x03\rW\x81a\x02la\x02fa\x02a_a\x01tV[a\0\xC6V[\x91a\0\xC6V[\x14a\x02\xF1W\x82a\x02\x8Ca\x02\x86a\x02\x81_a\x01tV[a\0\xC6V[\x91a\0\xC6V[\x14a\x02\xD5Wa\x02\xD2\x92a\x02\xA1a\x02\xC4\x92a\x01\xADV[`\x80Ra\x02\xB6a\x02\xAFa\x01\xDDV[\x84\x90a\x03\xC7V[Pa\x02\xBFa\x01\xE9V[a\x03\xC7V[Pa\x02\xCDa\x02\rV[a\x03\xC7V[PV[_c\xD9.#=`\xE0\x1B\x81R\x80a\x02\xED`\x04\x82\x01a\x01\x80V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x03\t`\x04\x82\x01a\x01\x80V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x03%`\x04\x82\x01a\x01\x80V[\x03\x90\xFD[_\x90V[\x15\x15\x90V[a\x03;\x90a\x01\xB9V[\x90V[\x90a\x03H\x90a\x032V[_R` R`@_ \x90V[a\x03]\x90a\x01\x85V[\x90V[a\x03i\x90a\x03TV[\x90V[\x90a\x03v\x90a\x03`V[_R` R`@_ \x90V[\x90a\x03\x8E`\xFF\x91a\x01\xBCV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x03\xA1\x90a\x03-V[\x90V[\x90V[\x90a\x03\xBCa\x03\xB7a\x03\xC3\x92a\x03\x98V[a\x03\xA4V[\x82Ta\x03\x82V[\x90UV[a\x03\xCFa\x03)V[Pa\x03\xE4a\x03\xDE\x82\x84\x90a\x04\x9EV[\x15a\x03-V[_\x14a\x04lWa\x04\x0B`\x01a\x04\x06_a\x03\xFE\x81\x86\x90a\x03>V[\x01\x85\x90a\x03lV[a\x03\xA7V[\x90a\x04\x14a\x04\xCBV[\x90a\x04Qa\x04Ka\x04E\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\x032V[\x92a\x03`V[\x92a\x03`V[\x92a\x04Za\0SV[\x80a\x04d\x81a\x01\x80V[\x03\x90\xA4`\x01\x90V[PP_\x90V[_\x1C\x90V[`\xFF\x16\x90V[a\x04\x89a\x04\x8E\x91a\x04rV[a\x04wV[\x90V[a\x04\x9B\x90Ta\x04}V[\x90V[a\x04\xC4\x91_a\x04\xB9a\x04\xBF\x93a\x04\xB2a\x03)V[P\x82a\x03>V[\x01a\x03lV[a\x04\x91V[\x90V[_\x90V[a\x04\xD3a\x04\xC7V[P3\x90V\xFE`\x80`@R`\x046\x10\x15a\0\x13W[a\x0C\xFAV[a\0\x1D_5a\x01\xCCV[\x80c\x01\xFF\xC9\xA7\x14a\x01\xC7W\x80c\x15\x8E\xF9>\x14a\x01\xC2W\x80c#f@\xB9\x14a\x01\xBDW\x80c$\x8A\x9C\xA3\x14a\x01\xB8W\x80c//\xF1]\x14a\x01\xB3W\x80c6V\x8A\xBE\x14a\x01\xAEW\x80cX\x80\xF4\x9E\x14a\x01\xA9W\x80c[\xDFl\xA1\x14a\x01\xA4W\x80c_\x15\xC3\xC9\x14a\x01\x9FW\x80cvg\x18\x08\x14a\x01\x9AW\x80c\x80W/\x18\x14a\x01\x95W\x80c\x91\xD1HT\x14a\x01\x90W\x80c\xA0\x88x}\x14a\x01\x8BW\x80c\xA2\x17\xFD\xDF\x14a\x01\x86W\x80c\xAF\xCAt\x05\x14a\x01\x81W\x80c\xB1\x98\xD0(\x14a\x01|W\x80c\xC6:\tD\x14a\x01wW\x80c\xD2\xBC\xC9\xFF\x14a\x01rW\x80c\xD5Gt\x1F\x14a\x01mW\x80c\xDC\xA5\x04\xB6\x14a\x01hW\x80c\xDE\xBEO\x1F\x14a\x01cW\x80c\xDF\x02D\xB1\x14a\x01^W\x80c\xE0\xF5\x14t\x14a\x01YW\x80c\xE1\xF2~\xB8\x14a\x01TW\x80c\xE4\xB7\xFBs\x14a\x01OW\x80c\xEC\xEDU&\x14a\x01JWc\xFA9\x1Cd\x03a\0\x0EWa\x0C\xC5V[a\x0C\x90V[a\x0C\x1DV[a\x0B\xE8V[a\x0B\x95V[a\x0B`V[a\x0B\x1CV[a\n\xB8V[a\nUV[a\n!V[a\t]V[a\t(V[a\x08\xB2V[a\x082V[a\x07\xBEV[a\x07;V[a\x07\x06V[a\x06\xD1V[a\x06dV[a\x05\xF8V[a\x05GV[a\x04\xE6V[a\x04\xB2V[a\x04\x11V[a\x03vV[a\x02\xDBV[a\x02XV[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x01\xF9\x81a\x01\xE4V[\x03a\x02\0WV[_\x80\xFD[\x90P5\x90a\x02\x11\x82a\x01\xF0V[V[\x90` \x82\x82\x03\x12a\x02,Wa\x02)\x91_\x01a\x02\x04V[\x90V[a\x01\xDCV[\x15\x15\x90V[a\x02?\x90a\x021V[\x90RV[\x91\x90a\x02V\x90_` \x85\x01\x94\x01\x90a\x026V[V[4a\x02\x88Wa\x02\x84a\x02sa\x02n6`\x04a\x02\x13V[a\r\x02V[a\x02{a\x01\xD2V[\x91\x82\x91\x82a\x02CV[\x03\x90\xF3[a\x01\xD8V[_\x91\x03\x12a\x02\x97WV[a\x01\xDCV[\x1C\x90V[`\xFF\x16\x90V[a\x02\xB6\x90`\x08a\x02\xBB\x93\x02a\x02\x9CV[a\x02\xA0V[\x90V[\x90a\x02\xC9\x91Ta\x02\xA6V[\x90V[a\x02\xD8`\x04_\x90a\x02\xBEV[\x90V[4a\x03\x0BWa\x02\xEB6`\x04a\x02\x8DV[a\x03\x07a\x02\xF6a\x02\xCCV[a\x02\xFEa\x01\xD2V[\x91\x82\x91\x82a\x02CV[\x03\x90\xF3[a\x01\xD8V[\x90V[a\x03\x1C\x81a\x03\x10V[\x03a\x03#WV[_\x80\xFD[\x90P5\x90a\x034\x82a\x03\x13V[V[\x90` \x82\x82\x03\x12a\x03OWa\x03L\x91_\x01a\x03'V[\x90V[a\x01\xDCV[a\x03]\x90a\x03\x10V[\x90RV[\x91\x90a\x03t\x90_` \x85\x01\x94\x01\x90a\x03TV[V[4a\x03\xA6Wa\x03\xA2a\x03\x91a\x03\x8C6`\x04a\x036V[a\r\xFAV[a\x03\x99a\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[\x90V[a\x03\xB7\x81a\x03\xABV[\x03a\x03\xBEWV[_\x80\xFD[\x90P5\x90a\x03\xCF\x82a\x03\xAEV[V[\x90` \x82\x82\x03\x12a\x03\xEAWa\x03\xE7\x91_\x01a\x03\xC2V[\x90V[a\x01\xDCV[a\x03\xF8\x90a\x03\xABV[\x90RV[\x91\x90a\x04\x0F\x90_` \x85\x01\x94\x01\x90a\x03\xEFV[V[4a\x04AWa\x04=a\x04,a\x04'6`\x04a\x03\xD1V[a\x0E\xE5V[a\x044a\x01\xD2V[\x91\x82\x91\x82a\x03\xFCV[\x03\x90\xF3[a\x01\xD8V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x04Z\x90a\x04FV[\x90V[a\x04f\x81a\x04QV[\x03a\x04mWV[_\x80\xFD[\x90P5\x90a\x04~\x82a\x04]V[V[\x91\x90`@\x83\x82\x03\x12a\x04\xA8W\x80a\x04\x9Ca\x04\xA5\x92_\x86\x01a\x03\xC2V[\x93` \x01a\x04qV[\x90V[a\x01\xDCV[_\x01\x90V[4a\x04\xE1Wa\x04\xCBa\x04\xC56`\x04a\x04\x80V[\x90a\x0F0V[a\x04\xD3a\x01\xD2V[\x80a\x04\xDD\x81a\x04\xADV[\x03\x90\xF3[a\x01\xD8V[4a\x05\x15Wa\x04\xFFa\x04\xF96`\x04a\x04\x80V[\x90a\x0F<V[a\x05\x07a\x01\xD2V[\x80a\x05\x11\x81a\x04\xADV[\x03\x90\xF3[a\x01\xD8V[\x91\x90`@\x83\x82\x03\x12a\x05BW\x80a\x056a\x05?\x92_\x86\x01a\x03'V[\x93` \x01a\x03'V[\x90V[a\x01\xDCV[4a\x05vWa\x05`a\x05Z6`\x04a\x05\x1AV[\x90a\x11;V[a\x05ha\x01\xD2V[\x80a\x05r\x81a\x04\xADV[\x03\x90\xF3[a\x01\xD8V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[\x90V[a\x05\xB6a\x05\xB1a\x05\xBB\x92a\x04FV[a\x05\x9FV[a\x04FV[\x90V[a\x05\xC7\x90a\x05\xA2V[\x90V[a\x05\xD3\x90a\x05\xBEV[\x90V[a\x05\xDF\x90a\x05\xCAV[\x90RV[\x91\x90a\x05\xF6\x90_` \x85\x01\x94\x01\x90a\x05\xD6V[V[4a\x06(Wa\x06\x086`\x04a\x02\x8DV[a\x06$a\x06\x13a\x05{V[a\x06\x1Ba\x01\xD2V[\x91\x82\x91\x82a\x05\xE3V[\x03\x90\xF3[a\x01\xD8V[\x90V[a\x06Da\x06?a\x06I\x92a\x06-V[a\x05\x9FV[a\x03\x10V[\x90V[a\x06V`0a\x060V[\x90V[a\x06aa\x06LV[\x90V[4a\x06\x94Wa\x06t6`\x04a\x02\x8DV[a\x06\x90a\x06\x7Fa\x06YV[a\x06\x87a\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[\x90V[a\x06\xAC\x90`\x08a\x06\xB1\x93\x02a\x02\x9CV[a\x06\x99V[\x90V[\x90a\x06\xBF\x91Ta\x06\x9CV[\x90V[a\x06\xCE`\x02_\x90a\x06\xB4V[\x90V[4a\x07\x01Wa\x06\xE16`\x04a\x02\x8DV[a\x06\xFDa\x06\xECa\x06\xC2V[a\x06\xF4a\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[4a\x076Wa\x07\x166`\x04a\x02\x8DV[a\x072a\x07!a\x11\xACV[a\x07)a\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[4a\x07lWa\x07ha\x07Wa\x07Q6`\x04a\x04\x80V[\x90a\x12\xCEV[a\x07_a\x01\xD2V[\x91\x82\x91\x82a\x02CV[\x03\x90\xF3[a\x01\xD8V[\x90\x95\x94\x92a\x07\xBC\x94a\x07\xABa\x07\xB5\x92a\x07\xA1`\x80\x96a\x07\x97`\xA0\x88\x01\x9C_\x89\x01\x90a\x03TV[` \x87\x01\x90a\x03TV[`@\x85\x01\x90a\x03TV[``\x83\x01\x90a\x03TV[\x01\x90a\x026V[V[4a\x07\xF2Wa\x07\xCE6`\x04a\x02\x8DV[a\x07\xEEa\x07\xD9a\x12\xF7V[\x91a\x07\xE5\x95\x93\x95a\x01\xD2V[\x95\x86\x95\x86a\x07qV[\x03\x90\xF3[a\x01\xD8V[\x90V[_\x1B\x90V[a\x08\x13a\x08\x0Ea\x08\x18\x92a\x07\xF7V[a\x07\xFAV[a\x03\xABV[\x90V[a\x08$_a\x07\xFFV[\x90V[a\x08/a\x08\x1BV[\x90V[4a\x08bWa\x08B6`\x04a\x02\x8DV[a\x08^a\x08Ma\x08'V[a\x08Ua\x01\xD2V[\x91\x82\x91\x82a\x03\xFCV[\x03\x90\xF3[a\x01\xD8V[a\x08{a\x08va\x08\x80\x92a\x03\x10V[a\x05\x9FV[a\x03\x10V[\x90V[\x90a\x08\x8D\x90a\x08gV[_R` R`@_ \x90V[a\x08\xAF\x90a\x08\xAA`\x01\x91_\x92a\x08\x83V[a\x06\xB4V[\x90V[4a\x08\xE2Wa\x08\xDEa\x08\xCDa\x08\xC86`\x04a\x036V[a\x08\x99V[a\x08\xD5a\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[\x90V[a\x08\xFEa\x08\xF9a\t\x03\x92a\x08\xE7V[a\x05\x9FV[a\x03\x10V[\x90V[a\t\x1AjR\xB7\xD2\xDC\xC8\x0C\xD2\xE4\0\0\0a\x08\xEAV[\x90V[a\t%a\t\x06V[\x90V[4a\tXWa\t86`\x04a\x02\x8DV[a\tTa\tCa\t\x1DV[a\tKa\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[4a\t\x8BWa\tua\tp6`\x04a\x036V[a\x14\xF4V[a\t}a\x01\xD2V[\x80a\t\x87\x81a\x04\xADV[\x03\x90\xF3[a\x01\xD8V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\t\xD6W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\t\xD1W` \x01\x92` \x83\x02\x84\x01\x11a\t\xCCWV[a\t\x98V[a\t\x94V[a\t\x90V[\x91\x90\x91`@\x81\x84\x03\x12a\n\x1CWa\t\xF4\x83_\x83\x01a\x03'V[\x92` \x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\n\x17Wa\n\x13\x92\x01a\t\x9CV[\x90\x91V[a\x01\xE0V[a\x01\xDCV[4a\nPWa\n:a\n46`\x04a\t\xDBV[\x91a\x17\x13V[a\nBa\x01\xD2V[\x80a\nL\x81a\x04\xADV[\x03\x90\xF3[a\x01\xD8V[4a\n\x84Wa\nna\nh6`\x04a\x04\x80V[\x90a\x17JV[a\nva\x01\xD2V[\x80a\n\x80\x81a\x04\xADV[\x03\x90\xF3[a\x01\xD8V[\x7F9zL\xBE\xCEd\t?c\t\xC3C\x80\xBD\x98\x01\x91\xB5\xF3,w\xF5\x83\xBA\xCDMQ\x04Nh\xA1\x03\x90V[a\n\xB5a\n\x89V[\x90V[4a\n\xE8Wa\n\xC86`\x04a\x02\x8DV[a\n\xE4a\n\xD3a\n\xADV[a\n\xDBa\x01\xD2V[\x91\x82\x91\x82a\x03\xFCV[\x03\x90\xF3[a\x01\xD8V[\x7F\x07n\xB8\xB8u\xB6\xEA\x83\x9B\x08|L\x0C\x1AFa\xB0\x89\xD3\xB6\xEE,\x1E\xF1\xB9\xCF\xA7\xFE\x10f\xD2\x06\x90V[a\x0B\x19a\n\xEDV[\x90V[4a\x0BLWa\x0B,6`\x04a\x02\x8DV[a\x0BHa\x0B7a\x0B\x11V[a\x0B?a\x01\xD2V[\x91\x82\x91\x82a\x03\xFCV[\x03\x90\xF3[a\x01\xD8V[a\x0B]`\x03_\x90a\x06\xB4V[\x90V[4a\x0B\x90Wa\x0Bp6`\x04a\x02\x8DV[a\x0B\x8Ca\x0B{a\x0BQV[a\x0B\x83a\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[4a\x0B\xC5Wa\x0B\xC1a\x0B\xB0a\x0B\xAB6`\x04a\x036V[a\x17VV[a\x0B\xB8a\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[\x90` \x82\x82\x03\x12a\x0B\xE3Wa\x0B\xE0\x91_\x01a\x04qV[\x90V[a\x01\xDCV[4a\x0C\x18Wa\x0C\x14a\x0C\x03a\x0B\xFE6`\x04a\x0B\xCAV[a\x1B\x89V[a\x0C\x0Ba\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[4a\x0CMWa\x0C-6`\x04a\x02\x8DV[a\x0CIa\x0C8a\x1B\xCAV[a\x0C@a\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[\x90V[a\x0Cia\x0Cda\x0Cn\x92a\x0CRV[a\x05\x9FV[a\x03\x10V[\x90V[a\x0C\x82g\r\xE0\xB6\xB3\xA7d\0\0a\x0CUV[\x90V[a\x0C\x8Da\x0CqV[\x90V[4a\x0C\xC0Wa\x0C\xA06`\x04a\x02\x8DV[a\x0C\xBCa\x0C\xABa\x0C\x85V[a\x0C\xB3a\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[4a\x0C\xF5Wa\x0C\xD56`\x04a\x02\x8DV[a\x0C\xF1a\x0C\xE0a\x1D\x91V[a\x0C\xE8a\x01\xD2V[\x91\x82\x91\x82a\x02CV[\x03\x90\xF3[a\x01\xD8V[_\x80\xFD[_\x90V[a\r\na\x0C\xFEV[P\x80a\r%a\r\x1Fcye\xDB\x0B`\xE0\x1Ba\x01\xE4V[\x91a\x01\xE4V[\x14\x90\x81\x15a\r2W[P\x90V[a\r<\x91Pa\x1D\xC2V[_a\r.V[_\x90V[`\x01a\rR\x91\x01a\x03\x10V[\x90V[_\x1C\x90V[a\rfa\rk\x91a\rUV[a\x06\x99V[\x90V[a\rx\x90Ta\rZV[\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\r\x9Ea\r\xA4\x91\x93\x92\x93a\x03\x10V[\x92a\x03\x10V[\x91a\r\xB0\x83\x82\x02a\x03\x10V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a\r\xBFWV[a\r{V[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a\r\xE4a\r\xEA\x91a\x03\x10V[\x91a\x03\x10V[\x90\x81\x15a\r\xF5W\x04\x90V[a\r\xC4V[a\x0E\x02a\rBV[P\x80a\x0E\x1Da\x0E\x17a\x0E\x12a\x06LV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x0E\x8FWa\x0E+a\x0CqV[[\x81a\x0EFa\x0E@a\x0E;a\x06LV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x0E\x8AWa\x0E~a\x0Epa\x0E\x84\x92a\x0Eja\x0Ee`\x01\x87\x90a\x08\x83V[a\rnV[\x90a\r\x8FV[a\x0Exa\x0CqV[\x90a\r\xD8V[\x91a\rFV[\x90a\x0E,V[\x90P\x90V[Pa\x0E\x98a\x0CqV[\x90V[_\x90V[a\x0E\xA8\x90a\x03\xABV[\x90V[\x90a\x0E\xB5\x90a\x0E\x9FV[_R` R`@_ \x90V[\x90V[a\x0E\xD0a\x0E\xD5\x91a\rUV[a\x0E\xC1V[\x90V[a\x0E\xE2\x90Ta\x0E\xC4V[\x90V[`\x01a\x0E\xFDa\x0F\x03\x92a\x0E\xF6a\x0E\x9BV[P_a\x0E\xABV[\x01a\x0E\xD8V[\x90V[\x90a\x0F!\x91a\x0F\x1Ca\x0F\x17\x82a\x0E\xE5V[a\x1D\xE8V[a\x0F#V[V[\x90a\x0F-\x91a\x1D\xFCV[PV[\x90a\x0F:\x91a\x0F\x06V[V[\x90\x80a\x0FWa\x0FQa\x0FLa\x1E\xABV[a\x04QV[\x91a\x04QV[\x03a\x0FhWa\x0Fe\x91a\x1E\xB8V[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a\x0F\x80`\x04\x82\x01a\x04\xADV[\x03\x90\xFD[\x90a\x0F\x9E\x91a\x0F\x99a\x0F\x94a\n\x89V[a\x1D\xE8V[a\x10\x01V[V[a\x0F\xB4a\x0F\xAFa\x0F\xB9\x92a\x07\xF7V[a\x05\x9FV[a\x03\x10V[\x90V[\x90a\x0F\xC8_\x19\x91a\x07\xFAV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x90a\x0F\xEAa\x0F\xE5a\x0F\xF1\x92a\x08gV[a\x0F\xD2V[\x82Ta\x0F\xBCV[\x90UV[a\x0F\xFE\x90a\x05\xBEV[\x90V[\x80a\x10\x1Ba\x10\x15a\x10\x10a\x06LV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x11\x1FW\x80a\x10=a\x107a\x102`\x02a\rnV[a\x03\x10V[\x91a\x03\x10V[\x10a\x11\x03W\x81a\x10Ua\x10O_a\x0F\xA0V[\x91a\x03\x10V[\x14\x80\x15a\x10\xE1W[a\x10\xC5Wa\x10v\x82a\x10q`\x01\x84\x90a\x08\x83V[a\x0F\xD5V[3\x90a\x10\xC0a\x10\xAEa\x10\xA8\x7FK\x9BP\x02\xD7\x83Hd\xC4\xD8\xAE\x87\xF7\xBF\x0E\xC4\xB1u*\xBF~\x07\x03\xB5\xB3/\xF1\x1E3y\x89\xBC\x93a\x08gV[\x93a\x0F\xF5V[\x93a\x10\xB7a\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xA3V[_cZ\xE6\x16/`\xE0\x1B\x81R\x80a\x10\xDD`\x04\x82\x01a\x04\xADV[\x03\x90\xFD[P\x81a\x10\xFCa\x10\xF6a\x10\xF1a\x0CqV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x10]V[_ce\xCBm\xCB`\xE0\x1B\x81R\x80a\x11\x1B`\x04\x82\x01a\x04\xADV[\x03\x90\xFD[_c\xD5\xB2[c`\xE0\x1B\x81R\x80a\x117`\x04\x82\x01a\x04\xADV[\x03\x90\xFD[\x90a\x11E\x91a\x0F\x84V[V[a\x11Sa\x11X\x91a\rUV[a\x02\xA0V[\x90V[a\x11e\x90Ta\x11GV[\x90V[\x90V[a\x11\x7Fa\x11za\x11\x84\x92a\x11hV[a\x05\x9FV[a\x03\x10V[\x90V[a\x11\x96a\x11\x9C\x91\x93\x92\x93a\x03\x10V[\x92a\x03\x10V[\x82\x03\x91\x82\x11a\x11\xA7WV[a\r{V[a\x11\xB4a\rBV[Pa\x11\xC8a\x11\xC2`\x04a\x11[V[\x15a\x021V[\x80\x15a\x12\x8DW[a\x12\x81Wa\x11\xDBa\x1B\xCAV[a\x11\xE5`\x02a\rnV[a\x12\x11a\x12\x0Ba\x12\x06a\x11\xF6a\x06LV[a\x12\0`\x01a\x11kV[\x90a\x11\x87V[a\x03\x10V[\x91a\x03\x10V[\x14a\x12~Wa\x12{\x90a\x12ua\x12ga\x12=a\x128`\x01a\x122`\x02a\rnV[\x90a\x08\x83V[a\rnV[a\x12aa\x12Ra\x12M`\x02a\rnV[a\r\xFAV[\x94\x91a\x12\\a\x0CqV[a\x11\x87V[\x90a\r\x8FV[\x91a\x12pa\x0CqV[a\x11\x87V[\x90a\r\xD8V[\x90V[\x90V[a\x12\x8A_a\x0F\xA0V[\x90V[Pa\x12\x98`\x02a\rnV[a\x12\xB1a\x12\xABa\x12\xA6a\x06LV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x11\xCFV[\x90a\x12\xC2\x90a\x0F\xF5V[_R` R`@_ \x90V[a\x12\xF4\x91_a\x12\xE9a\x12\xEF\x93a\x12\xE2a\x0C\xFEV[P\x82a\x0E\xABV[\x01a\x12\xB8V[a\x11[V[\x90V[a\x12\xFFa\rBV[Pa\x13\x08a\rBV[Pa\x13\x11a\rBV[Pa\x13\x1Aa\rBV[Pa\x13#a\x0C\xFEV[Pa\x13.`\x02a\rnV[a\x136a\x06LV[\x91a\x13A`\x03a\rnV[\x91a\x13Ja\x1B\xCAV[\x91a\x13U`\x02a\rnV[a\x13na\x13ha\x13ca\x06LV[a\x03\x10V[\x91a\x03\x10V[\x10\x15\x91\x94\x93\x92\x91\x90V[a\x13\x91\x90a\x13\x8Ca\x13\x87a\x08\x1BV[a\x1D\xE8V[a\x13\xD8V[V[\x90a\x13\x9F`\xFF\x91a\x07\xFAV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x13\xB2\x90a\x021V[\x90V[\x90V[\x90a\x13\xCDa\x13\xC8a\x13\xD4\x92a\x13\xA9V[a\x13\xB5V[\x82Ta\x13\x93V[\x90UV[a\x13\xE2`\x04a\x11[V[a\x14\xD8W\x80a\x13\xF9a\x13\xF3_a\x0F\xA0V[\x91a\x03\x10V[\x14\x80\x15a\x14\xB6W[a\x14\x9AWa\x14\x11`\x01`\x04a\x13\xB8V[a\x14\x1A_a\x0F\xA0V[[\x80a\x145a\x14/a\x14*a\x06LV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x14^Wa\x14Y\x90a\x14T\x83a\x14O`\x01\x84\x90a\x08\x83V[a\x0F\xD5V[a\rFV[a\x14\x1BV[Pa\x14\x95\x7F\xC1,`\xAB\xC2\x16(n\xF2^4\xB1\x80Z\x0C=\xDAs\xE4\xC2\xFDl\xF3`\xE8\x07\xA7\xA9\xE71g9\x91a\x14\x8Ca\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xA1V[_cZ\xE6\x16/`\xE0\x1B\x81R\x80a\x14\xB2`\x04\x82\x01a\x04\xADV[\x03\x90\xFD[P\x80a\x14\xD1a\x14\xCBa\x14\xC6a\x0CqV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x14\x01V[_c\x9E\x91\xC9\xE7`\xE0\x1B\x81R\x80a\x14\xF0`\x04\x82\x01a\x04\xADV[\x03\x90\xFD[a\x14\xFD\x90a\x13xV[V[\x90a\x15\x1A\x92\x91a\x15\x15a\x15\x10a\n\x89V[a\x1D\xE8V[a\x15{V[V[P\x90V[a\x15/a\x155\x91\x93\x92\x93a\x03\x10V[\x92a\x03\x10V[\x82\x01\x80\x92\x11a\x15@WV[a\r{V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[\x91\x90\x81\x10\x15a\x15iW` \x02\x01\x90V[a\x15EV[5a\x15x\x81a\x03\x13V[\x90V[\x91a\x15\x85_a\x0F\xA0V[[\x80a\x15\xA3a\x15\x9Da\x15\x98\x86\x86\x90a\x15\x1CV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x17\nWa\x15\xB4\x84\x82\x90a\x15 V[\x90\x81a\x15\xCFa\x15\xC9a\x15\xC4a\x06LV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x17\x02W\x81a\x16\xBC\x92a\x15\xF5a\x15\xEFa\x15\xEA`\x02a\rnV[a\x03\x10V[\x91a\x03\x10V[\x10a\x16\xFCWa\x16\x0Ea\x16\t\x86\x86\x85\x91a\x15YV[a\x15nV[a\x16 a\x16\x1A_a\x0F\xA0V[\x91a\x03\x10V[\x14\x80\x15a\x16\xC7W[a\x16\xC1Wa\x16Ta\x16Ca\x16>\x87\x87\x86\x91a\x15YV[a\x15nV[a\x16O`\x01\x84\x90a\x08\x83V[a\x0F\xD5V[a\x16ha\x16c\x86\x86\x85\x91a\x15YV[a\x15nV[\x903\x90a\x16\xB3a\x16\xA1a\x16\x9B\x7FK\x9BP\x02\xD7\x83Hd\xC4\xD8\xAE\x87\xF7\xBF\x0E\xC4\xB1u*\xBF~\x07\x03\xB5\xB3/\xF1\x1E3y\x89\xBC\x93a\x08gV[\x93a\x0F\xF5V[\x93a\x16\xAAa\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xA3[a\rFV[a\x15\x86V[Pa\x16\xB7V[Pa\x16\xDCa\x16\xD7\x86\x86\x85\x91a\x15YV[a\x15nV[a\x16\xF5a\x16\xEFa\x16\xEAa\x0CqV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x16(V[Pa\x16\xB7V[PPPPP[V[PPPPa\x17\x08V[\x90a\x17\x1E\x92\x91a\x14\xFFV[V[\x90a\x17;\x91a\x176a\x171\x82a\x0E\xE5V[a\x1D\xE8V[a\x17=V[V[\x90a\x17G\x91a\x1E\xB8V[PV[\x90a\x17T\x91a\x17 V[V[a\x17^a\rBV[P\x80a\x17ya\x17sa\x17na\x06LV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x17\x95Wa\x17\x8Da\x17\x92\x91`\x01a\x08\x83V[a\rnV[\x90V[_c\xD5\xB2[c`\xE0\x1B\x81R\x80a\x17\xAD`\x04\x82\x01a\x04\xADV[\x03\x90\xFD[\x90a\x17\xCB\x91a\x17\xC6a\x17\xC1a\n\xEDV[a\x1D\xE8V[a\x18\xD5V[\x90V[a\x17\xE2a\x17\xDDa\x17\xE7\x92a\x07\xF7V[a\x05\x9FV[a\x04FV[\x90V[a\x17\xF3\x90a\x17\xCEV[\x90V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x18\"\x90a\x17\xFAV[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x18<W`@RV[a\x18\x04V[`\xE0\x1B\x90V[_\x91\x03\x12a\x18QWV[a\x01\xDCV[a\x18_\x90a\x04QV[\x90RV[\x91` a\x18\x84\x92\x94\x93a\x18}`@\x82\x01\x96_\x83\x01\x90a\x18VV[\x01\x90a\x03TV[V[a\x18\x8Ea\x01\xD2V[=_\x82>=\x90\xFD[\x91` a\x18\xB7\x92\x94\x93a\x18\xB0`@\x82\x01\x96_\x83\x01\x90a\x03TV[\x01\x90a\x03TV[V[a\x18\xC2\x90a\x03\x10V[_\x19\x81\x14a\x18\xD0W`\x01\x01\x90V[a\r{V[Pa\x18\xE9a\x18\xE3`\x04a\x11[V[\x15a\x021V[a\x1BmWa\x18\xF7`\x02a\rnV[a\x19\x10a\x19\na\x19\x05a\x06LV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x1BQW\x80a\x191a\x19+a\x19&_a\x17\xEAV[a\x04QV[\x91a\x04QV[\x14a\x1B5Wa\x19>a\x1B\xCAV[a\x19Fa\rBV[Pa\x19Q`\x02a\rnV[a\x19}a\x19wa\x19ra\x19ba\x06LV[a\x19l`\x01a\x11kV[\x90a\x11\x87V[a\x03\x10V[\x91a\x03\x10V[\x14_\x14a\x1A\xCAW\x80\x91[a\x19\xA4a\x19\x9D\x84a\x19\x98`\x03a\rnV[a\x15 V[`\x03a\x0F\xD5V[a\x19\xCD\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x05\xCAV[c@\xC1\x0F\x19\x82\x85\x92\x80;\x15a\x1A\xC5Wa\x19\xF9_\x80\x94a\x1A\x04a\x19\xEDa\x01\xD2V[\x97\x88\x96\x87\x95\x86\x94a\x18AV[\x84R`\x04\x84\x01a\x18cV[\x03\x92Z\xF1\x80\x15a\x1A\xC0Wa\x1A\x94W[Pa\x1A\x1E`\x02a\rnV[a\x1A*\x84\x93\x85\x90a\x11\x87V[a\x1A]a\x1AW\x7F\x16\x0F\xC1\x95\xD6\xE56\x91\xD3\r\x80L\xE1\x90\xDC\tG\x18\x91g~CC;\x91\xA7\xA6\x13\x1C\x12\xA5\x9A\x93a\x08gV[\x93a\x0F\xF5V[\x93a\x1Ara\x1Aia\x01\xD2V[\x92\x83\x92\x83a\x18\x96V[\x03\x90\xA3a\x1A\x91a\x1A\x8Aa\x1A\x85`\x02a\rnV[a\x18\xB9V[`\x02a\x0F\xD5V[\x90V[a\x1A\xB3\x90_=\x81\x11a\x1A\xB9W[a\x1A\xAB\x81\x83a\x18\x18V[\x81\x01\x90a\x18GV[_a\x1A\x13V[P=a\x1A\xA1V[a\x18\x86V[a\x17\xF6V[a\x1B/a\x1A\xEAa\x1A\xE5`\x01a\x1A\xDF`\x02a\rnV[\x90a\x08\x83V[a\rnV[a\x1B)a\x1B\x1Ba\x1B\x02a\x1A\xFD`\x02a\rnV[a\r\xFAV[\x92a\x1B\x15\x86\x91a\x1B\x10a\x0CqV[a\x11\x87V[\x90a\r\x8FV[\x91a\x1B$a\x0CqV[a\x11\x87V[\x90a\r\xD8V[\x91a\x19\x87V[_c\xD9.#=`\xE0\x1B\x81R\x80a\x1BM`\x04\x82\x01a\x04\xADV[\x03\x90\xFD[_c\x9E\x91\xC9\xE7`\xE0\x1B\x81R\x80a\x1Bi`\x04\x82\x01a\x04\xADV[\x03\x90\xFD[_c\x9E\x91\xC9\xE7`\xE0\x1B\x81R\x80a\x1B\x85`\x04\x82\x01a\x04\xADV[\x03\x90\xFD[a\x1B\x9A\x90a\x1B\x95a\rBV[a\x17\xB1V[\x90V[\x90PQ\x90a\x1B\xAA\x82a\x03\x13V[V[\x90` \x82\x82\x03\x12a\x1B\xC5Wa\x1B\xC2\x91_\x01a\x1B\x9DV[\x90V[a\x01\xDCV[a\x1B\xD2a\rBV[Pa\x1C\x17` a\x1C\x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x05\xCAV[c\x18\x16\r\xDD\x90a\x1C\x0Fa\x01\xD2V[\x93\x84\x92a\x18AV[\x82R\x81\x80a\x1C'`\x04\x82\x01a\x04\xADV[\x03\x91Z\xFA\x90\x81\x15a\x1D\x8CW_\x91a\x1D^W[Pa\x1C~` a\x1Ch\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x05\xCAV[c\x90-U\xA5\x90a\x1Cva\x01\xD2V[\x93\x84\x92a\x18AV[\x82R\x81\x80a\x1C\x8E`\x04\x82\x01a\x04\xADV[\x03\x91Z\xFA\x80\x15a\x1DYWa\x1C\xB2\x91_\x91a\x1D+W[Pa\x1C\xACa\t\x06V[\x90a\x11\x87V[\x81a\x1C\xC5a\x1C\xBF\x83a\x03\x10V[\x91a\x03\x10V[\x11_\x14a\x1D\x1BWa\x1C\xD5\x91a\x11\x87V[[a\x1C\xDEa\t\x06V[a\x1C\xF0a\x1C\xEA\x83a\x03\x10V[\x91a\x03\x10V[\x11_\x14a\x1D\x0CWa\x1D\x08\x90a\x1D\x03a\t\x06V[a\x11\x87V[[\x90V[Pa\x1D\x16_a\x0F\xA0V[a\x1D\tV[PPa\x1D&_a\x0F\xA0V[a\x1C\xD6V[a\x1DL\x91P` =\x81\x11a\x1DRW[a\x1DD\x81\x83a\x18\x18V[\x81\x01\x90a\x1B\xACV[_a\x1C\xA3V[P=a\x1D:V[a\x18\x86V[a\x1D\x7F\x91P` =\x81\x11a\x1D\x85W[a\x1Dw\x81\x83a\x18\x18V[\x81\x01\x90a\x1B\xACV[_a\x1C9V[P=a\x1DmV[a\x18\x86V[a\x1D\x99a\x0C\xFEV[Pa\x1D\xA4`\x02a\rnV[a\x1D\xBDa\x1D\xB7a\x1D\xB2a\x06LV[a\x03\x10V[\x91a\x03\x10V[\x10\x15\x90V[a\x1D\xCAa\x0C\xFEV[Pa\x1D\xE4a\x1D\xDEc\x01\xFF\xC9\xA7`\xE0\x1Ba\x01\xE4V[\x91a\x01\xE4V[\x14\x90V[a\x1D\xFA\x90a\x1D\xF4a\x1E\xABV[\x90a\x1F|V[V[a\x1E\x04a\x0C\xFEV[Pa\x1E\x19a\x1E\x13\x82\x84\x90a\x12\xCEV[\x15a\x021V[_\x14a\x1E\xA1Wa\x1E@`\x01a\x1E;_a\x1E3\x81\x86\x90a\x0E\xABV[\x01\x85\x90a\x12\xB8V[a\x13\xB8V[\x90a\x1EIa\x1E\xABV[\x90a\x1E\x86a\x1E\x80a\x1Ez\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\x0E\x9FV[\x92a\x0F\xF5V[\x92a\x0F\xF5V[\x92a\x1E\x8Fa\x01\xD2V[\x80a\x1E\x99\x81a\x04\xADV[\x03\x90\xA4`\x01\x90V[PP_\x90V[_\x90V[a\x1E\xB3a\x1E\xA7V[P3\x90V[a\x1E\xC0a\x0C\xFEV[Pa\x1E\xCC\x81\x83\x90a\x12\xCEV[_\x14a\x1FSWa\x1E\xF2_a\x1E\xED_a\x1E\xE5\x81\x86\x90a\x0E\xABV[\x01\x85\x90a\x12\xB8V[a\x13\xB8V[\x90a\x1E\xFBa\x1E\xABV[\x90a\x1F8a\x1F2a\x1F,\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a\x0E\x9FV[\x92a\x0F\xF5V[\x92a\x0F\xF5V[\x92a\x1FAa\x01\xD2V[\x80a\x1FK\x81a\x04\xADV[\x03\x90\xA4`\x01\x90V[PP_\x90V[\x91` a\x1Fz\x92\x94\x93a\x1Fs`@\x82\x01\x96_\x83\x01\x90a\x18VV[\x01\x90a\x03\xEFV[V[\x90a\x1F\x91a\x1F\x8B\x83\x83\x90a\x12\xCEV[\x15a\x021V[a\x1F\x99WPPV[a\x1F\xB3_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01a\x1FYV[\x03\x90\xFD",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610013575b610cfa565b61001d5f356101cc565b806301ffc9a7146101c7578063158ef93e146101c2578063236640b9146101bd578063248a9ca3146101b85780632f2ff15d146101b357806336568abe146101ae5780635880f49e146101a95780635bdf6ca1146101a45780635f15c3c91461019f578063766718081461019a57806380572f181461019557806391d1485414610190578063a088787d1461018b578063a217fddf14610186578063afca740514610181578063b198d0281461017c578063c63a094414610177578063d2bcc9ff14610172578063d547741f1461016d578063dca504b614610168578063debe4f1f14610163578063df0244b11461015e578063e0f5147414610159578063e1f27eb814610154578063e4b7fb731461014f578063eced55261461014a5763fa391c640361000e57610cc5565b610c90565b610c1d565b610be8565b610b95565b610b60565b610b1c565b610ab8565b610a55565b610a21565b61095d565b610928565b6108b2565b610832565b6107be565b61073b565b610706565b6106d1565b610664565b6105f8565b610547565b6104e6565b6104b2565b610411565b610376565b6102db565b610258565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b6101f9816101e4565b0361020057565b5f80fd5b90503590610211826101f0565b565b9060208282031261022c57610229915f01610204565b90565b6101dc565b151590565b61023f90610231565b9052565b9190610256905f60208501940190610236565b565b346102885761028461027361026e366004610213565b610d02565b61027b6101d2565b91829182610243565b0390f35b6101d8565b5f91031261029757565b6101dc565b1c90565b60ff1690565b6102b69060086102bb930261029c565b6102a0565b90565b906102c991546102a6565b90565b6102d860045f906102be565b90565b3461030b576102eb36600461028d565b6103076102f66102cc565b6102fe6101d2565b91829182610243565b0390f35b6101d8565b90565b61031c81610310565b0361032357565b5f80fd5b9050359061033482610313565b565b9060208282031261034f5761034c915f01610327565b90565b6101dc565b61035d90610310565b9052565b9190610374905f60208501940190610354565b565b346103a6576103a261039161038c366004610336565b610dfa565b6103996101d2565b91829182610361565b0390f35b6101d8565b90565b6103b7816103ab565b036103be57565b5f80fd5b905035906103cf826103ae565b565b906020828203126103ea576103e7915f016103c2565b90565b6101dc565b6103f8906103ab565b9052565b919061040f905f602085019401906103ef565b565b346104415761043d61042c6104273660046103d1565b610ee5565b6104346101d2565b918291826103fc565b0390f35b6101d8565b60018060a01b031690565b61045a90610446565b90565b61046681610451565b0361046d57565b5f80fd5b9050359061047e8261045d565b565b91906040838203126104a8578061049c6104a5925f86016103c2565b93602001610471565b90565b6101dc565b5f0190565b346104e1576104cb6104c5366004610480565b90610f30565b6104d36101d2565b806104dd816104ad565b0390f35b6101d8565b34610515576104ff6104f9366004610480565b90610f3c565b6105076101d2565b80610511816104ad565b0390f35b6101d8565b9190604083820312610542578061053661053f925f8601610327565b93602001610327565b90565b6101dc565b346105765761056061055a36600461051a565b9061113b565b6105686101d2565b80610572816104ad565b0390f35b6101d8565b7f000000000000000000000000000000000000000000000000000000000000000090565b90565b6105b66105b16105bb92610446565b61059f565b610446565b90565b6105c7906105a2565b90565b6105d3906105be565b90565b6105df906105ca565b9052565b91906105f6905f602085019401906105d6565b565b346106285761060836600461028d565b61062461061361057b565b61061b6101d2565b918291826105e3565b0390f35b6101d8565b90565b61064461063f6106499261062d565b61059f565b610310565b90565b6106566030610630565b90565b61066161064c565b90565b346106945761067436600461028d565b61069061067f610659565b6106876101d2565b91829182610361565b0390f35b6101d8565b90565b6106ac9060086106b1930261029c565b610699565b90565b906106bf915461069c565b90565b6106ce60025f906106b4565b90565b34610701576106e136600461028d565b6106fd6106ec6106c2565b6106f46101d2565b91829182610361565b0390f35b6101d8565b346107365761071636600461028d565b6107326107216111ac565b6107296101d2565b91829182610361565b0390f35b6101d8565b3461076c57610768610757610751366004610480565b906112ce565b61075f6101d2565b91829182610243565b0390f35b6101d8565b909594926107bc946107ab6107b5926107a160809661079760a088019c5f890190610354565b6020870190610354565b6040850190610354565b6060830190610354565b0190610236565b565b346107f2576107ce36600461028d565b6107ee6107d96112f7565b916107e59593956101d2565b95869586610771565b0390f35b6101d8565b90565b5f1b90565b61081361080e610818926107f7565b6107fa565b6103ab565b90565b6108245f6107ff565b90565b61082f61081b565b90565b346108625761084236600461028d565b61085e61084d610827565b6108556101d2565b918291826103fc565b0390f35b6101d8565b61087b61087661088092610310565b61059f565b610310565b90565b9061088d90610867565b5f5260205260405f2090565b6108af906108aa6001915f92610883565b6106b4565b90565b346108e2576108de6108cd6108c8366004610336565b610899565b6108d56101d2565b91829182610361565b0390f35b6101d8565b90565b6108fe6108f9610903926108e7565b61059f565b610310565b90565b61091a6a52b7d2dcc80cd2e40000006108ea565b90565b610925610906565b90565b346109585761093836600461028d565b61095461094361091d565b61094b6101d2565b91829182610361565b0390f35b6101d8565b3461098b57610975610970366004610336565b6114f4565b61097d6101d2565b80610987816104ad565b0390f35b6101d8565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156109d65781359167ffffffffffffffff83116109d15760200192602083028401116109cc57565b610998565b610994565b610990565b919091604081840312610a1c576109f4835f8301610327565b92602082013567ffffffffffffffff8111610a1757610a13920161099c565b9091565b6101e0565b6101dc565b34610a5057610a3a610a343660046109db565b91611713565b610a426101d2565b80610a4c816104ad565b0390f35b6101d8565b34610a8457610a6e610a68366004610480565b9061174a565b610a766101d2565b80610a80816104ad565b0390f35b6101d8565b7f397a4cbece64093f6309c34380bd980191b5f32c77f583bacd4d51044e68a10390565b610ab5610a89565b90565b34610ae857610ac836600461028d565b610ae4610ad3610aad565b610adb6101d2565b918291826103fc565b0390f35b6101d8565b7f076eb8b875b6ea839b087c4c0c1a4661b089d3b6ee2c1ef1b9cfa7fe1066d20690565b610b19610aed565b90565b34610b4c57610b2c36600461028d565b610b48610b37610b11565b610b3f6101d2565b918291826103fc565b0390f35b6101d8565b610b5d60035f906106b4565b90565b34610b9057610b7036600461028d565b610b8c610b7b610b51565b610b836101d2565b91829182610361565b0390f35b6101d8565b34610bc557610bc1610bb0610bab366004610336565b611756565b610bb86101d2565b91829182610361565b0390f35b6101d8565b90602082820312610be357610be0915f01610471565b90565b6101dc565b34610c1857610c14610c03610bfe366004610bca565b611b89565b610c0b6101d2565b91829182610361565b0390f35b6101d8565b34610c4d57610c2d36600461028d565b610c49610c38611bca565b610c406101d2565b91829182610361565b0390f35b6101d8565b90565b610c69610c64610c6e92610c52565b61059f565b610310565b90565b610c82670de0b6b3a7640000610c55565b90565b610c8d610c71565b90565b34610cc057610ca036600461028d565b610cbc610cab610c85565b610cb36101d2565b91829182610361565b0390f35b6101d8565b34610cf557610cd536600461028d565b610cf1610ce0611d91565b610ce86101d2565b91829182610243565b0390f35b6101d8565b5f80fd5b5f90565b610d0a610cfe565b5080610d25610d1f637965db0b60e01b6101e4565b916101e4565b14908115610d32575b5090565b610d3c9150611dc2565b5f610d2e565b5f90565b6001610d529101610310565b90565b5f1c90565b610d66610d6b91610d55565b610699565b90565b610d789054610d5a565b90565b634e487b7160e01b5f52601160045260245ffd5b610d9e610da491939293610310565b92610310565b91610db0838202610310565b928184041490151715610dbf57565b610d7b565b634e487b7160e01b5f52601260045260245ffd5b610de4610dea91610310565b91610310565b908115610df5570490565b610dc4565b610e02610d42565b5080610e1d610e17610e1261064c565b610310565b91610310565b1015610e8f57610e2b610c71565b5b81610e46610e40610e3b61064c565b610310565b91610310565b1015610e8a57610e7e610e70610e8492610e6a610e6560018790610883565b610d6e565b90610d8f565b610e78610c71565b90610dd8565b91610d46565b90610e2c565b905090565b50610e98610c71565b90565b5f90565b610ea8906103ab565b90565b90610eb590610e9f565b5f5260205260405f2090565b90565b610ed0610ed591610d55565b610ec1565b90565b610ee29054610ec4565b90565b6001610efd610f0392610ef6610e9b565b505f610eab565b01610ed8565b90565b90610f2191610f1c610f1782610ee5565b611de8565b610f23565b565b90610f2d91611dfc565b50565b90610f3a91610f06565b565b9080610f57610f51610f4c611eab565b610451565b91610451565b03610f6857610f6591611eb8565b50565b5f63334bd91960e11b815280610f80600482016104ad565b0390fd5b90610f9e91610f99610f94610a89565b611de8565b611001565b565b610fb4610faf610fb9926107f7565b61059f565b610310565b90565b90610fc85f19916107fa565b9181191691161790565b90565b90610fea610fe5610ff192610867565b610fd2565b8254610fbc565b9055565b610ffe906105be565b90565b8061101b61101561101061064c565b610310565b91610310565b101561111f578061103d6110376110326002610d6e565b610310565b91610310565b10611103578161105561104f5f610fa0565b91610310565b1480156110e1575b6110c5576110768261107160018490610883565b610fd5565b33906110c06110ae6110a87f4b9b5002d7834864c4d8ae87f7bf0ec4b1752abf7e0703b5b32ff11e337989bc93610867565b93610ff5565b936110b76101d2565b91829182610361565b0390a3565b5f635ae6162f60e01b8152806110dd600482016104ad565b0390fd5b50816110fc6110f66110f1610c71565b610310565b91610310565b101561105d565b5f6365cb6dcb60e01b81528061111b600482016104ad565b0390fd5b5f63d5b25b6360e01b815280611137600482016104ad565b0390fd5b9061114591610f84565b565b61115361115891610d55565b6102a0565b90565b6111659054611147565b90565b90565b61117f61117a61118492611168565b61059f565b610310565b90565b61119661119c91939293610310565b92610310565b82039182116111a757565b610d7b565b6111b4610d42565b506111c86111c2600461115b565b15610231565b801561128d575b611281576111db611bca565b6111e56002610d6e565b61121161120b6112066111f661064c565b611200600161116b565b90611187565b610310565b91610310565b1461127e5761127b9061127561126761123d61123860016112326002610d6e565b90610883565b610d6e565b61126161125261124d6002610d6e565b610dfa565b949161125c610c71565b611187565b90610d8f565b91611270610c71565b611187565b90610dd8565b90565b90565b61128a5f610fa0565b90565b506112986002610d6e565b6112b16112ab6112a661064c565b610310565b91610310565b10156111cf565b906112c290610ff5565b5f5260205260405f2090565b6112f4915f6112e96112ef936112e2610cfe565b5082610eab565b016112b8565b61115b565b90565b6112ff610d42565b50611308610d42565b50611311610d42565b5061131a610d42565b50611323610cfe565b5061132e6002610d6e565b61133661064c565b916113416003610d6e565b9161134a611bca565b916113556002610d6e565b61136e61136861136361064c565b610310565b91610310565b1015919493929190565b6113919061138c61138761081b565b611de8565b6113d8565b565b9061139f60ff916107fa565b9181191691161790565b6113b290610231565b90565b90565b906113cd6113c86113d4926113a9565b6113b5565b8254611393565b9055565b6113e2600461115b565b6114d857806113f96113f35f610fa0565b91610310565b1480156114b6575b61149a57611411600160046113b8565b61141a5f610fa0565b5b8061143561142f61142a61064c565b610310565b91610310565b101561145e57611459906114548361144f60018490610883565b610fd5565b610d46565b61141b565b506114957fc12c60abc216286ef25e34b1805a0c3dda73e4c2fd6cf360e807a7a9e73167399161148c6101d2565b91829182610361565b0390a1565b5f635ae6162f60e01b8152806114b2600482016104ad565b0390fd5b50806114d16114cb6114c6610c71565b610310565b91610310565b1015611401565b5f639e91c9e760e01b8152806114f0600482016104ad565b0390fd5b6114fd90611378565b565b9061151a9291611515611510610a89565b611de8565b61157b565b565b5090565b61152f61153591939293610310565b92610310565b820180921161154057565b610d7b565b634e487b7160e01b5f52603260045260245ffd5b9190811015611569576020020190565b611545565b3561157881610313565b90565b916115855f610fa0565b5b806115a361159d61159886869061151c565b610310565b91610310565b101561170a576115b4848290611520565b90816115cf6115c96115c461064c565b610310565b91610310565b101561170257816116bc926115f56115ef6115ea6002610d6e565b610310565b91610310565b106116fc5761160e61160986868591611559565b61156e565b61162061161a5f610fa0565b91610310565b1480156116c7575b6116c15761165461164361163e87878691611559565b61156e565b61164f60018490610883565b610fd5565b61166861166386868591611559565b61156e565b9033906116b36116a161169b7f4b9b5002d7834864c4d8ae87f7bf0ec4b1752abf7e0703b5b32ff11e337989bc93610867565b93610ff5565b936116aa6101d2565b91829182610361565b0390a35b610d46565b611586565b506116b7565b506116dc6116d786868591611559565b61156e565b6116f56116ef6116ea610c71565b610310565b91610310565b1015611628565b506116b7565b50505050505b565b50505050611708565b9061171e92916114ff565b565b9061173b9161173661173182610ee5565b611de8565b61173d565b565b9061174791611eb8565b50565b9061175491611720565b565b61175e610d42565b508061177961177361176e61064c565b610310565b91610310565b10156117955761178d611792916001610883565b610d6e565b90565b5f63d5b25b6360e01b8152806117ad600482016104ad565b0390fd5b906117cb916117c66117c1610aed565b611de8565b6118d5565b90565b6117e26117dd6117e7926107f7565b61059f565b610446565b90565b6117f3906117ce565b90565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b90611822906117fa565b810190811067ffffffffffffffff82111761183c57604052565b611804565b60e01b90565b5f91031261185157565b6101dc565b61185f90610451565b9052565b91602061188492949361187d60408201965f830190611856565b0190610354565b565b61188e6101d2565b3d5f823e3d90fd5b9160206118b79294936118b060408201965f830190610354565b0190610354565b565b6118c290610310565b5f1981146118d05760010190565b610d7b565b506118e96118e3600461115b565b15610231565b611b6d576118f76002610d6e565b61191061190a61190561064c565b610310565b91610310565b1015611b51578061193161192b6119265f6117ea565b610451565b91610451565b14611b355761193e611bca565b611946610d42565b506119516002610d6e565b61197d61197761197261196261064c565b61196c600161116b565b90611187565b610310565b91610310565b145f14611aca5780915b6119a461199d846119986003610d6e565b611520565b6003610fd5565b6119cd7f00000000000000000000000000000000000000000000000000000000000000006105ca565b6340c10f19828592803b15611ac5576119f95f8094611a046119ed6101d2565b97889687958694611841565b845260048401611863565b03925af18015611ac057611a94575b50611a1e6002610d6e565b611a2a84938590611187565b611a5d611a577f160fc195d6e53691d30d804ce190dc09471891677e43433b91a7a6131c12a59a93610867565b93610ff5565b93611a72611a696101d2565b92839283611896565b0390a3611a91611a8a611a856002610d6e565b6118b9565b6002610fd5565b90565b611ab3905f3d8111611ab9575b611aab8183611818565b810190611847565b5f611a13565b503d611aa1565b611886565b6117f6565b611b2f611aea611ae56001611adf6002610d6e565b90610883565b610d6e565b611b29611b1b611b02611afd6002610d6e565b610dfa565b92611b158691611b10610c71565b611187565b90610d8f565b91611b24610c71565b611187565b90610dd8565b91611987565b5f63d92e233d60e01b815280611b4d600482016104ad565b0390fd5b5f639e91c9e760e01b815280611b69600482016104ad565b0390fd5b5f639e91c9e760e01b815280611b85600482016104ad565b0390fd5b611b9a90611b95610d42565b6117b1565b90565b90505190611baa82610313565b565b90602082820312611bc557611bc2915f01611b9d565b90565b6101dc565b611bd2610d42565b50611c176020611c017f00000000000000000000000000000000000000000000000000000000000000006105ca565b6318160ddd90611c0f6101d2565b938492611841565b82528180611c27600482016104ad565b03915afa908115611d8c575f91611d5e575b50611c7e6020611c687f00000000000000000000000000000000000000000000000000000000000000006105ca565b63902d55a590611c766101d2565b938492611841565b82528180611c8e600482016104ad565b03915afa8015611d5957611cb2915f91611d2b575b50611cac610906565b90611187565b81611cc5611cbf83610310565b91610310565b115f14611d1b57611cd591611187565b5b611cde610906565b611cf0611cea83610310565b91610310565b115f14611d0c57611d0890611d03610906565b611187565b5b90565b50611d165f610fa0565b611d09565b5050611d265f610fa0565b611cd6565b611d4c915060203d8111611d52575b611d448183611818565b810190611bac565b5f611ca3565b503d611d3a565b611886565b611d7f915060203d8111611d85575b611d778183611818565b810190611bac565b5f611c39565b503d611d6d565b611886565b611d99610cfe565b50611da46002610d6e565b611dbd611db7611db261064c565b610310565b91610310565b101590565b611dca610cfe565b50611de4611dde6301ffc9a760e01b6101e4565b916101e4565b1490565b611dfa90611df4611eab565b90611f7c565b565b611e04610cfe565b50611e19611e138284906112ce565b15610231565b5f14611ea157611e406001611e3b5f611e33818690610eab565b0185906112b8565b6113b8565b90611e49611eab565b90611e86611e80611e7a7f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d95610e9f565b92610ff5565b92610ff5565b92611e8f6101d2565b80611e99816104ad565b0390a4600190565b50505f90565b5f90565b611eb3611ea7565b503390565b611ec0610cfe565b50611ecc8183906112ce565b5f14611f5357611ef25f611eed5f611ee5818690610eab565b0185906112b8565b6113b8565b90611efb611eab565b90611f38611f32611f2c7ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b95610e9f565b92610ff5565b92610ff5565b92611f416101d2565b80611f4b816104ad565b0390a4600190565b50505f90565b916020611f7a929493611f7360408201965f830190611856565b01906103ef565b565b90611f91611f8b8383906112ce565b15610231565b611f99575050565b611fb35f92839263e2517d3f60e01b845260048401611f59565b0390fd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x13W[a\x0C\xFAV[a\0\x1D_5a\x01\xCCV[\x80c\x01\xFF\xC9\xA7\x14a\x01\xC7W\x80c\x15\x8E\xF9>\x14a\x01\xC2W\x80c#f@\xB9\x14a\x01\xBDW\x80c$\x8A\x9C\xA3\x14a\x01\xB8W\x80c//\xF1]\x14a\x01\xB3W\x80c6V\x8A\xBE\x14a\x01\xAEW\x80cX\x80\xF4\x9E\x14a\x01\xA9W\x80c[\xDFl\xA1\x14a\x01\xA4W\x80c_\x15\xC3\xC9\x14a\x01\x9FW\x80cvg\x18\x08\x14a\x01\x9AW\x80c\x80W/\x18\x14a\x01\x95W\x80c\x91\xD1HT\x14a\x01\x90W\x80c\xA0\x88x}\x14a\x01\x8BW\x80c\xA2\x17\xFD\xDF\x14a\x01\x86W\x80c\xAF\xCAt\x05\x14a\x01\x81W\x80c\xB1\x98\xD0(\x14a\x01|W\x80c\xC6:\tD\x14a\x01wW\x80c\xD2\xBC\xC9\xFF\x14a\x01rW\x80c\xD5Gt\x1F\x14a\x01mW\x80c\xDC\xA5\x04\xB6\x14a\x01hW\x80c\xDE\xBEO\x1F\x14a\x01cW\x80c\xDF\x02D\xB1\x14a\x01^W\x80c\xE0\xF5\x14t\x14a\x01YW\x80c\xE1\xF2~\xB8\x14a\x01TW\x80c\xE4\xB7\xFBs\x14a\x01OW\x80c\xEC\xEDU&\x14a\x01JWc\xFA9\x1Cd\x03a\0\x0EWa\x0C\xC5V[a\x0C\x90V[a\x0C\x1DV[a\x0B\xE8V[a\x0B\x95V[a\x0B`V[a\x0B\x1CV[a\n\xB8V[a\nUV[a\n!V[a\t]V[a\t(V[a\x08\xB2V[a\x082V[a\x07\xBEV[a\x07;V[a\x07\x06V[a\x06\xD1V[a\x06dV[a\x05\xF8V[a\x05GV[a\x04\xE6V[a\x04\xB2V[a\x04\x11V[a\x03vV[a\x02\xDBV[a\x02XV[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x01\xF9\x81a\x01\xE4V[\x03a\x02\0WV[_\x80\xFD[\x90P5\x90a\x02\x11\x82a\x01\xF0V[V[\x90` \x82\x82\x03\x12a\x02,Wa\x02)\x91_\x01a\x02\x04V[\x90V[a\x01\xDCV[\x15\x15\x90V[a\x02?\x90a\x021V[\x90RV[\x91\x90a\x02V\x90_` \x85\x01\x94\x01\x90a\x026V[V[4a\x02\x88Wa\x02\x84a\x02sa\x02n6`\x04a\x02\x13V[a\r\x02V[a\x02{a\x01\xD2V[\x91\x82\x91\x82a\x02CV[\x03\x90\xF3[a\x01\xD8V[_\x91\x03\x12a\x02\x97WV[a\x01\xDCV[\x1C\x90V[`\xFF\x16\x90V[a\x02\xB6\x90`\x08a\x02\xBB\x93\x02a\x02\x9CV[a\x02\xA0V[\x90V[\x90a\x02\xC9\x91Ta\x02\xA6V[\x90V[a\x02\xD8`\x04_\x90a\x02\xBEV[\x90V[4a\x03\x0BWa\x02\xEB6`\x04a\x02\x8DV[a\x03\x07a\x02\xF6a\x02\xCCV[a\x02\xFEa\x01\xD2V[\x91\x82\x91\x82a\x02CV[\x03\x90\xF3[a\x01\xD8V[\x90V[a\x03\x1C\x81a\x03\x10V[\x03a\x03#WV[_\x80\xFD[\x90P5\x90a\x034\x82a\x03\x13V[V[\x90` \x82\x82\x03\x12a\x03OWa\x03L\x91_\x01a\x03'V[\x90V[a\x01\xDCV[a\x03]\x90a\x03\x10V[\x90RV[\x91\x90a\x03t\x90_` \x85\x01\x94\x01\x90a\x03TV[V[4a\x03\xA6Wa\x03\xA2a\x03\x91a\x03\x8C6`\x04a\x036V[a\r\xFAV[a\x03\x99a\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[\x90V[a\x03\xB7\x81a\x03\xABV[\x03a\x03\xBEWV[_\x80\xFD[\x90P5\x90a\x03\xCF\x82a\x03\xAEV[V[\x90` \x82\x82\x03\x12a\x03\xEAWa\x03\xE7\x91_\x01a\x03\xC2V[\x90V[a\x01\xDCV[a\x03\xF8\x90a\x03\xABV[\x90RV[\x91\x90a\x04\x0F\x90_` \x85\x01\x94\x01\x90a\x03\xEFV[V[4a\x04AWa\x04=a\x04,a\x04'6`\x04a\x03\xD1V[a\x0E\xE5V[a\x044a\x01\xD2V[\x91\x82\x91\x82a\x03\xFCV[\x03\x90\xF3[a\x01\xD8V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x04Z\x90a\x04FV[\x90V[a\x04f\x81a\x04QV[\x03a\x04mWV[_\x80\xFD[\x90P5\x90a\x04~\x82a\x04]V[V[\x91\x90`@\x83\x82\x03\x12a\x04\xA8W\x80a\x04\x9Ca\x04\xA5\x92_\x86\x01a\x03\xC2V[\x93` \x01a\x04qV[\x90V[a\x01\xDCV[_\x01\x90V[4a\x04\xE1Wa\x04\xCBa\x04\xC56`\x04a\x04\x80V[\x90a\x0F0V[a\x04\xD3a\x01\xD2V[\x80a\x04\xDD\x81a\x04\xADV[\x03\x90\xF3[a\x01\xD8V[4a\x05\x15Wa\x04\xFFa\x04\xF96`\x04a\x04\x80V[\x90a\x0F<V[a\x05\x07a\x01\xD2V[\x80a\x05\x11\x81a\x04\xADV[\x03\x90\xF3[a\x01\xD8V[\x91\x90`@\x83\x82\x03\x12a\x05BW\x80a\x056a\x05?\x92_\x86\x01a\x03'V[\x93` \x01a\x03'V[\x90V[a\x01\xDCV[4a\x05vWa\x05`a\x05Z6`\x04a\x05\x1AV[\x90a\x11;V[a\x05ha\x01\xD2V[\x80a\x05r\x81a\x04\xADV[\x03\x90\xF3[a\x01\xD8V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[\x90V[a\x05\xB6a\x05\xB1a\x05\xBB\x92a\x04FV[a\x05\x9FV[a\x04FV[\x90V[a\x05\xC7\x90a\x05\xA2V[\x90V[a\x05\xD3\x90a\x05\xBEV[\x90V[a\x05\xDF\x90a\x05\xCAV[\x90RV[\x91\x90a\x05\xF6\x90_` \x85\x01\x94\x01\x90a\x05\xD6V[V[4a\x06(Wa\x06\x086`\x04a\x02\x8DV[a\x06$a\x06\x13a\x05{V[a\x06\x1Ba\x01\xD2V[\x91\x82\x91\x82a\x05\xE3V[\x03\x90\xF3[a\x01\xD8V[\x90V[a\x06Da\x06?a\x06I\x92a\x06-V[a\x05\x9FV[a\x03\x10V[\x90V[a\x06V`0a\x060V[\x90V[a\x06aa\x06LV[\x90V[4a\x06\x94Wa\x06t6`\x04a\x02\x8DV[a\x06\x90a\x06\x7Fa\x06YV[a\x06\x87a\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[\x90V[a\x06\xAC\x90`\x08a\x06\xB1\x93\x02a\x02\x9CV[a\x06\x99V[\x90V[\x90a\x06\xBF\x91Ta\x06\x9CV[\x90V[a\x06\xCE`\x02_\x90a\x06\xB4V[\x90V[4a\x07\x01Wa\x06\xE16`\x04a\x02\x8DV[a\x06\xFDa\x06\xECa\x06\xC2V[a\x06\xF4a\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[4a\x076Wa\x07\x166`\x04a\x02\x8DV[a\x072a\x07!a\x11\xACV[a\x07)a\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[4a\x07lWa\x07ha\x07Wa\x07Q6`\x04a\x04\x80V[\x90a\x12\xCEV[a\x07_a\x01\xD2V[\x91\x82\x91\x82a\x02CV[\x03\x90\xF3[a\x01\xD8V[\x90\x95\x94\x92a\x07\xBC\x94a\x07\xABa\x07\xB5\x92a\x07\xA1`\x80\x96a\x07\x97`\xA0\x88\x01\x9C_\x89\x01\x90a\x03TV[` \x87\x01\x90a\x03TV[`@\x85\x01\x90a\x03TV[``\x83\x01\x90a\x03TV[\x01\x90a\x026V[V[4a\x07\xF2Wa\x07\xCE6`\x04a\x02\x8DV[a\x07\xEEa\x07\xD9a\x12\xF7V[\x91a\x07\xE5\x95\x93\x95a\x01\xD2V[\x95\x86\x95\x86a\x07qV[\x03\x90\xF3[a\x01\xD8V[\x90V[_\x1B\x90V[a\x08\x13a\x08\x0Ea\x08\x18\x92a\x07\xF7V[a\x07\xFAV[a\x03\xABV[\x90V[a\x08$_a\x07\xFFV[\x90V[a\x08/a\x08\x1BV[\x90V[4a\x08bWa\x08B6`\x04a\x02\x8DV[a\x08^a\x08Ma\x08'V[a\x08Ua\x01\xD2V[\x91\x82\x91\x82a\x03\xFCV[\x03\x90\xF3[a\x01\xD8V[a\x08{a\x08va\x08\x80\x92a\x03\x10V[a\x05\x9FV[a\x03\x10V[\x90V[\x90a\x08\x8D\x90a\x08gV[_R` R`@_ \x90V[a\x08\xAF\x90a\x08\xAA`\x01\x91_\x92a\x08\x83V[a\x06\xB4V[\x90V[4a\x08\xE2Wa\x08\xDEa\x08\xCDa\x08\xC86`\x04a\x036V[a\x08\x99V[a\x08\xD5a\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[\x90V[a\x08\xFEa\x08\xF9a\t\x03\x92a\x08\xE7V[a\x05\x9FV[a\x03\x10V[\x90V[a\t\x1AjR\xB7\xD2\xDC\xC8\x0C\xD2\xE4\0\0\0a\x08\xEAV[\x90V[a\t%a\t\x06V[\x90V[4a\tXWa\t86`\x04a\x02\x8DV[a\tTa\tCa\t\x1DV[a\tKa\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[4a\t\x8BWa\tua\tp6`\x04a\x036V[a\x14\xF4V[a\t}a\x01\xD2V[\x80a\t\x87\x81a\x04\xADV[\x03\x90\xF3[a\x01\xD8V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\t\xD6W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\t\xD1W` \x01\x92` \x83\x02\x84\x01\x11a\t\xCCWV[a\t\x98V[a\t\x94V[a\t\x90V[\x91\x90\x91`@\x81\x84\x03\x12a\n\x1CWa\t\xF4\x83_\x83\x01a\x03'V[\x92` \x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\n\x17Wa\n\x13\x92\x01a\t\x9CV[\x90\x91V[a\x01\xE0V[a\x01\xDCV[4a\nPWa\n:a\n46`\x04a\t\xDBV[\x91a\x17\x13V[a\nBa\x01\xD2V[\x80a\nL\x81a\x04\xADV[\x03\x90\xF3[a\x01\xD8V[4a\n\x84Wa\nna\nh6`\x04a\x04\x80V[\x90a\x17JV[a\nva\x01\xD2V[\x80a\n\x80\x81a\x04\xADV[\x03\x90\xF3[a\x01\xD8V[\x7F9zL\xBE\xCEd\t?c\t\xC3C\x80\xBD\x98\x01\x91\xB5\xF3,w\xF5\x83\xBA\xCDMQ\x04Nh\xA1\x03\x90V[a\n\xB5a\n\x89V[\x90V[4a\n\xE8Wa\n\xC86`\x04a\x02\x8DV[a\n\xE4a\n\xD3a\n\xADV[a\n\xDBa\x01\xD2V[\x91\x82\x91\x82a\x03\xFCV[\x03\x90\xF3[a\x01\xD8V[\x7F\x07n\xB8\xB8u\xB6\xEA\x83\x9B\x08|L\x0C\x1AFa\xB0\x89\xD3\xB6\xEE,\x1E\xF1\xB9\xCF\xA7\xFE\x10f\xD2\x06\x90V[a\x0B\x19a\n\xEDV[\x90V[4a\x0BLWa\x0B,6`\x04a\x02\x8DV[a\x0BHa\x0B7a\x0B\x11V[a\x0B?a\x01\xD2V[\x91\x82\x91\x82a\x03\xFCV[\x03\x90\xF3[a\x01\xD8V[a\x0B]`\x03_\x90a\x06\xB4V[\x90V[4a\x0B\x90Wa\x0Bp6`\x04a\x02\x8DV[a\x0B\x8Ca\x0B{a\x0BQV[a\x0B\x83a\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[4a\x0B\xC5Wa\x0B\xC1a\x0B\xB0a\x0B\xAB6`\x04a\x036V[a\x17VV[a\x0B\xB8a\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[\x90` \x82\x82\x03\x12a\x0B\xE3Wa\x0B\xE0\x91_\x01a\x04qV[\x90V[a\x01\xDCV[4a\x0C\x18Wa\x0C\x14a\x0C\x03a\x0B\xFE6`\x04a\x0B\xCAV[a\x1B\x89V[a\x0C\x0Ba\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[4a\x0CMWa\x0C-6`\x04a\x02\x8DV[a\x0CIa\x0C8a\x1B\xCAV[a\x0C@a\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[\x90V[a\x0Cia\x0Cda\x0Cn\x92a\x0CRV[a\x05\x9FV[a\x03\x10V[\x90V[a\x0C\x82g\r\xE0\xB6\xB3\xA7d\0\0a\x0CUV[\x90V[a\x0C\x8Da\x0CqV[\x90V[4a\x0C\xC0Wa\x0C\xA06`\x04a\x02\x8DV[a\x0C\xBCa\x0C\xABa\x0C\x85V[a\x0C\xB3a\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xF3[a\x01\xD8V[4a\x0C\xF5Wa\x0C\xD56`\x04a\x02\x8DV[a\x0C\xF1a\x0C\xE0a\x1D\x91V[a\x0C\xE8a\x01\xD2V[\x91\x82\x91\x82a\x02CV[\x03\x90\xF3[a\x01\xD8V[_\x80\xFD[_\x90V[a\r\na\x0C\xFEV[P\x80a\r%a\r\x1Fcye\xDB\x0B`\xE0\x1Ba\x01\xE4V[\x91a\x01\xE4V[\x14\x90\x81\x15a\r2W[P\x90V[a\r<\x91Pa\x1D\xC2V[_a\r.V[_\x90V[`\x01a\rR\x91\x01a\x03\x10V[\x90V[_\x1C\x90V[a\rfa\rk\x91a\rUV[a\x06\x99V[\x90V[a\rx\x90Ta\rZV[\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\r\x9Ea\r\xA4\x91\x93\x92\x93a\x03\x10V[\x92a\x03\x10V[\x91a\r\xB0\x83\x82\x02a\x03\x10V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a\r\xBFWV[a\r{V[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a\r\xE4a\r\xEA\x91a\x03\x10V[\x91a\x03\x10V[\x90\x81\x15a\r\xF5W\x04\x90V[a\r\xC4V[a\x0E\x02a\rBV[P\x80a\x0E\x1Da\x0E\x17a\x0E\x12a\x06LV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x0E\x8FWa\x0E+a\x0CqV[[\x81a\x0EFa\x0E@a\x0E;a\x06LV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x0E\x8AWa\x0E~a\x0Epa\x0E\x84\x92a\x0Eja\x0Ee`\x01\x87\x90a\x08\x83V[a\rnV[\x90a\r\x8FV[a\x0Exa\x0CqV[\x90a\r\xD8V[\x91a\rFV[\x90a\x0E,V[\x90P\x90V[Pa\x0E\x98a\x0CqV[\x90V[_\x90V[a\x0E\xA8\x90a\x03\xABV[\x90V[\x90a\x0E\xB5\x90a\x0E\x9FV[_R` R`@_ \x90V[\x90V[a\x0E\xD0a\x0E\xD5\x91a\rUV[a\x0E\xC1V[\x90V[a\x0E\xE2\x90Ta\x0E\xC4V[\x90V[`\x01a\x0E\xFDa\x0F\x03\x92a\x0E\xF6a\x0E\x9BV[P_a\x0E\xABV[\x01a\x0E\xD8V[\x90V[\x90a\x0F!\x91a\x0F\x1Ca\x0F\x17\x82a\x0E\xE5V[a\x1D\xE8V[a\x0F#V[V[\x90a\x0F-\x91a\x1D\xFCV[PV[\x90a\x0F:\x91a\x0F\x06V[V[\x90\x80a\x0FWa\x0FQa\x0FLa\x1E\xABV[a\x04QV[\x91a\x04QV[\x03a\x0FhWa\x0Fe\x91a\x1E\xB8V[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a\x0F\x80`\x04\x82\x01a\x04\xADV[\x03\x90\xFD[\x90a\x0F\x9E\x91a\x0F\x99a\x0F\x94a\n\x89V[a\x1D\xE8V[a\x10\x01V[V[a\x0F\xB4a\x0F\xAFa\x0F\xB9\x92a\x07\xF7V[a\x05\x9FV[a\x03\x10V[\x90V[\x90a\x0F\xC8_\x19\x91a\x07\xFAV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x90a\x0F\xEAa\x0F\xE5a\x0F\xF1\x92a\x08gV[a\x0F\xD2V[\x82Ta\x0F\xBCV[\x90UV[a\x0F\xFE\x90a\x05\xBEV[\x90V[\x80a\x10\x1Ba\x10\x15a\x10\x10a\x06LV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x11\x1FW\x80a\x10=a\x107a\x102`\x02a\rnV[a\x03\x10V[\x91a\x03\x10V[\x10a\x11\x03W\x81a\x10Ua\x10O_a\x0F\xA0V[\x91a\x03\x10V[\x14\x80\x15a\x10\xE1W[a\x10\xC5Wa\x10v\x82a\x10q`\x01\x84\x90a\x08\x83V[a\x0F\xD5V[3\x90a\x10\xC0a\x10\xAEa\x10\xA8\x7FK\x9BP\x02\xD7\x83Hd\xC4\xD8\xAE\x87\xF7\xBF\x0E\xC4\xB1u*\xBF~\x07\x03\xB5\xB3/\xF1\x1E3y\x89\xBC\x93a\x08gV[\x93a\x0F\xF5V[\x93a\x10\xB7a\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xA3V[_cZ\xE6\x16/`\xE0\x1B\x81R\x80a\x10\xDD`\x04\x82\x01a\x04\xADV[\x03\x90\xFD[P\x81a\x10\xFCa\x10\xF6a\x10\xF1a\x0CqV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x10]V[_ce\xCBm\xCB`\xE0\x1B\x81R\x80a\x11\x1B`\x04\x82\x01a\x04\xADV[\x03\x90\xFD[_c\xD5\xB2[c`\xE0\x1B\x81R\x80a\x117`\x04\x82\x01a\x04\xADV[\x03\x90\xFD[\x90a\x11E\x91a\x0F\x84V[V[a\x11Sa\x11X\x91a\rUV[a\x02\xA0V[\x90V[a\x11e\x90Ta\x11GV[\x90V[\x90V[a\x11\x7Fa\x11za\x11\x84\x92a\x11hV[a\x05\x9FV[a\x03\x10V[\x90V[a\x11\x96a\x11\x9C\x91\x93\x92\x93a\x03\x10V[\x92a\x03\x10V[\x82\x03\x91\x82\x11a\x11\xA7WV[a\r{V[a\x11\xB4a\rBV[Pa\x11\xC8a\x11\xC2`\x04a\x11[V[\x15a\x021V[\x80\x15a\x12\x8DW[a\x12\x81Wa\x11\xDBa\x1B\xCAV[a\x11\xE5`\x02a\rnV[a\x12\x11a\x12\x0Ba\x12\x06a\x11\xF6a\x06LV[a\x12\0`\x01a\x11kV[\x90a\x11\x87V[a\x03\x10V[\x91a\x03\x10V[\x14a\x12~Wa\x12{\x90a\x12ua\x12ga\x12=a\x128`\x01a\x122`\x02a\rnV[\x90a\x08\x83V[a\rnV[a\x12aa\x12Ra\x12M`\x02a\rnV[a\r\xFAV[\x94\x91a\x12\\a\x0CqV[a\x11\x87V[\x90a\r\x8FV[\x91a\x12pa\x0CqV[a\x11\x87V[\x90a\r\xD8V[\x90V[\x90V[a\x12\x8A_a\x0F\xA0V[\x90V[Pa\x12\x98`\x02a\rnV[a\x12\xB1a\x12\xABa\x12\xA6a\x06LV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x11\xCFV[\x90a\x12\xC2\x90a\x0F\xF5V[_R` R`@_ \x90V[a\x12\xF4\x91_a\x12\xE9a\x12\xEF\x93a\x12\xE2a\x0C\xFEV[P\x82a\x0E\xABV[\x01a\x12\xB8V[a\x11[V[\x90V[a\x12\xFFa\rBV[Pa\x13\x08a\rBV[Pa\x13\x11a\rBV[Pa\x13\x1Aa\rBV[Pa\x13#a\x0C\xFEV[Pa\x13.`\x02a\rnV[a\x136a\x06LV[\x91a\x13A`\x03a\rnV[\x91a\x13Ja\x1B\xCAV[\x91a\x13U`\x02a\rnV[a\x13na\x13ha\x13ca\x06LV[a\x03\x10V[\x91a\x03\x10V[\x10\x15\x91\x94\x93\x92\x91\x90V[a\x13\x91\x90a\x13\x8Ca\x13\x87a\x08\x1BV[a\x1D\xE8V[a\x13\xD8V[V[\x90a\x13\x9F`\xFF\x91a\x07\xFAV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x13\xB2\x90a\x021V[\x90V[\x90V[\x90a\x13\xCDa\x13\xC8a\x13\xD4\x92a\x13\xA9V[a\x13\xB5V[\x82Ta\x13\x93V[\x90UV[a\x13\xE2`\x04a\x11[V[a\x14\xD8W\x80a\x13\xF9a\x13\xF3_a\x0F\xA0V[\x91a\x03\x10V[\x14\x80\x15a\x14\xB6W[a\x14\x9AWa\x14\x11`\x01`\x04a\x13\xB8V[a\x14\x1A_a\x0F\xA0V[[\x80a\x145a\x14/a\x14*a\x06LV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x14^Wa\x14Y\x90a\x14T\x83a\x14O`\x01\x84\x90a\x08\x83V[a\x0F\xD5V[a\rFV[a\x14\x1BV[Pa\x14\x95\x7F\xC1,`\xAB\xC2\x16(n\xF2^4\xB1\x80Z\x0C=\xDAs\xE4\xC2\xFDl\xF3`\xE8\x07\xA7\xA9\xE71g9\x91a\x14\x8Ca\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xA1V[_cZ\xE6\x16/`\xE0\x1B\x81R\x80a\x14\xB2`\x04\x82\x01a\x04\xADV[\x03\x90\xFD[P\x80a\x14\xD1a\x14\xCBa\x14\xC6a\x0CqV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x14\x01V[_c\x9E\x91\xC9\xE7`\xE0\x1B\x81R\x80a\x14\xF0`\x04\x82\x01a\x04\xADV[\x03\x90\xFD[a\x14\xFD\x90a\x13xV[V[\x90a\x15\x1A\x92\x91a\x15\x15a\x15\x10a\n\x89V[a\x1D\xE8V[a\x15{V[V[P\x90V[a\x15/a\x155\x91\x93\x92\x93a\x03\x10V[\x92a\x03\x10V[\x82\x01\x80\x92\x11a\x15@WV[a\r{V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[\x91\x90\x81\x10\x15a\x15iW` \x02\x01\x90V[a\x15EV[5a\x15x\x81a\x03\x13V[\x90V[\x91a\x15\x85_a\x0F\xA0V[[\x80a\x15\xA3a\x15\x9Da\x15\x98\x86\x86\x90a\x15\x1CV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x17\nWa\x15\xB4\x84\x82\x90a\x15 V[\x90\x81a\x15\xCFa\x15\xC9a\x15\xC4a\x06LV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x17\x02W\x81a\x16\xBC\x92a\x15\xF5a\x15\xEFa\x15\xEA`\x02a\rnV[a\x03\x10V[\x91a\x03\x10V[\x10a\x16\xFCWa\x16\x0Ea\x16\t\x86\x86\x85\x91a\x15YV[a\x15nV[a\x16 a\x16\x1A_a\x0F\xA0V[\x91a\x03\x10V[\x14\x80\x15a\x16\xC7W[a\x16\xC1Wa\x16Ta\x16Ca\x16>\x87\x87\x86\x91a\x15YV[a\x15nV[a\x16O`\x01\x84\x90a\x08\x83V[a\x0F\xD5V[a\x16ha\x16c\x86\x86\x85\x91a\x15YV[a\x15nV[\x903\x90a\x16\xB3a\x16\xA1a\x16\x9B\x7FK\x9BP\x02\xD7\x83Hd\xC4\xD8\xAE\x87\xF7\xBF\x0E\xC4\xB1u*\xBF~\x07\x03\xB5\xB3/\xF1\x1E3y\x89\xBC\x93a\x08gV[\x93a\x0F\xF5V[\x93a\x16\xAAa\x01\xD2V[\x91\x82\x91\x82a\x03aV[\x03\x90\xA3[a\rFV[a\x15\x86V[Pa\x16\xB7V[Pa\x16\xDCa\x16\xD7\x86\x86\x85\x91a\x15YV[a\x15nV[a\x16\xF5a\x16\xEFa\x16\xEAa\x0CqV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x16(V[Pa\x16\xB7V[PPPPP[V[PPPPa\x17\x08V[\x90a\x17\x1E\x92\x91a\x14\xFFV[V[\x90a\x17;\x91a\x176a\x171\x82a\x0E\xE5V[a\x1D\xE8V[a\x17=V[V[\x90a\x17G\x91a\x1E\xB8V[PV[\x90a\x17T\x91a\x17 V[V[a\x17^a\rBV[P\x80a\x17ya\x17sa\x17na\x06LV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x17\x95Wa\x17\x8Da\x17\x92\x91`\x01a\x08\x83V[a\rnV[\x90V[_c\xD5\xB2[c`\xE0\x1B\x81R\x80a\x17\xAD`\x04\x82\x01a\x04\xADV[\x03\x90\xFD[\x90a\x17\xCB\x91a\x17\xC6a\x17\xC1a\n\xEDV[a\x1D\xE8V[a\x18\xD5V[\x90V[a\x17\xE2a\x17\xDDa\x17\xE7\x92a\x07\xF7V[a\x05\x9FV[a\x04FV[\x90V[a\x17\xF3\x90a\x17\xCEV[\x90V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x18\"\x90a\x17\xFAV[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x18<W`@RV[a\x18\x04V[`\xE0\x1B\x90V[_\x91\x03\x12a\x18QWV[a\x01\xDCV[a\x18_\x90a\x04QV[\x90RV[\x91` a\x18\x84\x92\x94\x93a\x18}`@\x82\x01\x96_\x83\x01\x90a\x18VV[\x01\x90a\x03TV[V[a\x18\x8Ea\x01\xD2V[=_\x82>=\x90\xFD[\x91` a\x18\xB7\x92\x94\x93a\x18\xB0`@\x82\x01\x96_\x83\x01\x90a\x03TV[\x01\x90a\x03TV[V[a\x18\xC2\x90a\x03\x10V[_\x19\x81\x14a\x18\xD0W`\x01\x01\x90V[a\r{V[Pa\x18\xE9a\x18\xE3`\x04a\x11[V[\x15a\x021V[a\x1BmWa\x18\xF7`\x02a\rnV[a\x19\x10a\x19\na\x19\x05a\x06LV[a\x03\x10V[\x91a\x03\x10V[\x10\x15a\x1BQW\x80a\x191a\x19+a\x19&_a\x17\xEAV[a\x04QV[\x91a\x04QV[\x14a\x1B5Wa\x19>a\x1B\xCAV[a\x19Fa\rBV[Pa\x19Q`\x02a\rnV[a\x19}a\x19wa\x19ra\x19ba\x06LV[a\x19l`\x01a\x11kV[\x90a\x11\x87V[a\x03\x10V[\x91a\x03\x10V[\x14_\x14a\x1A\xCAW\x80\x91[a\x19\xA4a\x19\x9D\x84a\x19\x98`\x03a\rnV[a\x15 V[`\x03a\x0F\xD5V[a\x19\xCD\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x05\xCAV[c@\xC1\x0F\x19\x82\x85\x92\x80;\x15a\x1A\xC5Wa\x19\xF9_\x80\x94a\x1A\x04a\x19\xEDa\x01\xD2V[\x97\x88\x96\x87\x95\x86\x94a\x18AV[\x84R`\x04\x84\x01a\x18cV[\x03\x92Z\xF1\x80\x15a\x1A\xC0Wa\x1A\x94W[Pa\x1A\x1E`\x02a\rnV[a\x1A*\x84\x93\x85\x90a\x11\x87V[a\x1A]a\x1AW\x7F\x16\x0F\xC1\x95\xD6\xE56\x91\xD3\r\x80L\xE1\x90\xDC\tG\x18\x91g~CC;\x91\xA7\xA6\x13\x1C\x12\xA5\x9A\x93a\x08gV[\x93a\x0F\xF5V[\x93a\x1Ara\x1Aia\x01\xD2V[\x92\x83\x92\x83a\x18\x96V[\x03\x90\xA3a\x1A\x91a\x1A\x8Aa\x1A\x85`\x02a\rnV[a\x18\xB9V[`\x02a\x0F\xD5V[\x90V[a\x1A\xB3\x90_=\x81\x11a\x1A\xB9W[a\x1A\xAB\x81\x83a\x18\x18V[\x81\x01\x90a\x18GV[_a\x1A\x13V[P=a\x1A\xA1V[a\x18\x86V[a\x17\xF6V[a\x1B/a\x1A\xEAa\x1A\xE5`\x01a\x1A\xDF`\x02a\rnV[\x90a\x08\x83V[a\rnV[a\x1B)a\x1B\x1Ba\x1B\x02a\x1A\xFD`\x02a\rnV[a\r\xFAV[\x92a\x1B\x15\x86\x91a\x1B\x10a\x0CqV[a\x11\x87V[\x90a\r\x8FV[\x91a\x1B$a\x0CqV[a\x11\x87V[\x90a\r\xD8V[\x91a\x19\x87V[_c\xD9.#=`\xE0\x1B\x81R\x80a\x1BM`\x04\x82\x01a\x04\xADV[\x03\x90\xFD[_c\x9E\x91\xC9\xE7`\xE0\x1B\x81R\x80a\x1Bi`\x04\x82\x01a\x04\xADV[\x03\x90\xFD[_c\x9E\x91\xC9\xE7`\xE0\x1B\x81R\x80a\x1B\x85`\x04\x82\x01a\x04\xADV[\x03\x90\xFD[a\x1B\x9A\x90a\x1B\x95a\rBV[a\x17\xB1V[\x90V[\x90PQ\x90a\x1B\xAA\x82a\x03\x13V[V[\x90` \x82\x82\x03\x12a\x1B\xC5Wa\x1B\xC2\x91_\x01a\x1B\x9DV[\x90V[a\x01\xDCV[a\x1B\xD2a\rBV[Pa\x1C\x17` a\x1C\x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x05\xCAV[c\x18\x16\r\xDD\x90a\x1C\x0Fa\x01\xD2V[\x93\x84\x92a\x18AV[\x82R\x81\x80a\x1C'`\x04\x82\x01a\x04\xADV[\x03\x91Z\xFA\x90\x81\x15a\x1D\x8CW_\x91a\x1D^W[Pa\x1C~` a\x1Ch\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x05\xCAV[c\x90-U\xA5\x90a\x1Cva\x01\xD2V[\x93\x84\x92a\x18AV[\x82R\x81\x80a\x1C\x8E`\x04\x82\x01a\x04\xADV[\x03\x91Z\xFA\x80\x15a\x1DYWa\x1C\xB2\x91_\x91a\x1D+W[Pa\x1C\xACa\t\x06V[\x90a\x11\x87V[\x81a\x1C\xC5a\x1C\xBF\x83a\x03\x10V[\x91a\x03\x10V[\x11_\x14a\x1D\x1BWa\x1C\xD5\x91a\x11\x87V[[a\x1C\xDEa\t\x06V[a\x1C\xF0a\x1C\xEA\x83a\x03\x10V[\x91a\x03\x10V[\x11_\x14a\x1D\x0CWa\x1D\x08\x90a\x1D\x03a\t\x06V[a\x11\x87V[[\x90V[Pa\x1D\x16_a\x0F\xA0V[a\x1D\tV[PPa\x1D&_a\x0F\xA0V[a\x1C\xD6V[a\x1DL\x91P` =\x81\x11a\x1DRW[a\x1DD\x81\x83a\x18\x18V[\x81\x01\x90a\x1B\xACV[_a\x1C\xA3V[P=a\x1D:V[a\x18\x86V[a\x1D\x7F\x91P` =\x81\x11a\x1D\x85W[a\x1Dw\x81\x83a\x18\x18V[\x81\x01\x90a\x1B\xACV[_a\x1C9V[P=a\x1DmV[a\x18\x86V[a\x1D\x99a\x0C\xFEV[Pa\x1D\xA4`\x02a\rnV[a\x1D\xBDa\x1D\xB7a\x1D\xB2a\x06LV[a\x03\x10V[\x91a\x03\x10V[\x10\x15\x90V[a\x1D\xCAa\x0C\xFEV[Pa\x1D\xE4a\x1D\xDEc\x01\xFF\xC9\xA7`\xE0\x1Ba\x01\xE4V[\x91a\x01\xE4V[\x14\x90V[a\x1D\xFA\x90a\x1D\xF4a\x1E\xABV[\x90a\x1F|V[V[a\x1E\x04a\x0C\xFEV[Pa\x1E\x19a\x1E\x13\x82\x84\x90a\x12\xCEV[\x15a\x021V[_\x14a\x1E\xA1Wa\x1E@`\x01a\x1E;_a\x1E3\x81\x86\x90a\x0E\xABV[\x01\x85\x90a\x12\xB8V[a\x13\xB8V[\x90a\x1EIa\x1E\xABV[\x90a\x1E\x86a\x1E\x80a\x1Ez\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\x0E\x9FV[\x92a\x0F\xF5V[\x92a\x0F\xF5V[\x92a\x1E\x8Fa\x01\xD2V[\x80a\x1E\x99\x81a\x04\xADV[\x03\x90\xA4`\x01\x90V[PP_\x90V[_\x90V[a\x1E\xB3a\x1E\xA7V[P3\x90V[a\x1E\xC0a\x0C\xFEV[Pa\x1E\xCC\x81\x83\x90a\x12\xCEV[_\x14a\x1FSWa\x1E\xF2_a\x1E\xED_a\x1E\xE5\x81\x86\x90a\x0E\xABV[\x01\x85\x90a\x12\xB8V[a\x13\xB8V[\x90a\x1E\xFBa\x1E\xABV[\x90a\x1F8a\x1F2a\x1F,\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a\x0E\x9FV[\x92a\x0F\xF5V[\x92a\x0F\xF5V[\x92a\x1FAa\x01\xD2V[\x80a\x1FK\x81a\x04\xADV[\x03\x90\xA4`\x01\x90V[PP_\x90V[\x91` a\x1Fz\x92\x94\x93a\x1Fs`@\x82\x01\x96_\x83\x01\x90a\x18VV[\x01\x90a\x03\xEFV[V[\x90a\x1F\x91a\x1F\x8B\x83\x83\x90a\x12\xCEV[\x15a\x021V[a\x1F\x99WPPV[a\x1F\xB3_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01a\x1FYV[\x03\x90\xFD",
    );
    /**Custom error with signature `AccessControlBadConfirmation()` and selector `0x6697b232`.
```solidity
error AccessControlBadConfirmation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlBadConfirmation {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlBadConfirmation>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlBadConfirmation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlBadConfirmation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlBadConfirmation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlBadConfirmation()";
            const SELECTOR: [u8; 4] = [102u8, 151u8, 178u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `AccessControlUnauthorizedAccount(address,bytes32)` and selector `0xe2517d3f`.
```solidity
error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub neededRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlUnauthorizedAccount) -> Self {
                (value.account, value.neededRole)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    neededRole: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlUnauthorizedAccount(address,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 81u8, 125u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.neededRole),
                )
            }
        }
    };
    /**Custom error with signature `CannotModifyPastEpoch()` and selector `0x65cb6dcb`.
```solidity
error CannotModifyPastEpoch();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CannotModifyPastEpoch {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CannotModifyPastEpoch> for UnderlyingRustTuple<'_> {
            fn from(value: CannotModifyPastEpoch) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CannotModifyPastEpoch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CannotModifyPastEpoch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CannotModifyPastEpoch()";
            const SELECTOR: [u8; 4] = [101u8, 203u8, 109u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionsCompleted()` and selector `0x9e91c9e7`.
```solidity
error EmissionsCompleted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionsCompleted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionsCompleted> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionsCompleted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionsCompleted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionsCompleted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionsCompleted()";
            const SELECTOR: [u8; 4] = [158u8, 145u8, 201u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidDecayFactor()` and selector `0x5ae6162f`.
```solidity
error InvalidDecayFactor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidDecayFactor {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidDecayFactor> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidDecayFactor) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidDecayFactor {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidDecayFactor {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidDecayFactor()";
            const SELECTOR: [u8; 4] = [90u8, 230u8, 22u8, 47u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidEpoch()` and selector `0xd5b25b63`.
```solidity
error InvalidEpoch();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidEpoch {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidEpoch> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidEpoch) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidEpoch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidEpoch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidEpoch()";
            const SELECTOR: [u8; 4] = [213u8, 178u8, 91u8, 99u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ZeroAddress()` and selector `0xd92e233d`.
```solidity
error ZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAddress {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAddress()";
            const SELECTOR: [u8; 4] = [217u8, 46u8, 35u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Event with signature `DecayFactorSet(uint256,uint256,address)` and selector `0x4b9b5002d7834864c4d8ae87f7bf0ec4b1752abf7e0703b5b32ff11e337989bc`.
```solidity
event DecayFactorSet(uint256 indexed epoch, uint256 decayFactor, address indexed setter);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DecayFactorSet {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub decayFactor: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub setter: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DecayFactorSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "DecayFactorSet(uint256,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                75u8,
                155u8,
                80u8,
                2u8,
                215u8,
                131u8,
                72u8,
                100u8,
                196u8,
                216u8,
                174u8,
                135u8,
                247u8,
                191u8,
                14u8,
                196u8,
                177u8,
                117u8,
                42u8,
                191u8,
                126u8,
                7u8,
                3u8,
                181u8,
                179u8,
                47u8,
                241u8,
                30u8,
                51u8,
                121u8,
                137u8,
                188u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    epoch: topics.1,
                    decayFactor: data.0,
                    setter: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.decayFactor),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.epoch.clone(), self.setter.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.epoch);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.setter,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DecayFactorSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DecayFactorSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DecayFactorSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionMinted(uint256,uint256,uint256,address)` and selector `0x160fc195d6e53691d30d804ce190dc09471891677e43433b91a7a6131c12a59a`.
```solidity
event EmissionMinted(uint256 indexed epoch, uint256 amount, uint256 remainingSupply, address indexed to);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionMinted {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub remainingSupply: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionMinted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "EmissionMinted(uint256,uint256,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                22u8,
                15u8,
                193u8,
                149u8,
                214u8,
                229u8,
                54u8,
                145u8,
                211u8,
                13u8,
                128u8,
                76u8,
                225u8,
                144u8,
                220u8,
                9u8,
                71u8,
                24u8,
                145u8,
                103u8,
                126u8,
                67u8,
                67u8,
                59u8,
                145u8,
                167u8,
                166u8,
                19u8,
                28u8,
                18u8,
                165u8,
                154u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    epoch: topics.1,
                    amount: data.0,
                    remainingSupply: data.1,
                    to: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.remainingSupply),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.epoch.clone(), self.to.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.epoch);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.to,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionMinted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionMinted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionMinted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionsInitialized(uint256)` and selector `0xc12c60abc216286ef25e34b1805a0c3dda73e4c2fd6cf360e807a7a9e7316739`.
```solidity
event EmissionsInitialized(uint256 defaultDecayFactor);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionsInitialized {
        #[allow(missing_docs)]
        pub defaultDecayFactor: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionsInitialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EmissionsInitialized(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                193u8,
                44u8,
                96u8,
                171u8,
                194u8,
                22u8,
                40u8,
                110u8,
                242u8,
                94u8,
                52u8,
                177u8,
                128u8,
                90u8,
                12u8,
                61u8,
                218u8,
                115u8,
                228u8,
                194u8,
                253u8,
                108u8,
                243u8,
                96u8,
                232u8,
                7u8,
                167u8,
                169u8,
                231u8,
                49u8,
                103u8,
                57u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { defaultDecayFactor: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.defaultDecayFactor),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionsInitialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionsInitialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionsInitialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address _syndicateToken, address defaultAdmin, address decayManager);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub _syndicateToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub defaultAdmin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub decayManager: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value._syndicateToken, value.defaultAdmin, value.decayManager)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _syndicateToken: tuple.0,
                        defaultAdmin: tuple.1,
                        decayManager: tuple.2,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._syndicateToken,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.defaultAdmin,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.decayManager,
                    ),
                )
            }
        }
    };
    /**Function with signature `DECAY_MANAGER_ROLE()` and selector `0xdca504b6`.
```solidity
function DECAY_MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DECAY_MANAGER_ROLECall {}
    ///Container type for the return parameters of the [`DECAY_MANAGER_ROLE()`](DECAY_MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DECAY_MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DECAY_MANAGER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DECAY_MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DECAY_MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DECAY_MANAGER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DECAY_MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DECAY_MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DECAY_MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DECAY_MANAGER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DECAY_MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [220u8, 165u8, 4u8, 182u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall {}
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DEFAULT_ADMIN_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSIONS_CAP()` and selector `0xb198d028`.
```solidity
function EMISSIONS_CAP() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_CAPCall {}
    ///Container type for the return parameters of the [`EMISSIONS_CAP()`](EMISSIONS_CAPCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_CAPReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_CAPCall> for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_CAPCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for EMISSIONS_CAPCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_CAPReturn> for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_CAPReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for EMISSIONS_CAPReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSIONS_CAPCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSIONS_CAPReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSIONS_CAP()";
            const SELECTOR: [u8; 4] = [177u8, 152u8, 208u8, 40u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSIONS_ROLE()` and selector `0xdebe4f1f`.
```solidity
function EMISSIONS_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_ROLECall {}
    ///Container type for the return parameters of the [`EMISSIONS_ROLE()`](EMISSIONS_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_ROLECall> for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for EMISSIONS_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSIONS_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSIONS_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSIONS_ROLE()";
            const SELECTOR: [u8; 4] = [222u8, 190u8, 79u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `SCALE()` and selector `0xeced5526`.
```solidity
function SCALE() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SCALECall {}
    ///Container type for the return parameters of the [`SCALE()`](SCALECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SCALEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SCALECall> for UnderlyingRustTuple<'_> {
                fn from(value: SCALECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SCALECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SCALEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: SCALEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SCALEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SCALECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = SCALEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SCALE()";
            const SELECTOR: [u8; 4] = [236u8, 237u8, 85u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `TOTAL_EPOCHS()` and selector `0x5f15c3c9`.
```solidity
function TOTAL_EPOCHS() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_EPOCHSCall {}
    ///Container type for the return parameters of the [`TOTAL_EPOCHS()`](TOTAL_EPOCHSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_EPOCHSReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_EPOCHSCall> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_EPOCHSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_EPOCHSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_EPOCHSReturn> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_EPOCHSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_EPOCHSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TOTAL_EPOCHSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = TOTAL_EPOCHSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TOTAL_EPOCHS()";
            const SELECTOR: [u8; 4] = [95u8, 21u8, 195u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `calculateAndMintEmission(address)` and selector `0xe1f27eb8`.
```solidity
function calculateAndMintEmission(address to) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calculateAndMintEmissionCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`calculateAndMintEmission(address)`](calculateAndMintEmissionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calculateAndMintEmissionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateAndMintEmissionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: calculateAndMintEmissionCall) -> Self {
                    (value.to,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for calculateAndMintEmissionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { to: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateAndMintEmissionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: calculateAndMintEmissionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for calculateAndMintEmissionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for calculateAndMintEmissionCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = calculateAndMintEmissionReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "calculateAndMintEmission(address)";
            const SELECTOR: [u8; 4] = [225u8, 242u8, 126u8, 184u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `calculateCumulativeProduct(uint256)` and selector `0x236640b9`.
```solidity
function calculateCumulativeProduct(uint256 fromEpoch) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calculateCumulativeProductCall {
        #[allow(missing_docs)]
        pub fromEpoch: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`calculateCumulativeProduct(uint256)`](calculateCumulativeProductCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calculateCumulativeProductReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateCumulativeProductCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: calculateCumulativeProductCall) -> Self {
                    (value.fromEpoch,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for calculateCumulativeProductCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { fromEpoch: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateCumulativeProductReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: calculateCumulativeProductReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for calculateCumulativeProductReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for calculateCumulativeProductCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = calculateCumulativeProductReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "calculateCumulativeProduct(uint256)";
            const SELECTOR: [u8; 4] = [35u8, 102u8, 64u8, 185u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.fromEpoch),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `currentEpoch()` and selector `0x76671808`.
```solidity
function currentEpoch() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentEpochCall {}
    ///Container type for the return parameters of the [`currentEpoch()`](currentEpochCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentEpochReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentEpochCall> for UnderlyingRustTuple<'_> {
                fn from(value: currentEpochCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentEpochCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentEpochReturn> for UnderlyingRustTuple<'_> {
                fn from(value: currentEpochReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentEpochReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for currentEpochCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = currentEpochReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "currentEpoch()";
            const SELECTOR: [u8; 4] = [118u8, 103u8, 24u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `decayFactors(uint256)` and selector `0xafca7405`.
```solidity
function decayFactors(uint256) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decayFactorsCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`decayFactors(uint256)`](decayFactorsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decayFactorsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decayFactorsCall> for UnderlyingRustTuple<'_> {
                fn from(value: decayFactorsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decayFactorsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decayFactorsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: decayFactorsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decayFactorsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for decayFactorsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = decayFactorsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "decayFactors(uint256)";
            const SELECTOR: [u8; 4] = [175u8, 202u8, 116u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getDecayFactor(uint256)` and selector `0xe0f51474`.
```solidity
function getDecayFactor(uint256 epoch) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDecayFactorCall {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getDecayFactor(uint256)`](getDecayFactorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDecayFactorReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDecayFactorCall> for UnderlyingRustTuple<'_> {
                fn from(value: getDecayFactorCall) -> Self {
                    (value.epoch,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getDecayFactorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epoch: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDecayFactorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getDecayFactorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getDecayFactorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getDecayFactorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getDecayFactorReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getDecayFactor(uint256)";
            const SELECTOR: [u8; 4] = [224u8, 245u8, 20u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epoch),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getEmissionsInfo()` and selector `0xa088787d`.
```solidity
function getEmissionsInfo() external view returns (uint256 current, uint256 total, uint256 emitted, uint256 remaining, bool completed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEmissionsInfoCall {}
    ///Container type for the return parameters of the [`getEmissionsInfo()`](getEmissionsInfoCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEmissionsInfoReturn {
        #[allow(missing_docs)]
        pub current: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub emitted: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub remaining: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub completed: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEmissionsInfoCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEmissionsInfoCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEmissionsInfoCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                bool,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEmissionsInfoReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEmissionsInfoReturn) -> Self {
                    (
                        value.current,
                        value.total,
                        value.emitted,
                        value.remaining,
                        value.completed,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEmissionsInfoReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        current: tuple.0,
                        total: tuple.1,
                        emitted: tuple.2,
                        remaining: tuple.3,
                        completed: tuple.4,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getEmissionsInfoCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getEmissionsInfoReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getEmissionsInfo()";
            const SELECTOR: [u8; 4] = [160u8, 136u8, 120u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRemainingSupply()` and selector `0xe4b7fb73`.
```solidity
function getRemainingSupply() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRemainingSupplyCall {}
    ///Container type for the return parameters of the [`getRemainingSupply()`](getRemainingSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRemainingSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRemainingSupplyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRemainingSupplyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRemainingSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRemainingSupplyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRemainingSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRemainingSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRemainingSupplyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRemainingSupplyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRemainingSupply()";
            const SELECTOR: [u8; 4] = [228u8, 183u8, 251u8, 115u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRoleAdminReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasRoleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `initializeEmissions(uint256)` and selector `0xc63a0944`.
```solidity
function initializeEmissions(uint256 defaultDecayFactor) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeEmissionsCall {
        #[allow(missing_docs)]
        pub defaultDecayFactor: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`initializeEmissions(uint256)`](initializeEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeEmissionsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeEmissionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeEmissionsCall) -> Self {
                    (value.defaultDecayFactor,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        defaultDecayFactor: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeEmissionsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeEmissionsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeEmissionsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initializeEmissions(uint256)";
            const SELECTOR: [u8; 4] = [198u8, 58u8, 9u8, 68u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.defaultDecayFactor),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `initialized()` and selector `0x158ef93e`.
```solidity
function initialized() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializedCall {}
    ///Container type for the return parameters of the [`initialized()`](initializedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializedCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialized()";
            const SELECTOR: [u8; 4] = [21u8, 142u8, 249u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isCompleted()` and selector `0xfa391c64`.
```solidity
function isCompleted() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isCompletedCall {}
    ///Container type for the return parameters of the [`isCompleted()`](isCompletedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isCompletedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isCompletedCall> for UnderlyingRustTuple<'_> {
                fn from(value: isCompletedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isCompletedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isCompletedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isCompletedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isCompletedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isCompletedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isCompletedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isCompleted()";
            const SELECTOR: [u8; 4] = [250u8, 57u8, 28u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `previewCurrentEmission()` and selector `0x80572f18`.
```solidity
function previewCurrentEmission() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct previewCurrentEmissionCall {}
    ///Container type for the return parameters of the [`previewCurrentEmission()`](previewCurrentEmissionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct previewCurrentEmissionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<previewCurrentEmissionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: previewCurrentEmissionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for previewCurrentEmissionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<previewCurrentEmissionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: previewCurrentEmissionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for previewCurrentEmissionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for previewCurrentEmissionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = previewCurrentEmissionReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "previewCurrentEmission()";
            const SELECTOR: [u8; 4] = [128u8, 87u8, 47u8, 24u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address callerConfirmation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub callerConfirmation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.callerConfirmation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        callerConfirmation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callerConfirmation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setDecayFactor(uint256,uint256)` and selector `0x5880f49e`.
```solidity
function setDecayFactor(uint256 epoch, uint256 decayFactor) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setDecayFactorCall {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub decayFactor: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setDecayFactor(uint256,uint256)`](setDecayFactorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setDecayFactorReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setDecayFactorCall> for UnderlyingRustTuple<'_> {
                fn from(value: setDecayFactorCall) -> Self {
                    (value.epoch, value.decayFactor)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setDecayFactorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epoch: tuple.0,
                        decayFactor: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setDecayFactorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setDecayFactorReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setDecayFactorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setDecayFactorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setDecayFactorReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setDecayFactor(uint256,uint256)";
            const SELECTOR: [u8; 4] = [88u8, 128u8, 244u8, 158u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epoch),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.decayFactor),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setDecayFactors(uint256,uint256[])` and selector `0xd2bcc9ff`.
```solidity
function setDecayFactors(uint256 startEpoch, uint256[] memory decayFactorArray) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setDecayFactorsCall {
        #[allow(missing_docs)]
        pub startEpoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub decayFactorArray: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    ///Container type for the return parameters of the [`setDecayFactors(uint256,uint256[])`](setDecayFactorsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setDecayFactorsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setDecayFactorsCall> for UnderlyingRustTuple<'_> {
                fn from(value: setDecayFactorsCall) -> Self {
                    (value.startEpoch, value.decayFactorArray)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setDecayFactorsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        startEpoch: tuple.0,
                        decayFactorArray: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setDecayFactorsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setDecayFactorsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setDecayFactorsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setDecayFactorsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setDecayFactorsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setDecayFactors(uint256,uint256[])";
            const SELECTOR: [u8; 4] = [210u8, 188u8, 201u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startEpoch),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.decayFactorArray),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = supportsInterfaceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `syndicateToken()` and selector `0x5bdf6ca1`.
```solidity
function syndicateToken() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct syndicateTokenCall {}
    ///Container type for the return parameters of the [`syndicateToken()`](syndicateTokenCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct syndicateTokenReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<syndicateTokenCall> for UnderlyingRustTuple<'_> {
                fn from(value: syndicateTokenCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for syndicateTokenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<syndicateTokenReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: syndicateTokenReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for syndicateTokenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for syndicateTokenCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = syndicateTokenReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "syndicateToken()";
            const SELECTOR: [u8; 4] = [91u8, 223u8, 108u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `totalEmitted()` and selector `0xdf0244b1`.
```solidity
function totalEmitted() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalEmittedCall {}
    ///Container type for the return parameters of the [`totalEmitted()`](totalEmittedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalEmittedReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalEmittedCall> for UnderlyingRustTuple<'_> {
                fn from(value: totalEmittedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalEmittedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalEmittedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: totalEmittedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalEmittedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalEmittedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = totalEmittedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalEmitted()";
            const SELECTOR: [u8; 4] = [223u8, 2u8, 68u8, 177u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`EmissionsCalculator`](self) function calls.
    pub enum EmissionsCalculatorCalls {
        #[allow(missing_docs)]
        DECAY_MANAGER_ROLE(DECAY_MANAGER_ROLECall),
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        EMISSIONS_CAP(EMISSIONS_CAPCall),
        #[allow(missing_docs)]
        EMISSIONS_ROLE(EMISSIONS_ROLECall),
        #[allow(missing_docs)]
        SCALE(SCALECall),
        #[allow(missing_docs)]
        TOTAL_EPOCHS(TOTAL_EPOCHSCall),
        #[allow(missing_docs)]
        calculateAndMintEmission(calculateAndMintEmissionCall),
        #[allow(missing_docs)]
        calculateCumulativeProduct(calculateCumulativeProductCall),
        #[allow(missing_docs)]
        currentEpoch(currentEpochCall),
        #[allow(missing_docs)]
        decayFactors(decayFactorsCall),
        #[allow(missing_docs)]
        getDecayFactor(getDecayFactorCall),
        #[allow(missing_docs)]
        getEmissionsInfo(getEmissionsInfoCall),
        #[allow(missing_docs)]
        getRemainingSupply(getRemainingSupplyCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        initializeEmissions(initializeEmissionsCall),
        #[allow(missing_docs)]
        initialized(initializedCall),
        #[allow(missing_docs)]
        isCompleted(isCompletedCall),
        #[allow(missing_docs)]
        previewCurrentEmission(previewCurrentEmissionCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        setDecayFactor(setDecayFactorCall),
        #[allow(missing_docs)]
        setDecayFactors(setDecayFactorsCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
        #[allow(missing_docs)]
        syndicateToken(syndicateTokenCall),
        #[allow(missing_docs)]
        totalEmitted(totalEmittedCall),
    }
    #[automatically_derived]
    impl EmissionsCalculatorCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 255u8, 201u8, 167u8],
            [21u8, 142u8, 249u8, 62u8],
            [35u8, 102u8, 64u8, 185u8],
            [36u8, 138u8, 156u8, 163u8],
            [47u8, 47u8, 241u8, 93u8],
            [54u8, 86u8, 138u8, 190u8],
            [88u8, 128u8, 244u8, 158u8],
            [91u8, 223u8, 108u8, 161u8],
            [95u8, 21u8, 195u8, 201u8],
            [118u8, 103u8, 24u8, 8u8],
            [128u8, 87u8, 47u8, 24u8],
            [145u8, 209u8, 72u8, 84u8],
            [160u8, 136u8, 120u8, 125u8],
            [162u8, 23u8, 253u8, 223u8],
            [175u8, 202u8, 116u8, 5u8],
            [177u8, 152u8, 208u8, 40u8],
            [198u8, 58u8, 9u8, 68u8],
            [210u8, 188u8, 201u8, 255u8],
            [213u8, 71u8, 116u8, 31u8],
            [220u8, 165u8, 4u8, 182u8],
            [222u8, 190u8, 79u8, 31u8],
            [223u8, 2u8, 68u8, 177u8],
            [224u8, 245u8, 20u8, 116u8],
            [225u8, 242u8, 126u8, 184u8],
            [228u8, 183u8, 251u8, 115u8],
            [236u8, 237u8, 85u8, 38u8],
            [250u8, 57u8, 28u8, 100u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for EmissionsCalculatorCalls {
        const NAME: &'static str = "EmissionsCalculatorCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 27usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::DECAY_MANAGER_ROLE(_) => {
                    <DECAY_MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSIONS_CAP(_) => {
                    <EMISSIONS_CAPCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSIONS_ROLE(_) => {
                    <EMISSIONS_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SCALE(_) => <SCALECall as alloy_sol_types::SolCall>::SELECTOR,
                Self::TOTAL_EPOCHS(_) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::calculateAndMintEmission(_) => {
                    <calculateAndMintEmissionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::calculateCumulativeProduct(_) => {
                    <calculateCumulativeProductCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::currentEpoch(_) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::decayFactors(_) => {
                    <decayFactorsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getDecayFactor(_) => {
                    <getDecayFactorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getEmissionsInfo(_) => {
                    <getEmissionsInfoCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRemainingSupply(_) => {
                    <getRemainingSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::initializeEmissions(_) => {
                    <initializeEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initialized(_) => {
                    <initializedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isCompleted(_) => {
                    <isCompletedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::previewCurrentEmission(_) => {
                    <previewCurrentEmissionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setDecayFactor(_) => {
                    <setDecayFactorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setDecayFactors(_) => {
                    <setDecayFactorsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::syndicateToken(_) => {
                    <syndicateTokenCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::totalEmitted(_) => {
                    <totalEmittedCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<EmissionsCalculatorCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn initialized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <initializedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::initialized)
                    }
                    initialized
                },
                {
                    fn calculateCumulativeProduct(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <calculateCumulativeProductCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::calculateCumulativeProduct)
                    }
                    calculateCumulativeProduct
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn grantRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn renounceRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn setDecayFactor(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <setDecayFactorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::setDecayFactor)
                    }
                    setDecayFactor
                },
                {
                    fn syndicateToken(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <syndicateTokenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::syndicateToken)
                    }
                    syndicateToken
                },
                {
                    fn TOTAL_EPOCHS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::TOTAL_EPOCHS)
                    }
                    TOTAL_EPOCHS
                },
                {
                    fn currentEpoch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <currentEpochCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::currentEpoch)
                    }
                    currentEpoch
                },
                {
                    fn previewCurrentEmission(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <previewCurrentEmissionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::previewCurrentEmission)
                    }
                    previewCurrentEmission
                },
                {
                    fn hasRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn getEmissionsInfo(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <getEmissionsInfoCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::getEmissionsInfo)
                    }
                    getEmissionsInfo
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn decayFactors(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <decayFactorsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::decayFactors)
                    }
                    decayFactors
                },
                {
                    fn EMISSIONS_CAP(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <EMISSIONS_CAPCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::EMISSIONS_CAP)
                    }
                    EMISSIONS_CAP
                },
                {
                    fn initializeEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <initializeEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::initializeEmissions)
                    }
                    initializeEmissions
                },
                {
                    fn setDecayFactors(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <setDecayFactorsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::setDecayFactors)
                    }
                    setDecayFactors
                },
                {
                    fn revokeRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn DECAY_MANAGER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <DECAY_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::DECAY_MANAGER_ROLE)
                    }
                    DECAY_MANAGER_ROLE
                },
                {
                    fn EMISSIONS_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <EMISSIONS_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::EMISSIONS_ROLE)
                    }
                    EMISSIONS_ROLE
                },
                {
                    fn totalEmitted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <totalEmittedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::totalEmitted)
                    }
                    totalEmitted
                },
                {
                    fn getDecayFactor(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <getDecayFactorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::getDecayFactor)
                    }
                    getDecayFactor
                },
                {
                    fn calculateAndMintEmission(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <calculateAndMintEmissionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::calculateAndMintEmission)
                    }
                    calculateAndMintEmission
                },
                {
                    fn getRemainingSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <getRemainingSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::getRemainingSupply)
                    }
                    getRemainingSupply
                },
                {
                    fn SCALE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <SCALECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::SCALE)
                    }
                    SCALE
                },
                {
                    fn isCompleted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorCalls> {
                        <isCompletedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorCalls::isCompleted)
                    }
                    isCompleted
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::DECAY_MANAGER_ROLE(inner) => {
                    <DECAY_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSIONS_CAP(inner) => {
                    <EMISSIONS_CAPCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSIONS_ROLE(inner) => {
                    <EMISSIONS_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SCALE(inner) => {
                    <SCALECall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::TOTAL_EPOCHS(inner) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::calculateAndMintEmission(inner) => {
                    <calculateAndMintEmissionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::calculateCumulativeProduct(inner) => {
                    <calculateCumulativeProductCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::currentEpoch(inner) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::decayFactors(inner) => {
                    <decayFactorsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getDecayFactor(inner) => {
                    <getDecayFactorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getEmissionsInfo(inner) => {
                    <getEmissionsInfoCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRemainingSupply(inner) => {
                    <getRemainingSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initializeEmissions(inner) => {
                    <initializeEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::initialized(inner) => {
                    <initializedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isCompleted(inner) => {
                    <isCompletedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::previewCurrentEmission(inner) => {
                    <previewCurrentEmissionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setDecayFactor(inner) => {
                    <setDecayFactorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setDecayFactors(inner) => {
                    <setDecayFactorsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::syndicateToken(inner) => {
                    <syndicateTokenCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::totalEmitted(inner) => {
                    <totalEmittedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::DECAY_MANAGER_ROLE(inner) => {
                    <DECAY_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSIONS_CAP(inner) => {
                    <EMISSIONS_CAPCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSIONS_ROLE(inner) => {
                    <EMISSIONS_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SCALE(inner) => {
                    <SCALECall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::TOTAL_EPOCHS(inner) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::calculateAndMintEmission(inner) => {
                    <calculateAndMintEmissionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::calculateCumulativeProduct(inner) => {
                    <calculateCumulativeProductCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::currentEpoch(inner) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::decayFactors(inner) => {
                    <decayFactorsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getDecayFactor(inner) => {
                    <getDecayFactorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getEmissionsInfo(inner) => {
                    <getEmissionsInfoCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRemainingSupply(inner) => {
                    <getRemainingSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::initializeEmissions(inner) => {
                    <initializeEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initialized(inner) => {
                    <initializedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isCompleted(inner) => {
                    <isCompletedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::previewCurrentEmission(inner) => {
                    <previewCurrentEmissionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setDecayFactor(inner) => {
                    <setDecayFactorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setDecayFactors(inner) => {
                    <setDecayFactorsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::syndicateToken(inner) => {
                    <syndicateTokenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::totalEmitted(inner) => {
                    <totalEmittedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`EmissionsCalculator`](self) custom errors.
    pub enum EmissionsCalculatorErrors {
        #[allow(missing_docs)]
        AccessControlBadConfirmation(AccessControlBadConfirmation),
        #[allow(missing_docs)]
        AccessControlUnauthorizedAccount(AccessControlUnauthorizedAccount),
        #[allow(missing_docs)]
        CannotModifyPastEpoch(CannotModifyPastEpoch),
        #[allow(missing_docs)]
        EmissionsCompleted(EmissionsCompleted),
        #[allow(missing_docs)]
        InvalidDecayFactor(InvalidDecayFactor),
        #[allow(missing_docs)]
        InvalidEpoch(InvalidEpoch),
        #[allow(missing_docs)]
        ZeroAddress(ZeroAddress),
    }
    #[automatically_derived]
    impl EmissionsCalculatorErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [90u8, 230u8, 22u8, 47u8],
            [101u8, 203u8, 109u8, 203u8],
            [102u8, 151u8, 178u8, 50u8],
            [158u8, 145u8, 201u8, 231u8],
            [213u8, 178u8, 91u8, 99u8],
            [217u8, 46u8, 35u8, 61u8],
            [226u8, 81u8, 125u8, 63u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for EmissionsCalculatorErrors {
        const NAME: &'static str = "EmissionsCalculatorErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 7usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccessControlBadConfirmation(_) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AccessControlUnauthorizedAccount(_) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CannotModifyPastEpoch(_) => {
                    <CannotModifyPastEpoch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionsCompleted(_) => {
                    <EmissionsCompleted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidDecayFactor(_) => {
                    <InvalidDecayFactor as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidEpoch(_) => {
                    <InvalidEpoch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAddress(_) => {
                    <ZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<EmissionsCalculatorErrors>] = &[
                {
                    fn InvalidDecayFactor(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorErrors> {
                        <InvalidDecayFactor as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorErrors::InvalidDecayFactor)
                    }
                    InvalidDecayFactor
                },
                {
                    fn CannotModifyPastEpoch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorErrors> {
                        <CannotModifyPastEpoch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorErrors::CannotModifyPastEpoch)
                    }
                    CannotModifyPastEpoch
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorErrors::AccessControlBadConfirmation)
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn EmissionsCompleted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorErrors> {
                        <EmissionsCompleted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorErrors::EmissionsCompleted)
                    }
                    EmissionsCompleted
                },
                {
                    fn InvalidEpoch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorErrors> {
                        <InvalidEpoch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorErrors::InvalidEpoch)
                    }
                    InvalidEpoch
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EmissionsCalculatorErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EmissionsCalculatorErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                EmissionsCalculatorErrors::AccessControlUnauthorizedAccount,
                            )
                    }
                    AccessControlUnauthorizedAccount
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CannotModifyPastEpoch(inner) => {
                    <CannotModifyPastEpoch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionsCompleted(inner) => {
                    <EmissionsCompleted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidDecayFactor(inner) => {
                    <InvalidDecayFactor as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidEpoch(inner) => {
                    <InvalidEpoch as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CannotModifyPastEpoch(inner) => {
                    <CannotModifyPastEpoch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionsCompleted(inner) => {
                    <EmissionsCompleted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidDecayFactor(inner) => {
                    <InvalidDecayFactor as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidEpoch(inner) => {
                    <InvalidEpoch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`EmissionsCalculator`](self) events.
    pub enum EmissionsCalculatorEvents {
        #[allow(missing_docs)]
        DecayFactorSet(DecayFactorSet),
        #[allow(missing_docs)]
        EmissionMinted(EmissionMinted),
        #[allow(missing_docs)]
        EmissionsInitialized(EmissionsInitialized),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
    }
    #[automatically_derived]
    impl EmissionsCalculatorEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                22u8,
                15u8,
                193u8,
                149u8,
                214u8,
                229u8,
                54u8,
                145u8,
                211u8,
                13u8,
                128u8,
                76u8,
                225u8,
                144u8,
                220u8,
                9u8,
                71u8,
                24u8,
                145u8,
                103u8,
                126u8,
                67u8,
                67u8,
                59u8,
                145u8,
                167u8,
                166u8,
                19u8,
                28u8,
                18u8,
                165u8,
                154u8,
            ],
            [
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ],
            [
                75u8,
                155u8,
                80u8,
                2u8,
                215u8,
                131u8,
                72u8,
                100u8,
                196u8,
                216u8,
                174u8,
                135u8,
                247u8,
                191u8,
                14u8,
                196u8,
                177u8,
                117u8,
                42u8,
                191u8,
                126u8,
                7u8,
                3u8,
                181u8,
                179u8,
                47u8,
                241u8,
                30u8,
                51u8,
                121u8,
                137u8,
                188u8,
            ],
            [
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ],
            [
                193u8,
                44u8,
                96u8,
                171u8,
                194u8,
                22u8,
                40u8,
                110u8,
                242u8,
                94u8,
                52u8,
                177u8,
                128u8,
                90u8,
                12u8,
                61u8,
                218u8,
                115u8,
                228u8,
                194u8,
                253u8,
                108u8,
                243u8,
                96u8,
                232u8,
                7u8,
                167u8,
                169u8,
                231u8,
                49u8,
                103u8,
                57u8,
            ],
            [
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for EmissionsCalculatorEvents {
        const NAME: &'static str = "EmissionsCalculatorEvents";
        const COUNT: usize = 6usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<DecayFactorSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <DecayFactorSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DecayFactorSet)
                }
                Some(<EmissionMinted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionMinted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionMinted)
                }
                Some(
                    <EmissionsInitialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EmissionsInitialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionsInitialized)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleRevoked)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for EmissionsCalculatorEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::DecayFactorSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionMinted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionsInitialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::DecayFactorSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionMinted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionsInitialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`EmissionsCalculator`](self) contract instance.

See the [wrapper's documentation](`EmissionsCalculatorInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> EmissionsCalculatorInstance<T, P, N> {
        EmissionsCalculatorInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _syndicateToken: alloy::sol_types::private::Address,
        defaultAdmin: alloy::sol_types::private::Address,
        decayManager: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<EmissionsCalculatorInstance<T, P, N>>,
    > {
        EmissionsCalculatorInstance::<
            T,
            P,
            N,
        >::deploy(provider, _syndicateToken, defaultAdmin, decayManager)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _syndicateToken: alloy::sol_types::private::Address,
        defaultAdmin: alloy::sol_types::private::Address,
        decayManager: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        EmissionsCalculatorInstance::<
            T,
            P,
            N,
        >::deploy_builder(provider, _syndicateToken, defaultAdmin, decayManager)
    }
    /**A [`EmissionsCalculator`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`EmissionsCalculator`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct EmissionsCalculatorInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for EmissionsCalculatorInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("EmissionsCalculatorInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > EmissionsCalculatorInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`EmissionsCalculator`](self) contract instance.

See the [wrapper's documentation](`EmissionsCalculatorInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            _syndicateToken: alloy::sol_types::private::Address,
            defaultAdmin: alloy::sol_types::private::Address,
            decayManager: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<EmissionsCalculatorInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                _syndicateToken,
                defaultAdmin,
                decayManager,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            _syndicateToken: alloy::sol_types::private::Address,
            defaultAdmin: alloy::sol_types::private::Address,
            decayManager: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            _syndicateToken,
                            defaultAdmin,
                            decayManager,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> EmissionsCalculatorInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> EmissionsCalculatorInstance<T, P, N> {
            EmissionsCalculatorInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > EmissionsCalculatorInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`DECAY_MANAGER_ROLE`] function.
        pub fn DECAY_MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DECAY_MANAGER_ROLECall, N> {
            self.call_builder(&DECAY_MANAGER_ROLECall {})
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall {})
        }
        ///Creates a new call builder for the [`EMISSIONS_CAP`] function.
        pub fn EMISSIONS_CAP(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSIONS_CAPCall, N> {
            self.call_builder(&EMISSIONS_CAPCall {})
        }
        ///Creates a new call builder for the [`EMISSIONS_ROLE`] function.
        pub fn EMISSIONS_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSIONS_ROLECall, N> {
            self.call_builder(&EMISSIONS_ROLECall {})
        }
        ///Creates a new call builder for the [`SCALE`] function.
        pub fn SCALE(&self) -> alloy_contract::SolCallBuilder<T, &P, SCALECall, N> {
            self.call_builder(&SCALECall {})
        }
        ///Creates a new call builder for the [`TOTAL_EPOCHS`] function.
        pub fn TOTAL_EPOCHS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, TOTAL_EPOCHSCall, N> {
            self.call_builder(&TOTAL_EPOCHSCall {})
        }
        ///Creates a new call builder for the [`calculateAndMintEmission`] function.
        pub fn calculateAndMintEmission(
            &self,
            to: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, calculateAndMintEmissionCall, N> {
            self.call_builder(&calculateAndMintEmissionCall { to })
        }
        ///Creates a new call builder for the [`calculateCumulativeProduct`] function.
        pub fn calculateCumulativeProduct(
            &self,
            fromEpoch: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, calculateCumulativeProductCall, N> {
            self.call_builder(
                &calculateCumulativeProductCall {
                    fromEpoch,
                },
            )
        }
        ///Creates a new call builder for the [`currentEpoch`] function.
        pub fn currentEpoch(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, currentEpochCall, N> {
            self.call_builder(&currentEpochCall {})
        }
        ///Creates a new call builder for the [`decayFactors`] function.
        pub fn decayFactors(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, decayFactorsCall, N> {
            self.call_builder(&decayFactorsCall { _0 })
        }
        ///Creates a new call builder for the [`getDecayFactor`] function.
        pub fn getDecayFactor(
            &self,
            epoch: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getDecayFactorCall, N> {
            self.call_builder(&getDecayFactorCall { epoch })
        }
        ///Creates a new call builder for the [`getEmissionsInfo`] function.
        pub fn getEmissionsInfo(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getEmissionsInfoCall, N> {
            self.call_builder(&getEmissionsInfoCall {})
        }
        ///Creates a new call builder for the [`getRemainingSupply`] function.
        pub fn getRemainingSupply(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRemainingSupplyCall, N> {
            self.call_builder(&getRemainingSupplyCall {})
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`initializeEmissions`] function.
        pub fn initializeEmissions(
            &self,
            defaultDecayFactor: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, initializeEmissionsCall, N> {
            self.call_builder(
                &initializeEmissionsCall {
                    defaultDecayFactor,
                },
            )
        }
        ///Creates a new call builder for the [`initialized`] function.
        pub fn initialized(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, initializedCall, N> {
            self.call_builder(&initializedCall {})
        }
        ///Creates a new call builder for the [`isCompleted`] function.
        pub fn isCompleted(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, isCompletedCall, N> {
            self.call_builder(&isCompletedCall {})
        }
        ///Creates a new call builder for the [`previewCurrentEmission`] function.
        pub fn previewCurrentEmission(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, previewCurrentEmissionCall, N> {
            self.call_builder(&previewCurrentEmissionCall {})
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            callerConfirmation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceRoleCall, N> {
            self.call_builder(
                &renounceRoleCall {
                    role,
                    callerConfirmation,
                },
            )
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`setDecayFactor`] function.
        pub fn setDecayFactor(
            &self,
            epoch: alloy::sol_types::private::primitives::aliases::U256,
            decayFactor: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setDecayFactorCall, N> {
            self.call_builder(
                &setDecayFactorCall {
                    epoch,
                    decayFactor,
                },
            )
        }
        ///Creates a new call builder for the [`setDecayFactors`] function.
        pub fn setDecayFactors(
            &self,
            startEpoch: alloy::sol_types::private::primitives::aliases::U256,
            decayFactorArray: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, setDecayFactorsCall, N> {
            self.call_builder(
                &setDecayFactorsCall {
                    startEpoch,
                    decayFactorArray,
                },
            )
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<T, &P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`syndicateToken`] function.
        pub fn syndicateToken(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, syndicateTokenCall, N> {
            self.call_builder(&syndicateTokenCall {})
        }
        ///Creates a new call builder for the [`totalEmitted`] function.
        pub fn totalEmitted(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, totalEmittedCall, N> {
            self.call_builder(&totalEmittedCall {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > EmissionsCalculatorInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`DecayFactorSet`] event.
        pub fn DecayFactorSet_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DecayFactorSet, N> {
            self.event_filter::<DecayFactorSet>()
        }
        ///Creates a new event filter for the [`EmissionMinted`] event.
        pub fn EmissionMinted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionMinted, N> {
            self.event_filter::<EmissionMinted>()
        }
        ///Creates a new event filter for the [`EmissionsInitialized`] event.
        pub fn EmissionsInitialized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionsInitialized, N> {
            self.event_filter::<EmissionsInitialized>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
    }
}
