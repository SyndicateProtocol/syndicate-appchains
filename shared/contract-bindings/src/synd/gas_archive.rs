/**

Generated by the following Solidity interface...
```solidity
interface GasArchive {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error AccountDoesNotExistInProof();
    error AlreadySubmitted();
    error CannotSubmitProofForSettlementChain();
    error ChainIDNotFound();
    error EmptyDataHash();
    error EmptySlot();
    error EpochAlreadyCompleted();
    error InvalidData();
    error InvalidEthereumBlockHeader();
    error InvalidInitialization();
    error InvalidProof();
    error InvalidSeqChainBlockHeader();
    error NotArchivedEpoch();
    error NotBlockHashSender();
    error NotInitializing();
    error OldSettlementChainBlockNumber();
    error SequencingChainAlreadyExists();
    error ZeroAddress();
    error ZeroLengthArray();

    event EpochCompleted(uint256 indexed epoch);
    event EpochDataValidated(uint256 indexed epoch, uint256 indexed seqChainID, bytes32 dataHash);
    event EpochExpectedChainsUpdated(uint256 indexed epoch, uint256[] chainIds);
    event GasAggregatorAddressUpdated(address indexed oldAddress, address indexed newAddress);
    event Initialized(uint64 version);
    event LastKnownBlockHashesUpdated(bytes32 ethBlockHash, bytes32 settlementBlockHash, uint256 settlementBlockNumber);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    constructor();

    function AGGREGATED_EPOCH_DATA_HASH_SLOT() external view returns (uint256);
    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function HEADER_STATE_ROOT_INDEX() external view returns (uint256);
    function STORAGE_ROOT_ACCOUNT_FIELDS_INDEX() external view returns (uint256);
    function addSequencingChain(uint256 chainID, address aggregatorAddress, address bridgeAddress, uint256 storageSlotIndex) external;
    function blockHashSender() external view returns (address);
    function confirmEpochDataHash(uint256 epoch, uint256 seqChainID, bytes memory seqChainBlockHeader, bytes[] memory seqChainAccountProof, bytes[] memory seqChainStorageProof) external;
    function confirmSequencingChainBlockHash(uint256 seqChainID, bytes32 sendRoot, bytes memory ethereumBlockHeader, bytes[] memory ethereumAccountProof, bytes[] memory ethereumStorageProof) external;
    function epochAppchainEmissionsReceiver(uint256 epoch, uint256 appchainId) external view returns (address receiver);
    function epochAppchainIDs(uint256 epoch, uint256) external view returns (uint256 appchainIds);
    function epochAppchainTokensUsed(uint256 epoch, uint256 appchainId) external view returns (uint256 tokens);
    function epochChainDataSubmitted(uint256 epoch, uint256 chainId) external view returns (bool submitted);
    function epochCompleted(uint256 epoch) external view returns (bool completed);
    function epochExpectedChains(uint256 epoch, uint256) external view returns (uint256 chainIds);
    function epochTotalTokensUsed(uint256 epoch) external view returns (uint256 totalTokens);
    function epochVerifiedDataHash(uint256 epoch, uint256 seqChainID) external view returns (bytes32 dataHash);
    function getActiveAppchainIds(uint256 epochIndex) external view returns (uint256[] memory _chainIDs);
    function getAppchainGasFees(uint256 epochIndex, uint256 appchainId) external view returns (uint256);
    function getAppchainRewardsReceiver(uint256 epochIndex, uint256 appchainId) external view returns (address);
    function getEpochExpectedChains(uint256 epochIndex) external view returns (uint256[] memory);
    function getEpochProgress(uint256 epochIndex) external view returns (bool completed, uint256 totalExpected, uint256 totalSubmitted);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function getTotalGasFees(uint256 epochIndex) external view returns (uint256);
    function grantRole(bytes32 role, address account) external;
    function hasChainSubmittedForEpoch(uint256 epochIndex, uint256 chainId) external view returns (bool);
    function hasRole(bytes32 role, address account) external view returns (bool);
    function initialize(address _blockHashSender, uint256 _settlementChainID, address admin) external;
    function lastKnownEthereumBlockHash() external view returns (bytes32);
    function lastKnownSeqChainBlockHashes(uint256 chainId) external view returns (bytes32 blockHash);
    function lastKnownSettlementChainBlockHash() external view returns (bytes32);
    function lastKnownSettlementChainBlockNumber() external view returns (uint256);
    function removeSeqChain(uint256 chainID) external;
    function renounceRole(bytes32 role, address callerConfirmation) external;
    function revokeRole(bytes32 role, address account) external;
    function seqChainEthOutbox(uint256 chainId) external view returns (address outboxAddress);
    function seqChainEthSendRootStorageSlot(uint256 chainId) external view returns (uint256 sendRootStorageSlotIndex);
    function seqChainGasAggregatorAddresses(uint256 chainId) external view returns (address aggregatorAddress);
    function seqChainIDs(uint256) external view returns (uint256);
    function setBlockHashSender(address newBlockHashSender) external;
    function setEpochExpectedChains(uint256 epoch, uint256[] memory chainIds) external;
    function setLastKnownBlockHashes(bytes32 ethBlockHash, bytes32 settlementBlockHash, uint256 settlementBlockNumber) external;
    function settlementChainID() external view returns (uint256);
    function submitEpochPreImageData(uint256 epoch, uint256 seqChainID, uint256[] memory appchains, uint256[] memory tokens, address[] memory emissionsReceivers) external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "AGGREGATED_EPOCH_DATA_HASH_SLOT",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "HEADER_STATE_ROOT_INDEX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "STORAGE_ROOT_ACCOUNT_FIELDS_INDEX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "addSequencingChain",
    "inputs": [
      {
        "name": "chainID",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "aggregatorAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "bridgeAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "storageSlotIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "blockHashSender",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "confirmEpochDataHash",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "seqChainID",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "seqChainBlockHeader",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "seqChainAccountProof",
        "type": "bytes[]",
        "internalType": "bytes[]"
      },
      {
        "name": "seqChainStorageProof",
        "type": "bytes[]",
        "internalType": "bytes[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "confirmSequencingChainBlockHash",
    "inputs": [
      {
        "name": "seqChainID",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "sendRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "ethereumBlockHeader",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "ethereumAccountProof",
        "type": "bytes[]",
        "internalType": "bytes[]"
      },
      {
        "name": "ethereumStorageProof",
        "type": "bytes[]",
        "internalType": "bytes[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "epochAppchainEmissionsReceiver",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "receiver",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochAppchainIDs",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "appchainIds",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochAppchainTokensUsed",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "tokens",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochChainDataSubmitted",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "submitted",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochCompleted",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "completed",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochExpectedChains",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "chainIds",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochTotalTokensUsed",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "totalTokens",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "epochVerifiedDataHash",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "seqChainID",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "dataHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getActiveAppchainIds",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "_chainIDs",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAppchainGasFees",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAppchainRewardsReceiver",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getEpochExpectedChains",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getEpochProgress",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "completed",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "totalExpected",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "totalSubmitted",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getTotalGasFees",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasChainSubmittedForEpoch",
    "inputs": [
      {
        "name": "epochIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "_blockHashSender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_settlementChainID",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "admin",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "lastKnownEthereumBlockHash",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "lastKnownSeqChainBlockHashes",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "blockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "lastKnownSettlementChainBlockHash",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "lastKnownSettlementChainBlockNumber",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "removeSeqChain",
    "inputs": [
      {
        "name": "chainID",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "callerConfirmation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "seqChainEthOutbox",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "outboxAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "seqChainEthSendRootStorageSlot",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "sendRootStorageSlotIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "seqChainGasAggregatorAddresses",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "aggregatorAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "seqChainIDs",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setBlockHashSender",
    "inputs": [
      {
        "name": "newBlockHashSender",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setEpochExpectedChains",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "chainIds",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setLastKnownBlockHashes",
    "inputs": [
      {
        "name": "ethBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "settlementBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "settlementBlockNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "settlementChainID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "submitEpochPreImageData",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "seqChainID",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "appchains",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "tokens",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "emissionsReceivers",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "EpochCompleted",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EpochDataValidated",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "seqChainID",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "dataHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EpochExpectedChainsUpdated",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "chainIds",
        "type": "uint256[]",
        "indexed": false,
        "internalType": "uint256[]"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "GasAggregatorAddressUpdated",
    "inputs": [
      {
        "name": "oldAddress",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newAddress",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "LastKnownBlockHashesUpdated",
    "inputs": [
      {
        "name": "ethBlockHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "settlementBlockHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "settlementBlockNumber",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccessControlBadConfirmation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AccessControlUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "neededRole",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "AccountDoesNotExistInProof",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AlreadySubmitted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CannotSubmitProofForSettlementChain",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ChainIDNotFound",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyDataHash",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptySlot",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EpochAlreadyCompleted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidData",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidEthereumBlockHeader",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidInitialization",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidProof",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidSeqChainBlockHeader",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotArchivedEpoch",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotBlockHashSender",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotInitializing",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OldSettlementChainBlockNumber",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SequencingChainAlreadyExists",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroLengthArray",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod GasArchive {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080806040523460aa575f5160206135a95f395f51905f525460ff8160401c16609b576002600160401b03196001600160401b038216016049575b6040516134fa90816100af8239f35b6001600160401b0319166001600160401b039081175f5160206135a95f395f51905f525581527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d290602090a15f80603a565b63f92ee8a960e01b5f5260045ffd5b5f80fdfe60806040526004361015610011575f80fd5b5f3560e01c806301ffc9a7146102cf5780630344571f146102ca578063133bf89f146102c557806319771640146102c05780631bf4951c146102bb57806322623897146102b657806323afb0ff146102b1578063248a9ca3146102ac578063285f2446146102a75780632cd078b8146102a25780632f2ff15d1461029d57806330c709b614610298578063362b81541461029357806336568abe1461028e57806347dff69d146102895780634e6da2a414610284578063529f4b561461027f57806355fcc5561461027a5780635a633080146102395780635b1817e8146102755780635d579a6114610270578063650e13121461026b5780636b4d17ad146102665780636ba3d17f146102615780637a7f34e81461025c5780637c6edb3e146102575780637c715094146102525780637c901d7b1461024d5780638d935e1d146102485780638dd50eee1461024357806391d148541461023e57806395814bf514610239578063a217fddf14610234578063c350a1b51461022f578063ce537c9f1461022a578063d26bcc8014610225578063d547741f14610220578063e18b4dae1461021b578063e8c46c2814610216578063ec828a9114610211578063ef5122211461020c578063fd79d3e114610207578063fdd54123146102025763ff87c18c146101fd575f80fd5b611456565b611416565b6113ec565b6113cf565b61134a565b61132f565b611314565b6112b4565b611264565b611225565b610faa565b610f90565b610b8f565b610f11565b610ed1565b610eb4565b610e2d565b610dc5565b610d61565b610d37565b610cff565b610ce4565b610cc0565b610c79565b610bcc565b610b57565b610ad0565b6109d6565b6109ac565b61093e565b61090b565b6108dc565b610877565b6107f2565b610736565b6106e4565b6106c8565b6106ab565b610624565b61050c565b6104cb565b6103a5565b34610370576020600319360112610370576004357fffffffff00000000000000000000000000000000000000000000000000000000811680910361037057807f7965db0b0000000000000000000000000000000000000000000000000000000060209214908115610346575b506040519015158152f35b7f01ffc9a7000000000000000000000000000000000000000000000000000000009150145f61033b565b5f80fd5b9181601f840112156103705782359167ffffffffffffffff8311610370576020808501948460051b01011161037057565b346103705760406003193601126103705760043560243567ffffffffffffffff8111610370576103d9903690600401610374565b91906103e3612116565b815f52600c60205260ff60405f20541661048557815f52600d60205261040b60405f2061156a565b5f5b83811061045557507fa0fea12a5dfdb3ebf0b7c49a7ddd5ffdd3e5b2d7574ff16b0a1032edc19d658b61045393839261044b60405192839283611672565b0390a261220b565b005b60019061047f61046d855f52600d60205260405f2090565b61047883888761159a565b35906115f8565b0161040d565b7ffd93c15f000000000000000000000000000000000000000000000000000000005f5260045ffd5b73ffffffffffffffffffffffffffffffffffffffff81160361037057565b34610370576080600319360112610370576104536004356024356104ee816104ad565b604435906104fb826104ad565b60643592610507612116565b611686565b34610370576060600319360112610370576004356024356044359073ffffffffffffffffffffffffffffffffffffffff6003541633036105ce576002548211156105a65761055e925f55600155600255565b5f54600154600254604080519384526020840192909252908201527f78722ed9742b4dcda705d010fff7460a351e906f8223cff2d23a55b44b66427c9080606081015b0390a1005b7fc36ba423000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f24b2e7fd000000000000000000000000000000000000000000000000000000005f5260045ffd5b9181601f840112156103705782359167ffffffffffffffff8311610370576020838186019501011161037057565b346103705760a06003193601126103705760043560243560443567ffffffffffffffff81116103705761065b9036906004016105f6565b60649391933567ffffffffffffffff81116103705761067e903690600401610374565b916084359567ffffffffffffffff8711610370576106a3610453973690600401610374565b969095611896565b34610370575f600319360112610370576020600454604051908152f35b34610370575f6003193601126103705760205f54604051908152f35b3461037057602060031936011261037057602061072e6004355f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800602052600160405f20015490565b604051908152f35b346103705760406003193601126103705760043560243590805f52600c60205260ff60405f20541615610791575f52601060205260405f20905f5260205261078d60405f2054604051918291829190602083019252565b0390f35b7fc5b14571000000000000000000000000000000000000000000000000000000005f5260045ffd5b60206040818301928281528451809452019201905f5b8181106107dc5750505090565b82518452602093840193909201916001016107cf565b3461037057602060031936011261037057600435805f52600c60205260ff60405f20541615610791575f52600f60205260405f206040519081602082549182815201915f5260205f20905f5b8181106108615761078d8561085581870382611821565b604051918291826107b9565b825484526020909301926001928301920161083e565b346103705760406003193601126103705761045360243560043561089a826104ad565b6108d76108d2825f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800602052600160405f20015490565b61217e565b612605565b34610370576020600319360112610370576004355f52600c602052602060ff60405f2054166040519015158152f35b34610370575f60031936011261037057602073ffffffffffffffffffffffffffffffffffffffff60035416604051908152f35b346103705760406003193601126103705760043560243561095e816104ad565b3373ffffffffffffffffffffffffffffffffffffffff8216036109845761045391612722565b7f6697b232000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610370576020600319360112610370576004355f52600e602052602060405f2054604051908152f35b34610370576020600319360112610370576004355f815f52600c60205260ff60405f20541690825f52600d60205260405f2092604051808560208297549384815201905f5260205f20925f5b818110610ab7575050610a3792500385611821565b83515f5b8551811015610a9b57610a7a610a73610a5c855f52600a60205260405f2090565b610a66848a6119e7565b515f5260205260405f2090565b5460ff1690565b610a87575b600101610a3b565b92610a936001916119fb565b939050610a7f565b5060408051851515815260208101929092528101839052606090f35b8454835260019485019489945060209093019201610a22565b346103705760a06003193601126103705760043560243560443567ffffffffffffffff811161037057610b07903690600401610374565b60649391933567ffffffffffffffff811161037057610b2a903690600401610374565b916084359567ffffffffffffffff871161037057610b4f610453973690600401610374565b969095611af2565b3461037057604060031936011261037057600435602435905f52601060205260405f20905f52602052602060405f2054604051908152f35b3461037057604060031936011261037057600435602435905f52600a60205260405f20905f52602052602060ff60405f2054166040519015158152f35b3461037057604060031936011261037057600435602435905f52601160205260405f20905f52602052602073ffffffffffffffffffffffffffffffffffffffff60405f205416604051908152f35b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b600554811015610c5f5760055f5260205f2001905f90565b610c1a565b8054821015610c5f575f5260205f2001905f90565b3461037057604060031936011261037057600435602435905f52600d60205260405f20805482101561037057602091610cb191610c64565b90549060031b1c604051908152f35b3461037057602060031936011261037057610453600435610cdf612116565b611de5565b34610370575f60031936011261037057602060405160028152f35b3461037057604060031936011261037057600435602435905f52600b60205260405f20905f52602052602060405f2054604051908152f35b34610370576020600319360112610370576004355f526009602052602060405f2054604051908152f35b34610370576020600319360112610370576004355f52600d60205260405f206040519081602082549182815201915f5260205f20905f5b818110610daf5761078d8561085581870382611821565b8254845260209093019260019283019201610d98565b346103705760206003193601126103705773ffffffffffffffffffffffffffffffffffffffff600435610df7816104ad565b610dff612116565b167fffffffffffffffffffffffff000000000000000000000000000000000000000060035416176003555f80f35b346103705760a06003193601126103705760043560243560443567ffffffffffffffff811161037057610e649036906004016105f6565b60649391933567ffffffffffffffff811161037057610e87903690600401610374565b916084359567ffffffffffffffff871161037057610eac610453973690600401610374565b969095611ef3565b34610370575f600319360112610370576020600254604051908152f35b34610370576020600319360112610370576004355f526006602052602073ffffffffffffffffffffffffffffffffffffffff60405f205416604051908152f35b3461037057604060031936011261037057602060ff610f84602435600435610f38826104ad565b5f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800845260405f209073ffffffffffffffffffffffffffffffffffffffff165f5260205260405f2090565b54166040519015158152f35b34610370575f6003193601126103705760206040515f8152f35b3461037057606060031936011261037057600435610fc7816104ad565b60243590604435610fd7816104ad565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00549267ffffffffffffffff61102660ff604087901c1615611018565b1590565b9567ffffffffffffffff1690565b168015908161121d575b6001149081611213575b15908161120a575b506111e2576110c392846110ba60017fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000007ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005416177ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0055565b61116757612051565b6110c957005b6111347fffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0054167ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0055565b604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29080602081016105a1565b6111dd680100000000000000007fffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005416177ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0055565b612051565b7ff92ee8a9000000000000000000000000000000000000000000000000000000005f5260045ffd5b9050155f611042565b303b15915061103a565b859150611030565b3461037057602060031936011261037057600435805f52600c60205260ff60405f20541615610791575f52600e602052602060405f2054604051908152f35b34610370576020600319360112610370576004356005548110156103705760209060055f527f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db00154604051908152f35b34610370576040600319360112610370576104536024356004356112d7826104ad565b61130f6108d2825f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800602052600160405f20015490565b612722565b34610370575f60031936011261037057602060405160038152f35b34610370575f60031936011261037057602060405160078152f35b346103705760406003193601126103705760043560243590805f52600c60205260ff60405f20541615610791575f52601160205260405f20905f5260205261078d73ffffffffffffffffffffffffffffffffffffffff60405f2054166040519182918291909173ffffffffffffffffffffffffffffffffffffffff6020820193169052565b34610370575f600319360112610370576020600154604051908152f35b34610370576020600319360112610370576004355f526008602052602060405f2054604051908152f35b34610370576020600319360112610370576004355f526007602052602073ffffffffffffffffffffffffffffffffffffffff60405f205416604051908152f35b3461037057604060031936011261037057600435602435905f52600f60205260405f20805482101561037057602091610cb191610c64565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b908160011b91808304600214901517156114fe57565b6114bb565b9161151c918354905f199060031b92831b921b19161790565b9055565b906801000000000000000081116115655781549181815582821061154357505050565b5f5260205f2091820191015b81811061155a575050565b5f815560010161154f565b61148e565b8054905f815581611579575050565b5f5260205f20908101905b81811061158f575050565b5f8155600101611584565b9190811015610c5f5760051b0190565b600554680100000000000000008110156115655760018101600555600554811015610c5f5760055f527f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db00155565b80549068010000000000000000821015611565578161161f91600161151c94018155610c64565b81939154905f199060031b92831b921b19161790565b90918281527f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83116103705760209260051b809284830137010190565b916020611683938181520191611635565b90565b9073ffffffffffffffffffffffffffffffffffffffff6116cb6116b1845f52600660205260405f2090565b5473ffffffffffffffffffffffffffffffffffffffff1690565b166117dd5773ffffffffffffffffffffffffffffffffffffffff81161561179a5760045482146117c25773ffffffffffffffffffffffffffffffffffffffff83161561179a576117979261177761178992611725856115aa565b611737855f52600660205260405f2090565b9073ffffffffffffffffffffffffffffffffffffffff167fffffffffffffffffffffffff0000000000000000000000000000000000000000825416179055565b611737835f52600760205260405f2090565b5f52600860205260405f2090565b55565b7fd92e233d000000000000000000000000000000000000000000000000000000005f5260045ffd5b91506117db9250611737905f52600660205260405f2090565b565b7fdf650a00000000000000000000000000000000000000000000000000000000005f5260045ffd5b6040810190811067ffffffffffffffff82111761156557604052565b90601f601f19910116810190811067ffffffffffffffff82111761156557604052565b67ffffffffffffffff811161156557601f01601f191660200190565b92919261186c82611844565b9161187a6040519384611821565b829481845281830111610370578281602093845f960137010152565b969390949195926118a8368289611860565b602081519101205f5403611981575f8881526007602052604090205473ffffffffffffffffffffffffffffffffffffffff1695861561192857916119146117979896949261190e6119199997956119078d5f52600860205260405f2090565b54906122dc565b97612302565b6123c9565b915f52600960205260405f2090565b8860045414611959577f1242e9bb000000000000000000000000000000000000000000000000000000005f5260045ffd5b7fda261280000000000000000000000000000000000000000000000000000000005f5260045ffd5b7fefb64cf8000000000000000000000000000000000000000000000000000000005f5260045ffd5b805160021015610c5f5760600190565b805160101015610c5f576102200190565b805115610c5f5760200190565b805160011015610c5f5760400190565b8051821015610c5f5760209160051b010190565b5f1981146114fe5760010190565b929093611a27602095611a3494989798606087526060870191611635565b9184830386860152611635565b9060408183039101528281520191905f5b818110611a525750505090565b90919260208060019273ffffffffffffffffffffffffffffffffffffffff8735611a7b816104ad565b168152019401929101611a45565b9067ffffffffffffffff831161156557611aa38383611520565b905f5260205f205f5b838110611ab95750505050565b600190602084359401938184015501611aac565b90600182018092116114fe57565b919082018092116114fe57565b35611683816104ad565b959796909497929192611b21610a7387611b148a5f52600a60205260405f2090565b905f5260205260405f2090565b611ce157611b3b86611b14895f52600b60205260405f2090565b548482611b678c611b59876040519485938d8c60208701998a611a09565b03601f198101835282611821565b51902003611cb95797939291905f98611b928385611b8d8b5f52600f60205260405f2090565b611a89565b5f955b838710611c1c5750505050505050611c165f916117db9495611bbf855f52600e60205260405f2090565b55611c04611bd982611b14875f52600a60205260405f2090565b60017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00825416179055565b611b14845f52600b60205260405f2090565b5561220b565b90919293949599611c3b600191611c348d858b61159a565b3590611adb565b9a611c4781848a61159a565b35611c80611c78611c608d5f52601060205260405f2090565b611c6b858b8d61159a565b355f5260205260405f2090565b918254611adb565b9055611cad611c98611c9383888861159a565b611ae8565b611737611c608d5f52601160205260405f2090565b01959493929190611b95565b7f5cb045db000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f9fbfc589000000000000000000000000000000000000000000000000000000005f5260045ffd5b905f1982019182116114fe57565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff4082019182116114fe57565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8082019182116114fe57565b60200390602082116114fe57565b919082039182116114fe57565b6005548015611db8575f19810190600554821015610c5f575f195f916005835260208320010155600555565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603160045260245ffd5b6004548114611ede5760055480915f5b838110611ebc575b50828214611e9457611e3a61179792611e34611e2e611e24611e1f5f98611d09565b610c47565b90549060031b1c90565b91610c47565b90611503565b611e42611d8c565b611e7f611e57825f52600660205260405f2090565b7fffffffffffffffffffffffff00000000000000000000000000000000000000008154169055565b611789611e57825f52600760205260405f2090565b7f1242e9bb000000000000000000000000000000000000000000000000000000005f5260045ffd5b81611ec9611e2483610c47565b14611ed657600101611df5565b91505f611dfd565b611e576117db915f52600660205260405f2090565b9693909592949194611f14610a7388611b148b5f52600a60205260405f2090565b8015612032575b611ce157611f2a368288611860565b60208151910120611f43885f52600960205260405f2090565b546004548914612029575b0361200157611f5e958789612837565b908115611fd95780611fb491847f2c3f443599c6268aced473e7660b40746ea394d519179ea3f60f382974a2e78e60405180611f9f88829190602083019252565b0390a3611b14845f52600b60205260405f2090565b55611fc7815f52600d60205260405f2090565b5415611fd05750565b6117db90612914565b7f9a0cce53000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f9d8cbacd000000000000000000000000000000000000000000000000000000005f5260045ffd5b50600154611f4e565b5061204987611b148a5f52600b60205260405f2090565b541515611f1b565b73ffffffffffffffffffffffffffffffffffffffff16801561179a5773ffffffffffffffffffffffffffffffffffffffff83161561179a577fffffffffffffffffffffffff0000000000000000000000000000000000000000600354161760035560045560ff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005460401c16156120ee576120eb9061251e565b50565b7fd7e6bcf8000000000000000000000000000000000000000000000000000000005f5260045ffd5b335f9081527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d602052604090205460ff161561214e57565b7fe2517d3f000000000000000000000000000000000000000000000000000000005f52336004525f60245260445ffd5b805f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b62680060205260ff6121d23360405f209073ffffffffffffffffffffffffffffffffffffffff165f5260205260405f2090565b5416156121dc5750565b7fe2517d3f000000000000000000000000000000000000000000000000000000005f523360045260245260445ffd5b805f52600d60205260405f20604051808260208294549384815201905f5260205f20925f5b8181106122c357505061224592500382611821565b5f5b815181101561228657612275611014610a7361226b865f52600a60205260405f2090565b610a6685876119e7565b61228157600101612247565b505050565b505061229d611bd9825f52600c60205260405f2090565b7f78df938181afcb28eaa7d099235bbf9877832d6faafe36d1ea70916f3ace33e05f80a2565b8454835260019485019486945060209093019201612230565b9060405190602082019283526040820152604081526122fc606082611821565b51902090565b6123146123199161231e933691611860565b612982565b6129fd565b805160031015610c5f576080611683910151612aaa565b67ffffffffffffffff81116115655760051b60200190565b92919261235982612335565b936123676040519586611821565b602085848152019260051b8201918183116103705780935b83851061238d575050505050565b843567ffffffffffffffff811161037057820183601f82011215610370576020916123be8583858095359101611860565b81520194019361237f565b909161244361243e6123149461244996989997996040517fffffffffffffffffffffffffffffffffffffffff000000000000000000000000602082019260601b1682526014815261241b603482611821565b5190209360405194602086015260208552612437604086611821565b369161234d565b612aec565b91612b96565b918251156124f65761244361243e6124b0926124be9661243761247f6124796124746123149a6129fd565b6119a9565b51612aaa565b9660405161249a81611b596020820194859190602083019252565b5190206040519687916020830160209181520190565b03601f198101875286611821565b8051156124ce5761168390612aaa565b7f3477dcda000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f547706af000000000000000000000000000000000000000000000000000000005f5260045ffd5b73ffffffffffffffffffffffffffffffffffffffff81165f9081527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d602052604090205460ff166126005773ffffffffffffffffffffffffffffffffffffffff165f8181527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d6020526040812080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790553391907f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d8180a4600190565b505f90565b805f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b62680060205260ff6126598360405f209073ffffffffffffffffffffffffffffffffffffffff165f5260205260405f2090565b541661271c57805f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b6268006020526126b18260405f209073ffffffffffffffffffffffffffffffffffffffff165f5260205260405f2090565b60017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0082541617905573ffffffffffffffffffffffffffffffffffffffff339216907f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d5f80a4600190565b50505f90565b805f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b62680060205260ff6127768360405f209073ffffffffffffffffffffffffffffffffffffffff165f5260205260405f2090565b54161561271c57805f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b6268006020526127cf8260405f209073ffffffffffffffffffffffffffffffffffffffff165f5260205260405f2090565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00815416905573ffffffffffffffffffffffffffffffffffffffff339216907ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b5f80a4600190565b95929693909491945f52600660205273ffffffffffffffffffffffffffffffffffffffff60405f205416948515611e94576116839761287591612302565b95604051602081019182526007604082015260408152612896606082611821565b519020956123c9565b600581146120eb576005549067ffffffffffffffff8211611565576128c48282611520565b5f908152602081207f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db080545b8484106128fe575050505050565b60018091920193845492818501550192906128f0565b805f52600d60205261292860405f2061289f565b600454805f52600660205273ffffffffffffffffffffffffffffffffffffffff60405f205416612956575050565b6117db915f52600d60205260405f206115f8565b6040519061297782611805565b5f6020838281520152565b61298a61296a565b5060208151916040519261299d84611805565b835201602082015290565b1561037057565b906129b982612335565b6129c66040519182611821565b828152601f196129d68294612335565b01905f5b8281106129e657505050565b6020906129f161296a565b828285010152016129da565b90612a0782612ecc565b1561037057612a1582612eeb565b91612a1f836129af565b90602081018051612a2f81612f4c565b81018091116114fe57945f905b808210612a5e575050611683929394612a56915190611d7f565b9051146129a8565b9095612aa281612a6f600193612fb7565b90604051612a7e604082611821565b828152816020820152612a918b8a6119e7565b52612a9c8a896119e7565b50611adb565b960190612a3c565b80518015159081612ae0575b501561037057612ac590613071565b90519060208110612ad4575090565b6020036101000a900490565b6021915011155f612ab6565b612af681516129af565b905f5b8151811015612b345780612b18612b12600193856119e7565b51612982565b612b2282866119e7565b52612b2d81856119e7565b5001612af9565b505090565b60405190612b48602083611821565b5f808352366020840137565b90612b5e82611844565b612b6b6040519182611821565b828152601f19612b7b8294611844565b0190602036910137565b908151811015610c5f570160200190565b90612ba0906130d1565b5f915f612bab61296a565b50845115612e9357935f915b8151831015612e345782158080612e1e575b610370571580612e02575b61037057612beb612be584846119e7565b516129fd565b958651600281145f14612cec575050612c14612c0f612c09886119ca565b51613319565b613367565b95612c2a612c238888846133d4565b8092611adb565b965111612cce5715612c615750612c419051611d09565b11610370575111612c5857612c09611683916119d7565b50611683612b39565b919094612c6e8651611d09565b82146103705780612c8c611014612c866001946119d7565b51612ecc565b15612caf57612c9d612ca3916119d7565b51613359565b915b0191949094612bb7565b612cbb612cc8916119d7565b5160208101519051902090565b91612ca5565b505091509250612cdf915051611d09565b1161037057611683612b39565b6011909791939794929414612d05575b50600190612ca5565b959380925094929094518314155f14612de45760ff612d5f612d59612d53612d2d8787612b85565b517fff000000000000000000000000000000000000000000000000000000000000001690565b60f81c90565b94611acd565b9316601081101561037057612d7d612d7782896119e7565b51613343565b15612d9f5750505050612d9291925051611d09565b0361037057611683612b39565b86612db7611014612c8684600196989a97999b6119e7565b15612dd157612dc991612c9d916119e7565b915b90612cfc565b612dde91612cbb916119e7565b91612dcb565b505050612df19051611d09565b0361037057612c09611683916119b9565b50612e16612e1084846119e7565b516132e2565b861415612bd4565b50612e2c612cbb85856119e7565b821415612bc9565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f496e76616c6964204d50542070726f6f660000000000000000000000000000006044820152606490fd5b509050612ec492507f56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b4219150146129a8565b611683612b39565b80511561260057602060c0910151515f1a10612ee757600190565b5f90565b805115612600575f9060208101908151612f0481612f4c565b81018091116114fe579151905181018091116114fe5791905b828110612f2a5750905090565b612f3381612fb7565b81018091116114fe57612f4690916119fb565b90612f1d565b515f1a6080811015612f5d57505f90565b60b881108015612fa1575b15612f735750600190565b60c0811015612f925761168390612f8d9060b75b90611d7f565b611acd565b61168390612f8d9060f7612f87565b5060c08110158015612f68575060f88110612f68565b80515f1a906080821015612fcc575050600190565b60b8821015612fe25750612f8d61168391611d44565b60c08210156130235760010151602082900360b7016101000a9004017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff4a0190565b60f88210156130395750612f8d61168391611d17565b60010151602082900360f7016101000a9004017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0a0190565b9060208201916130818351612f4c565b9251908382018092116114fe57519283039283116114fe579190565b156130a457565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52600160045260245ffd5b906130fa5f6130eb84516130e68115156129a8565b6114e8565b6130f560016129a8565b611d7f565b9061310482612b54565b925f91825b613113855f611adb565b8410156131d35761318e612d596131139261312e8760011690565b613196577f0f0000000000000000000000000000000000000000000000000000000000000061317861316f612d53612d2d6131698c60011c90565b8b612b85565b60041c600f1690565b60f81b165f1a613188828b612b85565b53611acd565b939050613109565b7f0f000000000000000000000000000000000000000000000000000000000000006131786131cd612d53612d2d6131698c60011c90565b60ff1690565b915092506117db915083511461309d565b613204826131f883516130e68115156129a8565b6130f5818311156129a8565b9061320e82612b54565b9383925f5b61321d8287611adb565b8510156132d0579061329061328a61321d936132398860011690565b613299577f0f0000000000000000000000000000000000000000000000000000000000000061327a61316f612d53612d2d6132748d60011c90565b8c612b85565b60f81b165f1a613188828c612b85565b95611acd565b94909150613213565b7f0f0000000000000000000000000000000000000000000000000000000000000061327a6131cd612d53612d2d6132748d60011c90565b92505092506117db915083511461309d565b805160208110156132fa575060208101519051902090565b90602001512060405160208101918252602081526122fc604082611821565b8051156103705761332c61168391613071565b61333881939293612b54565b928360200190613487565b60018151036126005760200151515f1a60801490565b61336290613071565b902090565b9081511561037057600f61338361316f612d53612d2d866119ca565b1680613396575061168360025f936131e4565b600181036133ab575061168360015f936131e4565b600281036133c1575061168360026001936131e4565b60030361037057611683600180936131e4565b91905f5b8381018082116114fe57825181108061346e575b156134665761341c7fff000000000000000000000000000000000000000000000000000000000000009184612b85565b51167fff000000000000000000000000000000000000000000000000000000000000006134498386612b85565b5116900361345f5761345a906119fb565b6133d8565b9250505090565b509250505090565b50835182106133ec565b601f81116114fe576101000a90565b90918015612281575b60208110156134ca57806134a357505050565b6134b76134b26134bc92611d71565b613478565b611d09565b905182518216911916179052565b919080518252602081018091116114fe5790602081018091116114fe5791601f19810190811115613490576114bb56f0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80\x80`@R4`\xAAW_Q` a5\xA9_9_Q\x90_RT`\xFF\x81`@\x1C\x16`\x9BW`\x02`\x01`@\x1B\x03\x19`\x01`\x01`@\x1B\x03\x82\x16\x01`IW[`@Qa4\xFA\x90\x81a\0\xAF\x829\xF3[`\x01`\x01`@\x1B\x03\x19\x16`\x01`\x01`@\x1B\x03\x90\x81\x17_Q` a5\xA9_9_Q\x90_RU\x81R\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x90` \x90\xA1_\x80`:V[c\xF9.\xE8\xA9`\xE0\x1B_R`\x04_\xFD[_\x80\xFD\xFE`\x80`@R`\x046\x10\x15a\0\x11W_\x80\xFD[_5`\xE0\x1C\x80c\x01\xFF\xC9\xA7\x14a\x02\xCFW\x80c\x03DW\x1F\x14a\x02\xCAW\x80c\x13;\xF8\x9F\x14a\x02\xC5W\x80c\x19w\x16@\x14a\x02\xC0W\x80c\x1B\xF4\x95\x1C\x14a\x02\xBBW\x80c\"b8\x97\x14a\x02\xB6W\x80c#\xAF\xB0\xFF\x14a\x02\xB1W\x80c$\x8A\x9C\xA3\x14a\x02\xACW\x80c(_$F\x14a\x02\xA7W\x80c,\xD0x\xB8\x14a\x02\xA2W\x80c//\xF1]\x14a\x02\x9DW\x80c0\xC7\t\xB6\x14a\x02\x98W\x80c6+\x81T\x14a\x02\x93W\x80c6V\x8A\xBE\x14a\x02\x8EW\x80cG\xDF\xF6\x9D\x14a\x02\x89W\x80cNm\xA2\xA4\x14a\x02\x84W\x80cR\x9FKV\x14a\x02\x7FW\x80cU\xFC\xC5V\x14a\x02zW\x80cZc0\x80\x14a\x029W\x80c[\x18\x17\xE8\x14a\x02uW\x80c]W\x9Aa\x14a\x02pW\x80ce\x0E\x13\x12\x14a\x02kW\x80ckM\x17\xAD\x14a\x02fW\x80ck\xA3\xD1\x7F\x14a\x02aW\x80cz\x7F4\xE8\x14a\x02\\W\x80c|n\xDB>\x14a\x02WW\x80c|qP\x94\x14a\x02RW\x80c|\x90\x1D{\x14a\x02MW\x80c\x8D\x93^\x1D\x14a\x02HW\x80c\x8D\xD5\x0E\xEE\x14a\x02CW\x80c\x91\xD1HT\x14a\x02>W\x80c\x95\x81K\xF5\x14a\x029W\x80c\xA2\x17\xFD\xDF\x14a\x024W\x80c\xC3P\xA1\xB5\x14a\x02/W\x80c\xCES|\x9F\x14a\x02*W\x80c\xD2k\xCC\x80\x14a\x02%W\x80c\xD5Gt\x1F\x14a\x02 W\x80c\xE1\x8BM\xAE\x14a\x02\x1BW\x80c\xE8\xC4l(\x14a\x02\x16W\x80c\xEC\x82\x8A\x91\x14a\x02\x11W\x80c\xEFQ\"!\x14a\x02\x0CW\x80c\xFDy\xD3\xE1\x14a\x02\x07W\x80c\xFD\xD5A#\x14a\x02\x02Wc\xFF\x87\xC1\x8C\x14a\x01\xFDW_\x80\xFD[a\x14VV[a\x14\x16V[a\x13\xECV[a\x13\xCFV[a\x13JV[a\x13/V[a\x13\x14V[a\x12\xB4V[a\x12dV[a\x12%V[a\x0F\xAAV[a\x0F\x90V[a\x0B\x8FV[a\x0F\x11V[a\x0E\xD1V[a\x0E\xB4V[a\x0E-V[a\r\xC5V[a\raV[a\r7V[a\x0C\xFFV[a\x0C\xE4V[a\x0C\xC0V[a\x0CyV[a\x0B\xCCV[a\x0BWV[a\n\xD0V[a\t\xD6V[a\t\xACV[a\t>V[a\t\x0BV[a\x08\xDCV[a\x08wV[a\x07\xF2V[a\x076V[a\x06\xE4V[a\x06\xC8V[a\x06\xABV[a\x06$V[a\x05\x0CV[a\x04\xCBV[a\x03\xA5V[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16\x80\x91\x03a\x03pW\x80\x7Fye\xDB\x0B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x92\x14\x90\x81\x15a\x03FW[P`@Q\x90\x15\x15\x81R\xF3[\x7F\x01\xFF\xC9\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91P\x14_a\x03;V[_\x80\xFD[\x91\x81`\x1F\x84\x01\x12\x15a\x03pW\x825\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x03pW` \x80\x85\x01\x94\x84`\x05\x1B\x01\x01\x11a\x03pWV[4a\x03pW`@`\x03\x196\x01\x12a\x03pW`\x045`$5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03pWa\x03\xD9\x906\x90`\x04\x01a\x03tV[\x91\x90a\x03\xE3a!\x16V[\x81_R`\x0C` R`\xFF`@_ T\x16a\x04\x85W\x81_R`\r` Ra\x04\x0B`@_ a\x15jV[_[\x83\x81\x10a\x04UWP\x7F\xA0\xFE\xA1*]\xFD\xB3\xEB\xF0\xB7\xC4\x9A}\xDD_\xFD\xD3\xE5\xB2\xD7WO\xF1k\n\x102\xED\xC1\x9De\x8Ba\x04S\x93\x83\x92a\x04K`@Q\x92\x83\x92\x83a\x16rV[\x03\x90\xA2a\"\x0BV[\0[`\x01\x90a\x04\x7Fa\x04m\x85_R`\r` R`@_ \x90V[a\x04x\x83\x88\x87a\x15\x9AV[5\x90a\x15\xF8V[\x01a\x04\rV[\x7F\xFD\x93\xC1_\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x03a\x03pWV[4a\x03pW`\x80`\x03\x196\x01\x12a\x03pWa\x04S`\x045`$5a\x04\xEE\x81a\x04\xADV[`D5\x90a\x04\xFB\x82a\x04\xADV[`d5\x92a\x05\x07a!\x16V[a\x16\x86V[4a\x03pW```\x03\x196\x01\x12a\x03pW`\x045`$5`D5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x03T\x163\x03a\x05\xCEW`\x02T\x82\x11\x15a\x05\xA6Wa\x05^\x92_U`\x01U`\x02UV[_T`\x01T`\x02T`@\x80Q\x93\x84R` \x84\x01\x92\x90\x92R\x90\x82\x01R\x7Fxr.\xD9t+M\xCD\xA7\x05\xD0\x10\xFF\xF7F\n5\x1E\x90o\x82#\xCF\xF2\xD2:U\xB4KfB|\x90\x80``\x81\x01[\x03\x90\xA1\0[\x7F\xC3k\xA4#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F$\xB2\xE7\xFD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x91\x81`\x1F\x84\x01\x12\x15a\x03pW\x825\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x03pW` \x83\x81\x86\x01\x95\x01\x01\x11a\x03pWV[4a\x03pW`\xA0`\x03\x196\x01\x12a\x03pW`\x045`$5`D5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03pWa\x06[\x906\x90`\x04\x01a\x05\xF6V[`d\x93\x91\x935g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03pWa\x06~\x906\x90`\x04\x01a\x03tV[\x91`\x845\x95g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x87\x11a\x03pWa\x06\xA3a\x04S\x976\x90`\x04\x01a\x03tV[\x96\x90\x95a\x18\x96V[4a\x03pW_`\x03\x196\x01\x12a\x03pW` `\x04T`@Q\x90\x81R\xF3[4a\x03pW_`\x03\x196\x01\x12a\x03pW` _T`@Q\x90\x81R\xF3[4a\x03pW` `\x03\x196\x01\x12a\x03pW` a\x07.`\x045_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`\x01`@_ \x01T\x90V[`@Q\x90\x81R\xF3[4a\x03pW`@`\x03\x196\x01\x12a\x03pW`\x045`$5\x90\x80_R`\x0C` R`\xFF`@_ T\x16\x15a\x07\x91W_R`\x10` R`@_ \x90_R` Ra\x07\x8D`@_ T`@Q\x91\x82\x91\x82\x91\x90` \x83\x01\x92RV[\x03\x90\xF3[\x7F\xC5\xB1Eq\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[` `@\x81\x83\x01\x92\x82\x81R\x84Q\x80\x94R\x01\x92\x01\x90_[\x81\x81\x10a\x07\xDCWPPP\x90V[\x82Q\x84R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x07\xCFV[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045\x80_R`\x0C` R`\xFF`@_ T\x16\x15a\x07\x91W_R`\x0F` R`@_ `@Q\x90\x81` \x82T\x91\x82\x81R\x01\x91_R` _ \x90_[\x81\x81\x10a\x08aWa\x07\x8D\x85a\x08U\x81\x87\x03\x82a\x18!V[`@Q\x91\x82\x91\x82a\x07\xB9V[\x82T\x84R` \x90\x93\x01\x92`\x01\x92\x83\x01\x92\x01a\x08>V[4a\x03pW`@`\x03\x196\x01\x12a\x03pWa\x04S`$5`\x045a\x08\x9A\x82a\x04\xADV[a\x08\xD7a\x08\xD2\x82_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`\x01`@_ \x01T\x90V[a!~V[a&\x05V[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045_R`\x0C` R` `\xFF`@_ T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x03pW_`\x03\x196\x01\x12a\x03pW` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x03T\x16`@Q\x90\x81R\xF3[4a\x03pW`@`\x03\x196\x01\x12a\x03pW`\x045`$5a\t^\x81a\x04\xADV[3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x03a\t\x84Wa\x04S\x91a'\"V[\x7Ff\x97\xB22\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045_R`\x0E` R` `@_ T`@Q\x90\x81R\xF3[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045_\x81_R`\x0C` R`\xFF`@_ T\x16\x90\x82_R`\r` R`@_ \x92`@Q\x80\x85` \x82\x97T\x93\x84\x81R\x01\x90_R` _ \x92_[\x81\x81\x10a\n\xB7WPPa\n7\x92P\x03\x85a\x18!V[\x83Q_[\x85Q\x81\x10\x15a\n\x9BWa\nza\nsa\n\\\x85_R`\n` R`@_ \x90V[a\nf\x84\x8Aa\x19\xE7V[Q_R` R`@_ \x90V[T`\xFF\x16\x90V[a\n\x87W[`\x01\x01a\n;V[\x92a\n\x93`\x01\x91a\x19\xFBV[\x93\x90Pa\n\x7FV[P`@\x80Q\x85\x15\x15\x81R` \x81\x01\x92\x90\x92R\x81\x01\x83\x90R``\x90\xF3[\x84T\x83R`\x01\x94\x85\x01\x94\x89\x94P` \x90\x93\x01\x92\x01a\n\"V[4a\x03pW`\xA0`\x03\x196\x01\x12a\x03pW`\x045`$5`D5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03pWa\x0B\x07\x906\x90`\x04\x01a\x03tV[`d\x93\x91\x935g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03pWa\x0B*\x906\x90`\x04\x01a\x03tV[\x91`\x845\x95g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x87\x11a\x03pWa\x0BOa\x04S\x976\x90`\x04\x01a\x03tV[\x96\x90\x95a\x1A\xF2V[4a\x03pW`@`\x03\x196\x01\x12a\x03pW`\x045`$5\x90_R`\x10` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x03pW`@`\x03\x196\x01\x12a\x03pW`\x045`$5\x90_R`\n` R`@_ \x90_R` R` `\xFF`@_ T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x03pW`@`\x03\x196\x01\x12a\x03pW`\x045`$5\x90_R`\x11` R`@_ \x90_R` R` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ T\x16`@Q\x90\x81R\xF3[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[`\x05T\x81\x10\x15a\x0C_W`\x05_R` _ \x01\x90_\x90V[a\x0C\x1AV[\x80T\x82\x10\x15a\x0C_W_R` _ \x01\x90_\x90V[4a\x03pW`@`\x03\x196\x01\x12a\x03pW`\x045`$5\x90_R`\r` R`@_ \x80T\x82\x10\x15a\x03pW` \x91a\x0C\xB1\x91a\x0CdV[\x90T\x90`\x03\x1B\x1C`@Q\x90\x81R\xF3[4a\x03pW` `\x03\x196\x01\x12a\x03pWa\x04S`\x045a\x0C\xDFa!\x16V[a\x1D\xE5V[4a\x03pW_`\x03\x196\x01\x12a\x03pW` `@Q`\x02\x81R\xF3[4a\x03pW`@`\x03\x196\x01\x12a\x03pW`\x045`$5\x90_R`\x0B` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045_R`\t` R` `@_ T`@Q\x90\x81R\xF3[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045_R`\r` R`@_ `@Q\x90\x81` \x82T\x91\x82\x81R\x01\x91_R` _ \x90_[\x81\x81\x10a\r\xAFWa\x07\x8D\x85a\x08U\x81\x87\x03\x82a\x18!V[\x82T\x84R` \x90\x93\x01\x92`\x01\x92\x83\x01\x92\x01a\r\x98V[4a\x03pW` `\x03\x196\x01\x12a\x03pWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x045a\r\xF7\x81a\x04\xADV[a\r\xFFa!\x16V[\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x03T\x16\x17`\x03U_\x80\xF3[4a\x03pW`\xA0`\x03\x196\x01\x12a\x03pW`\x045`$5`D5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03pWa\x0Ed\x906\x90`\x04\x01a\x05\xF6V[`d\x93\x91\x935g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03pWa\x0E\x87\x906\x90`\x04\x01a\x03tV[\x91`\x845\x95g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x87\x11a\x03pWa\x0E\xACa\x04S\x976\x90`\x04\x01a\x03tV[\x96\x90\x95a\x1E\xF3V[4a\x03pW_`\x03\x196\x01\x12a\x03pW` `\x02T`@Q\x90\x81R\xF3[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045_R`\x06` R` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ T\x16`@Q\x90\x81R\xF3[4a\x03pW`@`\x03\x196\x01\x12a\x03pW` `\xFFa\x0F\x84`$5`\x045a\x0F8\x82a\x04\xADV[_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0\x84R`@_ \x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_R` R`@_ \x90V[T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x03pW_`\x03\x196\x01\x12a\x03pW` `@Q_\x81R\xF3[4a\x03pW```\x03\x196\x01\x12a\x03pW`\x045a\x0F\xC7\x81a\x04\xADV[`$5\x90`D5a\x0F\xD7\x81a\x04\xADV[\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x92g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x10&`\xFF`@\x87\x90\x1C\x16\x15a\x10\x18V[\x15\x90V[\x95g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[\x16\x80\x15\x90\x81a\x12\x1DW[`\x01\x14\x90\x81a\x12\x13W[\x15\x90\x81a\x12\nW[Pa\x11\xE2Wa\x10\xC3\x92\x84a\x10\xBA`\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x16\x17\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0UV[a\x11gWa QV[a\x10\xC9W\0[a\x114\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x16\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0UV[`@Q`\x01\x81R\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x90\x80` \x81\x01a\x05\xA1V[a\x11\xDDh\x01\0\0\0\0\0\0\0\0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x16\x17\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0UV[a QV[\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90P\x15_a\x10BV[0;\x15\x91Pa\x10:V[\x85\x91Pa\x100V[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045\x80_R`\x0C` R`\xFF`@_ T\x16\x15a\x07\x91W_R`\x0E` R` `@_ T`@Q\x90\x81R\xF3[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045`\x05T\x81\x10\x15a\x03pW` \x90`\x05_R\x7F\x03kc\x84\xB5\xEC\xA7\x91\xC6'a\x15-\x0Cy\xBB\x06\x04\xC1\x04\xA5\xFBoN\xB0p?1T\xBB=\xB0\x01T`@Q\x90\x81R\xF3[4a\x03pW`@`\x03\x196\x01\x12a\x03pWa\x04S`$5`\x045a\x12\xD7\x82a\x04\xADV[a\x13\x0Fa\x08\xD2\x82_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`\x01`@_ \x01T\x90V[a'\"V[4a\x03pW_`\x03\x196\x01\x12a\x03pW` `@Q`\x03\x81R\xF3[4a\x03pW_`\x03\x196\x01\x12a\x03pW` `@Q`\x07\x81R\xF3[4a\x03pW`@`\x03\x196\x01\x12a\x03pW`\x045`$5\x90\x80_R`\x0C` R`\xFF`@_ T\x16\x15a\x07\x91W_R`\x11` R`@_ \x90_R` Ra\x07\x8Ds\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ T\x16`@Q\x91\x82\x91\x82\x91\x90\x91s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF` \x82\x01\x93\x16\x90RV[4a\x03pW_`\x03\x196\x01\x12a\x03pW` `\x01T`@Q\x90\x81R\xF3[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045_R`\x08` R` `@_ T`@Q\x90\x81R\xF3[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045_R`\x07` R` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ T\x16`@Q\x90\x81R\xF3[4a\x03pW`@`\x03\x196\x01\x12a\x03pW`\x045`$5\x90_R`\x0F` R`@_ \x80T\x82\x10\x15a\x03pW` \x91a\x0C\xB1\x91a\x0CdV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[\x90\x81`\x01\x1B\x91\x80\x83\x04`\x02\x14\x90\x15\x17\x15a\x14\xFEWV[a\x14\xBBV[\x91a\x15\x1C\x91\x83T\x90_\x19\x90`\x03\x1B\x92\x83\x1B\x92\x1B\x19\x16\x17\x90V[\x90UV[\x90h\x01\0\0\0\0\0\0\0\0\x81\x11a\x15eW\x81T\x91\x81\x81U\x82\x82\x10a\x15CWPPPV[_R` _ \x91\x82\x01\x91\x01[\x81\x81\x10a\x15ZWPPV[_\x81U`\x01\x01a\x15OV[a\x14\x8EV[\x80T\x90_\x81U\x81a\x15yWPPV[_R` _ \x90\x81\x01\x90[\x81\x81\x10a\x15\x8FWPPV[_\x81U`\x01\x01a\x15\x84V[\x91\x90\x81\x10\x15a\x0C_W`\x05\x1B\x01\x90V[`\x05Th\x01\0\0\0\0\0\0\0\0\x81\x10\x15a\x15eW`\x01\x81\x01`\x05U`\x05T\x81\x10\x15a\x0C_W`\x05_R\x7F\x03kc\x84\xB5\xEC\xA7\x91\xC6'a\x15-\x0Cy\xBB\x06\x04\xC1\x04\xA5\xFBoN\xB0p?1T\xBB=\xB0\x01UV[\x80T\x90h\x01\0\0\0\0\0\0\0\0\x82\x10\x15a\x15eW\x81a\x16\x1F\x91`\x01a\x15\x1C\x94\x01\x81Ua\x0CdV[\x81\x93\x91T\x90_\x19\x90`\x03\x1B\x92\x83\x1B\x92\x1B\x19\x16\x17\x90V[\x90\x91\x82\x81R\x7F\x07\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x03pW` \x92`\x05\x1B\x80\x92\x84\x83\x017\x01\x01\x90V[\x91` a\x16\x83\x93\x81\x81R\x01\x91a\x165V[\x90V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x16\xCBa\x16\xB1\x84_R`\x06` R`@_ \x90V[Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[\x16a\x17\xDDWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x15a\x17\x9AW`\x04T\x82\x14a\x17\xC2Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16\x15a\x17\x9AWa\x17\x97\x92a\x17wa\x17\x89\x92a\x17%\x85a\x15\xAAV[a\x177\x85_R`\x06` R`@_ \x90V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82T\x16\x17\x90UV[a\x177\x83_R`\x07` R`@_ \x90V[_R`\x08` R`@_ \x90V[UV[\x7F\xD9.#=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x91Pa\x17\xDB\x92Pa\x177\x90_R`\x06` R`@_ \x90V[V[\x7F\xDFe\n\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[`@\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x15eW`@RV[\x90`\x1F`\x1F\x19\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x15eW`@RV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x15eW`\x1F\x01`\x1F\x19\x16` \x01\x90V[\x92\x91\x92a\x18l\x82a\x18DV[\x91a\x18z`@Q\x93\x84a\x18!V[\x82\x94\x81\x84R\x81\x83\x01\x11a\x03pW\x82\x81` \x93\x84_\x96\x017\x01\x01RV[\x96\x93\x90\x94\x91\x95\x92a\x18\xA86\x82\x89a\x18`V[` \x81Q\x91\x01 _T\x03a\x19\x81W_\x88\x81R`\x07` R`@\x90 Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x95\x86\x15a\x19(W\x91a\x19\x14a\x17\x97\x98\x96\x94\x92a\x19\x0Ea\x19\x19\x99\x97\x95a\x19\x07\x8D_R`\x08` R`@_ \x90V[T\x90a\"\xDCV[\x97a#\x02V[a#\xC9V[\x91_R`\t` R`@_ \x90V[\x88`\x04T\x14a\x19YW\x7F\x12B\xE9\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\xDA&\x12\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\xEF\xB6L\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x80Q`\x02\x10\x15a\x0C_W``\x01\x90V[\x80Q`\x10\x10\x15a\x0C_Wa\x02 \x01\x90V[\x80Q\x15a\x0C_W` \x01\x90V[\x80Q`\x01\x10\x15a\x0C_W`@\x01\x90V[\x80Q\x82\x10\x15a\x0C_W` \x91`\x05\x1B\x01\x01\x90V[_\x19\x81\x14a\x14\xFEW`\x01\x01\x90V[\x92\x90\x93a\x1A'` \x95a\x1A4\x94\x98\x97\x98``\x87R``\x87\x01\x91a\x165V[\x91\x84\x83\x03\x86\x86\x01Ra\x165V[\x90`@\x81\x83\x03\x91\x01R\x82\x81R\x01\x91\x90_[\x81\x81\x10a\x1ARWPPP\x90V[\x90\x91\x92` \x80`\x01\x92s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x875a\x1A{\x81a\x04\xADV[\x16\x81R\x01\x94\x01\x92\x91\x01a\x1AEV[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x15eWa\x1A\xA3\x83\x83a\x15 V[\x90_R` _ _[\x83\x81\x10a\x1A\xB9WPPPPV[`\x01\x90` \x845\x94\x01\x93\x81\x84\x01U\x01a\x1A\xACV[\x90`\x01\x82\x01\x80\x92\x11a\x14\xFEWV[\x91\x90\x82\x01\x80\x92\x11a\x14\xFEWV[5a\x16\x83\x81a\x04\xADV[\x95\x97\x96\x90\x94\x97\x92\x91\x92a\x1B!a\ns\x87a\x1B\x14\x8A_R`\n` R`@_ \x90V[\x90_R` R`@_ \x90V[a\x1C\xE1Wa\x1B;\x86a\x1B\x14\x89_R`\x0B` R`@_ \x90V[T\x84\x82a\x1Bg\x8Ca\x1BY\x87`@Q\x94\x85\x93\x8D\x8C` \x87\x01\x99\x8Aa\x1A\tV[\x03`\x1F\x19\x81\x01\x83R\x82a\x18!V[Q\x90 \x03a\x1C\xB9W\x97\x93\x92\x91\x90_\x98a\x1B\x92\x83\x85a\x1B\x8D\x8B_R`\x0F` R`@_ \x90V[a\x1A\x89V[_\x95[\x83\x87\x10a\x1C\x1CWPPPPPPPa\x1C\x16_\x91a\x17\xDB\x94\x95a\x1B\xBF\x85_R`\x0E` R`@_ \x90V[Ua\x1C\x04a\x1B\xD9\x82a\x1B\x14\x87_R`\n` R`@_ \x90V[`\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x82T\x16\x17\x90UV[a\x1B\x14\x84_R`\x0B` R`@_ \x90V[Ua\"\x0BV[\x90\x91\x92\x93\x94\x95\x99a\x1C;`\x01\x91a\x1C4\x8D\x85\x8Ba\x15\x9AV[5\x90a\x1A\xDBV[\x9Aa\x1CG\x81\x84\x8Aa\x15\x9AV[5a\x1C\x80a\x1Cxa\x1C`\x8D_R`\x10` R`@_ \x90V[a\x1Ck\x85\x8B\x8Da\x15\x9AV[5_R` R`@_ \x90V[\x91\x82Ta\x1A\xDBV[\x90Ua\x1C\xADa\x1C\x98a\x1C\x93\x83\x88\x88a\x15\x9AV[a\x1A\xE8V[a\x177a\x1C`\x8D_R`\x11` R`@_ \x90V[\x01\x95\x94\x93\x92\x91\x90a\x1B\x95V[\x7F\\\xB0E\xDB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\x9F\xBF\xC5\x89\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90_\x19\x82\x01\x91\x82\x11a\x14\xFEWV[\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF@\x82\x01\x91\x82\x11a\x14\xFEWV[\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x01\x91\x82\x11a\x14\xFEWV[` \x03\x90` \x82\x11a\x14\xFEWV[\x91\x90\x82\x03\x91\x82\x11a\x14\xFEWV[`\x05T\x80\x15a\x1D\xB8W_\x19\x81\x01\x90`\x05T\x82\x10\x15a\x0C_W_\x19_\x91`\x05\x83R` \x83 \x01\x01U`\x05UV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`1`\x04R`$_\xFD[`\x04T\x81\x14a\x1E\xDEW`\x05T\x80\x91_[\x83\x81\x10a\x1E\xBCW[P\x82\x82\x14a\x1E\x94Wa\x1E:a\x17\x97\x92a\x1E4a\x1E.a\x1E$a\x1E\x1F_\x98a\x1D\tV[a\x0CGV[\x90T\x90`\x03\x1B\x1C\x90V[\x91a\x0CGV[\x90a\x15\x03V[a\x1EBa\x1D\x8CV[a\x1E\x7Fa\x1EW\x82_R`\x06` R`@_ \x90V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81T\x16\x90UV[a\x17\x89a\x1EW\x82_R`\x07` R`@_ \x90V[\x7F\x12B\xE9\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x81a\x1E\xC9a\x1E$\x83a\x0CGV[\x14a\x1E\xD6W`\x01\x01a\x1D\xF5V[\x91P_a\x1D\xFDV[a\x1EWa\x17\xDB\x91_R`\x06` R`@_ \x90V[\x96\x93\x90\x95\x92\x94\x91\x94a\x1F\x14a\ns\x88a\x1B\x14\x8B_R`\n` R`@_ \x90V[\x80\x15a 2W[a\x1C\xE1Wa\x1F*6\x82\x88a\x18`V[` \x81Q\x91\x01 a\x1FC\x88_R`\t` R`@_ \x90V[T`\x04T\x89\x14a )W[\x03a \x01Wa\x1F^\x95\x87\x89a(7V[\x90\x81\x15a\x1F\xD9W\x80a\x1F\xB4\x91\x84\x7F,?D5\x99\xC6&\x8A\xCE\xD4s\xE7f\x0B@tn\xA3\x94\xD5\x19\x17\x9E\xA3\xF6\x0F8)t\xA2\xE7\x8E`@Q\x80a\x1F\x9F\x88\x82\x91\x90` \x83\x01\x92RV[\x03\x90\xA3a\x1B\x14\x84_R`\x0B` R`@_ \x90V[Ua\x1F\xC7\x81_R`\r` R`@_ \x90V[T\x15a\x1F\xD0WPV[a\x17\xDB\x90a)\x14V[\x7F\x9A\x0C\xCES\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\x9D\x8C\xBA\xCD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[P`\x01Ta\x1FNV[Pa I\x87a\x1B\x14\x8A_R`\x0B` R`@_ \x90V[T\x15\x15a\x1F\x1BV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x15a\x17\x9AWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16\x15a\x17\x9AW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x03T\x16\x17`\x03U`\x04U`\xFF\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T`@\x1C\x16\x15a \xEEWa \xEB\x90a%\x1EV[PV[\x7F\xD7\xE6\xBC\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[3_\x90\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x90 T`\xFF\x16\x15a!NWV[\x7F\xE2Q}?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R3`\x04R_`$R`D_\xFD[\x80_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`\xFFa!\xD23`@_ \x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_R` R`@_ \x90V[T\x16\x15a!\xDCWPV[\x7F\xE2Q}?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R3`\x04R`$R`D_\xFD[\x80_R`\r` R`@_ `@Q\x80\x82` \x82\x94T\x93\x84\x81R\x01\x90_R` _ \x92_[\x81\x81\x10a\"\xC3WPPa\"E\x92P\x03\x82a\x18!V[_[\x81Q\x81\x10\x15a\"\x86Wa\"ua\x10\x14a\nsa\"k\x86_R`\n` R`@_ \x90V[a\nf\x85\x87a\x19\xE7V[a\"\x81W`\x01\x01a\"GV[PPPV[PPa\"\x9Da\x1B\xD9\x82_R`\x0C` R`@_ \x90V[\x7Fx\xDF\x93\x81\x81\xAF\xCB(\xEA\xA7\xD0\x99#[\xBF\x98w\x83-o\xAA\xFE6\xD1\xEAp\x91o:\xCE3\xE0_\x80\xA2V[\x84T\x83R`\x01\x94\x85\x01\x94\x86\x94P` \x90\x93\x01\x92\x01a\"0V[\x90`@Q\x90` \x82\x01\x92\x83R`@\x82\x01R`@\x81Ra\"\xFC``\x82a\x18!V[Q\x90 \x90V[a#\x14a#\x19\x91a#\x1E\x936\x91a\x18`V[a)\x82V[a)\xFDV[\x80Q`\x03\x10\x15a\x0C_W`\x80a\x16\x83\x91\x01Qa*\xAAV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x15eW`\x05\x1B` \x01\x90V[\x92\x91\x92a#Y\x82a#5V[\x93a#g`@Q\x95\x86a\x18!V[` \x85\x84\x81R\x01\x92`\x05\x1B\x82\x01\x91\x81\x83\x11a\x03pW\x80\x93[\x83\x85\x10a#\x8DWPPPPPV[\x845g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03pW\x82\x01\x83`\x1F\x82\x01\x12\x15a\x03pW` \x91a#\xBE\x85\x83\x85\x80\x955\x91\x01a\x18`V[\x81R\x01\x94\x01\x93a#\x7FV[\x90\x91a$Ca$>a#\x14\x94a$I\x96\x98\x99\x97\x99`@Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01\x92``\x1B\x16\x82R`\x14\x81Ra$\x1B`4\x82a\x18!V[Q\x90 \x93`@Q\x94` \x86\x01R` \x85Ra$7`@\x86a\x18!V[6\x91a#MV[a*\xECV[\x91a+\x96V[\x91\x82Q\x15a$\xF6Wa$Ca$>a$\xB0\x92a$\xBE\x96a$7a$\x7Fa$ya$ta#\x14\x9Aa)\xFDV[a\x19\xA9V[Qa*\xAAV[\x96`@Qa$\x9A\x81a\x1BY` \x82\x01\x94\x85\x91\x90` \x83\x01\x92RV[Q\x90 `@Q\x96\x87\x91` \x83\x01` \x91\x81R\x01\x90V[\x03`\x1F\x19\x81\x01\x87R\x86a\x18!V[\x80Q\x15a$\xCEWa\x16\x83\x90a*\xAAV[\x7F4w\xDC\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7FTw\x06\xAF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16_\x90\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x90 T`\xFF\x16a&\0Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_\x81\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x81 \x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x16`\x01\x17\x90U3\x91\x90\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x81\x80\xA4`\x01\x90V[P_\x90V[\x80_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`\xFFa&Y\x83`@_ \x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_R` R`@_ \x90V[T\x16a'\x1CW\x80_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` Ra&\xB1\x82`@_ \x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_R` R`@_ \x90V[`\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x82T\x16\x17\x90Us\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x92\x16\x90\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r_\x80\xA4`\x01\x90V[PP_\x90V[\x80_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`\xFFa'v\x83`@_ \x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_R` R`@_ \x90V[T\x16\x15a'\x1CW\x80_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` Ra'\xCF\x82`@_ \x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_R` R`@_ \x90V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x81T\x16\x90Us\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x92\x16\x90\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B_\x80\xA4`\x01\x90V[\x95\x92\x96\x93\x90\x94\x91\x94_R`\x06` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ T\x16\x94\x85\x15a\x1E\x94Wa\x16\x83\x97a(u\x91a#\x02V[\x95`@Q` \x81\x01\x91\x82R`\x07`@\x82\x01R`@\x81Ra(\x96``\x82a\x18!V[Q\x90 \x95a#\xC9V[`\x05\x81\x14a \xEBW`\x05T\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x15eWa(\xC4\x82\x82a\x15 V[_\x90\x81R` \x81 \x7F\x03kc\x84\xB5\xEC\xA7\x91\xC6'a\x15-\x0Cy\xBB\x06\x04\xC1\x04\xA5\xFBoN\xB0p?1T\xBB=\xB0\x80T[\x84\x84\x10a(\xFEWPPPPPV[`\x01\x80\x91\x92\x01\x93\x84T\x92\x81\x85\x01U\x01\x92\x90a(\xF0V[\x80_R`\r` Ra)(`@_ a(\x9FV[`\x04T\x80_R`\x06` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ T\x16a)VWPPV[a\x17\xDB\x91_R`\r` R`@_ a\x15\xF8V[`@Q\x90a)w\x82a\x18\x05V[_` \x83\x82\x81R\x01RV[a)\x8Aa)jV[P` \x81Q\x91`@Q\x92a)\x9D\x84a\x18\x05V[\x83R\x01` \x82\x01R\x90V[\x15a\x03pWV[\x90a)\xB9\x82a#5V[a)\xC6`@Q\x91\x82a\x18!V[\x82\x81R`\x1F\x19a)\xD6\x82\x94a#5V[\x01\x90_[\x82\x81\x10a)\xE6WPPPV[` \x90a)\xF1a)jV[\x82\x82\x85\x01\x01R\x01a)\xDAV[\x90a*\x07\x82a.\xCCV[\x15a\x03pWa*\x15\x82a.\xEBV[\x91a*\x1F\x83a)\xAFV[\x90` \x81\x01\x80Qa*/\x81a/LV[\x81\x01\x80\x91\x11a\x14\xFEW\x94_\x90[\x80\x82\x10a*^WPPa\x16\x83\x92\x93\x94a*V\x91Q\x90a\x1D\x7FV[\x90Q\x14a)\xA8V[\x90\x95a*\xA2\x81a*o`\x01\x93a/\xB7V[\x90`@Qa*~`@\x82a\x18!V[\x82\x81R\x81` \x82\x01Ra*\x91\x8B\x8Aa\x19\xE7V[Ra*\x9C\x8A\x89a\x19\xE7V[Pa\x1A\xDBV[\x96\x01\x90a*<V[\x80Q\x80\x15\x15\x90\x81a*\xE0W[P\x15a\x03pWa*\xC5\x90a0qV[\x90Q\x90` \x81\x10a*\xD4WP\x90V[` \x03a\x01\0\n\x90\x04\x90V[`!\x91P\x11\x15_a*\xB6V[a*\xF6\x81Qa)\xAFV[\x90_[\x81Q\x81\x10\x15a+4W\x80a+\x18a+\x12`\x01\x93\x85a\x19\xE7V[Qa)\x82V[a+\"\x82\x86a\x19\xE7V[Ra+-\x81\x85a\x19\xE7V[P\x01a*\xF9V[PP\x90V[`@Q\x90a+H` \x83a\x18!V[_\x80\x83R6` \x84\x017V[\x90a+^\x82a\x18DV[a+k`@Q\x91\x82a\x18!V[\x82\x81R`\x1F\x19a+{\x82\x94a\x18DV[\x01\x90` 6\x91\x017V[\x90\x81Q\x81\x10\x15a\x0C_W\x01` \x01\x90V[\x90a+\xA0\x90a0\xD1V[_\x91_a+\xABa)jV[P\x84Q\x15a.\x93W\x93_\x91[\x81Q\x83\x10\x15a.4W\x82\x15\x80\x80a.\x1EW[a\x03pW\x15\x80a.\x02W[a\x03pWa+\xEBa+\xE5\x84\x84a\x19\xE7V[Qa)\xFDV[\x95\x86Q`\x02\x81\x14_\x14a,\xECWPPa,\x14a,\x0Fa,\t\x88a\x19\xCAV[Qa3\x19V[a3gV[\x95a,*a,#\x88\x88\x84a3\xD4V[\x80\x92a\x1A\xDBV[\x96Q\x11a,\xCEW\x15a,aWPa,A\x90Qa\x1D\tV[\x11a\x03pWQ\x11a,XWa,\ta\x16\x83\x91a\x19\xD7V[Pa\x16\x83a+9V[\x91\x90\x94a,n\x86Qa\x1D\tV[\x82\x14a\x03pW\x80a,\x8Ca\x10\x14a,\x86`\x01\x94a\x19\xD7V[Qa.\xCCV[\x15a,\xAFWa,\x9Da,\xA3\x91a\x19\xD7V[Qa3YV[\x91[\x01\x91\x94\x90\x94a+\xB7V[a,\xBBa,\xC8\x91a\x19\xD7V[Q` \x81\x01Q\x90Q\x90 \x90V[\x91a,\xA5V[PP\x91P\x92Pa,\xDF\x91PQa\x1D\tV[\x11a\x03pWa\x16\x83a+9V[`\x11\x90\x97\x91\x93\x97\x94\x92\x94\x14a-\x05W[P`\x01\x90a,\xA5V[\x95\x93\x80\x92P\x94\x92\x90\x94Q\x83\x14\x15_\x14a-\xE4W`\xFFa-_a-Ya-Sa--\x87\x87a+\x85V[Q\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90V[`\xF8\x1C\x90V[\x94a\x1A\xCDV[\x93\x16`\x10\x81\x10\x15a\x03pWa-}a-w\x82\x89a\x19\xE7V[Qa3CV[\x15a-\x9FWPPPPa-\x92\x91\x92PQa\x1D\tV[\x03a\x03pWa\x16\x83a+9V[\x86a-\xB7a\x10\x14a,\x86\x84`\x01\x96\x98\x9A\x97\x99\x9Ba\x19\xE7V[\x15a-\xD1Wa-\xC9\x91a,\x9D\x91a\x19\xE7V[\x91[\x90a,\xFCV[a-\xDE\x91a,\xBB\x91a\x19\xE7V[\x91a-\xCBV[PPPa-\xF1\x90Qa\x1D\tV[\x03a\x03pWa,\ta\x16\x83\x91a\x19\xB9V[Pa.\x16a.\x10\x84\x84a\x19\xE7V[Qa2\xE2V[\x86\x14\x15a+\xD4V[Pa.,a,\xBB\x85\x85a\x19\xE7V[\x82\x14\x15a+\xC9V[`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x11`$\x82\x01R\x7FInvalid MPT proof\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x90\xFD[P\x90Pa.\xC4\x92P\x7FV\xE8\x1F\x17\x1B\xCCU\xA6\xFF\x83E\xE6\x92\xC0\xF8n[H\xE0\x1B\x99l\xAD\xC0\x01b/\xB5\xE3c\xB4!\x91P\x14a)\xA8V[a\x16\x83a+9V[\x80Q\x15a&\0W` `\xC0\x91\x01QQ_\x1A\x10a.\xE7W`\x01\x90V[_\x90V[\x80Q\x15a&\0W_\x90` \x81\x01\x90\x81Qa/\x04\x81a/LV[\x81\x01\x80\x91\x11a\x14\xFEW\x91Q\x90Q\x81\x01\x80\x91\x11a\x14\xFEW\x91\x90[\x82\x81\x10a/*WP\x90P\x90V[a/3\x81a/\xB7V[\x81\x01\x80\x91\x11a\x14\xFEWa/F\x90\x91a\x19\xFBV[\x90a/\x1DV[Q_\x1A`\x80\x81\x10\x15a/]WP_\x90V[`\xB8\x81\x10\x80\x15a/\xA1W[\x15a/sWP`\x01\x90V[`\xC0\x81\x10\x15a/\x92Wa\x16\x83\x90a/\x8D\x90`\xB7[\x90a\x1D\x7FV[a\x1A\xCDV[a\x16\x83\x90a/\x8D\x90`\xF7a/\x87V[P`\xC0\x81\x10\x15\x80\x15a/hWP`\xF8\x81\x10a/hV[\x80Q_\x1A\x90`\x80\x82\x10\x15a/\xCCWPP`\x01\x90V[`\xB8\x82\x10\x15a/\xE2WPa/\x8Da\x16\x83\x91a\x1DDV[`\xC0\x82\x10\x15a0#W`\x01\x01Q` \x82\x90\x03`\xB7\x01a\x01\0\n\x90\x04\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFJ\x01\x90V[`\xF8\x82\x10\x15a09WPa/\x8Da\x16\x83\x91a\x1D\x17V[`\x01\x01Q` \x82\x90\x03`\xF7\x01a\x01\0\n\x90\x04\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\n\x01\x90V[\x90` \x82\x01\x91a0\x81\x83Qa/LV[\x92Q\x90\x83\x82\x01\x80\x92\x11a\x14\xFEWQ\x92\x83\x03\x92\x83\x11a\x14\xFEW\x91\x90V[\x15a0\xA4WV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x01`\x04R`$_\xFD[\x90a0\xFA_a0\xEB\x84Qa0\xE6\x81\x15\x15a)\xA8V[a\x14\xE8V[a0\xF5`\x01a)\xA8V[a\x1D\x7FV[\x90a1\x04\x82a+TV[\x92_\x91\x82[a1\x13\x85_a\x1A\xDBV[\x84\x10\x15a1\xD3Wa1\x8Ea-Ya1\x13\x92a1.\x87`\x01\x16\x90V[a1\x96W\x7F\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a1xa1oa-Sa--a1i\x8C`\x01\x1C\x90V[\x8Ba+\x85V[`\x04\x1C`\x0F\x16\x90V[`\xF8\x1B\x16_\x1Aa1\x88\x82\x8Ba+\x85V[Sa\x1A\xCDV[\x93\x90Pa1\tV[\x7F\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a1xa1\xCDa-Sa--a1i\x8C`\x01\x1C\x90V[`\xFF\x16\x90V[\x91P\x92Pa\x17\xDB\x91P\x83Q\x14a0\x9DV[a2\x04\x82a1\xF8\x83Qa0\xE6\x81\x15\x15a)\xA8V[a0\xF5\x81\x83\x11\x15a)\xA8V[\x90a2\x0E\x82a+TV[\x93\x83\x92_[a2\x1D\x82\x87a\x1A\xDBV[\x85\x10\x15a2\xD0W\x90a2\x90a2\x8Aa2\x1D\x93a29\x88`\x01\x16\x90V[a2\x99W\x7F\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a2za1oa-Sa--a2t\x8D`\x01\x1C\x90V[\x8Ca+\x85V[`\xF8\x1B\x16_\x1Aa1\x88\x82\x8Ca+\x85V[\x95a\x1A\xCDV[\x94\x90\x91Pa2\x13V[\x7F\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a2za1\xCDa-Sa--a2t\x8D`\x01\x1C\x90V[\x92PP\x92Pa\x17\xDB\x91P\x83Q\x14a0\x9DV[\x80Q` \x81\x10\x15a2\xFAWP` \x81\x01Q\x90Q\x90 \x90V[\x90` \x01Q `@Q` \x81\x01\x91\x82R` \x81Ra\"\xFC`@\x82a\x18!V[\x80Q\x15a\x03pWa3,a\x16\x83\x91a0qV[a38\x81\x93\x92\x93a+TV[\x92\x83` \x01\x90a4\x87V[`\x01\x81Q\x03a&\0W` \x01QQ_\x1A`\x80\x14\x90V[a3b\x90a0qV[\x90 \x90V[\x90\x81Q\x15a\x03pW`\x0Fa3\x83a1oa-Sa--\x86a\x19\xCAV[\x16\x80a3\x96WPa\x16\x83`\x02_\x93a1\xE4V[`\x01\x81\x03a3\xABWPa\x16\x83`\x01_\x93a1\xE4V[`\x02\x81\x03a3\xC1WPa\x16\x83`\x02`\x01\x93a1\xE4V[`\x03\x03a\x03pWa\x16\x83`\x01\x80\x93a1\xE4V[\x91\x90_[\x83\x81\x01\x80\x82\x11a\x14\xFEW\x82Q\x81\x10\x80a4nW[\x15a4fWa4\x1C\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x84a+\x85V[Q\x16\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a4I\x83\x86a+\x85V[Q\x16\x90\x03a4_Wa4Z\x90a\x19\xFBV[a3\xD8V[\x92PPP\x90V[P\x92PPP\x90V[P\x83Q\x82\x10a3\xECV[`\x1F\x81\x11a\x14\xFEWa\x01\0\n\x90V[\x90\x91\x80\x15a\"\x81W[` \x81\x10\x15a4\xCAW\x80a4\xA3WPPPV[a4\xB7a4\xB2a4\xBC\x92a\x1DqV[a4xV[a\x1D\tV[\x90Q\x82Q\x82\x16\x91\x19\x16\x17\x90RV[\x91\x90\x80Q\x82R` \x81\x01\x80\x91\x11a\x14\xFEW\x90` \x81\x01\x80\x91\x11a\x14\xFEW\x91`\x1F\x19\x81\x01\x90\x81\x11\x15a4\x90Wa\x14\xBBV\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610011575f80fd5b5f3560e01c806301ffc9a7146102cf5780630344571f146102ca578063133bf89f146102c557806319771640146102c05780631bf4951c146102bb57806322623897146102b657806323afb0ff146102b1578063248a9ca3146102ac578063285f2446146102a75780632cd078b8146102a25780632f2ff15d1461029d57806330c709b614610298578063362b81541461029357806336568abe1461028e57806347dff69d146102895780634e6da2a414610284578063529f4b561461027f57806355fcc5561461027a5780635a633080146102395780635b1817e8146102755780635d579a6114610270578063650e13121461026b5780636b4d17ad146102665780636ba3d17f146102615780637a7f34e81461025c5780637c6edb3e146102575780637c715094146102525780637c901d7b1461024d5780638d935e1d146102485780638dd50eee1461024357806391d148541461023e57806395814bf514610239578063a217fddf14610234578063c350a1b51461022f578063ce537c9f1461022a578063d26bcc8014610225578063d547741f14610220578063e18b4dae1461021b578063e8c46c2814610216578063ec828a9114610211578063ef5122211461020c578063fd79d3e114610207578063fdd54123146102025763ff87c18c146101fd575f80fd5b611456565b611416565b6113ec565b6113cf565b61134a565b61132f565b611314565b6112b4565b611264565b611225565b610faa565b610f90565b610b8f565b610f11565b610ed1565b610eb4565b610e2d565b610dc5565b610d61565b610d37565b610cff565b610ce4565b610cc0565b610c79565b610bcc565b610b57565b610ad0565b6109d6565b6109ac565b61093e565b61090b565b6108dc565b610877565b6107f2565b610736565b6106e4565b6106c8565b6106ab565b610624565b61050c565b6104cb565b6103a5565b34610370576020600319360112610370576004357fffffffff00000000000000000000000000000000000000000000000000000000811680910361037057807f7965db0b0000000000000000000000000000000000000000000000000000000060209214908115610346575b506040519015158152f35b7f01ffc9a7000000000000000000000000000000000000000000000000000000009150145f61033b565b5f80fd5b9181601f840112156103705782359167ffffffffffffffff8311610370576020808501948460051b01011161037057565b346103705760406003193601126103705760043560243567ffffffffffffffff8111610370576103d9903690600401610374565b91906103e3612116565b815f52600c60205260ff60405f20541661048557815f52600d60205261040b60405f2061156a565b5f5b83811061045557507fa0fea12a5dfdb3ebf0b7c49a7ddd5ffdd3e5b2d7574ff16b0a1032edc19d658b61045393839261044b60405192839283611672565b0390a261220b565b005b60019061047f61046d855f52600d60205260405f2090565b61047883888761159a565b35906115f8565b0161040d565b7ffd93c15f000000000000000000000000000000000000000000000000000000005f5260045ffd5b73ffffffffffffffffffffffffffffffffffffffff81160361037057565b34610370576080600319360112610370576104536004356024356104ee816104ad565b604435906104fb826104ad565b60643592610507612116565b611686565b34610370576060600319360112610370576004356024356044359073ffffffffffffffffffffffffffffffffffffffff6003541633036105ce576002548211156105a65761055e925f55600155600255565b5f54600154600254604080519384526020840192909252908201527f78722ed9742b4dcda705d010fff7460a351e906f8223cff2d23a55b44b66427c9080606081015b0390a1005b7fc36ba423000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f24b2e7fd000000000000000000000000000000000000000000000000000000005f5260045ffd5b9181601f840112156103705782359167ffffffffffffffff8311610370576020838186019501011161037057565b346103705760a06003193601126103705760043560243560443567ffffffffffffffff81116103705761065b9036906004016105f6565b60649391933567ffffffffffffffff81116103705761067e903690600401610374565b916084359567ffffffffffffffff8711610370576106a3610453973690600401610374565b969095611896565b34610370575f600319360112610370576020600454604051908152f35b34610370575f6003193601126103705760205f54604051908152f35b3461037057602060031936011261037057602061072e6004355f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800602052600160405f20015490565b604051908152f35b346103705760406003193601126103705760043560243590805f52600c60205260ff60405f20541615610791575f52601060205260405f20905f5260205261078d60405f2054604051918291829190602083019252565b0390f35b7fc5b14571000000000000000000000000000000000000000000000000000000005f5260045ffd5b60206040818301928281528451809452019201905f5b8181106107dc5750505090565b82518452602093840193909201916001016107cf565b3461037057602060031936011261037057600435805f52600c60205260ff60405f20541615610791575f52600f60205260405f206040519081602082549182815201915f5260205f20905f5b8181106108615761078d8561085581870382611821565b604051918291826107b9565b825484526020909301926001928301920161083e565b346103705760406003193601126103705761045360243560043561089a826104ad565b6108d76108d2825f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800602052600160405f20015490565b61217e565b612605565b34610370576020600319360112610370576004355f52600c602052602060ff60405f2054166040519015158152f35b34610370575f60031936011261037057602073ffffffffffffffffffffffffffffffffffffffff60035416604051908152f35b346103705760406003193601126103705760043560243561095e816104ad565b3373ffffffffffffffffffffffffffffffffffffffff8216036109845761045391612722565b7f6697b232000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610370576020600319360112610370576004355f52600e602052602060405f2054604051908152f35b34610370576020600319360112610370576004355f815f52600c60205260ff60405f20541690825f52600d60205260405f2092604051808560208297549384815201905f5260205f20925f5b818110610ab7575050610a3792500385611821565b83515f5b8551811015610a9b57610a7a610a73610a5c855f52600a60205260405f2090565b610a66848a6119e7565b515f5260205260405f2090565b5460ff1690565b610a87575b600101610a3b565b92610a936001916119fb565b939050610a7f565b5060408051851515815260208101929092528101839052606090f35b8454835260019485019489945060209093019201610a22565b346103705760a06003193601126103705760043560243560443567ffffffffffffffff811161037057610b07903690600401610374565b60649391933567ffffffffffffffff811161037057610b2a903690600401610374565b916084359567ffffffffffffffff871161037057610b4f610453973690600401610374565b969095611af2565b3461037057604060031936011261037057600435602435905f52601060205260405f20905f52602052602060405f2054604051908152f35b3461037057604060031936011261037057600435602435905f52600a60205260405f20905f52602052602060ff60405f2054166040519015158152f35b3461037057604060031936011261037057600435602435905f52601160205260405f20905f52602052602073ffffffffffffffffffffffffffffffffffffffff60405f205416604051908152f35b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b600554811015610c5f5760055f5260205f2001905f90565b610c1a565b8054821015610c5f575f5260205f2001905f90565b3461037057604060031936011261037057600435602435905f52600d60205260405f20805482101561037057602091610cb191610c64565b90549060031b1c604051908152f35b3461037057602060031936011261037057610453600435610cdf612116565b611de5565b34610370575f60031936011261037057602060405160028152f35b3461037057604060031936011261037057600435602435905f52600b60205260405f20905f52602052602060405f2054604051908152f35b34610370576020600319360112610370576004355f526009602052602060405f2054604051908152f35b34610370576020600319360112610370576004355f52600d60205260405f206040519081602082549182815201915f5260205f20905f5b818110610daf5761078d8561085581870382611821565b8254845260209093019260019283019201610d98565b346103705760206003193601126103705773ffffffffffffffffffffffffffffffffffffffff600435610df7816104ad565b610dff612116565b167fffffffffffffffffffffffff000000000000000000000000000000000000000060035416176003555f80f35b346103705760a06003193601126103705760043560243560443567ffffffffffffffff811161037057610e649036906004016105f6565b60649391933567ffffffffffffffff811161037057610e87903690600401610374565b916084359567ffffffffffffffff871161037057610eac610453973690600401610374565b969095611ef3565b34610370575f600319360112610370576020600254604051908152f35b34610370576020600319360112610370576004355f526006602052602073ffffffffffffffffffffffffffffffffffffffff60405f205416604051908152f35b3461037057604060031936011261037057602060ff610f84602435600435610f38826104ad565b5f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800845260405f209073ffffffffffffffffffffffffffffffffffffffff165f5260205260405f2090565b54166040519015158152f35b34610370575f6003193601126103705760206040515f8152f35b3461037057606060031936011261037057600435610fc7816104ad565b60243590604435610fd7816104ad565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00549267ffffffffffffffff61102660ff604087901c1615611018565b1590565b9567ffffffffffffffff1690565b168015908161121d575b6001149081611213575b15908161120a575b506111e2576110c392846110ba60017fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000007ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005416177ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0055565b61116757612051565b6110c957005b6111347fffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0054167ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0055565b604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29080602081016105a1565b6111dd680100000000000000007fffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005416177ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0055565b612051565b7ff92ee8a9000000000000000000000000000000000000000000000000000000005f5260045ffd5b9050155f611042565b303b15915061103a565b859150611030565b3461037057602060031936011261037057600435805f52600c60205260ff60405f20541615610791575f52600e602052602060405f2054604051908152f35b34610370576020600319360112610370576004356005548110156103705760209060055f527f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db00154604051908152f35b34610370576040600319360112610370576104536024356004356112d7826104ad565b61130f6108d2825f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800602052600160405f20015490565b612722565b34610370575f60031936011261037057602060405160038152f35b34610370575f60031936011261037057602060405160078152f35b346103705760406003193601126103705760043560243590805f52600c60205260ff60405f20541615610791575f52601160205260405f20905f5260205261078d73ffffffffffffffffffffffffffffffffffffffff60405f2054166040519182918291909173ffffffffffffffffffffffffffffffffffffffff6020820193169052565b34610370575f600319360112610370576020600154604051908152f35b34610370576020600319360112610370576004355f526008602052602060405f2054604051908152f35b34610370576020600319360112610370576004355f526007602052602073ffffffffffffffffffffffffffffffffffffffff60405f205416604051908152f35b3461037057604060031936011261037057600435602435905f52600f60205260405f20805482101561037057602091610cb191610c64565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b908160011b91808304600214901517156114fe57565b6114bb565b9161151c918354905f199060031b92831b921b19161790565b9055565b906801000000000000000081116115655781549181815582821061154357505050565b5f5260205f2091820191015b81811061155a575050565b5f815560010161154f565b61148e565b8054905f815581611579575050565b5f5260205f20908101905b81811061158f575050565b5f8155600101611584565b9190811015610c5f5760051b0190565b600554680100000000000000008110156115655760018101600555600554811015610c5f5760055f527f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db00155565b80549068010000000000000000821015611565578161161f91600161151c94018155610c64565b81939154905f199060031b92831b921b19161790565b90918281527f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83116103705760209260051b809284830137010190565b916020611683938181520191611635565b90565b9073ffffffffffffffffffffffffffffffffffffffff6116cb6116b1845f52600660205260405f2090565b5473ffffffffffffffffffffffffffffffffffffffff1690565b166117dd5773ffffffffffffffffffffffffffffffffffffffff81161561179a5760045482146117c25773ffffffffffffffffffffffffffffffffffffffff83161561179a576117979261177761178992611725856115aa565b611737855f52600660205260405f2090565b9073ffffffffffffffffffffffffffffffffffffffff167fffffffffffffffffffffffff0000000000000000000000000000000000000000825416179055565b611737835f52600760205260405f2090565b5f52600860205260405f2090565b55565b7fd92e233d000000000000000000000000000000000000000000000000000000005f5260045ffd5b91506117db9250611737905f52600660205260405f2090565b565b7fdf650a00000000000000000000000000000000000000000000000000000000005f5260045ffd5b6040810190811067ffffffffffffffff82111761156557604052565b90601f601f19910116810190811067ffffffffffffffff82111761156557604052565b67ffffffffffffffff811161156557601f01601f191660200190565b92919261186c82611844565b9161187a6040519384611821565b829481845281830111610370578281602093845f960137010152565b969390949195926118a8368289611860565b602081519101205f5403611981575f8881526007602052604090205473ffffffffffffffffffffffffffffffffffffffff1695861561192857916119146117979896949261190e6119199997956119078d5f52600860205260405f2090565b54906122dc565b97612302565b6123c9565b915f52600960205260405f2090565b8860045414611959577f1242e9bb000000000000000000000000000000000000000000000000000000005f5260045ffd5b7fda261280000000000000000000000000000000000000000000000000000000005f5260045ffd5b7fefb64cf8000000000000000000000000000000000000000000000000000000005f5260045ffd5b805160021015610c5f5760600190565b805160101015610c5f576102200190565b805115610c5f5760200190565b805160011015610c5f5760400190565b8051821015610c5f5760209160051b010190565b5f1981146114fe5760010190565b929093611a27602095611a3494989798606087526060870191611635565b9184830386860152611635565b9060408183039101528281520191905f5b818110611a525750505090565b90919260208060019273ffffffffffffffffffffffffffffffffffffffff8735611a7b816104ad565b168152019401929101611a45565b9067ffffffffffffffff831161156557611aa38383611520565b905f5260205f205f5b838110611ab95750505050565b600190602084359401938184015501611aac565b90600182018092116114fe57565b919082018092116114fe57565b35611683816104ad565b959796909497929192611b21610a7387611b148a5f52600a60205260405f2090565b905f5260205260405f2090565b611ce157611b3b86611b14895f52600b60205260405f2090565b548482611b678c611b59876040519485938d8c60208701998a611a09565b03601f198101835282611821565b51902003611cb95797939291905f98611b928385611b8d8b5f52600f60205260405f2090565b611a89565b5f955b838710611c1c5750505050505050611c165f916117db9495611bbf855f52600e60205260405f2090565b55611c04611bd982611b14875f52600a60205260405f2090565b60017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00825416179055565b611b14845f52600b60205260405f2090565b5561220b565b90919293949599611c3b600191611c348d858b61159a565b3590611adb565b9a611c4781848a61159a565b35611c80611c78611c608d5f52601060205260405f2090565b611c6b858b8d61159a565b355f5260205260405f2090565b918254611adb565b9055611cad611c98611c9383888861159a565b611ae8565b611737611c608d5f52601160205260405f2090565b01959493929190611b95565b7f5cb045db000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f9fbfc589000000000000000000000000000000000000000000000000000000005f5260045ffd5b905f1982019182116114fe57565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff4082019182116114fe57565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8082019182116114fe57565b60200390602082116114fe57565b919082039182116114fe57565b6005548015611db8575f19810190600554821015610c5f575f195f916005835260208320010155600555565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603160045260245ffd5b6004548114611ede5760055480915f5b838110611ebc575b50828214611e9457611e3a61179792611e34611e2e611e24611e1f5f98611d09565b610c47565b90549060031b1c90565b91610c47565b90611503565b611e42611d8c565b611e7f611e57825f52600660205260405f2090565b7fffffffffffffffffffffffff00000000000000000000000000000000000000008154169055565b611789611e57825f52600760205260405f2090565b7f1242e9bb000000000000000000000000000000000000000000000000000000005f5260045ffd5b81611ec9611e2483610c47565b14611ed657600101611df5565b91505f611dfd565b611e576117db915f52600660205260405f2090565b9693909592949194611f14610a7388611b148b5f52600a60205260405f2090565b8015612032575b611ce157611f2a368288611860565b60208151910120611f43885f52600960205260405f2090565b546004548914612029575b0361200157611f5e958789612837565b908115611fd95780611fb491847f2c3f443599c6268aced473e7660b40746ea394d519179ea3f60f382974a2e78e60405180611f9f88829190602083019252565b0390a3611b14845f52600b60205260405f2090565b55611fc7815f52600d60205260405f2090565b5415611fd05750565b6117db90612914565b7f9a0cce53000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f9d8cbacd000000000000000000000000000000000000000000000000000000005f5260045ffd5b50600154611f4e565b5061204987611b148a5f52600b60205260405f2090565b541515611f1b565b73ffffffffffffffffffffffffffffffffffffffff16801561179a5773ffffffffffffffffffffffffffffffffffffffff83161561179a577fffffffffffffffffffffffff0000000000000000000000000000000000000000600354161760035560045560ff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005460401c16156120ee576120eb9061251e565b50565b7fd7e6bcf8000000000000000000000000000000000000000000000000000000005f5260045ffd5b335f9081527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d602052604090205460ff161561214e57565b7fe2517d3f000000000000000000000000000000000000000000000000000000005f52336004525f60245260445ffd5b805f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b62680060205260ff6121d23360405f209073ffffffffffffffffffffffffffffffffffffffff165f5260205260405f2090565b5416156121dc5750565b7fe2517d3f000000000000000000000000000000000000000000000000000000005f523360045260245260445ffd5b805f52600d60205260405f20604051808260208294549384815201905f5260205f20925f5b8181106122c357505061224592500382611821565b5f5b815181101561228657612275611014610a7361226b865f52600a60205260405f2090565b610a6685876119e7565b61228157600101612247565b505050565b505061229d611bd9825f52600c60205260405f2090565b7f78df938181afcb28eaa7d099235bbf9877832d6faafe36d1ea70916f3ace33e05f80a2565b8454835260019485019486945060209093019201612230565b9060405190602082019283526040820152604081526122fc606082611821565b51902090565b6123146123199161231e933691611860565b612982565b6129fd565b805160031015610c5f576080611683910151612aaa565b67ffffffffffffffff81116115655760051b60200190565b92919261235982612335565b936123676040519586611821565b602085848152019260051b8201918183116103705780935b83851061238d575050505050565b843567ffffffffffffffff811161037057820183601f82011215610370576020916123be8583858095359101611860565b81520194019361237f565b909161244361243e6123149461244996989997996040517fffffffffffffffffffffffffffffffffffffffff000000000000000000000000602082019260601b1682526014815261241b603482611821565b5190209360405194602086015260208552612437604086611821565b369161234d565b612aec565b91612b96565b918251156124f65761244361243e6124b0926124be9661243761247f6124796124746123149a6129fd565b6119a9565b51612aaa565b9660405161249a81611b596020820194859190602083019252565b5190206040519687916020830160209181520190565b03601f198101875286611821565b8051156124ce5761168390612aaa565b7f3477dcda000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f547706af000000000000000000000000000000000000000000000000000000005f5260045ffd5b73ffffffffffffffffffffffffffffffffffffffff81165f9081527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d602052604090205460ff166126005773ffffffffffffffffffffffffffffffffffffffff165f8181527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d6020526040812080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790553391907f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d8180a4600190565b505f90565b805f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b62680060205260ff6126598360405f209073ffffffffffffffffffffffffffffffffffffffff165f5260205260405f2090565b541661271c57805f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b6268006020526126b18260405f209073ffffffffffffffffffffffffffffffffffffffff165f5260205260405f2090565b60017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0082541617905573ffffffffffffffffffffffffffffffffffffffff339216907f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d5f80a4600190565b50505f90565b805f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b62680060205260ff6127768360405f209073ffffffffffffffffffffffffffffffffffffffff165f5260205260405f2090565b54161561271c57805f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b6268006020526127cf8260405f209073ffffffffffffffffffffffffffffffffffffffff165f5260205260405f2090565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00815416905573ffffffffffffffffffffffffffffffffffffffff339216907ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b5f80a4600190565b95929693909491945f52600660205273ffffffffffffffffffffffffffffffffffffffff60405f205416948515611e94576116839761287591612302565b95604051602081019182526007604082015260408152612896606082611821565b519020956123c9565b600581146120eb576005549067ffffffffffffffff8211611565576128c48282611520565b5f908152602081207f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db080545b8484106128fe575050505050565b60018091920193845492818501550192906128f0565b805f52600d60205261292860405f2061289f565b600454805f52600660205273ffffffffffffffffffffffffffffffffffffffff60405f205416612956575050565b6117db915f52600d60205260405f206115f8565b6040519061297782611805565b5f6020838281520152565b61298a61296a565b5060208151916040519261299d84611805565b835201602082015290565b1561037057565b906129b982612335565b6129c66040519182611821565b828152601f196129d68294612335565b01905f5b8281106129e657505050565b6020906129f161296a565b828285010152016129da565b90612a0782612ecc565b1561037057612a1582612eeb565b91612a1f836129af565b90602081018051612a2f81612f4c565b81018091116114fe57945f905b808210612a5e575050611683929394612a56915190611d7f565b9051146129a8565b9095612aa281612a6f600193612fb7565b90604051612a7e604082611821565b828152816020820152612a918b8a6119e7565b52612a9c8a896119e7565b50611adb565b960190612a3c565b80518015159081612ae0575b501561037057612ac590613071565b90519060208110612ad4575090565b6020036101000a900490565b6021915011155f612ab6565b612af681516129af565b905f5b8151811015612b345780612b18612b12600193856119e7565b51612982565b612b2282866119e7565b52612b2d81856119e7565b5001612af9565b505090565b60405190612b48602083611821565b5f808352366020840137565b90612b5e82611844565b612b6b6040519182611821565b828152601f19612b7b8294611844565b0190602036910137565b908151811015610c5f570160200190565b90612ba0906130d1565b5f915f612bab61296a565b50845115612e9357935f915b8151831015612e345782158080612e1e575b610370571580612e02575b61037057612beb612be584846119e7565b516129fd565b958651600281145f14612cec575050612c14612c0f612c09886119ca565b51613319565b613367565b95612c2a612c238888846133d4565b8092611adb565b965111612cce5715612c615750612c419051611d09565b11610370575111612c5857612c09611683916119d7565b50611683612b39565b919094612c6e8651611d09565b82146103705780612c8c611014612c866001946119d7565b51612ecc565b15612caf57612c9d612ca3916119d7565b51613359565b915b0191949094612bb7565b612cbb612cc8916119d7565b5160208101519051902090565b91612ca5565b505091509250612cdf915051611d09565b1161037057611683612b39565b6011909791939794929414612d05575b50600190612ca5565b959380925094929094518314155f14612de45760ff612d5f612d59612d53612d2d8787612b85565b517fff000000000000000000000000000000000000000000000000000000000000001690565b60f81c90565b94611acd565b9316601081101561037057612d7d612d7782896119e7565b51613343565b15612d9f5750505050612d9291925051611d09565b0361037057611683612b39565b86612db7611014612c8684600196989a97999b6119e7565b15612dd157612dc991612c9d916119e7565b915b90612cfc565b612dde91612cbb916119e7565b91612dcb565b505050612df19051611d09565b0361037057612c09611683916119b9565b50612e16612e1084846119e7565b516132e2565b861415612bd4565b50612e2c612cbb85856119e7565b821415612bc9565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f496e76616c6964204d50542070726f6f660000000000000000000000000000006044820152606490fd5b509050612ec492507f56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b4219150146129a8565b611683612b39565b80511561260057602060c0910151515f1a10612ee757600190565b5f90565b805115612600575f9060208101908151612f0481612f4c565b81018091116114fe579151905181018091116114fe5791905b828110612f2a5750905090565b612f3381612fb7565b81018091116114fe57612f4690916119fb565b90612f1d565b515f1a6080811015612f5d57505f90565b60b881108015612fa1575b15612f735750600190565b60c0811015612f925761168390612f8d9060b75b90611d7f565b611acd565b61168390612f8d9060f7612f87565b5060c08110158015612f68575060f88110612f68565b80515f1a906080821015612fcc575050600190565b60b8821015612fe25750612f8d61168391611d44565b60c08210156130235760010151602082900360b7016101000a9004017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff4a0190565b60f88210156130395750612f8d61168391611d17565b60010151602082900360f7016101000a9004017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0a0190565b9060208201916130818351612f4c565b9251908382018092116114fe57519283039283116114fe579190565b156130a457565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52600160045260245ffd5b906130fa5f6130eb84516130e68115156129a8565b6114e8565b6130f560016129a8565b611d7f565b9061310482612b54565b925f91825b613113855f611adb565b8410156131d35761318e612d596131139261312e8760011690565b613196577f0f0000000000000000000000000000000000000000000000000000000000000061317861316f612d53612d2d6131698c60011c90565b8b612b85565b60041c600f1690565b60f81b165f1a613188828b612b85565b53611acd565b939050613109565b7f0f000000000000000000000000000000000000000000000000000000000000006131786131cd612d53612d2d6131698c60011c90565b60ff1690565b915092506117db915083511461309d565b613204826131f883516130e68115156129a8565b6130f5818311156129a8565b9061320e82612b54565b9383925f5b61321d8287611adb565b8510156132d0579061329061328a61321d936132398860011690565b613299577f0f0000000000000000000000000000000000000000000000000000000000000061327a61316f612d53612d2d6132748d60011c90565b8c612b85565b60f81b165f1a613188828c612b85565b95611acd565b94909150613213565b7f0f0000000000000000000000000000000000000000000000000000000000000061327a6131cd612d53612d2d6132748d60011c90565b92505092506117db915083511461309d565b805160208110156132fa575060208101519051902090565b90602001512060405160208101918252602081526122fc604082611821565b8051156103705761332c61168391613071565b61333881939293612b54565b928360200190613487565b60018151036126005760200151515f1a60801490565b61336290613071565b902090565b9081511561037057600f61338361316f612d53612d2d866119ca565b1680613396575061168360025f936131e4565b600181036133ab575061168360015f936131e4565b600281036133c1575061168360026001936131e4565b60030361037057611683600180936131e4565b91905f5b8381018082116114fe57825181108061346e575b156134665761341c7fff000000000000000000000000000000000000000000000000000000000000009184612b85565b51167fff000000000000000000000000000000000000000000000000000000000000006134498386612b85565b5116900361345f5761345a906119fb565b6133d8565b9250505090565b509250505090565b50835182106133ec565b601f81116114fe576101000a90565b90918015612281575b60208110156134ca57806134a357505050565b6134b76134b26134bc92611d71565b613478565b611d09565b905182518216911916179052565b919080518252602081018091116114fe5790602081018091116114fe5791601f19810190811115613490576114bb56
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x11W_\x80\xFD[_5`\xE0\x1C\x80c\x01\xFF\xC9\xA7\x14a\x02\xCFW\x80c\x03DW\x1F\x14a\x02\xCAW\x80c\x13;\xF8\x9F\x14a\x02\xC5W\x80c\x19w\x16@\x14a\x02\xC0W\x80c\x1B\xF4\x95\x1C\x14a\x02\xBBW\x80c\"b8\x97\x14a\x02\xB6W\x80c#\xAF\xB0\xFF\x14a\x02\xB1W\x80c$\x8A\x9C\xA3\x14a\x02\xACW\x80c(_$F\x14a\x02\xA7W\x80c,\xD0x\xB8\x14a\x02\xA2W\x80c//\xF1]\x14a\x02\x9DW\x80c0\xC7\t\xB6\x14a\x02\x98W\x80c6+\x81T\x14a\x02\x93W\x80c6V\x8A\xBE\x14a\x02\x8EW\x80cG\xDF\xF6\x9D\x14a\x02\x89W\x80cNm\xA2\xA4\x14a\x02\x84W\x80cR\x9FKV\x14a\x02\x7FW\x80cU\xFC\xC5V\x14a\x02zW\x80cZc0\x80\x14a\x029W\x80c[\x18\x17\xE8\x14a\x02uW\x80c]W\x9Aa\x14a\x02pW\x80ce\x0E\x13\x12\x14a\x02kW\x80ckM\x17\xAD\x14a\x02fW\x80ck\xA3\xD1\x7F\x14a\x02aW\x80cz\x7F4\xE8\x14a\x02\\W\x80c|n\xDB>\x14a\x02WW\x80c|qP\x94\x14a\x02RW\x80c|\x90\x1D{\x14a\x02MW\x80c\x8D\x93^\x1D\x14a\x02HW\x80c\x8D\xD5\x0E\xEE\x14a\x02CW\x80c\x91\xD1HT\x14a\x02>W\x80c\x95\x81K\xF5\x14a\x029W\x80c\xA2\x17\xFD\xDF\x14a\x024W\x80c\xC3P\xA1\xB5\x14a\x02/W\x80c\xCES|\x9F\x14a\x02*W\x80c\xD2k\xCC\x80\x14a\x02%W\x80c\xD5Gt\x1F\x14a\x02 W\x80c\xE1\x8BM\xAE\x14a\x02\x1BW\x80c\xE8\xC4l(\x14a\x02\x16W\x80c\xEC\x82\x8A\x91\x14a\x02\x11W\x80c\xEFQ\"!\x14a\x02\x0CW\x80c\xFDy\xD3\xE1\x14a\x02\x07W\x80c\xFD\xD5A#\x14a\x02\x02Wc\xFF\x87\xC1\x8C\x14a\x01\xFDW_\x80\xFD[a\x14VV[a\x14\x16V[a\x13\xECV[a\x13\xCFV[a\x13JV[a\x13/V[a\x13\x14V[a\x12\xB4V[a\x12dV[a\x12%V[a\x0F\xAAV[a\x0F\x90V[a\x0B\x8FV[a\x0F\x11V[a\x0E\xD1V[a\x0E\xB4V[a\x0E-V[a\r\xC5V[a\raV[a\r7V[a\x0C\xFFV[a\x0C\xE4V[a\x0C\xC0V[a\x0CyV[a\x0B\xCCV[a\x0BWV[a\n\xD0V[a\t\xD6V[a\t\xACV[a\t>V[a\t\x0BV[a\x08\xDCV[a\x08wV[a\x07\xF2V[a\x076V[a\x06\xE4V[a\x06\xC8V[a\x06\xABV[a\x06$V[a\x05\x0CV[a\x04\xCBV[a\x03\xA5V[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16\x80\x91\x03a\x03pW\x80\x7Fye\xDB\x0B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x92\x14\x90\x81\x15a\x03FW[P`@Q\x90\x15\x15\x81R\xF3[\x7F\x01\xFF\xC9\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91P\x14_a\x03;V[_\x80\xFD[\x91\x81`\x1F\x84\x01\x12\x15a\x03pW\x825\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x03pW` \x80\x85\x01\x94\x84`\x05\x1B\x01\x01\x11a\x03pWV[4a\x03pW`@`\x03\x196\x01\x12a\x03pW`\x045`$5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03pWa\x03\xD9\x906\x90`\x04\x01a\x03tV[\x91\x90a\x03\xE3a!\x16V[\x81_R`\x0C` R`\xFF`@_ T\x16a\x04\x85W\x81_R`\r` Ra\x04\x0B`@_ a\x15jV[_[\x83\x81\x10a\x04UWP\x7F\xA0\xFE\xA1*]\xFD\xB3\xEB\xF0\xB7\xC4\x9A}\xDD_\xFD\xD3\xE5\xB2\xD7WO\xF1k\n\x102\xED\xC1\x9De\x8Ba\x04S\x93\x83\x92a\x04K`@Q\x92\x83\x92\x83a\x16rV[\x03\x90\xA2a\"\x0BV[\0[`\x01\x90a\x04\x7Fa\x04m\x85_R`\r` R`@_ \x90V[a\x04x\x83\x88\x87a\x15\x9AV[5\x90a\x15\xF8V[\x01a\x04\rV[\x7F\xFD\x93\xC1_\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x03a\x03pWV[4a\x03pW`\x80`\x03\x196\x01\x12a\x03pWa\x04S`\x045`$5a\x04\xEE\x81a\x04\xADV[`D5\x90a\x04\xFB\x82a\x04\xADV[`d5\x92a\x05\x07a!\x16V[a\x16\x86V[4a\x03pW```\x03\x196\x01\x12a\x03pW`\x045`$5`D5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x03T\x163\x03a\x05\xCEW`\x02T\x82\x11\x15a\x05\xA6Wa\x05^\x92_U`\x01U`\x02UV[_T`\x01T`\x02T`@\x80Q\x93\x84R` \x84\x01\x92\x90\x92R\x90\x82\x01R\x7Fxr.\xD9t+M\xCD\xA7\x05\xD0\x10\xFF\xF7F\n5\x1E\x90o\x82#\xCF\xF2\xD2:U\xB4KfB|\x90\x80``\x81\x01[\x03\x90\xA1\0[\x7F\xC3k\xA4#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F$\xB2\xE7\xFD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x91\x81`\x1F\x84\x01\x12\x15a\x03pW\x825\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x03pW` \x83\x81\x86\x01\x95\x01\x01\x11a\x03pWV[4a\x03pW`\xA0`\x03\x196\x01\x12a\x03pW`\x045`$5`D5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03pWa\x06[\x906\x90`\x04\x01a\x05\xF6V[`d\x93\x91\x935g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03pWa\x06~\x906\x90`\x04\x01a\x03tV[\x91`\x845\x95g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x87\x11a\x03pWa\x06\xA3a\x04S\x976\x90`\x04\x01a\x03tV[\x96\x90\x95a\x18\x96V[4a\x03pW_`\x03\x196\x01\x12a\x03pW` `\x04T`@Q\x90\x81R\xF3[4a\x03pW_`\x03\x196\x01\x12a\x03pW` _T`@Q\x90\x81R\xF3[4a\x03pW` `\x03\x196\x01\x12a\x03pW` a\x07.`\x045_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`\x01`@_ \x01T\x90V[`@Q\x90\x81R\xF3[4a\x03pW`@`\x03\x196\x01\x12a\x03pW`\x045`$5\x90\x80_R`\x0C` R`\xFF`@_ T\x16\x15a\x07\x91W_R`\x10` R`@_ \x90_R` Ra\x07\x8D`@_ T`@Q\x91\x82\x91\x82\x91\x90` \x83\x01\x92RV[\x03\x90\xF3[\x7F\xC5\xB1Eq\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[` `@\x81\x83\x01\x92\x82\x81R\x84Q\x80\x94R\x01\x92\x01\x90_[\x81\x81\x10a\x07\xDCWPPP\x90V[\x82Q\x84R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x07\xCFV[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045\x80_R`\x0C` R`\xFF`@_ T\x16\x15a\x07\x91W_R`\x0F` R`@_ `@Q\x90\x81` \x82T\x91\x82\x81R\x01\x91_R` _ \x90_[\x81\x81\x10a\x08aWa\x07\x8D\x85a\x08U\x81\x87\x03\x82a\x18!V[`@Q\x91\x82\x91\x82a\x07\xB9V[\x82T\x84R` \x90\x93\x01\x92`\x01\x92\x83\x01\x92\x01a\x08>V[4a\x03pW`@`\x03\x196\x01\x12a\x03pWa\x04S`$5`\x045a\x08\x9A\x82a\x04\xADV[a\x08\xD7a\x08\xD2\x82_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`\x01`@_ \x01T\x90V[a!~V[a&\x05V[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045_R`\x0C` R` `\xFF`@_ T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x03pW_`\x03\x196\x01\x12a\x03pW` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x03T\x16`@Q\x90\x81R\xF3[4a\x03pW`@`\x03\x196\x01\x12a\x03pW`\x045`$5a\t^\x81a\x04\xADV[3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x03a\t\x84Wa\x04S\x91a'\"V[\x7Ff\x97\xB22\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045_R`\x0E` R` `@_ T`@Q\x90\x81R\xF3[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045_\x81_R`\x0C` R`\xFF`@_ T\x16\x90\x82_R`\r` R`@_ \x92`@Q\x80\x85` \x82\x97T\x93\x84\x81R\x01\x90_R` _ \x92_[\x81\x81\x10a\n\xB7WPPa\n7\x92P\x03\x85a\x18!V[\x83Q_[\x85Q\x81\x10\x15a\n\x9BWa\nza\nsa\n\\\x85_R`\n` R`@_ \x90V[a\nf\x84\x8Aa\x19\xE7V[Q_R` R`@_ \x90V[T`\xFF\x16\x90V[a\n\x87W[`\x01\x01a\n;V[\x92a\n\x93`\x01\x91a\x19\xFBV[\x93\x90Pa\n\x7FV[P`@\x80Q\x85\x15\x15\x81R` \x81\x01\x92\x90\x92R\x81\x01\x83\x90R``\x90\xF3[\x84T\x83R`\x01\x94\x85\x01\x94\x89\x94P` \x90\x93\x01\x92\x01a\n\"V[4a\x03pW`\xA0`\x03\x196\x01\x12a\x03pW`\x045`$5`D5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03pWa\x0B\x07\x906\x90`\x04\x01a\x03tV[`d\x93\x91\x935g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03pWa\x0B*\x906\x90`\x04\x01a\x03tV[\x91`\x845\x95g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x87\x11a\x03pWa\x0BOa\x04S\x976\x90`\x04\x01a\x03tV[\x96\x90\x95a\x1A\xF2V[4a\x03pW`@`\x03\x196\x01\x12a\x03pW`\x045`$5\x90_R`\x10` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x03pW`@`\x03\x196\x01\x12a\x03pW`\x045`$5\x90_R`\n` R`@_ \x90_R` R` `\xFF`@_ T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x03pW`@`\x03\x196\x01\x12a\x03pW`\x045`$5\x90_R`\x11` R`@_ \x90_R` R` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ T\x16`@Q\x90\x81R\xF3[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[`\x05T\x81\x10\x15a\x0C_W`\x05_R` _ \x01\x90_\x90V[a\x0C\x1AV[\x80T\x82\x10\x15a\x0C_W_R` _ \x01\x90_\x90V[4a\x03pW`@`\x03\x196\x01\x12a\x03pW`\x045`$5\x90_R`\r` R`@_ \x80T\x82\x10\x15a\x03pW` \x91a\x0C\xB1\x91a\x0CdV[\x90T\x90`\x03\x1B\x1C`@Q\x90\x81R\xF3[4a\x03pW` `\x03\x196\x01\x12a\x03pWa\x04S`\x045a\x0C\xDFa!\x16V[a\x1D\xE5V[4a\x03pW_`\x03\x196\x01\x12a\x03pW` `@Q`\x02\x81R\xF3[4a\x03pW`@`\x03\x196\x01\x12a\x03pW`\x045`$5\x90_R`\x0B` R`@_ \x90_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045_R`\t` R` `@_ T`@Q\x90\x81R\xF3[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045_R`\r` R`@_ `@Q\x90\x81` \x82T\x91\x82\x81R\x01\x91_R` _ \x90_[\x81\x81\x10a\r\xAFWa\x07\x8D\x85a\x08U\x81\x87\x03\x82a\x18!V[\x82T\x84R` \x90\x93\x01\x92`\x01\x92\x83\x01\x92\x01a\r\x98V[4a\x03pW` `\x03\x196\x01\x12a\x03pWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x045a\r\xF7\x81a\x04\xADV[a\r\xFFa!\x16V[\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x03T\x16\x17`\x03U_\x80\xF3[4a\x03pW`\xA0`\x03\x196\x01\x12a\x03pW`\x045`$5`D5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03pWa\x0Ed\x906\x90`\x04\x01a\x05\xF6V[`d\x93\x91\x935g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03pWa\x0E\x87\x906\x90`\x04\x01a\x03tV[\x91`\x845\x95g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x87\x11a\x03pWa\x0E\xACa\x04S\x976\x90`\x04\x01a\x03tV[\x96\x90\x95a\x1E\xF3V[4a\x03pW_`\x03\x196\x01\x12a\x03pW` `\x02T`@Q\x90\x81R\xF3[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045_R`\x06` R` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ T\x16`@Q\x90\x81R\xF3[4a\x03pW`@`\x03\x196\x01\x12a\x03pW` `\xFFa\x0F\x84`$5`\x045a\x0F8\x82a\x04\xADV[_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0\x84R`@_ \x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_R` R`@_ \x90V[T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x03pW_`\x03\x196\x01\x12a\x03pW` `@Q_\x81R\xF3[4a\x03pW```\x03\x196\x01\x12a\x03pW`\x045a\x0F\xC7\x81a\x04\xADV[`$5\x90`D5a\x0F\xD7\x81a\x04\xADV[\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x92g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x10&`\xFF`@\x87\x90\x1C\x16\x15a\x10\x18V[\x15\x90V[\x95g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[\x16\x80\x15\x90\x81a\x12\x1DW[`\x01\x14\x90\x81a\x12\x13W[\x15\x90\x81a\x12\nW[Pa\x11\xE2Wa\x10\xC3\x92\x84a\x10\xBA`\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x16\x17\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0UV[a\x11gWa QV[a\x10\xC9W\0[a\x114\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x16\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0UV[`@Q`\x01\x81R\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x90\x80` \x81\x01a\x05\xA1V[a\x11\xDDh\x01\0\0\0\0\0\0\0\0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x16\x17\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0UV[a QV[\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90P\x15_a\x10BV[0;\x15\x91Pa\x10:V[\x85\x91Pa\x100V[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045\x80_R`\x0C` R`\xFF`@_ T\x16\x15a\x07\x91W_R`\x0E` R` `@_ T`@Q\x90\x81R\xF3[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045`\x05T\x81\x10\x15a\x03pW` \x90`\x05_R\x7F\x03kc\x84\xB5\xEC\xA7\x91\xC6'a\x15-\x0Cy\xBB\x06\x04\xC1\x04\xA5\xFBoN\xB0p?1T\xBB=\xB0\x01T`@Q\x90\x81R\xF3[4a\x03pW`@`\x03\x196\x01\x12a\x03pWa\x04S`$5`\x045a\x12\xD7\x82a\x04\xADV[a\x13\x0Fa\x08\xD2\x82_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`\x01`@_ \x01T\x90V[a'\"V[4a\x03pW_`\x03\x196\x01\x12a\x03pW` `@Q`\x03\x81R\xF3[4a\x03pW_`\x03\x196\x01\x12a\x03pW` `@Q`\x07\x81R\xF3[4a\x03pW`@`\x03\x196\x01\x12a\x03pW`\x045`$5\x90\x80_R`\x0C` R`\xFF`@_ T\x16\x15a\x07\x91W_R`\x11` R`@_ \x90_R` Ra\x07\x8Ds\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ T\x16`@Q\x91\x82\x91\x82\x91\x90\x91s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF` \x82\x01\x93\x16\x90RV[4a\x03pW_`\x03\x196\x01\x12a\x03pW` `\x01T`@Q\x90\x81R\xF3[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045_R`\x08` R` `@_ T`@Q\x90\x81R\xF3[4a\x03pW` `\x03\x196\x01\x12a\x03pW`\x045_R`\x07` R` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ T\x16`@Q\x90\x81R\xF3[4a\x03pW`@`\x03\x196\x01\x12a\x03pW`\x045`$5\x90_R`\x0F` R`@_ \x80T\x82\x10\x15a\x03pW` \x91a\x0C\xB1\x91a\x0CdV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[\x90\x81`\x01\x1B\x91\x80\x83\x04`\x02\x14\x90\x15\x17\x15a\x14\xFEWV[a\x14\xBBV[\x91a\x15\x1C\x91\x83T\x90_\x19\x90`\x03\x1B\x92\x83\x1B\x92\x1B\x19\x16\x17\x90V[\x90UV[\x90h\x01\0\0\0\0\0\0\0\0\x81\x11a\x15eW\x81T\x91\x81\x81U\x82\x82\x10a\x15CWPPPV[_R` _ \x91\x82\x01\x91\x01[\x81\x81\x10a\x15ZWPPV[_\x81U`\x01\x01a\x15OV[a\x14\x8EV[\x80T\x90_\x81U\x81a\x15yWPPV[_R` _ \x90\x81\x01\x90[\x81\x81\x10a\x15\x8FWPPV[_\x81U`\x01\x01a\x15\x84V[\x91\x90\x81\x10\x15a\x0C_W`\x05\x1B\x01\x90V[`\x05Th\x01\0\0\0\0\0\0\0\0\x81\x10\x15a\x15eW`\x01\x81\x01`\x05U`\x05T\x81\x10\x15a\x0C_W`\x05_R\x7F\x03kc\x84\xB5\xEC\xA7\x91\xC6'a\x15-\x0Cy\xBB\x06\x04\xC1\x04\xA5\xFBoN\xB0p?1T\xBB=\xB0\x01UV[\x80T\x90h\x01\0\0\0\0\0\0\0\0\x82\x10\x15a\x15eW\x81a\x16\x1F\x91`\x01a\x15\x1C\x94\x01\x81Ua\x0CdV[\x81\x93\x91T\x90_\x19\x90`\x03\x1B\x92\x83\x1B\x92\x1B\x19\x16\x17\x90V[\x90\x91\x82\x81R\x7F\x07\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x03pW` \x92`\x05\x1B\x80\x92\x84\x83\x017\x01\x01\x90V[\x91` a\x16\x83\x93\x81\x81R\x01\x91a\x165V[\x90V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x16\xCBa\x16\xB1\x84_R`\x06` R`@_ \x90V[Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[\x16a\x17\xDDWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x15a\x17\x9AW`\x04T\x82\x14a\x17\xC2Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16\x15a\x17\x9AWa\x17\x97\x92a\x17wa\x17\x89\x92a\x17%\x85a\x15\xAAV[a\x177\x85_R`\x06` R`@_ \x90V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82T\x16\x17\x90UV[a\x177\x83_R`\x07` R`@_ \x90V[_R`\x08` R`@_ \x90V[UV[\x7F\xD9.#=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x91Pa\x17\xDB\x92Pa\x177\x90_R`\x06` R`@_ \x90V[V[\x7F\xDFe\n\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[`@\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x15eW`@RV[\x90`\x1F`\x1F\x19\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x15eW`@RV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x15eW`\x1F\x01`\x1F\x19\x16` \x01\x90V[\x92\x91\x92a\x18l\x82a\x18DV[\x91a\x18z`@Q\x93\x84a\x18!V[\x82\x94\x81\x84R\x81\x83\x01\x11a\x03pW\x82\x81` \x93\x84_\x96\x017\x01\x01RV[\x96\x93\x90\x94\x91\x95\x92a\x18\xA86\x82\x89a\x18`V[` \x81Q\x91\x01 _T\x03a\x19\x81W_\x88\x81R`\x07` R`@\x90 Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x95\x86\x15a\x19(W\x91a\x19\x14a\x17\x97\x98\x96\x94\x92a\x19\x0Ea\x19\x19\x99\x97\x95a\x19\x07\x8D_R`\x08` R`@_ \x90V[T\x90a\"\xDCV[\x97a#\x02V[a#\xC9V[\x91_R`\t` R`@_ \x90V[\x88`\x04T\x14a\x19YW\x7F\x12B\xE9\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\xDA&\x12\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\xEF\xB6L\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x80Q`\x02\x10\x15a\x0C_W``\x01\x90V[\x80Q`\x10\x10\x15a\x0C_Wa\x02 \x01\x90V[\x80Q\x15a\x0C_W` \x01\x90V[\x80Q`\x01\x10\x15a\x0C_W`@\x01\x90V[\x80Q\x82\x10\x15a\x0C_W` \x91`\x05\x1B\x01\x01\x90V[_\x19\x81\x14a\x14\xFEW`\x01\x01\x90V[\x92\x90\x93a\x1A'` \x95a\x1A4\x94\x98\x97\x98``\x87R``\x87\x01\x91a\x165V[\x91\x84\x83\x03\x86\x86\x01Ra\x165V[\x90`@\x81\x83\x03\x91\x01R\x82\x81R\x01\x91\x90_[\x81\x81\x10a\x1ARWPPP\x90V[\x90\x91\x92` \x80`\x01\x92s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x875a\x1A{\x81a\x04\xADV[\x16\x81R\x01\x94\x01\x92\x91\x01a\x1AEV[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x15eWa\x1A\xA3\x83\x83a\x15 V[\x90_R` _ _[\x83\x81\x10a\x1A\xB9WPPPPV[`\x01\x90` \x845\x94\x01\x93\x81\x84\x01U\x01a\x1A\xACV[\x90`\x01\x82\x01\x80\x92\x11a\x14\xFEWV[\x91\x90\x82\x01\x80\x92\x11a\x14\xFEWV[5a\x16\x83\x81a\x04\xADV[\x95\x97\x96\x90\x94\x97\x92\x91\x92a\x1B!a\ns\x87a\x1B\x14\x8A_R`\n` R`@_ \x90V[\x90_R` R`@_ \x90V[a\x1C\xE1Wa\x1B;\x86a\x1B\x14\x89_R`\x0B` R`@_ \x90V[T\x84\x82a\x1Bg\x8Ca\x1BY\x87`@Q\x94\x85\x93\x8D\x8C` \x87\x01\x99\x8Aa\x1A\tV[\x03`\x1F\x19\x81\x01\x83R\x82a\x18!V[Q\x90 \x03a\x1C\xB9W\x97\x93\x92\x91\x90_\x98a\x1B\x92\x83\x85a\x1B\x8D\x8B_R`\x0F` R`@_ \x90V[a\x1A\x89V[_\x95[\x83\x87\x10a\x1C\x1CWPPPPPPPa\x1C\x16_\x91a\x17\xDB\x94\x95a\x1B\xBF\x85_R`\x0E` R`@_ \x90V[Ua\x1C\x04a\x1B\xD9\x82a\x1B\x14\x87_R`\n` R`@_ \x90V[`\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x82T\x16\x17\x90UV[a\x1B\x14\x84_R`\x0B` R`@_ \x90V[Ua\"\x0BV[\x90\x91\x92\x93\x94\x95\x99a\x1C;`\x01\x91a\x1C4\x8D\x85\x8Ba\x15\x9AV[5\x90a\x1A\xDBV[\x9Aa\x1CG\x81\x84\x8Aa\x15\x9AV[5a\x1C\x80a\x1Cxa\x1C`\x8D_R`\x10` R`@_ \x90V[a\x1Ck\x85\x8B\x8Da\x15\x9AV[5_R` R`@_ \x90V[\x91\x82Ta\x1A\xDBV[\x90Ua\x1C\xADa\x1C\x98a\x1C\x93\x83\x88\x88a\x15\x9AV[a\x1A\xE8V[a\x177a\x1C`\x8D_R`\x11` R`@_ \x90V[\x01\x95\x94\x93\x92\x91\x90a\x1B\x95V[\x7F\\\xB0E\xDB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\x9F\xBF\xC5\x89\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90_\x19\x82\x01\x91\x82\x11a\x14\xFEWV[\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF@\x82\x01\x91\x82\x11a\x14\xFEWV[\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x01\x91\x82\x11a\x14\xFEWV[` \x03\x90` \x82\x11a\x14\xFEWV[\x91\x90\x82\x03\x91\x82\x11a\x14\xFEWV[`\x05T\x80\x15a\x1D\xB8W_\x19\x81\x01\x90`\x05T\x82\x10\x15a\x0C_W_\x19_\x91`\x05\x83R` \x83 \x01\x01U`\x05UV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`1`\x04R`$_\xFD[`\x04T\x81\x14a\x1E\xDEW`\x05T\x80\x91_[\x83\x81\x10a\x1E\xBCW[P\x82\x82\x14a\x1E\x94Wa\x1E:a\x17\x97\x92a\x1E4a\x1E.a\x1E$a\x1E\x1F_\x98a\x1D\tV[a\x0CGV[\x90T\x90`\x03\x1B\x1C\x90V[\x91a\x0CGV[\x90a\x15\x03V[a\x1EBa\x1D\x8CV[a\x1E\x7Fa\x1EW\x82_R`\x06` R`@_ \x90V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81T\x16\x90UV[a\x17\x89a\x1EW\x82_R`\x07` R`@_ \x90V[\x7F\x12B\xE9\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x81a\x1E\xC9a\x1E$\x83a\x0CGV[\x14a\x1E\xD6W`\x01\x01a\x1D\xF5V[\x91P_a\x1D\xFDV[a\x1EWa\x17\xDB\x91_R`\x06` R`@_ \x90V[\x96\x93\x90\x95\x92\x94\x91\x94a\x1F\x14a\ns\x88a\x1B\x14\x8B_R`\n` R`@_ \x90V[\x80\x15a 2W[a\x1C\xE1Wa\x1F*6\x82\x88a\x18`V[` \x81Q\x91\x01 a\x1FC\x88_R`\t` R`@_ \x90V[T`\x04T\x89\x14a )W[\x03a \x01Wa\x1F^\x95\x87\x89a(7V[\x90\x81\x15a\x1F\xD9W\x80a\x1F\xB4\x91\x84\x7F,?D5\x99\xC6&\x8A\xCE\xD4s\xE7f\x0B@tn\xA3\x94\xD5\x19\x17\x9E\xA3\xF6\x0F8)t\xA2\xE7\x8E`@Q\x80a\x1F\x9F\x88\x82\x91\x90` \x83\x01\x92RV[\x03\x90\xA3a\x1B\x14\x84_R`\x0B` R`@_ \x90V[Ua\x1F\xC7\x81_R`\r` R`@_ \x90V[T\x15a\x1F\xD0WPV[a\x17\xDB\x90a)\x14V[\x7F\x9A\x0C\xCES\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\x9D\x8C\xBA\xCD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[P`\x01Ta\x1FNV[Pa I\x87a\x1B\x14\x8A_R`\x0B` R`@_ \x90V[T\x15\x15a\x1F\x1BV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x15a\x17\x9AWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16\x15a\x17\x9AW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x03T\x16\x17`\x03U`\x04U`\xFF\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T`@\x1C\x16\x15a \xEEWa \xEB\x90a%\x1EV[PV[\x7F\xD7\xE6\xBC\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[3_\x90\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x90 T`\xFF\x16\x15a!NWV[\x7F\xE2Q}?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R3`\x04R_`$R`D_\xFD[\x80_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`\xFFa!\xD23`@_ \x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_R` R`@_ \x90V[T\x16\x15a!\xDCWPV[\x7F\xE2Q}?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R3`\x04R`$R`D_\xFD[\x80_R`\r` R`@_ `@Q\x80\x82` \x82\x94T\x93\x84\x81R\x01\x90_R` _ \x92_[\x81\x81\x10a\"\xC3WPPa\"E\x92P\x03\x82a\x18!V[_[\x81Q\x81\x10\x15a\"\x86Wa\"ua\x10\x14a\nsa\"k\x86_R`\n` R`@_ \x90V[a\nf\x85\x87a\x19\xE7V[a\"\x81W`\x01\x01a\"GV[PPPV[PPa\"\x9Da\x1B\xD9\x82_R`\x0C` R`@_ \x90V[\x7Fx\xDF\x93\x81\x81\xAF\xCB(\xEA\xA7\xD0\x99#[\xBF\x98w\x83-o\xAA\xFE6\xD1\xEAp\x91o:\xCE3\xE0_\x80\xA2V[\x84T\x83R`\x01\x94\x85\x01\x94\x86\x94P` \x90\x93\x01\x92\x01a\"0V[\x90`@Q\x90` \x82\x01\x92\x83R`@\x82\x01R`@\x81Ra\"\xFC``\x82a\x18!V[Q\x90 \x90V[a#\x14a#\x19\x91a#\x1E\x936\x91a\x18`V[a)\x82V[a)\xFDV[\x80Q`\x03\x10\x15a\x0C_W`\x80a\x16\x83\x91\x01Qa*\xAAV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x15eW`\x05\x1B` \x01\x90V[\x92\x91\x92a#Y\x82a#5V[\x93a#g`@Q\x95\x86a\x18!V[` \x85\x84\x81R\x01\x92`\x05\x1B\x82\x01\x91\x81\x83\x11a\x03pW\x80\x93[\x83\x85\x10a#\x8DWPPPPPV[\x845g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03pW\x82\x01\x83`\x1F\x82\x01\x12\x15a\x03pW` \x91a#\xBE\x85\x83\x85\x80\x955\x91\x01a\x18`V[\x81R\x01\x94\x01\x93a#\x7FV[\x90\x91a$Ca$>a#\x14\x94a$I\x96\x98\x99\x97\x99`@Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01\x92``\x1B\x16\x82R`\x14\x81Ra$\x1B`4\x82a\x18!V[Q\x90 \x93`@Q\x94` \x86\x01R` \x85Ra$7`@\x86a\x18!V[6\x91a#MV[a*\xECV[\x91a+\x96V[\x91\x82Q\x15a$\xF6Wa$Ca$>a$\xB0\x92a$\xBE\x96a$7a$\x7Fa$ya$ta#\x14\x9Aa)\xFDV[a\x19\xA9V[Qa*\xAAV[\x96`@Qa$\x9A\x81a\x1BY` \x82\x01\x94\x85\x91\x90` \x83\x01\x92RV[Q\x90 `@Q\x96\x87\x91` \x83\x01` \x91\x81R\x01\x90V[\x03`\x1F\x19\x81\x01\x87R\x86a\x18!V[\x80Q\x15a$\xCEWa\x16\x83\x90a*\xAAV[\x7F4w\xDC\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7FTw\x06\xAF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16_\x90\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x90 T`\xFF\x16a&\0Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_\x81\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x81 \x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x16`\x01\x17\x90U3\x91\x90\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x81\x80\xA4`\x01\x90V[P_\x90V[\x80_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`\xFFa&Y\x83`@_ \x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_R` R`@_ \x90V[T\x16a'\x1CW\x80_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` Ra&\xB1\x82`@_ \x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_R` R`@_ \x90V[`\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x82T\x16\x17\x90Us\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x92\x16\x90\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r_\x80\xA4`\x01\x90V[PP_\x90V[\x80_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`\xFFa'v\x83`@_ \x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_R` R`@_ \x90V[T\x16\x15a'\x1CW\x80_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` Ra'\xCF\x82`@_ \x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_R` R`@_ \x90V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x81T\x16\x90Us\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x92\x16\x90\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B_\x80\xA4`\x01\x90V[\x95\x92\x96\x93\x90\x94\x91\x94_R`\x06` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ T\x16\x94\x85\x15a\x1E\x94Wa\x16\x83\x97a(u\x91a#\x02V[\x95`@Q` \x81\x01\x91\x82R`\x07`@\x82\x01R`@\x81Ra(\x96``\x82a\x18!V[Q\x90 \x95a#\xC9V[`\x05\x81\x14a \xEBW`\x05T\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x15eWa(\xC4\x82\x82a\x15 V[_\x90\x81R` \x81 \x7F\x03kc\x84\xB5\xEC\xA7\x91\xC6'a\x15-\x0Cy\xBB\x06\x04\xC1\x04\xA5\xFBoN\xB0p?1T\xBB=\xB0\x80T[\x84\x84\x10a(\xFEWPPPPPV[`\x01\x80\x91\x92\x01\x93\x84T\x92\x81\x85\x01U\x01\x92\x90a(\xF0V[\x80_R`\r` Ra)(`@_ a(\x9FV[`\x04T\x80_R`\x06` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ T\x16a)VWPPV[a\x17\xDB\x91_R`\r` R`@_ a\x15\xF8V[`@Q\x90a)w\x82a\x18\x05V[_` \x83\x82\x81R\x01RV[a)\x8Aa)jV[P` \x81Q\x91`@Q\x92a)\x9D\x84a\x18\x05V[\x83R\x01` \x82\x01R\x90V[\x15a\x03pWV[\x90a)\xB9\x82a#5V[a)\xC6`@Q\x91\x82a\x18!V[\x82\x81R`\x1F\x19a)\xD6\x82\x94a#5V[\x01\x90_[\x82\x81\x10a)\xE6WPPPV[` \x90a)\xF1a)jV[\x82\x82\x85\x01\x01R\x01a)\xDAV[\x90a*\x07\x82a.\xCCV[\x15a\x03pWa*\x15\x82a.\xEBV[\x91a*\x1F\x83a)\xAFV[\x90` \x81\x01\x80Qa*/\x81a/LV[\x81\x01\x80\x91\x11a\x14\xFEW\x94_\x90[\x80\x82\x10a*^WPPa\x16\x83\x92\x93\x94a*V\x91Q\x90a\x1D\x7FV[\x90Q\x14a)\xA8V[\x90\x95a*\xA2\x81a*o`\x01\x93a/\xB7V[\x90`@Qa*~`@\x82a\x18!V[\x82\x81R\x81` \x82\x01Ra*\x91\x8B\x8Aa\x19\xE7V[Ra*\x9C\x8A\x89a\x19\xE7V[Pa\x1A\xDBV[\x96\x01\x90a*<V[\x80Q\x80\x15\x15\x90\x81a*\xE0W[P\x15a\x03pWa*\xC5\x90a0qV[\x90Q\x90` \x81\x10a*\xD4WP\x90V[` \x03a\x01\0\n\x90\x04\x90V[`!\x91P\x11\x15_a*\xB6V[a*\xF6\x81Qa)\xAFV[\x90_[\x81Q\x81\x10\x15a+4W\x80a+\x18a+\x12`\x01\x93\x85a\x19\xE7V[Qa)\x82V[a+\"\x82\x86a\x19\xE7V[Ra+-\x81\x85a\x19\xE7V[P\x01a*\xF9V[PP\x90V[`@Q\x90a+H` \x83a\x18!V[_\x80\x83R6` \x84\x017V[\x90a+^\x82a\x18DV[a+k`@Q\x91\x82a\x18!V[\x82\x81R`\x1F\x19a+{\x82\x94a\x18DV[\x01\x90` 6\x91\x017V[\x90\x81Q\x81\x10\x15a\x0C_W\x01` \x01\x90V[\x90a+\xA0\x90a0\xD1V[_\x91_a+\xABa)jV[P\x84Q\x15a.\x93W\x93_\x91[\x81Q\x83\x10\x15a.4W\x82\x15\x80\x80a.\x1EW[a\x03pW\x15\x80a.\x02W[a\x03pWa+\xEBa+\xE5\x84\x84a\x19\xE7V[Qa)\xFDV[\x95\x86Q`\x02\x81\x14_\x14a,\xECWPPa,\x14a,\x0Fa,\t\x88a\x19\xCAV[Qa3\x19V[a3gV[\x95a,*a,#\x88\x88\x84a3\xD4V[\x80\x92a\x1A\xDBV[\x96Q\x11a,\xCEW\x15a,aWPa,A\x90Qa\x1D\tV[\x11a\x03pWQ\x11a,XWa,\ta\x16\x83\x91a\x19\xD7V[Pa\x16\x83a+9V[\x91\x90\x94a,n\x86Qa\x1D\tV[\x82\x14a\x03pW\x80a,\x8Ca\x10\x14a,\x86`\x01\x94a\x19\xD7V[Qa.\xCCV[\x15a,\xAFWa,\x9Da,\xA3\x91a\x19\xD7V[Qa3YV[\x91[\x01\x91\x94\x90\x94a+\xB7V[a,\xBBa,\xC8\x91a\x19\xD7V[Q` \x81\x01Q\x90Q\x90 \x90V[\x91a,\xA5V[PP\x91P\x92Pa,\xDF\x91PQa\x1D\tV[\x11a\x03pWa\x16\x83a+9V[`\x11\x90\x97\x91\x93\x97\x94\x92\x94\x14a-\x05W[P`\x01\x90a,\xA5V[\x95\x93\x80\x92P\x94\x92\x90\x94Q\x83\x14\x15_\x14a-\xE4W`\xFFa-_a-Ya-Sa--\x87\x87a+\x85V[Q\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90V[`\xF8\x1C\x90V[\x94a\x1A\xCDV[\x93\x16`\x10\x81\x10\x15a\x03pWa-}a-w\x82\x89a\x19\xE7V[Qa3CV[\x15a-\x9FWPPPPa-\x92\x91\x92PQa\x1D\tV[\x03a\x03pWa\x16\x83a+9V[\x86a-\xB7a\x10\x14a,\x86\x84`\x01\x96\x98\x9A\x97\x99\x9Ba\x19\xE7V[\x15a-\xD1Wa-\xC9\x91a,\x9D\x91a\x19\xE7V[\x91[\x90a,\xFCV[a-\xDE\x91a,\xBB\x91a\x19\xE7V[\x91a-\xCBV[PPPa-\xF1\x90Qa\x1D\tV[\x03a\x03pWa,\ta\x16\x83\x91a\x19\xB9V[Pa.\x16a.\x10\x84\x84a\x19\xE7V[Qa2\xE2V[\x86\x14\x15a+\xD4V[Pa.,a,\xBB\x85\x85a\x19\xE7V[\x82\x14\x15a+\xC9V[`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x11`$\x82\x01R\x7FInvalid MPT proof\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x90\xFD[P\x90Pa.\xC4\x92P\x7FV\xE8\x1F\x17\x1B\xCCU\xA6\xFF\x83E\xE6\x92\xC0\xF8n[H\xE0\x1B\x99l\xAD\xC0\x01b/\xB5\xE3c\xB4!\x91P\x14a)\xA8V[a\x16\x83a+9V[\x80Q\x15a&\0W` `\xC0\x91\x01QQ_\x1A\x10a.\xE7W`\x01\x90V[_\x90V[\x80Q\x15a&\0W_\x90` \x81\x01\x90\x81Qa/\x04\x81a/LV[\x81\x01\x80\x91\x11a\x14\xFEW\x91Q\x90Q\x81\x01\x80\x91\x11a\x14\xFEW\x91\x90[\x82\x81\x10a/*WP\x90P\x90V[a/3\x81a/\xB7V[\x81\x01\x80\x91\x11a\x14\xFEWa/F\x90\x91a\x19\xFBV[\x90a/\x1DV[Q_\x1A`\x80\x81\x10\x15a/]WP_\x90V[`\xB8\x81\x10\x80\x15a/\xA1W[\x15a/sWP`\x01\x90V[`\xC0\x81\x10\x15a/\x92Wa\x16\x83\x90a/\x8D\x90`\xB7[\x90a\x1D\x7FV[a\x1A\xCDV[a\x16\x83\x90a/\x8D\x90`\xF7a/\x87V[P`\xC0\x81\x10\x15\x80\x15a/hWP`\xF8\x81\x10a/hV[\x80Q_\x1A\x90`\x80\x82\x10\x15a/\xCCWPP`\x01\x90V[`\xB8\x82\x10\x15a/\xE2WPa/\x8Da\x16\x83\x91a\x1DDV[`\xC0\x82\x10\x15a0#W`\x01\x01Q` \x82\x90\x03`\xB7\x01a\x01\0\n\x90\x04\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFJ\x01\x90V[`\xF8\x82\x10\x15a09WPa/\x8Da\x16\x83\x91a\x1D\x17V[`\x01\x01Q` \x82\x90\x03`\xF7\x01a\x01\0\n\x90\x04\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\n\x01\x90V[\x90` \x82\x01\x91a0\x81\x83Qa/LV[\x92Q\x90\x83\x82\x01\x80\x92\x11a\x14\xFEWQ\x92\x83\x03\x92\x83\x11a\x14\xFEW\x91\x90V[\x15a0\xA4WV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x01`\x04R`$_\xFD[\x90a0\xFA_a0\xEB\x84Qa0\xE6\x81\x15\x15a)\xA8V[a\x14\xE8V[a0\xF5`\x01a)\xA8V[a\x1D\x7FV[\x90a1\x04\x82a+TV[\x92_\x91\x82[a1\x13\x85_a\x1A\xDBV[\x84\x10\x15a1\xD3Wa1\x8Ea-Ya1\x13\x92a1.\x87`\x01\x16\x90V[a1\x96W\x7F\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a1xa1oa-Sa--a1i\x8C`\x01\x1C\x90V[\x8Ba+\x85V[`\x04\x1C`\x0F\x16\x90V[`\xF8\x1B\x16_\x1Aa1\x88\x82\x8Ba+\x85V[Sa\x1A\xCDV[\x93\x90Pa1\tV[\x7F\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a1xa1\xCDa-Sa--a1i\x8C`\x01\x1C\x90V[`\xFF\x16\x90V[\x91P\x92Pa\x17\xDB\x91P\x83Q\x14a0\x9DV[a2\x04\x82a1\xF8\x83Qa0\xE6\x81\x15\x15a)\xA8V[a0\xF5\x81\x83\x11\x15a)\xA8V[\x90a2\x0E\x82a+TV[\x93\x83\x92_[a2\x1D\x82\x87a\x1A\xDBV[\x85\x10\x15a2\xD0W\x90a2\x90a2\x8Aa2\x1D\x93a29\x88`\x01\x16\x90V[a2\x99W\x7F\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a2za1oa-Sa--a2t\x8D`\x01\x1C\x90V[\x8Ca+\x85V[`\xF8\x1B\x16_\x1Aa1\x88\x82\x8Ca+\x85V[\x95a\x1A\xCDV[\x94\x90\x91Pa2\x13V[\x7F\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a2za1\xCDa-Sa--a2t\x8D`\x01\x1C\x90V[\x92PP\x92Pa\x17\xDB\x91P\x83Q\x14a0\x9DV[\x80Q` \x81\x10\x15a2\xFAWP` \x81\x01Q\x90Q\x90 \x90V[\x90` \x01Q `@Q` \x81\x01\x91\x82R` \x81Ra\"\xFC`@\x82a\x18!V[\x80Q\x15a\x03pWa3,a\x16\x83\x91a0qV[a38\x81\x93\x92\x93a+TV[\x92\x83` \x01\x90a4\x87V[`\x01\x81Q\x03a&\0W` \x01QQ_\x1A`\x80\x14\x90V[a3b\x90a0qV[\x90 \x90V[\x90\x81Q\x15a\x03pW`\x0Fa3\x83a1oa-Sa--\x86a\x19\xCAV[\x16\x80a3\x96WPa\x16\x83`\x02_\x93a1\xE4V[`\x01\x81\x03a3\xABWPa\x16\x83`\x01_\x93a1\xE4V[`\x02\x81\x03a3\xC1WPa\x16\x83`\x02`\x01\x93a1\xE4V[`\x03\x03a\x03pWa\x16\x83`\x01\x80\x93a1\xE4V[\x91\x90_[\x83\x81\x01\x80\x82\x11a\x14\xFEW\x82Q\x81\x10\x80a4nW[\x15a4fWa4\x1C\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x84a+\x85V[Q\x16\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a4I\x83\x86a+\x85V[Q\x16\x90\x03a4_Wa4Z\x90a\x19\xFBV[a3\xD8V[\x92PPP\x90V[P\x92PPP\x90V[P\x83Q\x82\x10a3\xECV[`\x1F\x81\x11a\x14\xFEWa\x01\0\n\x90V[\x90\x91\x80\x15a\"\x81W[` \x81\x10\x15a4\xCAW\x80a4\xA3WPPPV[a4\xB7a4\xB2a4\xBC\x92a\x1DqV[a4xV[a\x1D\tV[\x90Q\x82Q\x82\x16\x91\x19\x16\x17\x90RV[\x91\x90\x80Q\x82R` \x81\x01\x80\x91\x11a\x14\xFEW\x90` \x81\x01\x80\x91\x11a\x14\xFEW\x91`\x1F\x19\x81\x01\x90\x81\x11\x15a4\x90Wa\x14\xBBV",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AccessControlBadConfirmation()` and selector `0x6697b232`.
```solidity
error AccessControlBadConfirmation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlBadConfirmation;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlBadConfirmation>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlBadConfirmation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlBadConfirmation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlBadConfirmation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlBadConfirmation()";
            const SELECTOR: [u8; 4] = [102u8, 151u8, 178u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AccessControlUnauthorizedAccount(address,bytes32)` and selector `0xe2517d3f`.
```solidity
error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub neededRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlUnauthorizedAccount) -> Self {
                (value.account, value.neededRole)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    neededRole: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlUnauthorizedAccount(address,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 81u8, 125u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.neededRole),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AccountDoesNotExistInProof()` and selector `0x547706af`.
```solidity
error AccountDoesNotExistInProof();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccountDoesNotExistInProof;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccountDoesNotExistInProof>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccountDoesNotExistInProof) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccountDoesNotExistInProof {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccountDoesNotExistInProof {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccountDoesNotExistInProof()";
            const SELECTOR: [u8; 4] = [84u8, 119u8, 6u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AlreadySubmitted()` and selector `0x9fbfc589`.
```solidity
error AlreadySubmitted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AlreadySubmitted;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AlreadySubmitted> for UnderlyingRustTuple<'_> {
            fn from(value: AlreadySubmitted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AlreadySubmitted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AlreadySubmitted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AlreadySubmitted()";
            const SELECTOR: [u8; 4] = [159u8, 191u8, 197u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `CannotSubmitProofForSettlementChain()` and selector `0xda261280`.
```solidity
error CannotSubmitProofForSettlementChain();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CannotSubmitProofForSettlementChain;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CannotSubmitProofForSettlementChain>
        for UnderlyingRustTuple<'_> {
            fn from(value: CannotSubmitProofForSettlementChain) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for CannotSubmitProofForSettlementChain {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CannotSubmitProofForSettlementChain {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CannotSubmitProofForSettlementChain()";
            const SELECTOR: [u8; 4] = [218u8, 38u8, 18u8, 128u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ChainIDNotFound()` and selector `0x1242e9bb`.
```solidity
error ChainIDNotFound();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ChainIDNotFound;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ChainIDNotFound> for UnderlyingRustTuple<'_> {
            fn from(value: ChainIDNotFound) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ChainIDNotFound {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ChainIDNotFound {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ChainIDNotFound()";
            const SELECTOR: [u8; 4] = [18u8, 66u8, 233u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `EmptyDataHash()` and selector `0x9a0cce53`.
```solidity
error EmptyDataHash();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyDataHash;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyDataHash> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyDataHash) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyDataHash {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyDataHash {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyDataHash()";
            const SELECTOR: [u8; 4] = [154u8, 12u8, 206u8, 83u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `EmptySlot()` and selector `0x3477dcda`.
```solidity
error EmptySlot();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptySlot;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptySlot> for UnderlyingRustTuple<'_> {
            fn from(value: EmptySlot) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptySlot {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptySlot {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptySlot()";
            const SELECTOR: [u8; 4] = [52u8, 119u8, 220u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `EpochAlreadyCompleted()` and selector `0xfd93c15f`.
```solidity
error EpochAlreadyCompleted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EpochAlreadyCompleted;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EpochAlreadyCompleted> for UnderlyingRustTuple<'_> {
            fn from(value: EpochAlreadyCompleted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EpochAlreadyCompleted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EpochAlreadyCompleted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EpochAlreadyCompleted()";
            const SELECTOR: [u8; 4] = [253u8, 147u8, 193u8, 95u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidData()` and selector `0x5cb045db`.
```solidity
error InvalidData();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidData;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidData> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidData) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidData {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidData {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidData()";
            const SELECTOR: [u8; 4] = [92u8, 176u8, 69u8, 219u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidEthereumBlockHeader()` and selector `0xefb64cf8`.
```solidity
error InvalidEthereumBlockHeader();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidEthereumBlockHeader;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidEthereumBlockHeader>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidEthereumBlockHeader) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidEthereumBlockHeader {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidEthereumBlockHeader {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidEthereumBlockHeader()";
            const SELECTOR: [u8; 4] = [239u8, 182u8, 76u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidInitialization()` and selector `0xf92ee8a9`.
```solidity
error InvalidInitialization();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidInitialization;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidInitialization> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidInitialization) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidInitialization {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidInitialization {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidInitialization()";
            const SELECTOR: [u8; 4] = [249u8, 46u8, 232u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidProof()` and selector `0x09bde339`.
```solidity
error InvalidProof();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidProof;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidProof> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidProof) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidProof {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidProof {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidProof()";
            const SELECTOR: [u8; 4] = [9u8, 189u8, 227u8, 57u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidSeqChainBlockHeader()` and selector `0x9d8cbacd`.
```solidity
error InvalidSeqChainBlockHeader();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidSeqChainBlockHeader;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidSeqChainBlockHeader>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidSeqChainBlockHeader) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidSeqChainBlockHeader {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidSeqChainBlockHeader {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidSeqChainBlockHeader()";
            const SELECTOR: [u8; 4] = [157u8, 140u8, 186u8, 205u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotArchivedEpoch()` and selector `0xc5b14571`.
```solidity
error NotArchivedEpoch();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotArchivedEpoch;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotArchivedEpoch> for UnderlyingRustTuple<'_> {
            fn from(value: NotArchivedEpoch) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotArchivedEpoch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotArchivedEpoch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotArchivedEpoch()";
            const SELECTOR: [u8; 4] = [197u8, 177u8, 69u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotBlockHashSender()` and selector `0x24b2e7fd`.
```solidity
error NotBlockHashSender();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotBlockHashSender;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotBlockHashSender> for UnderlyingRustTuple<'_> {
            fn from(value: NotBlockHashSender) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotBlockHashSender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotBlockHashSender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotBlockHashSender()";
            const SELECTOR: [u8; 4] = [36u8, 178u8, 231u8, 253u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotInitializing()` and selector `0xd7e6bcf8`.
```solidity
error NotInitializing();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializing;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializing> for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializing) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotInitializing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializing()";
            const SELECTOR: [u8; 4] = [215u8, 230u8, 188u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OldSettlementChainBlockNumber()` and selector `0xc36ba423`.
```solidity
error OldSettlementChainBlockNumber();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OldSettlementChainBlockNumber;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OldSettlementChainBlockNumber>
        for UnderlyingRustTuple<'_> {
            fn from(value: OldSettlementChainBlockNumber) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OldSettlementChainBlockNumber {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OldSettlementChainBlockNumber {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OldSettlementChainBlockNumber()";
            const SELECTOR: [u8; 4] = [195u8, 107u8, 164u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SequencingChainAlreadyExists()` and selector `0xdf650a00`.
```solidity
error SequencingChainAlreadyExists();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SequencingChainAlreadyExists;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SequencingChainAlreadyExists>
        for UnderlyingRustTuple<'_> {
            fn from(value: SequencingChainAlreadyExists) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SequencingChainAlreadyExists {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SequencingChainAlreadyExists {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SequencingChainAlreadyExists()";
            const SELECTOR: [u8; 4] = [223u8, 101u8, 10u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ZeroAddress()` and selector `0xd92e233d`.
```solidity
error ZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAddress;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAddress()";
            const SELECTOR: [u8; 4] = [217u8, 46u8, 35u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ZeroLengthArray()` and selector `0x0f59b9ff`.
```solidity
error ZeroLengthArray();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroLengthArray;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroLengthArray> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroLengthArray) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroLengthArray {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroLengthArray {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroLengthArray()";
            const SELECTOR: [u8; 4] = [15u8, 89u8, 185u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `EpochCompleted(uint256)` and selector `0x78df938181afcb28eaa7d099235bbf9877832d6faafe36d1ea70916f3ace33e0`.
```solidity
event EpochCompleted(uint256 indexed epoch);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EpochCompleted {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EpochCompleted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "EpochCompleted(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                120u8, 223u8, 147u8, 129u8, 129u8, 175u8, 203u8, 40u8, 234u8, 167u8,
                208u8, 153u8, 35u8, 91u8, 191u8, 152u8, 119u8, 131u8, 45u8, 111u8, 170u8,
                254u8, 54u8, 209u8, 234u8, 112u8, 145u8, 111u8, 58u8, 206u8, 51u8, 224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { epoch: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.epoch.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.epoch);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EpochCompleted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EpochCompleted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EpochCompleted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `EpochDataValidated(uint256,uint256,bytes32)` and selector `0x2c3f443599c6268aced473e7660b40746ea394d519179ea3f60f382974a2e78e`.
```solidity
event EpochDataValidated(uint256 indexed epoch, uint256 indexed seqChainID, bytes32 dataHash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EpochDataValidated {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub seqChainID: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub dataHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EpochDataValidated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "EpochDataValidated(uint256,uint256,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                44u8, 63u8, 68u8, 53u8, 153u8, 198u8, 38u8, 138u8, 206u8, 212u8, 115u8,
                231u8, 102u8, 11u8, 64u8, 116u8, 110u8, 163u8, 148u8, 213u8, 25u8, 23u8,
                158u8, 163u8, 246u8, 15u8, 56u8, 41u8, 116u8, 162u8, 231u8, 142u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    epoch: topics.1,
                    seqChainID: topics.2,
                    dataHash: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.dataHash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.epoch.clone(),
                    self.seqChainID.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.epoch);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.seqChainID);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EpochDataValidated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EpochDataValidated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EpochDataValidated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `EpochExpectedChainsUpdated(uint256,uint256[])` and selector `0xa0fea12a5dfdb3ebf0b7c49a7ddd5ffdd3e5b2d7574ff16b0a1032edc19d658b`.
```solidity
event EpochExpectedChainsUpdated(uint256 indexed epoch, uint256[] chainIds);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EpochExpectedChainsUpdated {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub chainIds: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EpochExpectedChainsUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "EpochExpectedChainsUpdated(uint256,uint256[])";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                160u8, 254u8, 161u8, 42u8, 93u8, 253u8, 179u8, 235u8, 240u8, 183u8,
                196u8, 154u8, 125u8, 221u8, 95u8, 253u8, 211u8, 229u8, 178u8, 215u8,
                87u8, 79u8, 241u8, 107u8, 10u8, 16u8, 50u8, 237u8, 193u8, 157u8, 101u8,
                139u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    epoch: topics.1,
                    chainIds: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIds),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.epoch.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.epoch);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EpochExpectedChainsUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EpochExpectedChainsUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &EpochExpectedChainsUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `GasAggregatorAddressUpdated(address,address)` and selector `0x302f5435119022728eaef6d234319e11d908b504f90442eb3be6606fc9545757`.
```solidity
event GasAggregatorAddressUpdated(address indexed oldAddress, address indexed newAddress);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct GasAggregatorAddressUpdated {
        #[allow(missing_docs)]
        pub oldAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for GasAggregatorAddressUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "GasAggregatorAddressUpdated(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                48u8, 47u8, 84u8, 53u8, 17u8, 144u8, 34u8, 114u8, 142u8, 174u8, 246u8,
                210u8, 52u8, 49u8, 158u8, 17u8, 217u8, 8u8, 181u8, 4u8, 249u8, 4u8, 66u8,
                235u8, 59u8, 230u8, 96u8, 111u8, 201u8, 84u8, 87u8, 87u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldAddress: topics.1,
                    newAddress: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.oldAddress.clone(),
                    self.newAddress.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.oldAddress,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newAddress,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for GasAggregatorAddressUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&GasAggregatorAddressUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &GasAggregatorAddressUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Initialized(uint64)` and selector `0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2`.
```solidity
event Initialized(uint64 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `LastKnownBlockHashesUpdated(bytes32,bytes32,uint256)` and selector `0x78722ed9742b4dcda705d010fff7460a351e906f8223cff2d23a55b44b66427c`.
```solidity
event LastKnownBlockHashesUpdated(bytes32 ethBlockHash, bytes32 settlementBlockHash, uint256 settlementBlockNumber);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct LastKnownBlockHashesUpdated {
        #[allow(missing_docs)]
        pub ethBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub settlementBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub settlementBlockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for LastKnownBlockHashesUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "LastKnownBlockHashesUpdated(bytes32,bytes32,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                120u8, 114u8, 46u8, 217u8, 116u8, 43u8, 77u8, 205u8, 167u8, 5u8, 208u8,
                16u8, 255u8, 247u8, 70u8, 10u8, 53u8, 30u8, 144u8, 111u8, 130u8, 35u8,
                207u8, 242u8, 210u8, 58u8, 85u8, 180u8, 75u8, 102u8, 66u8, 124u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    ethBlockHash: data.0,
                    settlementBlockHash: data.1,
                    settlementBlockNumber: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ethBlockHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.settlementBlockHash),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.settlementBlockNumber),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for LastKnownBlockHashesUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&LastKnownBlockHashesUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &LastKnownBlockHashesUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8, 121u8, 184u8, 111u8, 254u8, 10u8, 184u8, 232u8, 119u8, 97u8, 81u8,
                81u8, 66u8, 23u8, 205u8, 124u8, 172u8, 213u8, 44u8, 144u8, 159u8, 102u8,
                71u8, 92u8, 58u8, 244u8, 78u8, 18u8, 159u8, 11u8, 0u8, 255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8, 135u8, 136u8, 17u8, 126u8, 126u8, 255u8, 29u8, 130u8, 233u8, 38u8,
                236u8, 121u8, 73u8, 1u8, 209u8, 124u8, 120u8, 2u8, 74u8, 80u8, 39u8, 9u8,
                64u8, 48u8, 69u8, 64u8, 167u8, 51u8, 101u8, 111u8, 13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8, 57u8, 31u8, 92u8, 50u8, 217u8, 198u8, 157u8, 42u8, 71u8, 234u8,
                103u8, 11u8, 68u8, 41u8, 116u8, 181u8, 57u8, 53u8, 209u8, 237u8, 199u8,
                253u8, 100u8, 235u8, 33u8, 224u8, 71u8, 168u8, 57u8, 23u8, 27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `AGGREGATED_EPOCH_DATA_HASH_SLOT()` and selector `0xe8c46c28`.
```solidity
function AGGREGATED_EPOCH_DATA_HASH_SLOT() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AGGREGATED_EPOCH_DATA_HASH_SLOTCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`AGGREGATED_EPOCH_DATA_HASH_SLOT()`](AGGREGATED_EPOCH_DATA_HASH_SLOTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AGGREGATED_EPOCH_DATA_HASH_SLOTReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<AGGREGATED_EPOCH_DATA_HASH_SLOTCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: AGGREGATED_EPOCH_DATA_HASH_SLOTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for AGGREGATED_EPOCH_DATA_HASH_SLOTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<AGGREGATED_EPOCH_DATA_HASH_SLOTReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: AGGREGATED_EPOCH_DATA_HASH_SLOTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for AGGREGATED_EPOCH_DATA_HASH_SLOTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for AGGREGATED_EPOCH_DATA_HASH_SLOTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AGGREGATED_EPOCH_DATA_HASH_SLOT()";
            const SELECTOR: [u8; 4] = [232u8, 196u8, 108u8, 40u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: AGGREGATED_EPOCH_DATA_HASH_SLOTReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: AGGREGATED_EPOCH_DATA_HASH_SLOTReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: DEFAULT_ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: DEFAULT_ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `HEADER_STATE_ROOT_INDEX()` and selector `0xe18b4dae`.
```solidity
function HEADER_STATE_ROOT_INDEX() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct HEADER_STATE_ROOT_INDEXCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`HEADER_STATE_ROOT_INDEX()`](HEADER_STATE_ROOT_INDEXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct HEADER_STATE_ROOT_INDEXReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<HEADER_STATE_ROOT_INDEXCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: HEADER_STATE_ROOT_INDEXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for HEADER_STATE_ROOT_INDEXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<HEADER_STATE_ROOT_INDEXReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: HEADER_STATE_ROOT_INDEXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for HEADER_STATE_ROOT_INDEXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for HEADER_STATE_ROOT_INDEXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "HEADER_STATE_ROOT_INDEX()";
            const SELECTOR: [u8; 4] = [225u8, 139u8, 77u8, 174u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: HEADER_STATE_ROOT_INDEXReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: HEADER_STATE_ROOT_INDEXReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `STORAGE_ROOT_ACCOUNT_FIELDS_INDEX()` and selector `0x6b4d17ad`.
```solidity
function STORAGE_ROOT_ACCOUNT_FIELDS_INDEX() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct STORAGE_ROOT_ACCOUNT_FIELDS_INDEXCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`STORAGE_ROOT_ACCOUNT_FIELDS_INDEX()`](STORAGE_ROOT_ACCOUNT_FIELDS_INDEXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct STORAGE_ROOT_ACCOUNT_FIELDS_INDEXReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<STORAGE_ROOT_ACCOUNT_FIELDS_INDEXCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: STORAGE_ROOT_ACCOUNT_FIELDS_INDEXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for STORAGE_ROOT_ACCOUNT_FIELDS_INDEXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<STORAGE_ROOT_ACCOUNT_FIELDS_INDEXReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: STORAGE_ROOT_ACCOUNT_FIELDS_INDEXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for STORAGE_ROOT_ACCOUNT_FIELDS_INDEXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for STORAGE_ROOT_ACCOUNT_FIELDS_INDEXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "STORAGE_ROOT_ACCOUNT_FIELDS_INDEX()";
            const SELECTOR: [u8; 4] = [107u8, 77u8, 23u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: STORAGE_ROOT_ACCOUNT_FIELDS_INDEXReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: STORAGE_ROOT_ACCOUNT_FIELDS_INDEXReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `addSequencingChain(uint256,address,address,uint256)` and selector `0x133bf89f`.
```solidity
function addSequencingChain(uint256 chainID, address aggregatorAddress, address bridgeAddress, uint256 storageSlotIndex) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addSequencingChainCall {
        #[allow(missing_docs)]
        pub chainID: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub aggregatorAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub bridgeAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub storageSlotIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`addSequencingChain(uint256,address,address,uint256)`](addSequencingChainCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addSequencingChainReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addSequencingChainCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: addSequencingChainCall) -> Self {
                    (
                        value.chainID,
                        value.aggregatorAddress,
                        value.bridgeAddress,
                        value.storageSlotIndex,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for addSequencingChainCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        chainID: tuple.0,
                        aggregatorAddress: tuple.1,
                        bridgeAddress: tuple.2,
                        storageSlotIndex: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addSequencingChainReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: addSequencingChainReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for addSequencingChainReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl addSequencingChainReturn {
            fn _tokenize(
                &self,
            ) -> <addSequencingChainCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addSequencingChainCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addSequencingChainReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addSequencingChain(uint256,address,address,uint256)";
            const SELECTOR: [u8; 4] = [19u8, 59u8, 248u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainID),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.aggregatorAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridgeAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.storageSlotIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                addSequencingChainReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `blockHashSender()` and selector `0x362b8154`.
```solidity
function blockHashSender() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct blockHashSenderCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`blockHashSender()`](blockHashSenderCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct blockHashSenderReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<blockHashSenderCall> for UnderlyingRustTuple<'_> {
                fn from(value: blockHashSenderCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for blockHashSenderCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<blockHashSenderReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: blockHashSenderReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for blockHashSenderReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for blockHashSenderCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "blockHashSender()";
            const SELECTOR: [u8; 4] = [54u8, 43u8, 129u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: blockHashSenderReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: blockHashSenderReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `confirmEpochDataHash(uint256,uint256,bytes,bytes[],bytes[])` and selector `0x7c901d7b`.
```solidity
function confirmEpochDataHash(uint256 epoch, uint256 seqChainID, bytes memory seqChainBlockHeader, bytes[] memory seqChainAccountProof, bytes[] memory seqChainStorageProof) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct confirmEpochDataHashCall {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub seqChainID: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub seqChainBlockHeader: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub seqChainAccountProof: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Bytes,
        >,
        #[allow(missing_docs)]
        pub seqChainStorageProof: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Bytes,
        >,
    }
    ///Container type for the return parameters of the [`confirmEpochDataHash(uint256,uint256,bytes,bytes[],bytes[])`](confirmEpochDataHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct confirmEpochDataHashReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<confirmEpochDataHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: confirmEpochDataHashCall) -> Self {
                    (
                        value.epoch,
                        value.seqChainID,
                        value.seqChainBlockHeader,
                        value.seqChainAccountProof,
                        value.seqChainStorageProof,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for confirmEpochDataHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epoch: tuple.0,
                        seqChainID: tuple.1,
                        seqChainBlockHeader: tuple.2,
                        seqChainAccountProof: tuple.3,
                        seqChainStorageProof: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<confirmEpochDataHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: confirmEpochDataHashReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for confirmEpochDataHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl confirmEpochDataHashReturn {
            fn _tokenize(
                &self,
            ) -> <confirmEpochDataHashCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for confirmEpochDataHashCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = confirmEpochDataHashReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "confirmEpochDataHash(uint256,uint256,bytes,bytes[],bytes[])";
            const SELECTOR: [u8; 4] = [124u8, 144u8, 29u8, 123u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epoch),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.seqChainID),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.seqChainBlockHeader,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.seqChainAccountProof),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.seqChainStorageProof),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                confirmEpochDataHashReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `confirmSequencingChainBlockHash(uint256,bytes32,bytes,bytes[],bytes[])` and selector `0x1bf4951c`.
```solidity
function confirmSequencingChainBlockHash(uint256 seqChainID, bytes32 sendRoot, bytes memory ethereumBlockHeader, bytes[] memory ethereumAccountProof, bytes[] memory ethereumStorageProof) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct confirmSequencingChainBlockHashCall {
        #[allow(missing_docs)]
        pub seqChainID: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub sendRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ethereumBlockHeader: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub ethereumAccountProof: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Bytes,
        >,
        #[allow(missing_docs)]
        pub ethereumStorageProof: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Bytes,
        >,
    }
    ///Container type for the return parameters of the [`confirmSequencingChainBlockHash(uint256,bytes32,bytes,bytes[],bytes[])`](confirmSequencingChainBlockHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct confirmSequencingChainBlockHashReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<confirmSequencingChainBlockHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: confirmSequencingChainBlockHashCall) -> Self {
                    (
                        value.seqChainID,
                        value.sendRoot,
                        value.ethereumBlockHeader,
                        value.ethereumAccountProof,
                        value.ethereumStorageProof,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for confirmSequencingChainBlockHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        seqChainID: tuple.0,
                        sendRoot: tuple.1,
                        ethereumBlockHeader: tuple.2,
                        ethereumAccountProof: tuple.3,
                        ethereumStorageProof: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<confirmSequencingChainBlockHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: confirmSequencingChainBlockHashReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for confirmSequencingChainBlockHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl confirmSequencingChainBlockHashReturn {
            fn _tokenize(
                &self,
            ) -> <confirmSequencingChainBlockHashCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for confirmSequencingChainBlockHashCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = confirmSequencingChainBlockHashReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "confirmSequencingChainBlockHash(uint256,bytes32,bytes,bytes[],bytes[])";
            const SELECTOR: [u8; 4] = [27u8, 244u8, 149u8, 28u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.seqChainID),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.sendRoot),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.ethereumBlockHeader,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.ethereumAccountProof),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.ethereumStorageProof),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                confirmSequencingChainBlockHashReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochAppchainEmissionsReceiver(uint256,uint256)` and selector `0x5b1817e8`.
```solidity
function epochAppchainEmissionsReceiver(uint256 epoch, uint256 appchainId) external view returns (address receiver);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainEmissionsReceiverCall {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochAppchainEmissionsReceiver(uint256,uint256)`](epochAppchainEmissionsReceiverCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainEmissionsReceiverReturn {
        #[allow(missing_docs)]
        pub receiver: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainEmissionsReceiverCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainEmissionsReceiverCall) -> Self {
                    (value.epoch, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainEmissionsReceiverCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epoch: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainEmissionsReceiverReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainEmissionsReceiverReturn) -> Self {
                    (value.receiver,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainEmissionsReceiverReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { receiver: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochAppchainEmissionsReceiverCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochAppchainEmissionsReceiver(uint256,uint256)";
            const SELECTOR: [u8; 4] = [91u8, 24u8, 23u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epoch),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochAppchainEmissionsReceiverReturn = r.into();
                        r.receiver
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochAppchainEmissionsReceiverReturn = r.into();
                        r.receiver
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochAppchainIDs(uint256,uint256)` and selector `0xff87c18c`.
```solidity
function epochAppchainIDs(uint256 epoch, uint256) external view returns (uint256 appchainIds);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainIDsCall {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochAppchainIDs(uint256,uint256)`](epochAppchainIDsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainIDsReturn {
        #[allow(missing_docs)]
        pub appchainIds: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainIDsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainIDsCall) -> Self {
                    (value.epoch, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainIDsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epoch: tuple.0,
                        _1: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainIDsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainIDsReturn) -> Self {
                    (value.appchainIds,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainIDsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { appchainIds: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochAppchainIDsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochAppchainIDs(uint256,uint256)";
            const SELECTOR: [u8; 4] = [255u8, 135u8, 193u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epoch),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochAppchainIDsReturn = r.into();
                        r.appchainIds
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochAppchainIDsReturn = r.into();
                        r.appchainIds
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochAppchainTokensUsed(uint256,uint256)` and selector `0x55fcc556`.
```solidity
function epochAppchainTokensUsed(uint256 epoch, uint256 appchainId) external view returns (uint256 tokens);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainTokensUsedCall {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochAppchainTokensUsed(uint256,uint256)`](epochAppchainTokensUsedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochAppchainTokensUsedReturn {
        #[allow(missing_docs)]
        pub tokens: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainTokensUsedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainTokensUsedCall) -> Self {
                    (value.epoch, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainTokensUsedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epoch: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochAppchainTokensUsedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochAppchainTokensUsedReturn) -> Self {
                    (value.tokens,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochAppchainTokensUsedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { tokens: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochAppchainTokensUsedCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochAppchainTokensUsed(uint256,uint256)";
            const SELECTOR: [u8; 4] = [85u8, 252u8, 197u8, 86u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epoch),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochAppchainTokensUsedReturn = r.into();
                        r.tokens
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochAppchainTokensUsedReturn = r.into();
                        r.tokens
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochChainDataSubmitted(uint256,uint256)` and selector `0x5a633080`.
```solidity
function epochChainDataSubmitted(uint256 epoch, uint256 chainId) external view returns (bool submitted);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochChainDataSubmittedCall {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochChainDataSubmitted(uint256,uint256)`](epochChainDataSubmittedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochChainDataSubmittedReturn {
        #[allow(missing_docs)]
        pub submitted: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochChainDataSubmittedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochChainDataSubmittedCall) -> Self {
                    (value.epoch, value.chainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochChainDataSubmittedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epoch: tuple.0,
                        chainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochChainDataSubmittedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochChainDataSubmittedReturn) -> Self {
                    (value.submitted,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochChainDataSubmittedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { submitted: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochChainDataSubmittedCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochChainDataSubmitted(uint256,uint256)";
            const SELECTOR: [u8; 4] = [90u8, 99u8, 48u8, 128u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epoch),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochChainDataSubmittedReturn = r.into();
                        r.submitted
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochChainDataSubmittedReturn = r.into();
                        r.submitted
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochCompleted(uint256)` and selector `0x30c709b6`.
```solidity
function epochCompleted(uint256 epoch) external view returns (bool completed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochCompletedCall {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochCompleted(uint256)`](epochCompletedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochCompletedReturn {
        #[allow(missing_docs)]
        pub completed: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochCompletedCall> for UnderlyingRustTuple<'_> {
                fn from(value: epochCompletedCall) -> Self {
                    (value.epoch,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for epochCompletedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epoch: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochCompletedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochCompletedReturn) -> Self {
                    (value.completed,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochCompletedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { completed: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochCompletedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochCompleted(uint256)";
            const SELECTOR: [u8; 4] = [48u8, 199u8, 9u8, 182u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epoch),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochCompletedReturn = r.into();
                        r.completed
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochCompletedReturn = r.into();
                        r.completed
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochExpectedChains(uint256,uint256)` and selector `0x5d579a61`.
```solidity
function epochExpectedChains(uint256 epoch, uint256) external view returns (uint256 chainIds);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochExpectedChainsCall {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochExpectedChains(uint256,uint256)`](epochExpectedChainsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochExpectedChainsReturn {
        #[allow(missing_docs)]
        pub chainIds: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochExpectedChainsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochExpectedChainsCall) -> Self {
                    (value.epoch, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochExpectedChainsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epoch: tuple.0,
                        _1: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochExpectedChainsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochExpectedChainsReturn) -> Self {
                    (value.chainIds,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochExpectedChainsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { chainIds: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochExpectedChainsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochExpectedChains(uint256,uint256)";
            const SELECTOR: [u8; 4] = [93u8, 87u8, 154u8, 97u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epoch),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochExpectedChainsReturn = r.into();
                        r.chainIds
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochExpectedChainsReturn = r.into();
                        r.chainIds
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochTotalTokensUsed(uint256)` and selector `0x47dff69d`.
```solidity
function epochTotalTokensUsed(uint256 epoch) external view returns (uint256 totalTokens);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochTotalTokensUsedCall {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochTotalTokensUsed(uint256)`](epochTotalTokensUsedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochTotalTokensUsedReturn {
        #[allow(missing_docs)]
        pub totalTokens: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochTotalTokensUsedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochTotalTokensUsedCall) -> Self {
                    (value.epoch,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochTotalTokensUsedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epoch: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochTotalTokensUsedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochTotalTokensUsedReturn) -> Self {
                    (value.totalTokens,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochTotalTokensUsedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { totalTokens: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochTotalTokensUsedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochTotalTokensUsed(uint256)";
            const SELECTOR: [u8; 4] = [71u8, 223u8, 246u8, 157u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epoch),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochTotalTokensUsedReturn = r.into();
                        r.totalTokens
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochTotalTokensUsedReturn = r.into();
                        r.totalTokens
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `epochVerifiedDataHash(uint256,uint256)` and selector `0x6ba3d17f`.
```solidity
function epochVerifiedDataHash(uint256 epoch, uint256 seqChainID) external view returns (bytes32 dataHash);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochVerifiedDataHashCall {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub seqChainID: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`epochVerifiedDataHash(uint256,uint256)`](epochVerifiedDataHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct epochVerifiedDataHashReturn {
        #[allow(missing_docs)]
        pub dataHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochVerifiedDataHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochVerifiedDataHashCall) -> Self {
                    (value.epoch, value.seqChainID)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochVerifiedDataHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epoch: tuple.0,
                        seqChainID: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<epochVerifiedDataHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: epochVerifiedDataHashReturn) -> Self {
                    (value.dataHash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for epochVerifiedDataHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { dataHash: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for epochVerifiedDataHashCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "epochVerifiedDataHash(uint256,uint256)";
            const SELECTOR: [u8; 4] = [107u8, 163u8, 209u8, 127u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epoch),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.seqChainID),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: epochVerifiedDataHashReturn = r.into();
                        r.dataHash
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: epochVerifiedDataHashReturn = r.into();
                        r.dataHash
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getActiveAppchainIds(uint256)` and selector `0x2cd078b8`.
```solidity
function getActiveAppchainIds(uint256 epochIndex) external view returns (uint256[] memory _chainIDs);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getActiveAppchainIdsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getActiveAppchainIds(uint256)`](getActiveAppchainIdsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getActiveAppchainIdsReturn {
        #[allow(missing_docs)]
        pub _chainIDs: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getActiveAppchainIdsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getActiveAppchainIdsCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getActiveAppchainIdsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getActiveAppchainIdsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getActiveAppchainIdsReturn) -> Self {
                    (value._chainIDs,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getActiveAppchainIdsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _chainIDs: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getActiveAppchainIdsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getActiveAppchainIds(uint256)";
            const SELECTOR: [u8; 4] = [44u8, 208u8, 120u8, 184u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getActiveAppchainIdsReturn = r.into();
                        r._chainIDs
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getActiveAppchainIdsReturn = r.into();
                        r._chainIDs
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getAppchainGasFees(uint256,uint256)` and selector `0x285f2446`.
```solidity
function getAppchainGasFees(uint256 epochIndex, uint256 appchainId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAppchainGasFeesCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getAppchainGasFees(uint256,uint256)`](getAppchainGasFeesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAppchainGasFeesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAppchainGasFeesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAppchainGasFeesCall) -> Self {
                    (value.epochIndex, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAppchainGasFeesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAppchainGasFeesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAppchainGasFeesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAppchainGasFeesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAppchainGasFeesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAppchainGasFees(uint256,uint256)";
            const SELECTOR: [u8; 4] = [40u8, 95u8, 36u8, 70u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getAppchainGasFeesReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getAppchainGasFeesReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getAppchainRewardsReceiver(uint256,uint256)` and selector `0xec828a91`.
```solidity
function getAppchainRewardsReceiver(uint256 epochIndex, uint256 appchainId) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAppchainRewardsReceiverCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getAppchainRewardsReceiver(uint256,uint256)`](getAppchainRewardsReceiverCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAppchainRewardsReceiverReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAppchainRewardsReceiverCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAppchainRewardsReceiverCall) -> Self {
                    (value.epochIndex, value.appchainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAppchainRewardsReceiverCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        appchainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAppchainRewardsReceiverReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAppchainRewardsReceiverReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAppchainRewardsReceiverReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAppchainRewardsReceiverCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAppchainRewardsReceiver(uint256,uint256)";
            const SELECTOR: [u8; 4] = [236u8, 130u8, 138u8, 145u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getAppchainRewardsReceiverReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getAppchainRewardsReceiverReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getEpochExpectedChains(uint256)` and selector `0x7c6edb3e`.
```solidity
function getEpochExpectedChains(uint256 epochIndex) external view returns (uint256[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEpochExpectedChainsCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getEpochExpectedChains(uint256)`](getEpochExpectedChainsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEpochExpectedChainsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEpochExpectedChainsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEpochExpectedChainsCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEpochExpectedChainsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEpochExpectedChainsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEpochExpectedChainsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEpochExpectedChainsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getEpochExpectedChainsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getEpochExpectedChains(uint256)";
            const SELECTOR: [u8; 4] = [124u8, 110u8, 219u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getEpochExpectedChainsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getEpochExpectedChainsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getEpochProgress(uint256)` and selector `0x4e6da2a4`.
```solidity
function getEpochProgress(uint256 epochIndex) external view returns (bool completed, uint256 totalExpected, uint256 totalSubmitted);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEpochProgressCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getEpochProgress(uint256)`](getEpochProgressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEpochProgressReturn {
        #[allow(missing_docs)]
        pub completed: bool,
        #[allow(missing_docs)]
        pub totalExpected: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub totalSubmitted: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEpochProgressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEpochProgressCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEpochProgressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                bool,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEpochProgressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEpochProgressReturn) -> Self {
                    (value.completed, value.totalExpected, value.totalSubmitted)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEpochProgressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        completed: tuple.0,
                        totalExpected: tuple.1,
                        totalSubmitted: tuple.2,
                    }
                }
            }
        }
        impl getEpochProgressReturn {
            fn _tokenize(
                &self,
            ) -> <getEpochProgressCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.completed,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalExpected),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalSubmitted),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getEpochProgressCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getEpochProgressReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getEpochProgress(uint256)";
            const SELECTOR: [u8; 4] = [78u8, 109u8, 162u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                getEpochProgressReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleAdminReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleAdminReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getTotalGasFees(uint256)` and selector `0xce537c9f`.
```solidity
function getTotalGasFees(uint256 epochIndex) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTotalGasFeesCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getTotalGasFees(uint256)`](getTotalGasFeesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTotalGasFeesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTotalGasFeesCall> for UnderlyingRustTuple<'_> {
                fn from(value: getTotalGasFeesCall) -> Self {
                    (value.epochIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getTotalGasFeesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochIndex: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTotalGasFeesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getTotalGasFeesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getTotalGasFeesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getTotalGasFeesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getTotalGasFees(uint256)";
            const SELECTOR: [u8; 4] = [206u8, 83u8, 124u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getTotalGasFeesReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getTotalGasFeesReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl grantRoleReturn {
            fn _tokenize(
                &self,
            ) -> <grantRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                grantRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `hasChainSubmittedForEpoch(uint256,uint256)` and selector `0x95814bf5`.
```solidity
function hasChainSubmittedForEpoch(uint256 epochIndex, uint256 chainId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasChainSubmittedForEpochCall {
        #[allow(missing_docs)]
        pub epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`hasChainSubmittedForEpoch(uint256,uint256)`](hasChainSubmittedForEpochCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasChainSubmittedForEpochReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasChainSubmittedForEpochCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: hasChainSubmittedForEpochCall) -> Self {
                    (value.epochIndex, value.chainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for hasChainSubmittedForEpochCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epochIndex: tuple.0,
                        chainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasChainSubmittedForEpochReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: hasChainSubmittedForEpochReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for hasChainSubmittedForEpochReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasChainSubmittedForEpochCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasChainSubmittedForEpoch(uint256,uint256)";
            const SELECTOR: [u8; 4] = [149u8, 129u8, 75u8, 245u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: hasChainSubmittedForEpochReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: hasChainSubmittedForEpochReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: hasRoleReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: hasRoleReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initialize(address,uint256,address)` and selector `0xc350a1b5`.
```solidity
function initialize(address _blockHashSender, uint256 _settlementChainID, address admin) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeCall {
        #[allow(missing_docs)]
        pub _blockHashSender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _settlementChainID: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub admin: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`initialize(address,uint256,address)`](initializeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (value._blockHashSender, value._settlementChainID, value.admin)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _blockHashSender: tuple.0,
                        _settlementChainID: tuple.1,
                        admin: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeReturn {
            fn _tokenize(
                &self,
            ) -> <initializeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize(address,uint256,address)";
            const SELECTOR: [u8; 4] = [195u8, 80u8, 161u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._blockHashSender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._settlementChainID),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.admin,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `lastKnownEthereumBlockHash()` and selector `0x23afb0ff`.
```solidity
function lastKnownEthereumBlockHash() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastKnownEthereumBlockHashCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`lastKnownEthereumBlockHash()`](lastKnownEthereumBlockHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastKnownEthereumBlockHashReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastKnownEthereumBlockHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastKnownEthereumBlockHashCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastKnownEthereumBlockHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastKnownEthereumBlockHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastKnownEthereumBlockHashReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastKnownEthereumBlockHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for lastKnownEthereumBlockHashCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "lastKnownEthereumBlockHash()";
            const SELECTOR: [u8; 4] = [35u8, 175u8, 176u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: lastKnownEthereumBlockHashReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: lastKnownEthereumBlockHashReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `lastKnownSeqChainBlockHashes(uint256)` and selector `0x7a7f34e8`.
```solidity
function lastKnownSeqChainBlockHashes(uint256 chainId) external view returns (bytes32 blockHash);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastKnownSeqChainBlockHashesCall {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`lastKnownSeqChainBlockHashes(uint256)`](lastKnownSeqChainBlockHashesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastKnownSeqChainBlockHashesReturn {
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastKnownSeqChainBlockHashesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastKnownSeqChainBlockHashesCall) -> Self {
                    (value.chainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastKnownSeqChainBlockHashesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { chainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastKnownSeqChainBlockHashesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastKnownSeqChainBlockHashesReturn) -> Self {
                    (value.blockHash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastKnownSeqChainBlockHashesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blockHash: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for lastKnownSeqChainBlockHashesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "lastKnownSeqChainBlockHashes(uint256)";
            const SELECTOR: [u8; 4] = [122u8, 127u8, 52u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: lastKnownSeqChainBlockHashesReturn = r.into();
                        r.blockHash
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: lastKnownSeqChainBlockHashesReturn = r.into();
                        r.blockHash
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `lastKnownSettlementChainBlockHash()` and selector `0xef512221`.
```solidity
function lastKnownSettlementChainBlockHash() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastKnownSettlementChainBlockHashCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`lastKnownSettlementChainBlockHash()`](lastKnownSettlementChainBlockHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastKnownSettlementChainBlockHashReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastKnownSettlementChainBlockHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastKnownSettlementChainBlockHashCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastKnownSettlementChainBlockHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastKnownSettlementChainBlockHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastKnownSettlementChainBlockHashReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastKnownSettlementChainBlockHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for lastKnownSettlementChainBlockHashCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "lastKnownSettlementChainBlockHash()";
            const SELECTOR: [u8; 4] = [239u8, 81u8, 34u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: lastKnownSettlementChainBlockHashReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: lastKnownSettlementChainBlockHashReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `lastKnownSettlementChainBlockNumber()` and selector `0x8d935e1d`.
```solidity
function lastKnownSettlementChainBlockNumber() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastKnownSettlementChainBlockNumberCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`lastKnownSettlementChainBlockNumber()`](lastKnownSettlementChainBlockNumberCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastKnownSettlementChainBlockNumberReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastKnownSettlementChainBlockNumberCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastKnownSettlementChainBlockNumberCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastKnownSettlementChainBlockNumberCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastKnownSettlementChainBlockNumberReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastKnownSettlementChainBlockNumberReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastKnownSettlementChainBlockNumberReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for lastKnownSettlementChainBlockNumberCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "lastKnownSettlementChainBlockNumber()";
            const SELECTOR: [u8; 4] = [141u8, 147u8, 94u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: lastKnownSettlementChainBlockNumberReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: lastKnownSettlementChainBlockNumberReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `removeSeqChain(uint256)` and selector `0x650e1312`.
```solidity
function removeSeqChain(uint256 chainID) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeSeqChainCall {
        #[allow(missing_docs)]
        pub chainID: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`removeSeqChain(uint256)`](removeSeqChainCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeSeqChainReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeSeqChainCall> for UnderlyingRustTuple<'_> {
                fn from(value: removeSeqChainCall) -> Self {
                    (value.chainID,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeSeqChainCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { chainID: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeSeqChainReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeSeqChainReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeSeqChainReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl removeSeqChainReturn {
            fn _tokenize(
                &self,
            ) -> <removeSeqChainCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeSeqChainCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeSeqChainReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeSeqChain(uint256)";
            const SELECTOR: [u8; 4] = [101u8, 14u8, 19u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainID),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                removeSeqChainReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address callerConfirmation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub callerConfirmation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.callerConfirmation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        callerConfirmation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl renounceRoleReturn {
            fn _tokenize(
                &self,
            ) -> <renounceRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callerConfirmation,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                renounceRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl revokeRoleReturn {
            fn _tokenize(
                &self,
            ) -> <revokeRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                revokeRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `seqChainEthOutbox(uint256)` and selector `0xfdd54123`.
```solidity
function seqChainEthOutbox(uint256 chainId) external view returns (address outboxAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct seqChainEthOutboxCall {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`seqChainEthOutbox(uint256)`](seqChainEthOutboxCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct seqChainEthOutboxReturn {
        #[allow(missing_docs)]
        pub outboxAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<seqChainEthOutboxCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: seqChainEthOutboxCall) -> Self {
                    (value.chainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for seqChainEthOutboxCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { chainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<seqChainEthOutboxReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: seqChainEthOutboxReturn) -> Self {
                    (value.outboxAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for seqChainEthOutboxReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { outboxAddress: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for seqChainEthOutboxCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "seqChainEthOutbox(uint256)";
            const SELECTOR: [u8; 4] = [253u8, 213u8, 65u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: seqChainEthOutboxReturn = r.into();
                        r.outboxAddress
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: seqChainEthOutboxReturn = r.into();
                        r.outboxAddress
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `seqChainEthSendRootStorageSlot(uint256)` and selector `0xfd79d3e1`.
```solidity
function seqChainEthSendRootStorageSlot(uint256 chainId) external view returns (uint256 sendRootStorageSlotIndex);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct seqChainEthSendRootStorageSlotCall {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`seqChainEthSendRootStorageSlot(uint256)`](seqChainEthSendRootStorageSlotCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct seqChainEthSendRootStorageSlotReturn {
        #[allow(missing_docs)]
        pub sendRootStorageSlotIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<seqChainEthSendRootStorageSlotCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: seqChainEthSendRootStorageSlotCall) -> Self {
                    (value.chainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for seqChainEthSendRootStorageSlotCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { chainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<seqChainEthSendRootStorageSlotReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: seqChainEthSendRootStorageSlotReturn) -> Self {
                    (value.sendRootStorageSlotIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for seqChainEthSendRootStorageSlotReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        sendRootStorageSlotIndex: tuple.0,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for seqChainEthSendRootStorageSlotCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "seqChainEthSendRootStorageSlot(uint256)";
            const SELECTOR: [u8; 4] = [253u8, 121u8, 211u8, 225u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: seqChainEthSendRootStorageSlotReturn = r.into();
                        r.sendRootStorageSlotIndex
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: seqChainEthSendRootStorageSlotReturn = r.into();
                        r.sendRootStorageSlotIndex
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `seqChainGasAggregatorAddresses(uint256)` and selector `0x8dd50eee`.
```solidity
function seqChainGasAggregatorAddresses(uint256 chainId) external view returns (address aggregatorAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct seqChainGasAggregatorAddressesCall {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`seqChainGasAggregatorAddresses(uint256)`](seqChainGasAggregatorAddressesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct seqChainGasAggregatorAddressesReturn {
        #[allow(missing_docs)]
        pub aggregatorAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<seqChainGasAggregatorAddressesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: seqChainGasAggregatorAddressesCall) -> Self {
                    (value.chainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for seqChainGasAggregatorAddressesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { chainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<seqChainGasAggregatorAddressesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: seqChainGasAggregatorAddressesReturn) -> Self {
                    (value.aggregatorAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for seqChainGasAggregatorAddressesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { aggregatorAddress: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for seqChainGasAggregatorAddressesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "seqChainGasAggregatorAddresses(uint256)";
            const SELECTOR: [u8; 4] = [141u8, 213u8, 14u8, 238u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: seqChainGasAggregatorAddressesReturn = r.into();
                        r.aggregatorAddress
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: seqChainGasAggregatorAddressesReturn = r.into();
                        r.aggregatorAddress
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `seqChainIDs(uint256)` and selector `0xd26bcc80`.
```solidity
function seqChainIDs(uint256) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct seqChainIDsCall(pub alloy::sol_types::private::primitives::aliases::U256);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`seqChainIDs(uint256)`](seqChainIDsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct seqChainIDsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<seqChainIDsCall> for UnderlyingRustTuple<'_> {
                fn from(value: seqChainIDsCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for seqChainIDsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<seqChainIDsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: seqChainIDsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for seqChainIDsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for seqChainIDsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "seqChainIDs(uint256)";
            const SELECTOR: [u8; 4] = [210u8, 107u8, 204u8, 128u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: seqChainIDsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: seqChainIDsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setBlockHashSender(address)` and selector `0x7c715094`.
```solidity
function setBlockHashSender(address newBlockHashSender) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBlockHashSenderCall {
        #[allow(missing_docs)]
        pub newBlockHashSender: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setBlockHashSender(address)`](setBlockHashSenderCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBlockHashSenderReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBlockHashSenderCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBlockHashSenderCall) -> Self {
                    (value.newBlockHashSender,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBlockHashSenderCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newBlockHashSender: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBlockHashSenderReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBlockHashSenderReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBlockHashSenderReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setBlockHashSenderReturn {
            fn _tokenize(
                &self,
            ) -> <setBlockHashSenderCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBlockHashSenderCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBlockHashSenderReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBlockHashSender(address)";
            const SELECTOR: [u8; 4] = [124u8, 113u8, 80u8, 148u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newBlockHashSender,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setBlockHashSenderReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setEpochExpectedChains(uint256,uint256[])` and selector `0x0344571f`.
```solidity
function setEpochExpectedChains(uint256 epoch, uint256[] memory chainIds) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setEpochExpectedChainsCall {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub chainIds: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    ///Container type for the return parameters of the [`setEpochExpectedChains(uint256,uint256[])`](setEpochExpectedChainsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setEpochExpectedChainsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setEpochExpectedChainsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setEpochExpectedChainsCall) -> Self {
                    (value.epoch, value.chainIds)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setEpochExpectedChainsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epoch: tuple.0,
                        chainIds: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setEpochExpectedChainsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setEpochExpectedChainsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setEpochExpectedChainsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setEpochExpectedChainsReturn {
            fn _tokenize(
                &self,
            ) -> <setEpochExpectedChainsCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setEpochExpectedChainsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setEpochExpectedChainsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setEpochExpectedChains(uint256,uint256[])";
            const SELECTOR: [u8; 4] = [3u8, 68u8, 87u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epoch),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIds),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setEpochExpectedChainsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setLastKnownBlockHashes(bytes32,bytes32,uint256)` and selector `0x19771640`.
```solidity
function setLastKnownBlockHashes(bytes32 ethBlockHash, bytes32 settlementBlockHash, uint256 settlementBlockNumber) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setLastKnownBlockHashesCall {
        #[allow(missing_docs)]
        pub ethBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub settlementBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub settlementBlockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setLastKnownBlockHashes(bytes32,bytes32,uint256)`](setLastKnownBlockHashesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setLastKnownBlockHashesReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setLastKnownBlockHashesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setLastKnownBlockHashesCall) -> Self {
                    (
                        value.ethBlockHash,
                        value.settlementBlockHash,
                        value.settlementBlockNumber,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setLastKnownBlockHashesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        ethBlockHash: tuple.0,
                        settlementBlockHash: tuple.1,
                        settlementBlockNumber: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setLastKnownBlockHashesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setLastKnownBlockHashesReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setLastKnownBlockHashesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setLastKnownBlockHashesReturn {
            fn _tokenize(
                &self,
            ) -> <setLastKnownBlockHashesCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setLastKnownBlockHashesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setLastKnownBlockHashesReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setLastKnownBlockHashes(bytes32,bytes32,uint256)";
            const SELECTOR: [u8; 4] = [25u8, 119u8, 22u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.ethBlockHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.settlementBlockHash),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.settlementBlockNumber),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setLastKnownBlockHashesReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `settlementChainID()` and selector `0x22623897`.
```solidity
function settlementChainID() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct settlementChainIDCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`settlementChainID()`](settlementChainIDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct settlementChainIDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<settlementChainIDCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: settlementChainIDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for settlementChainIDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<settlementChainIDReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: settlementChainIDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for settlementChainIDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for settlementChainIDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "settlementChainID()";
            const SELECTOR: [u8; 4] = [34u8, 98u8, 56u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: settlementChainIDReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: settlementChainIDReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `submitEpochPreImageData(uint256,uint256,uint256[],uint256[],address[])` and selector `0x529f4b56`.
```solidity
function submitEpochPreImageData(uint256 epoch, uint256 seqChainID, uint256[] memory appchains, uint256[] memory tokens, address[] memory emissionsReceivers) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitEpochPreImageDataCall {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub seqChainID: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub appchains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
        #[allow(missing_docs)]
        pub tokens: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
        #[allow(missing_docs)]
        pub emissionsReceivers: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    ///Container type for the return parameters of the [`submitEpochPreImageData(uint256,uint256,uint256[],uint256[],address[])`](submitEpochPreImageDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitEpochPreImageDataReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitEpochPreImageDataCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: submitEpochPreImageDataCall) -> Self {
                    (
                        value.epoch,
                        value.seqChainID,
                        value.appchains,
                        value.tokens,
                        value.emissionsReceivers,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for submitEpochPreImageDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epoch: tuple.0,
                        seqChainID: tuple.1,
                        appchains: tuple.2,
                        tokens: tuple.3,
                        emissionsReceivers: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitEpochPreImageDataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: submitEpochPreImageDataReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for submitEpochPreImageDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl submitEpochPreImageDataReturn {
            fn _tokenize(
                &self,
            ) -> <submitEpochPreImageDataCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for submitEpochPreImageDataCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = submitEpochPreImageDataReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "submitEpochPreImageData(uint256,uint256,uint256[],uint256[],address[])";
            const SELECTOR: [u8; 4] = [82u8, 159u8, 75u8, 86u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epoch),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.seqChainID),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchains),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokens),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.emissionsReceivers),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                submitEpochPreImageDataReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: supportsInterfaceReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: supportsInterfaceReturn = r.into();
                        r._0
                    })
            }
        }
    };
    ///Container for all the [`GasArchive`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum GasArchiveCalls {
        #[allow(missing_docs)]
        AGGREGATED_EPOCH_DATA_HASH_SLOT(AGGREGATED_EPOCH_DATA_HASH_SLOTCall),
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        HEADER_STATE_ROOT_INDEX(HEADER_STATE_ROOT_INDEXCall),
        #[allow(missing_docs)]
        STORAGE_ROOT_ACCOUNT_FIELDS_INDEX(STORAGE_ROOT_ACCOUNT_FIELDS_INDEXCall),
        #[allow(missing_docs)]
        addSequencingChain(addSequencingChainCall),
        #[allow(missing_docs)]
        blockHashSender(blockHashSenderCall),
        #[allow(missing_docs)]
        confirmEpochDataHash(confirmEpochDataHashCall),
        #[allow(missing_docs)]
        confirmSequencingChainBlockHash(confirmSequencingChainBlockHashCall),
        #[allow(missing_docs)]
        epochAppchainEmissionsReceiver(epochAppchainEmissionsReceiverCall),
        #[allow(missing_docs)]
        epochAppchainIDs(epochAppchainIDsCall),
        #[allow(missing_docs)]
        epochAppchainTokensUsed(epochAppchainTokensUsedCall),
        #[allow(missing_docs)]
        epochChainDataSubmitted(epochChainDataSubmittedCall),
        #[allow(missing_docs)]
        epochCompleted(epochCompletedCall),
        #[allow(missing_docs)]
        epochExpectedChains(epochExpectedChainsCall),
        #[allow(missing_docs)]
        epochTotalTokensUsed(epochTotalTokensUsedCall),
        #[allow(missing_docs)]
        epochVerifiedDataHash(epochVerifiedDataHashCall),
        #[allow(missing_docs)]
        getActiveAppchainIds(getActiveAppchainIdsCall),
        #[allow(missing_docs)]
        getAppchainGasFees(getAppchainGasFeesCall),
        #[allow(missing_docs)]
        getAppchainRewardsReceiver(getAppchainRewardsReceiverCall),
        #[allow(missing_docs)]
        getEpochExpectedChains(getEpochExpectedChainsCall),
        #[allow(missing_docs)]
        getEpochProgress(getEpochProgressCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        getTotalGasFees(getTotalGasFeesCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasChainSubmittedForEpoch(hasChainSubmittedForEpochCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        initialize(initializeCall),
        #[allow(missing_docs)]
        lastKnownEthereumBlockHash(lastKnownEthereumBlockHashCall),
        #[allow(missing_docs)]
        lastKnownSeqChainBlockHashes(lastKnownSeqChainBlockHashesCall),
        #[allow(missing_docs)]
        lastKnownSettlementChainBlockHash(lastKnownSettlementChainBlockHashCall),
        #[allow(missing_docs)]
        lastKnownSettlementChainBlockNumber(lastKnownSettlementChainBlockNumberCall),
        #[allow(missing_docs)]
        removeSeqChain(removeSeqChainCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        seqChainEthOutbox(seqChainEthOutboxCall),
        #[allow(missing_docs)]
        seqChainEthSendRootStorageSlot(seqChainEthSendRootStorageSlotCall),
        #[allow(missing_docs)]
        seqChainGasAggregatorAddresses(seqChainGasAggregatorAddressesCall),
        #[allow(missing_docs)]
        seqChainIDs(seqChainIDsCall),
        #[allow(missing_docs)]
        setBlockHashSender(setBlockHashSenderCall),
        #[allow(missing_docs)]
        setEpochExpectedChains(setEpochExpectedChainsCall),
        #[allow(missing_docs)]
        setLastKnownBlockHashes(setLastKnownBlockHashesCall),
        #[allow(missing_docs)]
        settlementChainID(settlementChainIDCall),
        #[allow(missing_docs)]
        submitEpochPreImageData(submitEpochPreImageDataCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
    }
    #[automatically_derived]
    impl GasArchiveCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 255u8, 201u8, 167u8],
            [3u8, 68u8, 87u8, 31u8],
            [19u8, 59u8, 248u8, 159u8],
            [25u8, 119u8, 22u8, 64u8],
            [27u8, 244u8, 149u8, 28u8],
            [34u8, 98u8, 56u8, 151u8],
            [35u8, 175u8, 176u8, 255u8],
            [36u8, 138u8, 156u8, 163u8],
            [40u8, 95u8, 36u8, 70u8],
            [44u8, 208u8, 120u8, 184u8],
            [47u8, 47u8, 241u8, 93u8],
            [48u8, 199u8, 9u8, 182u8],
            [54u8, 43u8, 129u8, 84u8],
            [54u8, 86u8, 138u8, 190u8],
            [71u8, 223u8, 246u8, 157u8],
            [78u8, 109u8, 162u8, 164u8],
            [82u8, 159u8, 75u8, 86u8],
            [85u8, 252u8, 197u8, 86u8],
            [90u8, 99u8, 48u8, 128u8],
            [91u8, 24u8, 23u8, 232u8],
            [93u8, 87u8, 154u8, 97u8],
            [101u8, 14u8, 19u8, 18u8],
            [107u8, 77u8, 23u8, 173u8],
            [107u8, 163u8, 209u8, 127u8],
            [122u8, 127u8, 52u8, 232u8],
            [124u8, 110u8, 219u8, 62u8],
            [124u8, 113u8, 80u8, 148u8],
            [124u8, 144u8, 29u8, 123u8],
            [141u8, 147u8, 94u8, 29u8],
            [141u8, 213u8, 14u8, 238u8],
            [145u8, 209u8, 72u8, 84u8],
            [149u8, 129u8, 75u8, 245u8],
            [162u8, 23u8, 253u8, 223u8],
            [195u8, 80u8, 161u8, 181u8],
            [206u8, 83u8, 124u8, 159u8],
            [210u8, 107u8, 204u8, 128u8],
            [213u8, 71u8, 116u8, 31u8],
            [225u8, 139u8, 77u8, 174u8],
            [232u8, 196u8, 108u8, 40u8],
            [236u8, 130u8, 138u8, 145u8],
            [239u8, 81u8, 34u8, 33u8],
            [253u8, 121u8, 211u8, 225u8],
            [253u8, 213u8, 65u8, 35u8],
            [255u8, 135u8, 193u8, 140u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for GasArchiveCalls {
        const NAME: &'static str = "GasArchiveCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 44usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AGGREGATED_EPOCH_DATA_HASH_SLOT(_) => {
                    <AGGREGATED_EPOCH_DATA_HASH_SLOTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::HEADER_STATE_ROOT_INDEX(_) => {
                    <HEADER_STATE_ROOT_INDEXCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::STORAGE_ROOT_ACCOUNT_FIELDS_INDEX(_) => {
                    <STORAGE_ROOT_ACCOUNT_FIELDS_INDEXCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addSequencingChain(_) => {
                    <addSequencingChainCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::blockHashSender(_) => {
                    <blockHashSenderCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::confirmEpochDataHash(_) => {
                    <confirmEpochDataHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::confirmSequencingChainBlockHash(_) => {
                    <confirmSequencingChainBlockHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochAppchainEmissionsReceiver(_) => {
                    <epochAppchainEmissionsReceiverCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochAppchainIDs(_) => {
                    <epochAppchainIDsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochAppchainTokensUsed(_) => {
                    <epochAppchainTokensUsedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochChainDataSubmitted(_) => {
                    <epochChainDataSubmittedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochCompleted(_) => {
                    <epochCompletedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochExpectedChains(_) => {
                    <epochExpectedChainsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochTotalTokensUsed(_) => {
                    <epochTotalTokensUsedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::epochVerifiedDataHash(_) => {
                    <epochVerifiedDataHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getActiveAppchainIds(_) => {
                    <getActiveAppchainIdsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAppchainGasFees(_) => {
                    <getAppchainGasFeesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAppchainRewardsReceiver(_) => {
                    <getAppchainRewardsReceiverCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getEpochExpectedChains(_) => {
                    <getEpochExpectedChainsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getEpochProgress(_) => {
                    <getEpochProgressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getTotalGasFees(_) => {
                    <getTotalGasFeesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasChainSubmittedForEpoch(_) => {
                    <hasChainSubmittedForEpochCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::initialize(_) => {
                    <initializeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::lastKnownEthereumBlockHash(_) => {
                    <lastKnownEthereumBlockHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::lastKnownSeqChainBlockHashes(_) => {
                    <lastKnownSeqChainBlockHashesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::lastKnownSettlementChainBlockHash(_) => {
                    <lastKnownSettlementChainBlockHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::lastKnownSettlementChainBlockNumber(_) => {
                    <lastKnownSettlementChainBlockNumberCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeSeqChain(_) => {
                    <removeSeqChainCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::seqChainEthOutbox(_) => {
                    <seqChainEthOutboxCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::seqChainEthSendRootStorageSlot(_) => {
                    <seqChainEthSendRootStorageSlotCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::seqChainGasAggregatorAddresses(_) => {
                    <seqChainGasAggregatorAddressesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::seqChainIDs(_) => {
                    <seqChainIDsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBlockHashSender(_) => {
                    <setBlockHashSenderCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setEpochExpectedChains(_) => {
                    <setEpochExpectedChainsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setLastKnownBlockHashes(_) => {
                    <setLastKnownBlockHashesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::settlementChainID(_) => {
                    <settlementChainIDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::submitEpochPreImageData(_) => {
                    <submitEpochPreImageDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<GasArchiveCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn setEpochExpectedChains(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <setEpochExpectedChainsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::setEpochExpectedChains)
                    }
                    setEpochExpectedChains
                },
                {
                    fn addSequencingChain(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <addSequencingChainCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::addSequencingChain)
                    }
                    addSequencingChain
                },
                {
                    fn setLastKnownBlockHashes(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <setLastKnownBlockHashesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::setLastKnownBlockHashes)
                    }
                    setLastKnownBlockHashes
                },
                {
                    fn confirmSequencingChainBlockHash(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <confirmSequencingChainBlockHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::confirmSequencingChainBlockHash)
                    }
                    confirmSequencingChainBlockHash
                },
                {
                    fn settlementChainID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <settlementChainIDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::settlementChainID)
                    }
                    settlementChainID
                },
                {
                    fn lastKnownEthereumBlockHash(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <lastKnownEthereumBlockHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::lastKnownEthereumBlockHash)
                    }
                    lastKnownEthereumBlockHash
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn getAppchainGasFees(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <getAppchainGasFeesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::getAppchainGasFees)
                    }
                    getAppchainGasFees
                },
                {
                    fn getActiveAppchainIds(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <getActiveAppchainIdsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::getActiveAppchainIds)
                    }
                    getActiveAppchainIds
                },
                {
                    fn grantRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(GasArchiveCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn epochCompleted(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <epochCompletedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::epochCompleted)
                    }
                    epochCompleted
                },
                {
                    fn blockHashSender(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <blockHashSenderCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::blockHashSender)
                    }
                    blockHashSender
                },
                {
                    fn renounceRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn epochTotalTokensUsed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <epochTotalTokensUsedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::epochTotalTokensUsed)
                    }
                    epochTotalTokensUsed
                },
                {
                    fn getEpochProgress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <getEpochProgressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::getEpochProgress)
                    }
                    getEpochProgress
                },
                {
                    fn submitEpochPreImageData(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <submitEpochPreImageDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::submitEpochPreImageData)
                    }
                    submitEpochPreImageData
                },
                {
                    fn epochAppchainTokensUsed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <epochAppchainTokensUsedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::epochAppchainTokensUsed)
                    }
                    epochAppchainTokensUsed
                },
                {
                    fn epochChainDataSubmitted(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <epochChainDataSubmittedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::epochChainDataSubmitted)
                    }
                    epochChainDataSubmitted
                },
                {
                    fn epochAppchainEmissionsReceiver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <epochAppchainEmissionsReceiverCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::epochAppchainEmissionsReceiver)
                    }
                    epochAppchainEmissionsReceiver
                },
                {
                    fn epochExpectedChains(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <epochExpectedChainsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::epochExpectedChains)
                    }
                    epochExpectedChains
                },
                {
                    fn removeSeqChain(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <removeSeqChainCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::removeSeqChain)
                    }
                    removeSeqChain
                },
                {
                    fn STORAGE_ROOT_ACCOUNT_FIELDS_INDEX(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <STORAGE_ROOT_ACCOUNT_FIELDS_INDEXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::STORAGE_ROOT_ACCOUNT_FIELDS_INDEX)
                    }
                    STORAGE_ROOT_ACCOUNT_FIELDS_INDEX
                },
                {
                    fn epochVerifiedDataHash(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <epochVerifiedDataHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::epochVerifiedDataHash)
                    }
                    epochVerifiedDataHash
                },
                {
                    fn lastKnownSeqChainBlockHashes(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <lastKnownSeqChainBlockHashesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::lastKnownSeqChainBlockHashes)
                    }
                    lastKnownSeqChainBlockHashes
                },
                {
                    fn getEpochExpectedChains(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <getEpochExpectedChainsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::getEpochExpectedChains)
                    }
                    getEpochExpectedChains
                },
                {
                    fn setBlockHashSender(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <setBlockHashSenderCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::setBlockHashSender)
                    }
                    setBlockHashSender
                },
                {
                    fn confirmEpochDataHash(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <confirmEpochDataHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::confirmEpochDataHash)
                    }
                    confirmEpochDataHash
                },
                {
                    fn lastKnownSettlementChainBlockNumber(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <lastKnownSettlementChainBlockNumberCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::lastKnownSettlementChainBlockNumber)
                    }
                    lastKnownSettlementChainBlockNumber
                },
                {
                    fn seqChainGasAggregatorAddresses(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <seqChainGasAggregatorAddressesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::seqChainGasAggregatorAddresses)
                    }
                    seqChainGasAggregatorAddresses
                },
                {
                    fn hasRole(data: &[u8]) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(GasArchiveCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn hasChainSubmittedForEpoch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <hasChainSubmittedForEpochCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::hasChainSubmittedForEpoch)
                    }
                    hasChainSubmittedForEpoch
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn initialize(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::initialize)
                    }
                    initialize
                },
                {
                    fn getTotalGasFees(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <getTotalGasFeesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::getTotalGasFees)
                    }
                    getTotalGasFees
                },
                {
                    fn seqChainIDs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <seqChainIDsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::seqChainIDs)
                    }
                    seqChainIDs
                },
                {
                    fn revokeRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn HEADER_STATE_ROOT_INDEX(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <HEADER_STATE_ROOT_INDEXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::HEADER_STATE_ROOT_INDEX)
                    }
                    HEADER_STATE_ROOT_INDEX
                },
                {
                    fn AGGREGATED_EPOCH_DATA_HASH_SLOT(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <AGGREGATED_EPOCH_DATA_HASH_SLOTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::AGGREGATED_EPOCH_DATA_HASH_SLOT)
                    }
                    AGGREGATED_EPOCH_DATA_HASH_SLOT
                },
                {
                    fn getAppchainRewardsReceiver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <getAppchainRewardsReceiverCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::getAppchainRewardsReceiver)
                    }
                    getAppchainRewardsReceiver
                },
                {
                    fn lastKnownSettlementChainBlockHash(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <lastKnownSettlementChainBlockHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::lastKnownSettlementChainBlockHash)
                    }
                    lastKnownSettlementChainBlockHash
                },
                {
                    fn seqChainEthSendRootStorageSlot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <seqChainEthSendRootStorageSlotCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::seqChainEthSendRootStorageSlot)
                    }
                    seqChainEthSendRootStorageSlot
                },
                {
                    fn seqChainEthOutbox(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <seqChainEthOutboxCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::seqChainEthOutbox)
                    }
                    seqChainEthOutbox
                },
                {
                    fn epochAppchainIDs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <epochAppchainIDsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveCalls::epochAppchainIDs)
                    }
                    epochAppchainIDs
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<GasArchiveCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn setEpochExpectedChains(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <setEpochExpectedChainsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::setEpochExpectedChains)
                    }
                    setEpochExpectedChains
                },
                {
                    fn addSequencingChain(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <addSequencingChainCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::addSequencingChain)
                    }
                    addSequencingChain
                },
                {
                    fn setLastKnownBlockHashes(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <setLastKnownBlockHashesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::setLastKnownBlockHashes)
                    }
                    setLastKnownBlockHashes
                },
                {
                    fn confirmSequencingChainBlockHash(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <confirmSequencingChainBlockHashCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::confirmSequencingChainBlockHash)
                    }
                    confirmSequencingChainBlockHash
                },
                {
                    fn settlementChainID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <settlementChainIDCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::settlementChainID)
                    }
                    settlementChainID
                },
                {
                    fn lastKnownEthereumBlockHash(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <lastKnownEthereumBlockHashCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::lastKnownEthereumBlockHash)
                    }
                    lastKnownEthereumBlockHash
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn getAppchainGasFees(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <getAppchainGasFeesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::getAppchainGasFees)
                    }
                    getAppchainGasFees
                },
                {
                    fn getActiveAppchainIds(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <getActiveAppchainIdsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::getActiveAppchainIds)
                    }
                    getActiveAppchainIds
                },
                {
                    fn grantRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn epochCompleted(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <epochCompletedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::epochCompleted)
                    }
                    epochCompleted
                },
                {
                    fn blockHashSender(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <blockHashSenderCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::blockHashSender)
                    }
                    blockHashSender
                },
                {
                    fn renounceRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn epochTotalTokensUsed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <epochTotalTokensUsedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::epochTotalTokensUsed)
                    }
                    epochTotalTokensUsed
                },
                {
                    fn getEpochProgress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <getEpochProgressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::getEpochProgress)
                    }
                    getEpochProgress
                },
                {
                    fn submitEpochPreImageData(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <submitEpochPreImageDataCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::submitEpochPreImageData)
                    }
                    submitEpochPreImageData
                },
                {
                    fn epochAppchainTokensUsed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <epochAppchainTokensUsedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::epochAppchainTokensUsed)
                    }
                    epochAppchainTokensUsed
                },
                {
                    fn epochChainDataSubmitted(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <epochChainDataSubmittedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::epochChainDataSubmitted)
                    }
                    epochChainDataSubmitted
                },
                {
                    fn epochAppchainEmissionsReceiver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <epochAppchainEmissionsReceiverCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::epochAppchainEmissionsReceiver)
                    }
                    epochAppchainEmissionsReceiver
                },
                {
                    fn epochExpectedChains(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <epochExpectedChainsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::epochExpectedChains)
                    }
                    epochExpectedChains
                },
                {
                    fn removeSeqChain(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <removeSeqChainCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::removeSeqChain)
                    }
                    removeSeqChain
                },
                {
                    fn STORAGE_ROOT_ACCOUNT_FIELDS_INDEX(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <STORAGE_ROOT_ACCOUNT_FIELDS_INDEXCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::STORAGE_ROOT_ACCOUNT_FIELDS_INDEX)
                    }
                    STORAGE_ROOT_ACCOUNT_FIELDS_INDEX
                },
                {
                    fn epochVerifiedDataHash(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <epochVerifiedDataHashCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::epochVerifiedDataHash)
                    }
                    epochVerifiedDataHash
                },
                {
                    fn lastKnownSeqChainBlockHashes(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <lastKnownSeqChainBlockHashesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::lastKnownSeqChainBlockHashes)
                    }
                    lastKnownSeqChainBlockHashes
                },
                {
                    fn getEpochExpectedChains(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <getEpochExpectedChainsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::getEpochExpectedChains)
                    }
                    getEpochExpectedChains
                },
                {
                    fn setBlockHashSender(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <setBlockHashSenderCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::setBlockHashSender)
                    }
                    setBlockHashSender
                },
                {
                    fn confirmEpochDataHash(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <confirmEpochDataHashCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::confirmEpochDataHash)
                    }
                    confirmEpochDataHash
                },
                {
                    fn lastKnownSettlementChainBlockNumber(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <lastKnownSettlementChainBlockNumberCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::lastKnownSettlementChainBlockNumber)
                    }
                    lastKnownSettlementChainBlockNumber
                },
                {
                    fn seqChainGasAggregatorAddresses(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <seqChainGasAggregatorAddressesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::seqChainGasAggregatorAddresses)
                    }
                    seqChainGasAggregatorAddresses
                },
                {
                    fn hasRole(data: &[u8]) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn hasChainSubmittedForEpoch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <hasChainSubmittedForEpochCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::hasChainSubmittedForEpoch)
                    }
                    hasChainSubmittedForEpoch
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn initialize(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::initialize)
                    }
                    initialize
                },
                {
                    fn getTotalGasFees(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <getTotalGasFeesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::getTotalGasFees)
                    }
                    getTotalGasFees
                },
                {
                    fn seqChainIDs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <seqChainIDsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::seqChainIDs)
                    }
                    seqChainIDs
                },
                {
                    fn revokeRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn HEADER_STATE_ROOT_INDEX(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <HEADER_STATE_ROOT_INDEXCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::HEADER_STATE_ROOT_INDEX)
                    }
                    HEADER_STATE_ROOT_INDEX
                },
                {
                    fn AGGREGATED_EPOCH_DATA_HASH_SLOT(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <AGGREGATED_EPOCH_DATA_HASH_SLOTCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::AGGREGATED_EPOCH_DATA_HASH_SLOT)
                    }
                    AGGREGATED_EPOCH_DATA_HASH_SLOT
                },
                {
                    fn getAppchainRewardsReceiver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <getAppchainRewardsReceiverCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::getAppchainRewardsReceiver)
                    }
                    getAppchainRewardsReceiver
                },
                {
                    fn lastKnownSettlementChainBlockHash(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <lastKnownSettlementChainBlockHashCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::lastKnownSettlementChainBlockHash)
                    }
                    lastKnownSettlementChainBlockHash
                },
                {
                    fn seqChainEthSendRootStorageSlot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <seqChainEthSendRootStorageSlotCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::seqChainEthSendRootStorageSlot)
                    }
                    seqChainEthSendRootStorageSlot
                },
                {
                    fn seqChainEthOutbox(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <seqChainEthOutboxCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::seqChainEthOutbox)
                    }
                    seqChainEthOutbox
                },
                {
                    fn epochAppchainIDs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveCalls> {
                        <epochAppchainIDsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveCalls::epochAppchainIDs)
                    }
                    epochAppchainIDs
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AGGREGATED_EPOCH_DATA_HASH_SLOT(inner) => {
                    <AGGREGATED_EPOCH_DATA_HASH_SLOTCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::HEADER_STATE_ROOT_INDEX(inner) => {
                    <HEADER_STATE_ROOT_INDEXCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::STORAGE_ROOT_ACCOUNT_FIELDS_INDEX(inner) => {
                    <STORAGE_ROOT_ACCOUNT_FIELDS_INDEXCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::addSequencingChain(inner) => {
                    <addSequencingChainCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::blockHashSender(inner) => {
                    <blockHashSenderCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::confirmEpochDataHash(inner) => {
                    <confirmEpochDataHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::confirmSequencingChainBlockHash(inner) => {
                    <confirmSequencingChainBlockHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochAppchainEmissionsReceiver(inner) => {
                    <epochAppchainEmissionsReceiverCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochAppchainIDs(inner) => {
                    <epochAppchainIDsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochAppchainTokensUsed(inner) => {
                    <epochAppchainTokensUsedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochChainDataSubmitted(inner) => {
                    <epochChainDataSubmittedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochCompleted(inner) => {
                    <epochCompletedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochExpectedChains(inner) => {
                    <epochExpectedChainsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochTotalTokensUsed(inner) => {
                    <epochTotalTokensUsedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::epochVerifiedDataHash(inner) => {
                    <epochVerifiedDataHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getActiveAppchainIds(inner) => {
                    <getActiveAppchainIdsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAppchainGasFees(inner) => {
                    <getAppchainGasFeesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAppchainRewardsReceiver(inner) => {
                    <getAppchainRewardsReceiverCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getEpochExpectedChains(inner) => {
                    <getEpochExpectedChainsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getEpochProgress(inner) => {
                    <getEpochProgressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getTotalGasFees(inner) => {
                    <getTotalGasFeesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasChainSubmittedForEpoch(inner) => {
                    <hasChainSubmittedForEpochCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::lastKnownEthereumBlockHash(inner) => {
                    <lastKnownEthereumBlockHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::lastKnownSeqChainBlockHashes(inner) => {
                    <lastKnownSeqChainBlockHashesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::lastKnownSettlementChainBlockHash(inner) => {
                    <lastKnownSettlementChainBlockHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::lastKnownSettlementChainBlockNumber(inner) => {
                    <lastKnownSettlementChainBlockNumberCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeSeqChain(inner) => {
                    <removeSeqChainCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::seqChainEthOutbox(inner) => {
                    <seqChainEthOutboxCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::seqChainEthSendRootStorageSlot(inner) => {
                    <seqChainEthSendRootStorageSlotCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::seqChainGasAggregatorAddresses(inner) => {
                    <seqChainGasAggregatorAddressesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::seqChainIDs(inner) => {
                    <seqChainIDsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setBlockHashSender(inner) => {
                    <setBlockHashSenderCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setEpochExpectedChains(inner) => {
                    <setEpochExpectedChainsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setLastKnownBlockHashes(inner) => {
                    <setLastKnownBlockHashesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::settlementChainID(inner) => {
                    <settlementChainIDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::submitEpochPreImageData(inner) => {
                    <submitEpochPreImageDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AGGREGATED_EPOCH_DATA_HASH_SLOT(inner) => {
                    <AGGREGATED_EPOCH_DATA_HASH_SLOTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::HEADER_STATE_ROOT_INDEX(inner) => {
                    <HEADER_STATE_ROOT_INDEXCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::STORAGE_ROOT_ACCOUNT_FIELDS_INDEX(inner) => {
                    <STORAGE_ROOT_ACCOUNT_FIELDS_INDEXCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addSequencingChain(inner) => {
                    <addSequencingChainCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::blockHashSender(inner) => {
                    <blockHashSenderCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::confirmEpochDataHash(inner) => {
                    <confirmEpochDataHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::confirmSequencingChainBlockHash(inner) => {
                    <confirmSequencingChainBlockHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochAppchainEmissionsReceiver(inner) => {
                    <epochAppchainEmissionsReceiverCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochAppchainIDs(inner) => {
                    <epochAppchainIDsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochAppchainTokensUsed(inner) => {
                    <epochAppchainTokensUsedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochChainDataSubmitted(inner) => {
                    <epochChainDataSubmittedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochCompleted(inner) => {
                    <epochCompletedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochExpectedChains(inner) => {
                    <epochExpectedChainsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochTotalTokensUsed(inner) => {
                    <epochTotalTokensUsedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::epochVerifiedDataHash(inner) => {
                    <epochVerifiedDataHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getActiveAppchainIds(inner) => {
                    <getActiveAppchainIdsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAppchainGasFees(inner) => {
                    <getAppchainGasFeesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAppchainRewardsReceiver(inner) => {
                    <getAppchainRewardsReceiverCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getEpochExpectedChains(inner) => {
                    <getEpochExpectedChainsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getEpochProgress(inner) => {
                    <getEpochProgressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getTotalGasFees(inner) => {
                    <getTotalGasFeesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasChainSubmittedForEpoch(inner) => {
                    <hasChainSubmittedForEpochCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::lastKnownEthereumBlockHash(inner) => {
                    <lastKnownEthereumBlockHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::lastKnownSeqChainBlockHashes(inner) => {
                    <lastKnownSeqChainBlockHashesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::lastKnownSettlementChainBlockHash(inner) => {
                    <lastKnownSettlementChainBlockHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::lastKnownSettlementChainBlockNumber(inner) => {
                    <lastKnownSettlementChainBlockNumberCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeSeqChain(inner) => {
                    <removeSeqChainCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::seqChainEthOutbox(inner) => {
                    <seqChainEthOutboxCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::seqChainEthSendRootStorageSlot(inner) => {
                    <seqChainEthSendRootStorageSlotCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::seqChainGasAggregatorAddresses(inner) => {
                    <seqChainGasAggregatorAddressesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::seqChainIDs(inner) => {
                    <seqChainIDsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBlockHashSender(inner) => {
                    <setBlockHashSenderCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setEpochExpectedChains(inner) => {
                    <setEpochExpectedChainsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setLastKnownBlockHashes(inner) => {
                    <setLastKnownBlockHashesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::settlementChainID(inner) => {
                    <settlementChainIDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::submitEpochPreImageData(inner) => {
                    <submitEpochPreImageDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`GasArchive`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum GasArchiveErrors {
        #[allow(missing_docs)]
        AccessControlBadConfirmation(AccessControlBadConfirmation),
        #[allow(missing_docs)]
        AccessControlUnauthorizedAccount(AccessControlUnauthorizedAccount),
        #[allow(missing_docs)]
        AccountDoesNotExistInProof(AccountDoesNotExistInProof),
        #[allow(missing_docs)]
        AlreadySubmitted(AlreadySubmitted),
        #[allow(missing_docs)]
        CannotSubmitProofForSettlementChain(CannotSubmitProofForSettlementChain),
        #[allow(missing_docs)]
        ChainIDNotFound(ChainIDNotFound),
        #[allow(missing_docs)]
        EmptyDataHash(EmptyDataHash),
        #[allow(missing_docs)]
        EmptySlot(EmptySlot),
        #[allow(missing_docs)]
        EpochAlreadyCompleted(EpochAlreadyCompleted),
        #[allow(missing_docs)]
        InvalidData(InvalidData),
        #[allow(missing_docs)]
        InvalidEthereumBlockHeader(InvalidEthereumBlockHeader),
        #[allow(missing_docs)]
        InvalidInitialization(InvalidInitialization),
        #[allow(missing_docs)]
        InvalidProof(InvalidProof),
        #[allow(missing_docs)]
        InvalidSeqChainBlockHeader(InvalidSeqChainBlockHeader),
        #[allow(missing_docs)]
        NotArchivedEpoch(NotArchivedEpoch),
        #[allow(missing_docs)]
        NotBlockHashSender(NotBlockHashSender),
        #[allow(missing_docs)]
        NotInitializing(NotInitializing),
        #[allow(missing_docs)]
        OldSettlementChainBlockNumber(OldSettlementChainBlockNumber),
        #[allow(missing_docs)]
        SequencingChainAlreadyExists(SequencingChainAlreadyExists),
        #[allow(missing_docs)]
        ZeroAddress(ZeroAddress),
        #[allow(missing_docs)]
        ZeroLengthArray(ZeroLengthArray),
    }
    #[automatically_derived]
    impl GasArchiveErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [9u8, 189u8, 227u8, 57u8],
            [15u8, 89u8, 185u8, 255u8],
            [18u8, 66u8, 233u8, 187u8],
            [36u8, 178u8, 231u8, 253u8],
            [52u8, 119u8, 220u8, 218u8],
            [84u8, 119u8, 6u8, 175u8],
            [92u8, 176u8, 69u8, 219u8],
            [102u8, 151u8, 178u8, 50u8],
            [154u8, 12u8, 206u8, 83u8],
            [157u8, 140u8, 186u8, 205u8],
            [159u8, 191u8, 197u8, 137u8],
            [195u8, 107u8, 164u8, 35u8],
            [197u8, 177u8, 69u8, 113u8],
            [215u8, 230u8, 188u8, 248u8],
            [217u8, 46u8, 35u8, 61u8],
            [218u8, 38u8, 18u8, 128u8],
            [223u8, 101u8, 10u8, 0u8],
            [226u8, 81u8, 125u8, 63u8],
            [239u8, 182u8, 76u8, 248u8],
            [249u8, 46u8, 232u8, 169u8],
            [253u8, 147u8, 193u8, 95u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for GasArchiveErrors {
        const NAME: &'static str = "GasArchiveErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 21usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccessControlBadConfirmation(_) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AccessControlUnauthorizedAccount(_) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AccountDoesNotExistInProof(_) => {
                    <AccountDoesNotExistInProof as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AlreadySubmitted(_) => {
                    <AlreadySubmitted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CannotSubmitProofForSettlementChain(_) => {
                    <CannotSubmitProofForSettlementChain as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ChainIDNotFound(_) => {
                    <ChainIDNotFound as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyDataHash(_) => {
                    <EmptyDataHash as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptySlot(_) => <EmptySlot as alloy_sol_types::SolError>::SELECTOR,
                Self::EpochAlreadyCompleted(_) => {
                    <EpochAlreadyCompleted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidData(_) => {
                    <InvalidData as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidEthereumBlockHeader(_) => {
                    <InvalidEthereumBlockHeader as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidInitialization(_) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidProof(_) => {
                    <InvalidProof as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidSeqChainBlockHeader(_) => {
                    <InvalidSeqChainBlockHeader as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotArchivedEpoch(_) => {
                    <NotArchivedEpoch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotBlockHashSender(_) => {
                    <NotBlockHashSender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializing(_) => {
                    <NotInitializing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OldSettlementChainBlockNumber(_) => {
                    <OldSettlementChainBlockNumber as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SequencingChainAlreadyExists(_) => {
                    <SequencingChainAlreadyExists as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAddress(_) => {
                    <ZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroLengthArray(_) => {
                    <ZeroLengthArray as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<GasArchiveErrors>] = &[
                {
                    fn InvalidProof(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <InvalidProof as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(GasArchiveErrors::InvalidProof)
                    }
                    InvalidProof
                },
                {
                    fn ZeroLengthArray(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <ZeroLengthArray as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveErrors::ZeroLengthArray)
                    }
                    ZeroLengthArray
                },
                {
                    fn ChainIDNotFound(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <ChainIDNotFound as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveErrors::ChainIDNotFound)
                    }
                    ChainIDNotFound
                },
                {
                    fn NotBlockHashSender(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <NotBlockHashSender as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveErrors::NotBlockHashSender)
                    }
                    NotBlockHashSender
                },
                {
                    fn EmptySlot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <EmptySlot as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(GasArchiveErrors::EmptySlot)
                    }
                    EmptySlot
                },
                {
                    fn AccountDoesNotExistInProof(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <AccountDoesNotExistInProof as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveErrors::AccountDoesNotExistInProof)
                    }
                    AccountDoesNotExistInProof
                },
                {
                    fn InvalidData(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <InvalidData as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(GasArchiveErrors::InvalidData)
                    }
                    InvalidData
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveErrors::AccessControlBadConfirmation)
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn EmptyDataHash(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <EmptyDataHash as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveErrors::EmptyDataHash)
                    }
                    EmptyDataHash
                },
                {
                    fn InvalidSeqChainBlockHeader(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <InvalidSeqChainBlockHeader as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveErrors::InvalidSeqChainBlockHeader)
                    }
                    InvalidSeqChainBlockHeader
                },
                {
                    fn AlreadySubmitted(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <AlreadySubmitted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveErrors::AlreadySubmitted)
                    }
                    AlreadySubmitted
                },
                {
                    fn OldSettlementChainBlockNumber(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <OldSettlementChainBlockNumber as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveErrors::OldSettlementChainBlockNumber)
                    }
                    OldSettlementChainBlockNumber
                },
                {
                    fn NotArchivedEpoch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <NotArchivedEpoch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveErrors::NotArchivedEpoch)
                    }
                    NotArchivedEpoch
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(GasArchiveErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn CannotSubmitProofForSettlementChain(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <CannotSubmitProofForSettlementChain as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveErrors::CannotSubmitProofForSettlementChain)
                    }
                    CannotSubmitProofForSettlementChain
                },
                {
                    fn SequencingChainAlreadyExists(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <SequencingChainAlreadyExists as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveErrors::SequencingChainAlreadyExists)
                    }
                    SequencingChainAlreadyExists
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveErrors::AccessControlUnauthorizedAccount)
                    }
                    AccessControlUnauthorizedAccount
                },
                {
                    fn InvalidEthereumBlockHeader(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <InvalidEthereumBlockHeader as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveErrors::InvalidEthereumBlockHeader)
                    }
                    InvalidEthereumBlockHeader
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
                {
                    fn EpochAlreadyCompleted(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <EpochAlreadyCompleted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(GasArchiveErrors::EpochAlreadyCompleted)
                    }
                    EpochAlreadyCompleted
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<GasArchiveErrors>] = &[
                {
                    fn InvalidProof(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <InvalidProof as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::InvalidProof)
                    }
                    InvalidProof
                },
                {
                    fn ZeroLengthArray(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <ZeroLengthArray as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::ZeroLengthArray)
                    }
                    ZeroLengthArray
                },
                {
                    fn ChainIDNotFound(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <ChainIDNotFound as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::ChainIDNotFound)
                    }
                    ChainIDNotFound
                },
                {
                    fn NotBlockHashSender(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <NotBlockHashSender as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::NotBlockHashSender)
                    }
                    NotBlockHashSender
                },
                {
                    fn EmptySlot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <EmptySlot as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::EmptySlot)
                    }
                    EmptySlot
                },
                {
                    fn AccountDoesNotExistInProof(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <AccountDoesNotExistInProof as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::AccountDoesNotExistInProof)
                    }
                    AccountDoesNotExistInProof
                },
                {
                    fn InvalidData(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <InvalidData as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::InvalidData)
                    }
                    InvalidData
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::AccessControlBadConfirmation)
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn EmptyDataHash(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <EmptyDataHash as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::EmptyDataHash)
                    }
                    EmptyDataHash
                },
                {
                    fn InvalidSeqChainBlockHeader(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <InvalidSeqChainBlockHeader as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::InvalidSeqChainBlockHeader)
                    }
                    InvalidSeqChainBlockHeader
                },
                {
                    fn AlreadySubmitted(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <AlreadySubmitted as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::AlreadySubmitted)
                    }
                    AlreadySubmitted
                },
                {
                    fn OldSettlementChainBlockNumber(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <OldSettlementChainBlockNumber as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::OldSettlementChainBlockNumber)
                    }
                    OldSettlementChainBlockNumber
                },
                {
                    fn NotArchivedEpoch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <NotArchivedEpoch as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::NotArchivedEpoch)
                    }
                    NotArchivedEpoch
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn CannotSubmitProofForSettlementChain(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <CannotSubmitProofForSettlementChain as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::CannotSubmitProofForSettlementChain)
                    }
                    CannotSubmitProofForSettlementChain
                },
                {
                    fn SequencingChainAlreadyExists(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <SequencingChainAlreadyExists as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::SequencingChainAlreadyExists)
                    }
                    SequencingChainAlreadyExists
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::AccessControlUnauthorizedAccount)
                    }
                    AccessControlUnauthorizedAccount
                },
                {
                    fn InvalidEthereumBlockHeader(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <InvalidEthereumBlockHeader as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::InvalidEthereumBlockHeader)
                    }
                    InvalidEthereumBlockHeader
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
                {
                    fn EpochAlreadyCompleted(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<GasArchiveErrors> {
                        <EpochAlreadyCompleted as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(GasArchiveErrors::EpochAlreadyCompleted)
                    }
                    EpochAlreadyCompleted
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AccountDoesNotExistInProof(inner) => {
                    <AccountDoesNotExistInProof as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AlreadySubmitted(inner) => {
                    <AlreadySubmitted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CannotSubmitProofForSettlementChain(inner) => {
                    <CannotSubmitProofForSettlementChain as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ChainIDNotFound(inner) => {
                    <ChainIDNotFound as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyDataHash(inner) => {
                    <EmptyDataHash as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptySlot(inner) => {
                    <EmptySlot as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EpochAlreadyCompleted(inner) => {
                    <EpochAlreadyCompleted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidData(inner) => {
                    <InvalidData as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidEthereumBlockHeader(inner) => {
                    <InvalidEthereumBlockHeader as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidProof(inner) => {
                    <InvalidProof as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidSeqChainBlockHeader(inner) => {
                    <InvalidSeqChainBlockHeader as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotArchivedEpoch(inner) => {
                    <NotArchivedEpoch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotBlockHashSender(inner) => {
                    <NotBlockHashSender as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OldSettlementChainBlockNumber(inner) => {
                    <OldSettlementChainBlockNumber as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SequencingChainAlreadyExists(inner) => {
                    <SequencingChainAlreadyExists as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ZeroLengthArray(inner) => {
                    <ZeroLengthArray as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AccountDoesNotExistInProof(inner) => {
                    <AccountDoesNotExistInProof as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AlreadySubmitted(inner) => {
                    <AlreadySubmitted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CannotSubmitProofForSettlementChain(inner) => {
                    <CannotSubmitProofForSettlementChain as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ChainIDNotFound(inner) => {
                    <ChainIDNotFound as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyDataHash(inner) => {
                    <EmptyDataHash as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptySlot(inner) => {
                    <EmptySlot as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::EpochAlreadyCompleted(inner) => {
                    <EpochAlreadyCompleted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidData(inner) => {
                    <InvalidData as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidEthereumBlockHeader(inner) => {
                    <InvalidEthereumBlockHeader as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidProof(inner) => {
                    <InvalidProof as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidSeqChainBlockHeader(inner) => {
                    <InvalidSeqChainBlockHeader as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotArchivedEpoch(inner) => {
                    <NotArchivedEpoch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotBlockHashSender(inner) => {
                    <NotBlockHashSender as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OldSettlementChainBlockNumber(inner) => {
                    <OldSettlementChainBlockNumber as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SequencingChainAlreadyExists(inner) => {
                    <SequencingChainAlreadyExists as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroLengthArray(inner) => {
                    <ZeroLengthArray as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`GasArchive`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum GasArchiveEvents {
        #[allow(missing_docs)]
        EpochCompleted(EpochCompleted),
        #[allow(missing_docs)]
        EpochDataValidated(EpochDataValidated),
        #[allow(missing_docs)]
        EpochExpectedChainsUpdated(EpochExpectedChainsUpdated),
        #[allow(missing_docs)]
        GasAggregatorAddressUpdated(GasAggregatorAddressUpdated),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        LastKnownBlockHashesUpdated(LastKnownBlockHashesUpdated),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
    }
    #[automatically_derived]
    impl GasArchiveEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                44u8, 63u8, 68u8, 53u8, 153u8, 198u8, 38u8, 138u8, 206u8, 212u8, 115u8,
                231u8, 102u8, 11u8, 64u8, 116u8, 110u8, 163u8, 148u8, 213u8, 25u8, 23u8,
                158u8, 163u8, 246u8, 15u8, 56u8, 41u8, 116u8, 162u8, 231u8, 142u8,
            ],
            [
                47u8, 135u8, 136u8, 17u8, 126u8, 126u8, 255u8, 29u8, 130u8, 233u8, 38u8,
                236u8, 121u8, 73u8, 1u8, 209u8, 124u8, 120u8, 2u8, 74u8, 80u8, 39u8, 9u8,
                64u8, 48u8, 69u8, 64u8, 167u8, 51u8, 101u8, 111u8, 13u8,
            ],
            [
                48u8, 47u8, 84u8, 53u8, 17u8, 144u8, 34u8, 114u8, 142u8, 174u8, 246u8,
                210u8, 52u8, 49u8, 158u8, 17u8, 217u8, 8u8, 181u8, 4u8, 249u8, 4u8, 66u8,
                235u8, 59u8, 230u8, 96u8, 111u8, 201u8, 84u8, 87u8, 87u8,
            ],
            [
                120u8, 114u8, 46u8, 217u8, 116u8, 43u8, 77u8, 205u8, 167u8, 5u8, 208u8,
                16u8, 255u8, 247u8, 70u8, 10u8, 53u8, 30u8, 144u8, 111u8, 130u8, 35u8,
                207u8, 242u8, 210u8, 58u8, 85u8, 180u8, 75u8, 102u8, 66u8, 124u8,
            ],
            [
                120u8, 223u8, 147u8, 129u8, 129u8, 175u8, 203u8, 40u8, 234u8, 167u8,
                208u8, 153u8, 35u8, 91u8, 191u8, 152u8, 119u8, 131u8, 45u8, 111u8, 170u8,
                254u8, 54u8, 209u8, 234u8, 112u8, 145u8, 111u8, 58u8, 206u8, 51u8, 224u8,
            ],
            [
                160u8, 254u8, 161u8, 42u8, 93u8, 253u8, 179u8, 235u8, 240u8, 183u8,
                196u8, 154u8, 125u8, 221u8, 95u8, 253u8, 211u8, 229u8, 178u8, 215u8,
                87u8, 79u8, 241u8, 107u8, 10u8, 16u8, 50u8, 237u8, 193u8, 157u8, 101u8,
                139u8,
            ],
            [
                189u8, 121u8, 184u8, 111u8, 254u8, 10u8, 184u8, 232u8, 119u8, 97u8, 81u8,
                81u8, 66u8, 23u8, 205u8, 124u8, 172u8, 213u8, 44u8, 144u8, 159u8, 102u8,
                71u8, 92u8, 58u8, 244u8, 78u8, 18u8, 159u8, 11u8, 0u8, 255u8,
            ],
            [
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ],
            [
                246u8, 57u8, 31u8, 92u8, 50u8, 217u8, 198u8, 157u8, 42u8, 71u8, 234u8,
                103u8, 11u8, 68u8, 41u8, 116u8, 181u8, 57u8, 53u8, 209u8, 237u8, 199u8,
                253u8, 100u8, 235u8, 33u8, 224u8, 71u8, 168u8, 57u8, 23u8, 27u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for GasArchiveEvents {
        const NAME: &'static str = "GasArchiveEvents";
        const COUNT: usize = 9usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<EpochCompleted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EpochCompleted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::EpochCompleted)
                }
                Some(
                    <EpochDataValidated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EpochDataValidated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::EpochDataValidated)
                }
                Some(
                    <EpochExpectedChainsUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EpochExpectedChainsUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::EpochExpectedChainsUpdated)
                }
                Some(
                    <GasAggregatorAddressUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <GasAggregatorAddressUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::GasAggregatorAddressUpdated)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::Initialized)
                }
                Some(
                    <LastKnownBlockHashesUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <LastKnownBlockHashesUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::LastKnownBlockHashesUpdated)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleRevoked)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for GasArchiveEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::EpochCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EpochDataValidated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EpochExpectedChainsUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::GasAggregatorAddressUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::LastKnownBlockHashesUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::EpochCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EpochDataValidated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EpochExpectedChainsUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::GasAggregatorAddressUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::LastKnownBlockHashesUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`GasArchive`](self) contract instance.

See the [wrapper's documentation](`GasArchiveInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> GasArchiveInstance<P, N> {
        GasArchiveInstance::<P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<GasArchiveInstance<P, N>>,
    > {
        GasArchiveInstance::<P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
        GasArchiveInstance::<P, N>::deploy_builder(provider)
    }
    /**A [`GasArchive`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`GasArchive`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct GasArchiveInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for GasArchiveInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("GasArchiveInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > GasArchiveInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`GasArchive`](self) contract instance.

See the [wrapper's documentation](`GasArchiveInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<GasArchiveInstance<P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> GasArchiveInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> GasArchiveInstance<P, N> {
            GasArchiveInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > GasArchiveInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`AGGREGATED_EPOCH_DATA_HASH_SLOT`] function.
        pub fn AGGREGATED_EPOCH_DATA_HASH_SLOT(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, AGGREGATED_EPOCH_DATA_HASH_SLOTCall, N> {
            self.call_builder(&AGGREGATED_EPOCH_DATA_HASH_SLOTCall)
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall)
        }
        ///Creates a new call builder for the [`HEADER_STATE_ROOT_INDEX`] function.
        pub fn HEADER_STATE_ROOT_INDEX(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, HEADER_STATE_ROOT_INDEXCall, N> {
            self.call_builder(&HEADER_STATE_ROOT_INDEXCall)
        }
        ///Creates a new call builder for the [`STORAGE_ROOT_ACCOUNT_FIELDS_INDEX`] function.
        pub fn STORAGE_ROOT_ACCOUNT_FIELDS_INDEX(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            STORAGE_ROOT_ACCOUNT_FIELDS_INDEXCall,
            N,
        > {
            self.call_builder(&STORAGE_ROOT_ACCOUNT_FIELDS_INDEXCall)
        }
        ///Creates a new call builder for the [`addSequencingChain`] function.
        pub fn addSequencingChain(
            &self,
            chainID: alloy::sol_types::private::primitives::aliases::U256,
            aggregatorAddress: alloy::sol_types::private::Address,
            bridgeAddress: alloy::sol_types::private::Address,
            storageSlotIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, addSequencingChainCall, N> {
            self.call_builder(
                &addSequencingChainCall {
                    chainID,
                    aggregatorAddress,
                    bridgeAddress,
                    storageSlotIndex,
                },
            )
        }
        ///Creates a new call builder for the [`blockHashSender`] function.
        pub fn blockHashSender(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, blockHashSenderCall, N> {
            self.call_builder(&blockHashSenderCall)
        }
        ///Creates a new call builder for the [`confirmEpochDataHash`] function.
        pub fn confirmEpochDataHash(
            &self,
            epoch: alloy::sol_types::private::primitives::aliases::U256,
            seqChainID: alloy::sol_types::private::primitives::aliases::U256,
            seqChainBlockHeader: alloy::sol_types::private::Bytes,
            seqChainAccountProof: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Bytes,
            >,
            seqChainStorageProof: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Bytes,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, confirmEpochDataHashCall, N> {
            self.call_builder(
                &confirmEpochDataHashCall {
                    epoch,
                    seqChainID,
                    seqChainBlockHeader,
                    seqChainAccountProof,
                    seqChainStorageProof,
                },
            )
        }
        ///Creates a new call builder for the [`confirmSequencingChainBlockHash`] function.
        pub fn confirmSequencingChainBlockHash(
            &self,
            seqChainID: alloy::sol_types::private::primitives::aliases::U256,
            sendRoot: alloy::sol_types::private::FixedBytes<32>,
            ethereumBlockHeader: alloy::sol_types::private::Bytes,
            ethereumAccountProof: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Bytes,
            >,
            ethereumStorageProof: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Bytes,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, confirmSequencingChainBlockHashCall, N> {
            self.call_builder(
                &confirmSequencingChainBlockHashCall {
                    seqChainID,
                    sendRoot,
                    ethereumBlockHeader,
                    ethereumAccountProof,
                    ethereumStorageProof,
                },
            )
        }
        ///Creates a new call builder for the [`epochAppchainEmissionsReceiver`] function.
        pub fn epochAppchainEmissionsReceiver(
            &self,
            epoch: alloy::sol_types::private::primitives::aliases::U256,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochAppchainEmissionsReceiverCall, N> {
            self.call_builder(
                &epochAppchainEmissionsReceiverCall {
                    epoch,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochAppchainIDs`] function.
        pub fn epochAppchainIDs(
            &self,
            epoch: alloy::sol_types::private::primitives::aliases::U256,
            _1: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochAppchainIDsCall, N> {
            self.call_builder(&epochAppchainIDsCall { epoch, _1 })
        }
        ///Creates a new call builder for the [`epochAppchainTokensUsed`] function.
        pub fn epochAppchainTokensUsed(
            &self,
            epoch: alloy::sol_types::private::primitives::aliases::U256,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochAppchainTokensUsedCall, N> {
            self.call_builder(
                &epochAppchainTokensUsedCall {
                    epoch,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochChainDataSubmitted`] function.
        pub fn epochChainDataSubmitted(
            &self,
            epoch: alloy::sol_types::private::primitives::aliases::U256,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochChainDataSubmittedCall, N> {
            self.call_builder(
                &epochChainDataSubmittedCall {
                    epoch,
                    chainId,
                },
            )
        }
        ///Creates a new call builder for the [`epochCompleted`] function.
        pub fn epochCompleted(
            &self,
            epoch: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochCompletedCall, N> {
            self.call_builder(&epochCompletedCall { epoch })
        }
        ///Creates a new call builder for the [`epochExpectedChains`] function.
        pub fn epochExpectedChains(
            &self,
            epoch: alloy::sol_types::private::primitives::aliases::U256,
            _1: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochExpectedChainsCall, N> {
            self.call_builder(
                &epochExpectedChainsCall {
                    epoch,
                    _1,
                },
            )
        }
        ///Creates a new call builder for the [`epochTotalTokensUsed`] function.
        pub fn epochTotalTokensUsed(
            &self,
            epoch: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochTotalTokensUsedCall, N> {
            self.call_builder(&epochTotalTokensUsedCall { epoch })
        }
        ///Creates a new call builder for the [`epochVerifiedDataHash`] function.
        pub fn epochVerifiedDataHash(
            &self,
            epoch: alloy::sol_types::private::primitives::aliases::U256,
            seqChainID: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, epochVerifiedDataHashCall, N> {
            self.call_builder(
                &epochVerifiedDataHashCall {
                    epoch,
                    seqChainID,
                },
            )
        }
        ///Creates a new call builder for the [`getActiveAppchainIds`] function.
        pub fn getActiveAppchainIds(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getActiveAppchainIdsCall, N> {
            self.call_builder(
                &getActiveAppchainIdsCall {
                    epochIndex,
                },
            )
        }
        ///Creates a new call builder for the [`getAppchainGasFees`] function.
        pub fn getAppchainGasFees(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getAppchainGasFeesCall, N> {
            self.call_builder(
                &getAppchainGasFeesCall {
                    epochIndex,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`getAppchainRewardsReceiver`] function.
        pub fn getAppchainRewardsReceiver(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getAppchainRewardsReceiverCall, N> {
            self.call_builder(
                &getAppchainRewardsReceiverCall {
                    epochIndex,
                    appchainId,
                },
            )
        }
        ///Creates a new call builder for the [`getEpochExpectedChains`] function.
        pub fn getEpochExpectedChains(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getEpochExpectedChainsCall, N> {
            self.call_builder(
                &getEpochExpectedChainsCall {
                    epochIndex,
                },
            )
        }
        ///Creates a new call builder for the [`getEpochProgress`] function.
        pub fn getEpochProgress(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getEpochProgressCall, N> {
            self.call_builder(&getEpochProgressCall { epochIndex })
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`getTotalGasFees`] function.
        pub fn getTotalGasFees(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getTotalGasFeesCall, N> {
            self.call_builder(&getTotalGasFeesCall { epochIndex })
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasChainSubmittedForEpoch`] function.
        pub fn hasChainSubmittedForEpoch(
            &self,
            epochIndex: alloy::sol_types::private::primitives::aliases::U256,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, hasChainSubmittedForEpochCall, N> {
            self.call_builder(
                &hasChainSubmittedForEpochCall {
                    epochIndex,
                    chainId,
                },
            )
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`initialize`] function.
        pub fn initialize(
            &self,
            _blockHashSender: alloy::sol_types::private::Address,
            _settlementChainID: alloy::sol_types::private::primitives::aliases::U256,
            admin: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, initializeCall, N> {
            self.call_builder(
                &initializeCall {
                    _blockHashSender,
                    _settlementChainID,
                    admin,
                },
            )
        }
        ///Creates a new call builder for the [`lastKnownEthereumBlockHash`] function.
        pub fn lastKnownEthereumBlockHash(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, lastKnownEthereumBlockHashCall, N> {
            self.call_builder(&lastKnownEthereumBlockHashCall)
        }
        ///Creates a new call builder for the [`lastKnownSeqChainBlockHashes`] function.
        pub fn lastKnownSeqChainBlockHashes(
            &self,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, lastKnownSeqChainBlockHashesCall, N> {
            self.call_builder(
                &lastKnownSeqChainBlockHashesCall {
                    chainId,
                },
            )
        }
        ///Creates a new call builder for the [`lastKnownSettlementChainBlockHash`] function.
        pub fn lastKnownSettlementChainBlockHash(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            lastKnownSettlementChainBlockHashCall,
            N,
        > {
            self.call_builder(&lastKnownSettlementChainBlockHashCall)
        }
        ///Creates a new call builder for the [`lastKnownSettlementChainBlockNumber`] function.
        pub fn lastKnownSettlementChainBlockNumber(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            lastKnownSettlementChainBlockNumberCall,
            N,
        > {
            self.call_builder(&lastKnownSettlementChainBlockNumberCall)
        }
        ///Creates a new call builder for the [`removeSeqChain`] function.
        pub fn removeSeqChain(
            &self,
            chainID: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, removeSeqChainCall, N> {
            self.call_builder(&removeSeqChainCall { chainID })
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            callerConfirmation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, renounceRoleCall, N> {
            self.call_builder(
                &renounceRoleCall {
                    role,
                    callerConfirmation,
                },
            )
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`seqChainEthOutbox`] function.
        pub fn seqChainEthOutbox(
            &self,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, seqChainEthOutboxCall, N> {
            self.call_builder(&seqChainEthOutboxCall { chainId })
        }
        ///Creates a new call builder for the [`seqChainEthSendRootStorageSlot`] function.
        pub fn seqChainEthSendRootStorageSlot(
            &self,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, seqChainEthSendRootStorageSlotCall, N> {
            self.call_builder(
                &seqChainEthSendRootStorageSlotCall {
                    chainId,
                },
            )
        }
        ///Creates a new call builder for the [`seqChainGasAggregatorAddresses`] function.
        pub fn seqChainGasAggregatorAddresses(
            &self,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, seqChainGasAggregatorAddressesCall, N> {
            self.call_builder(
                &seqChainGasAggregatorAddressesCall {
                    chainId,
                },
            )
        }
        ///Creates a new call builder for the [`seqChainIDs`] function.
        pub fn seqChainIDs(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, seqChainIDsCall, N> {
            self.call_builder(&seqChainIDsCall(_0))
        }
        ///Creates a new call builder for the [`setBlockHashSender`] function.
        pub fn setBlockHashSender(
            &self,
            newBlockHashSender: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, setBlockHashSenderCall, N> {
            self.call_builder(
                &setBlockHashSenderCall {
                    newBlockHashSender,
                },
            )
        }
        ///Creates a new call builder for the [`setEpochExpectedChains`] function.
        pub fn setEpochExpectedChains(
            &self,
            epoch: alloy::sol_types::private::primitives::aliases::U256,
            chainIds: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, setEpochExpectedChainsCall, N> {
            self.call_builder(
                &setEpochExpectedChainsCall {
                    epoch,
                    chainIds,
                },
            )
        }
        ///Creates a new call builder for the [`setLastKnownBlockHashes`] function.
        pub fn setLastKnownBlockHashes(
            &self,
            ethBlockHash: alloy::sol_types::private::FixedBytes<32>,
            settlementBlockHash: alloy::sol_types::private::FixedBytes<32>,
            settlementBlockNumber: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, setLastKnownBlockHashesCall, N> {
            self.call_builder(
                &setLastKnownBlockHashesCall {
                    ethBlockHash,
                    settlementBlockHash,
                    settlementBlockNumber,
                },
            )
        }
        ///Creates a new call builder for the [`settlementChainID`] function.
        pub fn settlementChainID(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, settlementChainIDCall, N> {
            self.call_builder(&settlementChainIDCall)
        }
        ///Creates a new call builder for the [`submitEpochPreImageData`] function.
        pub fn submitEpochPreImageData(
            &self,
            epoch: alloy::sol_types::private::primitives::aliases::U256,
            seqChainID: alloy::sol_types::private::primitives::aliases::U256,
            appchains: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            tokens: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            emissionsReceivers: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, submitEpochPreImageDataCall, N> {
            self.call_builder(
                &submitEpochPreImageDataCall {
                    epoch,
                    seqChainID,
                    appchains,
                    tokens,
                    emissionsReceivers,
                },
            )
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<&P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > GasArchiveInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`EpochCompleted`] event.
        pub fn EpochCompleted_filter(
            &self,
        ) -> alloy_contract::Event<&P, EpochCompleted, N> {
            self.event_filter::<EpochCompleted>()
        }
        ///Creates a new event filter for the [`EpochDataValidated`] event.
        pub fn EpochDataValidated_filter(
            &self,
        ) -> alloy_contract::Event<&P, EpochDataValidated, N> {
            self.event_filter::<EpochDataValidated>()
        }
        ///Creates a new event filter for the [`EpochExpectedChainsUpdated`] event.
        pub fn EpochExpectedChainsUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, EpochExpectedChainsUpdated, N> {
            self.event_filter::<EpochExpectedChainsUpdated>()
        }
        ///Creates a new event filter for the [`GasAggregatorAddressUpdated`] event.
        pub fn GasAggregatorAddressUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, GasAggregatorAddressUpdated, N> {
            self.event_filter::<GasAggregatorAddressUpdated>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(&self) -> alloy_contract::Event<&P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`LastKnownBlockHashesUpdated`] event.
        pub fn LastKnownBlockHashesUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, LastKnownBlockHashesUpdated, N> {
            self.event_filter::<LastKnownBlockHashesUpdated>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<&P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(&self) -> alloy_contract::Event<&P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(&self) -> alloy_contract::Event<&P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
    }
}
