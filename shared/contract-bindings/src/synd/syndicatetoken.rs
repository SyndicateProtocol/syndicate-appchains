/**

Generated by the following Solidity interface...
```solidity
interface SyndicateToken {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error ECDSAInvalidSignature();
    error ECDSAInvalidSignatureLength(uint256 length);
    error ECDSAInvalidSignatureS(bytes32 s);
    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
    error ERC20InvalidApprover(address approver);
    error ERC20InvalidReceiver(address receiver);
    error ERC20InvalidSender(address sender);
    error ERC20InvalidSpender(address spender);
    error ERC2612ExpiredSignature(uint256 deadline);
    error ERC2612InvalidSigner(address signer, address owner);
    error InvalidAccountNonce(address account, uint256 currentNonce);
    error InvalidShortString();
    error StringTooLong(string str);

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event BridgeConfigurationUpdated(address indexed bridgeAddress, address indexed l2TokenAddress, address indexed l2DestinationAddress, uint32 gasLimit);
    event EIP712DomainChanged();
    event EmissionMinted(uint256 epoch, uint256 amount, address indexed l2DestinationAddress);
    event EmissionsStarted(uint256 startTime);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(address defaultAdmin, address syndFoundationAddress, address emissionsManager);

    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function EMISSIONS_MANAGER_ROLE() external view returns (bytes32);
    function EMISSIONS_SUPPLY() external view returns (uint256);
    function EMISSION_AMOUNT_1() external view returns (uint256);
    function EMISSION_AMOUNT_2() external view returns (uint256);
    function EMISSION_AMOUNT_3() external view returns (uint256);
    function EMISSION_AMOUNT_4() external view returns (uint256);
    function EMISSION_AMOUNT_5() external view returns (uint256);
    function EMISSION_AMOUNT_6() external view returns (uint256);
    function EMISSION_AMOUNT_7() external view returns (uint256);
    function EMISSION_AMOUNT_8() external view returns (uint256);
    function EPOCH_DURATION() external view returns (uint256);
    function INITIAL_MINT_SUPPLY() external view returns (uint256);
    function TOTAL_EPOCHS() external view returns (uint256);
    function TOTAL_SUPPLY() external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function bridgeAddress() external view returns (address);
    function bridgeExtraData() external view returns (bytes memory);
    function bridgeGasLimit() external view returns (uint32);
    function currentEpoch() external view returns (uint256);
    function decimals() external view returns (uint8);
    function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
    function emissionSchedule(uint256) external view returns (uint256);
    function emissionsStartTime() external view returns (uint256);
    function emissionsStarted() external view returns (bool);
    function getBridgeConfiguration() external view returns (address bridgeAddr, address l2TokenAddr, address l2DestAddr, uint32 gasLimit, bytes memory extraData);
    function getCurrentEpochInfo() external view returns (uint256 epoch, uint256 nextEmissionTime, uint256 nextEmissionAmount, bool canMintEmission);
    function getEmissionSchedule() external view returns (uint256[48] memory);
    function getRemainingEmissions() external view returns (uint256);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function isEmissionComplete() external view returns (bool);
    function l2DestinationAddress() external view returns (address);
    function l2TokenAddress() external view returns (address);
    function mintEmission() external;
    function name() external view returns (string memory);
    function nonces(address owner) external view returns (uint256);
    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
    function renounceRole(bytes32 role, address callerConfirmation) external;
    function revokeRole(bytes32 role, address account) external;
    function setBridgeConfiguration(address _bridgeAddress, address _l2TokenAddress, address _l2DestinationAddress, uint32 _gasLimit, bytes memory _extraData) external;
    function startEmissions() external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function symbol() external view returns (string memory);
    function totalEmissionsMinted() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "defaultAdmin",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "syndFoundationAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "emissionsManager",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DOMAIN_SEPARATOR",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSIONS_MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSIONS_SUPPLY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSION_AMOUNT_1",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSION_AMOUNT_2",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSION_AMOUNT_3",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSION_AMOUNT_4",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSION_AMOUNT_5",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSION_AMOUNT_6",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSION_AMOUNT_7",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSION_AMOUNT_8",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EPOCH_DURATION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "INITIAL_MINT_SUPPLY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TOTAL_EPOCHS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TOTAL_SUPPLY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "allowance",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "approve",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "balanceOf",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeAddress",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeExtraData",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeGasLimit",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "currentEpoch",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "decimals",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "eip712Domain",
    "inputs": [],
    "outputs": [
      {
        "name": "fields",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "version",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "verifyingContract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "extensions",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionSchedule",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsStartTime",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsStarted",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBridgeConfiguration",
    "inputs": [],
    "outputs": [
      {
        "name": "bridgeAddr",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "l2TokenAddr",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "l2DestAddr",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "gasLimit",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "extraData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCurrentEpochInfo",
    "inputs": [],
    "outputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nextEmissionTime",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nextEmissionAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "canMintEmission",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getEmissionSchedule",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256[48]",
        "internalType": "uint256[48]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRemainingEmissions",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isEmissionComplete",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "l2DestinationAddress",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "l2TokenAddress",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "mintEmission",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "name",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nonces",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "permit",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "deadline",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "v",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "callerConfirmation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeConfiguration",
    "inputs": [
      {
        "name": "_bridgeAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_l2TokenAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_l2DestinationAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_gasLimit",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "_extraData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "startEmissions",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "symbol",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "totalEmissionsMinted",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "totalSupply",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transfer",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferFrom",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Approval",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeConfigurationUpdated",
    "inputs": [
      {
        "name": "bridgeAddress",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "l2TokenAddress",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "l2DestinationAddress",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "gasLimit",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EIP712DomainChanged",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionMinted",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "l2DestinationAddress",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionsStarted",
    "inputs": [
      {
        "name": "startTime",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Transfer",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccessControlBadConfirmation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AccessControlUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "neededRole",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureLength",
    "inputs": [
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureS",
    "inputs": [
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InsufficientAllowance",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "allowance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InsufficientBalance",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidApprover",
    "inputs": [
      {
        "name": "approver",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidReceiver",
    "inputs": [
      {
        "name": "receiver",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidSender",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidSpender",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC2612ExpiredSignature",
    "inputs": [
      {
        "name": "deadline",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC2612InvalidSigner",
    "inputs": [
      {
        "name": "signer",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidAccountNonce",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "currentNonce",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidShortString",
    "inputs": []
  },
  {
    "type": "error",
    "name": "StringTooLong",
    "inputs": [
      {
        "name": "str",
        "type": "string",
        "internalType": "string"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod SyndicateToken {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x610160604052346100735761001b610015610154565b91610501565b610023610078565b61485161171a823960805181613ced015260a05181613d24015260c05181613cb4015260e05181614280015261010051816142a501526101205181613e2601526101405181613e66015261485190f35b61007e565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906100aa90610082565b810190811060018060401b038211176100c257604052565b61008c565b906100da6100d3610078565b92836100a0565b565b5f80fd5b60018060a01b031690565b6100f4906100e0565b90565b610100816100eb565b0361010757565b5f80fd5b90505190610118826100f7565b565b909160608284031261014f5761014c610135845f850161010b565b93610143816020860161010b565b9360400161010b565b90565b6100dc565b610172615f6b80380380610167816100c7565b92833981019061011a565b909192565b60018060401b0381116101935761018f602091610082565b0190565b61008c565b906101aa6101a583610177565b6100c7565b918252565b5f7f53796e6469636174650000000000000000000000000000000000000000000000910152565b6101e06009610198565b906101ed602083016101af565b565b6101f76101d6565b90565b5f7f53594e4400000000000000000000000000000000000000000000000000000000910152565b61022b6004610198565b90610238602083016101fa565b565b610242610221565b90565b90565b90565b61025f61025a61026492610245565b610248565b6100e0565b90565b6102709061024b565b90565b60209181520190565b60207f7265737300000000000000000000000000000000000000000000000000000000917f44656661756c742061646d696e2063616e6e6f74206265207a65726f206164645f8201520152565b6102d66024604092610273565b6102df8161027c565b0190565b6102f89060208101905f8183039101526102c9565b90565b1561030257565b61030a610078565b62461bcd60e51b815280610320600482016102e3565b0390fd5b60207f6f20616464726573730000000000000000000000000000000000000000000000917f466f756e646174696f6e20616464726573732063616e6e6f74206265207a65725f8201520152565b61037e6029604092610273565b61038781610324565b0190565b6103a09060208101905f818303910152610371565b90565b156103aa57565b6103b2610078565b62461bcd60e51b8152806103c86004820161038b565b0390fd5b60207f2061646472657373000000000000000000000000000000000000000000000000917f456d697373696f6e73206d616e616765722063616e6e6f74206265207a65726f5f8201520152565b6104266028604092610273565b61042f816103cc565b0190565b6104489060208101905f818303910152610419565b90565b1561045257565b61045a610078565b62461bcd60e51b81528061047060048201610433565b0390fd5b90565b5f1b90565b61049061048b61049592610245565b610477565b610474565b90565b6104a15f61047c565b90565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b90565b90565b6104e26104dd6104e7926104c8565b610248565b6104cb565b90565b6104fe6a4a723dc6b40b8a9a0000006104ce565b90565b6105c6926105a96105b79261052d6105176101ef565b61051f6101ef565b61052761023a565b9161061b565b6105528161054b6105456105405f610267565b6100eb565b916100eb565b14156102fb565b6105778561057061056a6105655f610267565b6100eb565b916100eb565b14156103a3565b61059c8361059561058f61058a5f610267565b6100eb565b916100eb565b141561044b565b6105a4610498565b610a3c565b506105b26104a4565b610a3c565b506105c06104ea565b90610b0a565b6105ce610e78565b565b5f7f3100000000000000000000000000000000000000000000000000000000000000910152565b6106016001610198565b9061060e602083016105d0565b565b6106186105f7565b90565b9061062f9291610629610610565b90610631565b565b9061063d939291610683565b565b90565b90565b60200190565b5190565b61066361065e610668926100e0565b610248565b6100e0565b90565b6106749061064f565b90565b6106809061066b565b90565b6106946106e4946106c99394610718565b6106a8816106a2600661063f565b90611150565b610120526106c0836106ba600761063f565b90611150565b61014052610642565b6106db6106d58261064b565b91610645565b2060e052610642565b6106f66106f08261064b565b91610645565b20610100524660a052610707611255565b60805261071330610677565b60c052565b9061072291610724565b565b9061072e91610730565b565b9061073a9161098d565b565b5190565b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610774575b602083101461076f57565b610740565b91607f1691610764565b5f5260205f2090565b601f602091010490565b1b90565b919060086107b09102916107aa5f1984610791565b92610791565b9181191691161790565b6107ce6107c96107d3926104cb565b610248565b6104cb565b90565b90565b91906107ef6107ea6107f7936107ba565b6107d6565b908354610795565b9055565b5f90565b6108119161080b6107fb565b916107d9565b565b5b81811061081f575050565b8061082c5f6001936107ff565b01610814565b9190601f8111610842575b505050565b61084e6108739361077e565b90602061085a84610787565b8301931061087b575b61086c90610787565b0190610813565b5f808061083d565b915061086c81929050610863565b1c90565b9061089d905f1990600802610889565b191690565b816108ac9161088d565b906002021790565b906108be8161073c565b9060018060401b03821161097c576108e0826108da8554610754565b85610832565b602090601f831160011461091457918091610903935f92610908575b50506108a2565b90555b565b90915001515f806108fc565b601f198316916109238561077e565b925f5b8181106109645750916002939185600196941061094a575b50505002019055610906565b61095a910151601f84169061088d565b90555f808061093e565b91936020600181928787015181550195019201610926565b61008c565b9061098b916108b4565b565b9061099c6109a3926003610981565b6004610981565b565b5f90565b151590565b6109b790610474565b90565b906109c4906109ae565b5f5260205260405f2090565b6109d99061066b565b90565b906109e6906109d0565b5f5260205260405f2090565b906109fe60ff91610477565b9181191691161790565b610a11906109a9565b90565b90565b90610a2c610a27610a3392610a08565b610a14565b82546109f2565b9055565b5f0190565b610a446109a5565b50610a59610a538284906112f2565b156109a9565b5f14610ae257610a816001610a7c5f610a74600586906109ba565b0185906109dc565b610a17565b90610a8a611320565b90610ac7610ac1610abb7f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d956109ae565b926109d0565b926109d0565b92610ad0610078565b80610ada81610a37565b0390a4600190565b50505f90565b610af1906100eb565b9052565b9190610b08905f60208501940190610ae8565b565b80610b25610b1f610b1a5f610267565b6100eb565b916100eb565b14610b4157610b3f91610b375f610267565b919091611439565b565b610b64610b4d5f610267565b5f91829163ec442f0560e01b835260048301610af5565b0390fd5b610b7c610b77610b8192610245565b610248565b6104cb565b90565b6001610b9091016104cb565b90565b90565b610baa610ba5610baf92610b93565b610248565b6104cb565b90565b90565b610bc9610bc4610bce92610bb2565b610248565b6104cb565b90565b610be4698f956f697aa4923c0000610bb5565b90565b634e487b7160e01b5f52603260045260245ffd5b50603090565b90565b610c0d81610bfb565b821015610c2757610c1f600191610c01565b910201905f90565b610be7565b90565b610c43610c3e610c4892610c2c565b610248565b6104cb565b90565b90565b610c62610c5d610c6792610c4b565b610248565b6104cb565b90565b610c7d695626760c1662be240000610c4e565b90565b90565b610c97610c92610c9c92610c80565b610248565b6104cb565b90565b90565b610cb6610cb1610cbb92610c9f565b610248565b6104cb565b90565b610cd16933b0b000fec593900000610ca2565b90565b90565b610ceb610ce6610cf092610cd4565b610248565b6104cb565b90565b90565b610d0a610d05610d0f92610cf3565b610248565b6104cb565b90565b610d25691f039ccd65a9bef00000610cf6565b90565b90565b610d3f610d3a610d4492610d28565b610248565b6104cb565b90565b90565b610d5e610d59610d6392610d47565b610248565b6104cb565b90565b610d7969129bc47b3cff72900000610d4a565b90565b90565b610d93610d8e610d9892610d7c565b610248565b6104cb565b90565b90565b610db2610dad610db792610d9b565b610248565b6104cb565b90565b610dcd690b2a483d6dadee180000610d9e565b90565b90565b610de7610de2610dec92610dd0565b610248565b6104cb565b90565b90565b610e06610e01610e0b92610def565b610248565b6104cb565b90565b610e216906b2efd13a962a6c0000610df2565b90565b90565b610e3b610e36610e4092610e24565b610248565b6104cb565b90565b90565b610e5a610e55610e5f92610e43565b610248565b6104cb565b90565b610e75690404f64a565a19740000610e46565b90565b610e815f610b68565b5b80610e96610e906006610b96565b916104cb565b1015610ec757610ec290610ebd610eab610bd1565b610eb760118490610c04565b906107d9565b610b84565b610e82565b50610ed26006610b96565b5b80610ee7610ee1600c610c2f565b916104cb565b1015610f1857610f1390610f0e610efc610c6a565b610f0860118490610c04565b906107d9565b610b84565b610ed3565b50610f23600c610c2f565b5b80610f38610f326012610c83565b916104cb565b1015610f6957610f6490610f5f610f4d610cbe565b610f5960118490610c04565b906107d9565b610b84565b610f24565b50610f746012610c83565b5b80610f89610f836018610cd7565b916104cb565b1015610fba57610fb590610fb0610f9e610d12565b610faa60118490610c04565b906107d9565b610b84565b610f75565b50610fc56018610cd7565b5b80610fda610fd4601e610d2b565b916104cb565b101561100b5761100690611001610fef610d66565b610ffb60118490610c04565b906107d9565b610b84565b610fc6565b50611016601e610d2b565b5b8061102b6110256024610d7f565b916104cb565b101561105c5761105790611052611040610dba565b61104c60118490610c04565b906107d9565b610b84565b611017565b506110676024610d7f565b5b8061107c611076602a610dd3565b916104cb565b10156110ad576110a8906110a3611091610e0e565b61109d60118490610c04565b906107d9565b610b84565b611068565b506110b8602a610dd3565b5b806110cd6110c76030610e27565b916104cb565b10156110fe576110f9906110f46110e2610e62565b6110ee60118490610c04565b906107d9565b610b84565b6110b9565b50565b5f90565b90565b61111c61111761112192611105565b610248565b6104cb565b90565b90565b61113b61113661114092611124565b610477565b610474565b90565b61114d60ff611127565b90565b90611159611101565b5061116b61116683610642565b61064b565b61117e6111786020611108565b916104cb565b105f14611192575061118f9061168f565b90565b5f6111a06111a693926115a8565b01610981565b6111b66111b1611143565b6109ae565b90565b5f90565b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b6111eb9051610474565b90565b6111f790610474565b9052565b611204906104cb565b9052565b909594926112539461124261124c9261123860809661122e60a088019c5f8901906111ee565b60208701906111ee565b60408501906111ee565b60608301906111fb565b0190610ae8565b565b61125d6111b9565b506112666111bd565b6112b061127360e06111e1565b916112a16112826101006111e1565b4661128c30610677565b91611295610078565b96879560208701611208565b602082018103825203826100a0565b6112c26112bc8261064b565b91610645565b2090565b5f1c90565b60ff1690565b6112dd6112e2916112c6565b6112cb565b90565b6112ef90546112d1565b90565b611319915f61130e611314936113066109a5565b5060056109ba565b016109dc565b6112e5565b90565b5f90565b61132861131c565b503390565b90611337906109d0565b5f5260205260405f2090565b90565b611352611357916112c6565b611343565b90565b6113649054611346565b90565b604090611390611397949695939661138660608401985f850190610ae8565b60208301906111fb565b01906111fb565b565b906113a491036104cb565b90565b906113b35f1991610477565b9181191691161790565b906113d26113cd6113d9926107ba565b6107d6565b82546113a7565b9055565b634e487b7160e01b5f52601160045260245ffd5b611400611406919392936104cb565b926104cb565b820180921161141157565b6113dd565b9061142191016104cb565b90565b9190611437905f602085019401906111fb565b565b9190918061145761145161144c5f610267565b6100eb565b916100eb565b145f146115385761147b6114748361146f600261135a565b6113f1565b60026113bd565b5b8261149761149161148c5f610267565b6100eb565b916100eb565b145f1461150c576114bb6114b4836114af600261135a565b611399565b60026113bd565b5b9190916115076114f56114ef7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef936109d0565b936109d0565b936114fe610078565b91829182611424565b0390a3565b6115338261152d61151e5f879061132d565b916115288361135a565b611416565b906113bd565b6114bc565b61154b6115465f839061132d565b61135a565b8061155e611558856104cb565b916104cb565b1061158657611571611581918490611399565b61157c5f849061132d565b6113bd565b61147c565b906115a49091925f93849363391434e360e21b855260048501611367565b0390fd5b90565b90565b6115c26115bd6115c7926115ab565b610248565b6104cb565b90565b90825f9392825e0152565b6115f46115fd602093611602936115eb8161073c565b93848093610273565b958691016115ca565b610082565b0190565b61161b9160208201915f8184039101526115d5565b90565b61163861163361162d8361064b565b92610645565b6111e1565b9060208110611646575b5090565b611658905f1990602003600802610791565b165f611642565b61166b611670916112c6565b6107ba565b90565b61168761168261168c926104cb565b610477565b610474565b90565b611697611101565b506116a181610642565b906116ab8261064b565b6116be6116b8601f6115ae565b916104cb565b116116f357506116eb816116e56116df6116da6116f09561161e565b61165f565b9161064b565b17611673565b6109ae565b90565b611715906116ff610078565b91829163305a27a960e01b835260048301611606565b0390fdfe60806040526004361015610013575b611c3e565b61001d5f3561035c565b806301ffc9a71461035757806306fdde031461035257806307a1d5fa1461034d578063095ea7b31461034857806318160ddd146103435780631b02f8451461033e57806323b872dd1461033957806323e1134c14610334578063248a9ca31461032f578063284e13331461032a5780632f2ff15d14610325578063313ce56714610320578063334d0bbd1461031b5780633644e5151461031657806336568abe1461031157806348b0daa61461030c5780634bdd36ce1461030757806353b64acb146103025780635adf0021146102fd5780635f15c3c9146102f85780636ca0319b146102f35780636cf01625146102ee5780636f3f51d9146102e957806370a08231146102e457806376671808146102df5780637b3a1286146102da5780637ecebe00146102d557806384b0196e146102d0578063902d55a5146102cb57806391d14854146102c657806395d89b41146102c15780639b7ef64b146102bc578063a026599a146102b7578063a1fab765146102b2578063a217fddf146102ad578063a32adef8146102a8578063a3c573eb146102a3578063a70b9f0c1461029e578063a9059cbb14610299578063af2aa63b14610294578063b518a6871461028f578063babc394f1461028a578063bd02dc2514610285578063c12303b314610280578063c5500cc31461027b578063d505accf14610276578063d547741f14610271578063dd62ed3e1461026c578063dd8c3e5d14610267578063e3abdfcb14610262578063e77f9cec1461025d5763f508e19d0361000e57611c09565b611bc5565b611b81565b611b1d565b611ae7565b611a86565b611a4c565b611984565b6118fb565b611886565b61183e565b6117cb565b611756565b6116ab565b611676565b611608565b61157e565b611509565b611499565b611424565b6113af565b611339565b611303565b6112ce565b611251565b61110a565b6110d5565b610f06565b610ec2565b610e6f565b610dfa565b610d84565b610d0f565b610ca3565b610c2e565b610b1b565b610ae6565b610aa3565b610a6e565b610a39565b610948565b6108ec565b61088c565b610857565b6107bc565b610743565b6106d6565b61069c565b610644565b610595565b610497565b6103e8565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61038981610374565b0361039057565b5f80fd5b905035906103a182610380565b565b906020828203126103bc576103b9915f01610394565b90565b61036c565b151590565b6103cf906103c1565b9052565b91906103e6905f602085019401906103c6565b565b34610418576104146104036103fe3660046103a3565b611c46565b61040b610362565b918291826103d3565b0390f35b610368565b5f91031261042757565b61036c565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b61046d61047660209361047b936104648161042c565b93848093610430565b95869101610439565b610444565b0190565b6104949160208201915f81840391015261044e565b90565b346104c7576104a736600461041d565b6104c36104b2611d64565b6104ba610362565b9182918261047f565b0390f35b610368565b60018060a01b031690565b6104e0906104cc565b90565b6104ec906104d7565b9052565b63ffffffff1690565b610502906104f0565b9052565b5190565b60209181520190565b61053261053b6020936105409361052981610506565b9384809361050a565b95869101610439565b610444565b0190565b919361057b6105929694610571610585949761056760a08801995f8901906104e3565b60208701906104e3565b60408501906104e3565b60608301906104f9565b6080818403910152610513565b90565b346105c9576105a536600461041d565b6105c56105b0611de0565b916105bc959395610362565b95869586610544565b0390f35b610368565b6105d7816104d7565b036105de57565b5f80fd5b905035906105ef826105ce565b565b90565b6105fd816105f1565b0361060457565b5f80fd5b90503590610615826105f4565b565b919060408382031261063f578061063361063c925f86016105e2565b93602001610608565b90565b61036c565b346106755761067161066061065a366004610617565b90611e4a565b610668610362565b918291826103d3565b0390f35b610368565b610683906105f1565b9052565b919061069a905f6020850194019061067a565b565b346106cc576106ac36600461041d565b6106c86106b7611e91565b6106bf610362565b91829182610687565b0390f35b610368565b5f0190565b34610704576106e636600461041d565b6106ee612367565b6106f6610362565b80610700816106d1565b0390f35b610368565b909160608284031261073e5761073b610724845f85016105e2565b9361073281602086016105e2565b93604001610608565b90565b61036c565b346107745761077061075f610759366004610709565b91612371565b610767610362565b918291826103d3565b0390f35b610368565b90565b90565b61079361078e61079892610779565b61077c565b6105f1565b90565b6107ae690404f64a565a1974000061077f565b90565b6107b961079b565b90565b346107ec576107cc36600461041d565b6107e86107d76107b1565b6107df610362565b91829182610687565b0390f35b610368565b90565b6107fd816107f1565b0361080457565b5f80fd5b90503590610815826107f4565b565b906020828203126108305761082d915f01610808565b90565b61036c565b61083e906107f1565b9052565b9190610855905f60208501940190610835565b565b346108875761088361087261086d366004610817565b6123ea565b61087a610362565b91829182610842565b0390f35b610368565b346108ba5761089c36600461041d565b6108a461288e565b6108ac610362565b806108b6816106d1565b0390f35b610368565b91906040838203126108e757806108db6108e4925f8601610808565b936020016105e2565b90565b61036c565b3461091b576109056108ff3660046108bf565b90612bef565b61090d610362565b80610917816106d1565b0390f35b610368565b60ff1690565b61092f90610920565b9052565b9190610946905f60208501940190610926565b565b346109785761095836600461041d565b610974610963612c1e565b61096b610362565b91829182610933565b0390f35b610368565b9060208282031261099657610993915f01610608565b90565b61036c565b634e487b7160e01b5f52603260045260245ffd5b50603090565b90565b6109c1816109af565b8210156109db576109d36001916109b5565b910201905f90565b61099b565b1c90565b90565b6109f79060086109fc93026109e0565b6109e4565b90565b90610a0a91546109e7565b90565b6011610a18816109af565b821015610a3557610a3291610a2c916109b8565b906109ff565b90565b5f80fd5b34610a6957610a65610a54610a4f36600461097d565b610a0d565b610a5c610362565b91829182610687565b0390f35b610368565b34610a9e57610a7e36600461041d565b610a9a610a89612c34565b610a91610362565b91829182610842565b0390f35b610368565b34610ad257610abc610ab63660046108bf565b90612c48565b610ac4610362565b80610ace816106d1565b0390f35b610368565b610ae3600a5f906109ff565b90565b34610b1657610af636600461041d565b610b12610b01610ad7565b610b09610362565b91829182610687565b0390f35b610368565b34610b4b57610b2b36600461041d565b610b47610b36612c90565b610b3e610362565b91829182610687565b0390f35b610368565b610b59816104f0565b03610b6057565b5f80fd5b90503590610b7182610b50565b565b5f80fd5b5f80fd5b5f80fd5b909182601f83011215610bb95781359167ffffffffffffffff8311610bb4576020019260018302840111610baf57565b610b7b565b610b77565b610b73565b91909160a081840312610c2957610bd7835f83016105e2565b92610be581602084016105e2565b92610bf382604085016105e2565b92610c018360608301610b64565b92608082013567ffffffffffffffff8111610c2457610c209201610b7f565b9091565b610370565b61036c565b34610c6357610c4d610c41366004610bbe565b949390939291926132d1565b610c55610362565b80610c5f816106d1565b0390f35b610368565b60ff1690565b610c7e906008610c8393026109e0565b610c68565b90565b90610c919154610c6e565b90565b610ca060095f90610c86565b90565b34610cd357610cb336600461041d565b610ccf610cbe610c94565b610cc6610362565b918291826103d3565b0390f35b610368565b90565b610cef610cea610cf492610cd8565b61077c565b6105f1565b90565b610d016030610cdb565b90565b610d0c610cf7565b90565b34610d3f57610d1f36600461041d565b610d3b610d2a610d04565b610d32610362565b91829182610687565b0390f35b610368565b90565b610d5b610d56610d6092610d44565b61077c565b6105f1565b90565b610d76691f039ccd65a9bef00000610d47565b90565b610d81610d63565b90565b34610db457610d9436600461041d565b610db0610d9f610d79565b610da7610362565b91829182610687565b0390f35b610368565b90565b610dd0610dcb610dd592610db9565b61077c565b6105f1565b90565b610dec6a084595161401484a000000610dbc565b90565b610df7610dd8565b90565b34610e2a57610e0a36600461041d565b610e26610e15610def565b610e1d610362565b91829182610687565b0390f35b610368565b90565b610e46610e41610e4b92610e2f565b61077c565b6105f1565b90565b610e6169129bc47b3cff72900000610e32565b90565b610e6c610e4e565b90565b34610e9f57610e7f36600461041d565b610e9b610e8a610e64565b610e92610362565b91829182610687565b0390f35b610368565b90602082820312610ebd57610eba915f016105e2565b90565b61036c565b34610ef257610eee610edd610ed8366004610ea4565b6132f7565b610ee5610362565b91829182610687565b0390f35b610368565b610f03600b5f906109ff565b90565b34610f3657610f1636600461041d565b610f32610f21610ef7565b610f29610362565b91829182610687565b0390f35b610368565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610f82575b6020831014610f7d57565b610f4e565b91607f1691610f72565b60209181520190565b5f5260205f2090565b905f9291805490610fb8610fb183610f62565b8094610f8c565b916001811690815f1461100f5750600114610fd3575b505050565b610fe09192939450610f95565b915f925b818410610ff757505001905f8080610fce565b60018160209295939554848601520191019290610fe4565b92949550505060ff19168252151560200201905f8080610fce565b9061103491610f9e565b90565b634e487b7160e01b5f52604160045260245ffd5b9061105590610444565b810190811067ffffffffffffffff82111761106f57604052565b611037565b9061109461108d92611084610362565b9384809261102a565b038361104b565b565b905f106110a9576110a690611074565b90565b610f3b565b6110ba60105f90611096565b90565b6110d29160208201915f818403910152610513565b90565b34611105576110e536600461041d565b6111016110f06110ae565b6110f8610362565b918291826110bd565b0390f35b610368565b3461113a57611136611125611120366004610ea4565b613315565b61112d610362565b91829182610687565b0390f35b610368565b60ff60f81b1690565b6111519061113f565b9052565b5190565b60209181520190565b60200190565b611171906105f1565b9052565b9061118281602093611168565b0190565b60200190565b906111a96111a361119c84611155565b8093611159565b92611162565b905f5b8181106111b95750505090565b9091926111d26111cc6001928651611175565b94611186565b91019190916111ac565b9395919461122d611222611241956112146112379561124e9c9a61120760e08c01925f8d0190611148565b8a820360208c015261044e565b9088820360408a015261044e565b97606087019061067a565b60808501906104e3565b60a0830190610835565b60c081840391015261118c565b90565b346112885761126136600461041d565b61128461126c6133bc565b9361127b979597939193610362565b978897886111dc565b0390f35b610368565b90565b6112a461129f6112a99261128d565b61077c565b6105f1565b90565b6112c06a52b7d2dcc80cd2e4000000611290565b90565b6112cb6112ac565b90565b346112fe576112de36600461041d565b6112fa6112e96112c3565b6112f1610362565b91829182610687565b0390f35b610368565b346113345761133061131f6113193660046108bf565b9061345c565b611327610362565b918291826103d3565b0390f35b610368565b346113695761134936600461041d565b611365611354613486565b61135c610362565b9182918261047f565b0390f35b610368565b90565b61138561138061138a9261136e565b61077c565b6105f1565b90565b6113a16a4a723dc6b40b8a9a000000611371565b90565b6113ac61138d565b90565b346113df576113bf36600461041d565b6113db6113ca6113a4565b6113d2610362565b91829182610687565b0390f35b610368565b90565b6113fb6113f6611400926113e4565b61077c565b6105f1565b90565b611416695626760c1662be2400006113e7565b90565b611421611403565b90565b346114545761143436600461041d565b61145061143f611419565b611447610362565b91829182610687565b0390f35b610368565b90565b61147061146b61147592611459565b61077c565b6105f1565b90565b61148b690b2a483d6dadee18000061145c565b90565b611496611478565b90565b346114c9576114a936600461041d565b6114c56114b461148e565b6114bc610362565b91829182610687565b0390f35b610368565b90565b5f1b90565b6114ea6114e56114ef926114ce565b6114d1565b6107f1565b90565b6114fb5f6114d6565b90565b6115066114f2565b90565b346115395761151936600461041d565b6115356115246114fe565b61152c610362565b91829182610842565b0390f35b610368565b90565b61155561155061155a9261153e565b61077c565b6105f1565b90565b6115706933b0b000fec593900000611541565b90565b61157b61155d565b90565b346115ae5761158e36600461041d565b6115aa611599611573565b6115a1610362565b91829182610687565b0390f35b610368565b60018060a01b031690565b6115ce9060086115d393026109e0565b6115b3565b90565b906115e191546115be565b90565b6115f0600d5f906115d6565b90565b9190611606905f602085019401906104e3565b565b346116385761161836600461041d565b6116346116236115e4565b61162b610362565b918291826115f3565b0390f35b610368565b90565b61165461164f6116599261163d565b61077c565b6105f1565b90565b61166862278d00611640565b90565b61167361165c565b90565b346116a65761168636600461041d565b6116a261169161166b565b611699610362565b91829182610687565b0390f35b610368565b346116dc576116d86116c76116c1366004610617565b9061349c565b6116cf610362565b918291826103d3565b0390f35b610368565b50603090565b905090565b90565b60200190565b61171161170b611704836116e1565b80946116e7565b916116ec565b5f915b8383106117215750505050565b6117376117316001928451611175565b926116ef565b92019190611714565b9190611754905f61060085019401906116f5565b565b346117865761176636600461041d565b6117826117716135c3565b611779610362565b91829182611740565b0390f35b610368565b90565b6117a261179d6117a79261178b565b61077c565b6105f1565b90565b6117bd6906b2efd13a962a6c000061178e565b90565b6117c86117aa565b90565b346117fb576117db36600461041d565b6117f76117e66117c0565b6117ee610362565b91829182610687565b0390f35b610368565b61183561183c9461182b606094989795611821608086019a5f87019061067a565b602085019061067a565b604083019061067a565b01906103c6565b565b346118725761184e36600461041d565b61186e61185961360e565b90611865949294610362565b94859485611800565b0390f35b610368565b611883600f5f906115d6565b90565b346118b65761189636600461041d565b6118b26118a1611877565b6118a9610362565b918291826115f3565b0390f35b610368565b90565b6118d26118cd6118d7926118bb565b61077c565b6105f1565b90565b6118ed698f956f697aa4923c00006118be565b90565b6118f86118da565b90565b3461192b5761190b36600461041d565b6119276119166118f0565b61191e610362565b91829182610687565b0390f35b610368565b63ffffffff1690565b61194990600861194e93026109e0565b611930565b90565b9061195c9154611939565b90565b61196c600f601490611951565b90565b9190611982905f602085019401906104f9565b565b346119b45761199436600461041d565b6119b061199f61195f565b6119a7610362565b9182918261196f565b0390f35b610368565b6119c281610920565b036119c957565b5f80fd5b905035906119da826119b9565b565b60e081830312611a47576119f2825f83016105e2565b92611a0083602084016105e2565b92611a0e8160408501610608565b92611a1c8260608301610608565b92611a44611a2d84608085016119cd565b93611a3b8160a08601610808565b9360c001610808565b90565b61036c565b34611a8157611a6b611a5f3660046119dc565b95949094939193613837565b611a73610362565b80611a7d816106d1565b0390f35b610368565b34611ab557611a9f611a993660046108bf565b90613955565b611aa7610362565b80611ab1816106d1565b0390f35b610368565b9190604083820312611ae25780611ad6611adf925f86016105e2565b936020016105e2565b90565b61036c565b34611b1857611b14611b03611afd366004611aba565b90613977565b611b0b610362565b91829182610687565b0390f35b610368565b34611b4d57611b2d36600461041d565b611b49611b3861399f565b611b40610362565b918291826103d3565b0390f35b610368565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b611b7e611b52565b90565b34611bb157611b9136600461041d565b611bad611b9c611b76565b611ba4610362565b91829182610842565b0390f35b610368565b611bc2600e5f906115d6565b90565b34611bf557611bd536600461041d565b611bf1611be0611bb6565b611be8610362565b918291826115f3565b0390f35b610368565b611c06600c5f906109ff565b90565b34611c3957611c1936600461041d565b611c35611c24611bfa565b611c2c610362565b91829182610687565b0390f35b610368565b5f80fd5b5f90565b611c4e611c42565b5080611c69611c63637965db0b60e01b610374565b91610374565b14908115611c76575b5090565b611c8091506139d0565b5f611c72565b606090565b60209181520190565b5f5260205f2090565b905f9291805490611cb7611cb083610f62565b8094611c8b565b916001811690815f14611d0e5750600114611cd2575b505050565b611cdf9192939450611c94565b915f925b818410611cf657505001905f8080611ccd565b60018160209295939554848601520191019290611ce3565b92949550505060ff19168252151560200201905f8080611ccd565b90611d3391611c9d565b90565b90611d56611d4f92611d46610362565b93848092611d29565b038361104b565b565b611d6190611d36565b90565b611d6c611c86565b50611d776003611d58565b90565b5f90565b5f90565b606090565b5f1c90565b611d98611d9d91611d87565b6115b3565b90565b611daa9054611d8c565b90565b60a01c90565b611dbf611dc491611dad565b611930565b90565b611dd19054611db3565b90565b611ddd90611074565b90565b611de8611d7a565b50611df1611d7a565b50611dfa611d7a565b50611e03611d7e565b50611e0c611d82565b50611e17600d611da0565b611e21600e611da0565b91611e2c600f611da0565b91611e37600f611dc7565b91611e4760109295949392611dd4565b90565b611e6791611e56611c42565b50611e5f6139f6565b919091613a03565b600190565b5f90565b611e7c611e8191611d87565b6109e4565b90565b611e8e9054611e70565b90565b611e99611e6c565b50611ea46002611e84565b90565b611eb7611eb2611b52565b613a13565b611ebf61224a565b565b611ecd611ed291611d87565b610c68565b90565b611edf9054611ec1565b90565b5f7f456d697373696f6e7320616c7265616479207374617274656400000000000000910152565b611f166019602092610430565b611f1f81611ee2565b0190565b611f389060208101905f818303910152611f09565b90565b15611f4257565b611f4a610362565b62461bcd60e51b815280611f6060048201611f23565b0390fd5b611f78611f73611f7d926114ce565b61077c565b6104cc565b90565b611f8990611f64565b90565b5f7f4272696467652061646472657373206e6f742073657400000000000000000000910152565b611fc06016602092610430565b611fc981611f8c565b0190565b611fe29060208101905f818303910152611fb3565b90565b15611fec57565b611ff4610362565b62461bcd60e51b81528061200a60048201611fcd565b0390fd5b5f7f4c3220746f6b656e2061646472657373206e6f74207365740000000000000000910152565b6120426018602092610430565b61204b8161200e565b0190565b6120649060208101905f818303910152612035565b90565b1561206e57565b612076610362565b62461bcd60e51b81528061208c6004820161204f565b0390fd5b5f7f4c322064657374696e6174696f6e2061646472657373206e6f74207365740000910152565b6120c4601e602092610430565b6120cd81612090565b0190565b6120e69060208101905f8183039101526120b7565b90565b156120f057565b6120f8610362565b62461bcd60e51b81528061210e600482016120d1565b0390fd5b61212661212161212b926114ce565b61077c565b6104f0565b90565b5f7f42726964676520676173206c696d6974206e6f74207365740000000000000000910152565b6121626018602092610430565b61216b8161212e565b0190565b6121849060208101905f818303910152612155565b90565b1561218e57565b612196610362565b62461bcd60e51b8152806121ac6004820161216f565b0390fd5b906121bc60ff916114d1565b9181191691161790565b6121cf906103c1565b90565b90565b906121ea6121e56121f1926121c6565b6121d2565b82546121b0565b9055565b906122015f19916114d1565b9181191691161790565b61221f61221a612224926105f1565b61077c565b6105f1565b90565b90565b9061223f61223a6122469261220b565b612227565b82546121f5565b9055565b61226561226061225a6009611ed5565b156103c1565b611f3b565b612293612272600d611da0565b61228c6122866122815f611f80565b6104d7565b916104d7565b1415611fe5565b6122c16122a0600e611da0565b6122ba6122b46122af5f611f80565b6104d7565b916104d7565b1415612067565b6122ef6122ce600f611da0565b6122e86122e26122dd5f611f80565b6104d7565b916104d7565b14156120e9565b6123146122fc600f611dc7565b61230e6123085f612112565b916104f0565b11612187565b612320600160096121d5565b61232b42600a61222a565b426123627f1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a322034116091612359610362565b91829182610687565b0390a1565b61236f611ea7565b565b9161239b9261237e611c42565b5061239361238a6139f6565b82908491613a67565b919091613af3565b600190565b5f90565b6123ad906107f1565b90565b906123ba906123a4565b5f5260205260405f2090565b90565b6123d56123da91611d87565b6123c6565b90565b6123e790546123c9565b90565b6001612403612409926123fb6123a0565b5060056123b0565b016123dd565b90565b5f7f456d697373696f6e73206e6f7420737461727465640000000000000000000000910152565b6124406015602092610430565b6124498161240c565b0190565b6124629060208101905f818303910152612433565b90565b1561246c57565b612474610362565b62461bcd60e51b81528061248a6004820161244d565b0390fd5b5f7f416c6c20656d697373696f6e7320636f6d706c65746564000000000000000000910152565b6124c26017602092610430565b6124cb8161248e565b0190565b6124e49060208101905f8183039101526124b5565b90565b156124ee57565b6124f6610362565b62461bcd60e51b81528061250c600482016124cf565b0390fd5b634e487b7160e01b5f52601160045260245ffd5b612533612539919392936105f1565b926105f1565b820391821161254457565b612510565b634e487b7160e01b5f52601260045260245ffd5b61256961256f916105f1565b916105f1565b90811561257a570490565b612549565b5f7f43757272656e742065706f636820616c7265616479206d696e74656400000000910152565b6125b3601c602092610430565b6125bc8161257f565b0190565b6125d59060208101905f8183039101526125a6565b90565b156125df57565b6125e7610362565b62461bcd60e51b8152806125fd600482016125c0565b0390fd5b61261561261061261a926114ce565b61077c565b6105f1565b90565b600161262991016105f1565b90565b61263b612641919392936105f1565b926105f1565b820180921161264c57565b612510565b5f7f43616e6e6f742065786365656420656d697373696f6e7320737570706c790000910152565b612685601e602092610430565b61268e81612651565b0190565b6126a79060208101905f818303910152612678565b90565b156126b157565b6126b9610362565b62461bcd60e51b8152806126cf60048201612692565b0390fd5b6126e76126e26126ec926104cc565b61077c565b6104cc565b90565b6126f8906126d3565b90565b612704906126ef565b90565b612710906126d3565b90565b61271c90612707565b90565b612728906126ef565b90565b5f80fd5b60e01b90565b5f91031261273f57565b61036c565b905f929180549061275e61275783610f62565b809461050a565b916001811690815f146127b55750600114612779575b505050565b6127869192939450610f95565b915f925b81841061279d57505001905f8080612774565b6001816020929593955484860152019101929061278a565b92949550505060ff19168252151560200201905f8080612774565b9261282d969461280c61281692612802612820969995996127f860c08a019b5f8b01906104e3565b60208901906104e3565b60408701906104e3565b606085019061067a565b60808301906104f9565b60a0818403910152612744565b90565b612838610362565b3d5f823e3d90fd5b90565b61285761285261285c92612840565b61077c565b6105f1565b90565b612868906126ef565b90565b91602061288c92949361288560408201965f83019061067a565b019061067a565b565b6128a061289b6009611ed5565b612465565b6128cc6128ad600b611e84565b6128c66128c06128bb610cf7565b6105f1565b916105f1565b106124e7565b6129296128f46128e6426128e0600a611e84565b90612524565b6128ee61165c565b9061255d565b6129198161291361290d612908600b611e84565b6105f1565b916105f1565b116125d8565b612923600b611e84565b90612524565b908161295761295161294c61293c610cf7565b612946600b611e84565b90612524565b6105f1565b916105f1565b11612ba2575b6129665f612601565b906129705f612601565b915b8261298561297f866105f1565b916105f1565b10156129cc576129c06129c6916129ba6129b460116129ae6129a7600b611e84565b899061262c565b906109b8565b906109ff565b9061262c565b9261261d565b91612972565b915091612a1c612a2391612a0d6129ed6129e6600c611e84565b869061262c565b612a06612a006129fb610dd8565b6105f1565b916105f1565b11156126aa565b612a17600b611e84565b61262c565b600b61222a565b612a40612a3982612a34600c611e84565b61262c565b600c61222a565b612a53612a4c306126fb565b8290613b90565b612a70612a5f306126fb565b612a69600d611da0565b8391613a03565b612a8a612a85612a80600d611da0565b612713565b61271f565b63540abf73612a98306126fb565b612aa2600e611da0565b92612aad600f611da0565b9285612ab9600f611dc7565b91601095843b15612b9d575f96612ae4948894612aef93612ad8610362565b9b8c9a8b998a9861272f565b8852600488016127d0565b03925af18015612b9857612b6c575b50612b1c612b0c600b611e84565b612b166001612843565b90612524565b90612b27600f611da0565b90612b527f34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb9261285f565b92612b67612b5e610362565b9283928361286b565b0390a2565b612b8b905f3d8111612b91575b612b83818361104b565b810190612735565b5f612afe565b503d612b79565b612830565b61272b565b9050612bbf612baf610cf7565b612bb9600b611e84565b90612524565b9061295d565b90612be091612bdb612bd6826123ea565b613a13565b612be2565b565b90612bec91613bee565b50565b90612bf991612bc5565b565b5f90565b90565b612c16612c11612c1b92612bff565b61077c565b610920565b90565b612c26612bfb565b50612c316012612c02565b90565b612c3c6123a0565b50612c45613c9a565b90565b9080612c63612c5d612c586139f6565b6104d7565b916104d7565b03612c7457612c7191613d54565b50565b5f63334bd91960e11b815280612c8c600482016106d1565b0390fd5b612c98611e6c565b50612cb4612ca4610dd8565b612cae600c611e84565b90612524565b90565b90612cd59594939291612cd0612ccb6114f2565b613a13565b6131b0565b565b5f7f42726964676520616464726573732063616e6e6f74206265207a65726f000000910152565b612d0b601d602092610430565b612d1481612cd7565b0190565b612d2d9060208101905f818303910152612cfe565b90565b15612d3757565b612d3f610362565b62461bcd60e51b815280612d5560048201612d18565b0390fd5b5f7f4c3220746f6b656e20616464726573732063616e6e6f74206265207a65726f00910152565b612d8d601f602092610430565b612d9681612d59565b0190565b612daf9060208101905f818303910152612d80565b90565b15612db957565b612dc1610362565b62461bcd60e51b815280612dd760048201612d9a565b0390fd5b60207f207a65726f000000000000000000000000000000000000000000000000000000917f4c322064657374696e6174696f6e20616464726573732063616e6e6f742062655f8201520152565b612e356025604092610430565b612e3e81612ddb565b0190565b612e579060208101905f818303910152612e28565b90565b15612e6157565b612e69610362565b62461bcd60e51b815280612e7f60048201612e42565b0390fd5b60207f65726f0000000000000000000000000000000000000000000000000000000000917f476173206c696d6974206d7573742062652067726561746572207468616e207a5f8201520152565b612edd6023604092610430565b612ee681612e83565b0190565b612eff9060208101905f818303910152612ed0565b90565b15612f0957565b612f11610362565b62461bcd60e51b815280612f2760048201612eea565b0390fd5b90612f3c60018060a01b03916114d1565b9181191691161790565b90565b90612f5e612f59612f659261285f565b612f46565b8254612f2b565b9055565b60a01b90565b90612f8163ffffffff60a01b91612f69565b9181191691161790565b612f9f612f9a612fa4926104f0565b61077c565b6104f0565b90565b90565b90612fbf612fba612fc692612f8b565b612fa7565b8254612f6f565b9055565b5090565b601f602091010490565b1b90565b91906008612ff7910291612ff15f1984612fd8565b92612fd8565b9181191691161790565b919061301761301261301f9361220b565b612227565b908354612fdc565b9055565b6130359161302f611e6c565b91613001565b565b5b818110613043575050565b806130505f600193613023565b01613038565b9190601f8111613066575b505050565b61307261309793610f95565b90602061307e84612fce565b8301931061309f575b61309090612fce565b0190613037565b5f8080613061565b915061309081929050613087565b906130bd905f19906008026109e0565b191690565b816130cc916130ad565b906002021790565b916130df9082612fca565b9067ffffffffffffffff821161319e57613103826130fd8554610f62565b85613056565b5f90601f831160011461313657918091613125935f9261312a575b50506130c2565b90555b565b90915001355f8061311e565b601f1983169161314585610f95565b925f5b8181106131865750916002939185600196941061316c575b50505002019055613128565b61317c910135601f8416906130ad565b90555f8080613160565b91936020600181928787013581550195019201613148565b611037565b906131ae92916130d4565b565b9192939461327791956131de846131d76131d16131cc5f611f80565b6104d7565b916104d7565b1415612d30565b613203876131fc6131f66131f15f611f80565b6104d7565b916104d7565b1415612db2565b6132288561322161321b6132165f611f80565b6104d7565b916104d7565b1415612e5a565b6132448661323e6132385f612112565b916104f0565b11612f02565b61324f84600d612f49565b61325a87600e612f49565b61326585600f612f49565b61327086600f612faa565b60106131a3565b929091926132cc6132ba6132b46132ae7f02d9f9397554a29bba1cc50e5dd30a55bd40e4d063f27e4b6dd646d28d8104609461285f565b9461285f565b9461285f565b946132c3610362565b9182918261196f565b0390a4565b906132df9594939291612cb7565b565b906132eb9061285f565b5f5260205260405f2090565b61330d61331291613306611e6c565b505f6132e1565b611e84565b90565b61332790613321611e6c565b50613df6565b90565b5f90565b606090565b61333c906126ef565b90565b9061335261334b610362565b928361104b565b565b67ffffffffffffffff811161336c5760208091020190565b611037565b9061338361337e83613354565b61333f565b918252565b369037565b906133b261339a83613371565b926020806133a88693613354565b9201910390613388565b565b600f60f81b90565b6133c461332a565b506133cd611c86565b506133d6611c86565b506133df611e6c565b506133e8611d7a565b506133f16123a0565b506133fa61332e565b50613403613e18565b9061340c613e58565b90469061341830613333565b906134225f6114d6565b9061343461342f5f612601565b61338d565b9061343d6133b4565b96959493929190565b906134509061285f565b5f5260205260405f2090565b613483915f61347861347e93613470611c42565b5060056123b0565b01613446565b611ed5565b90565b61348e611c86565b506134996004611d58565b90565b6134b9916134a8611c42565b506134b16139f6565b919091613af3565b600190565b67ffffffffffffffff81116134d35760200290565b611037565b6134e46134e9916134be565b61333f565b90565b9061350a6134f9836134d8565b9261350484916134be565b90613388565b565b61351660306134ec565b90565b905090565b6135289054611e70565b90565b60010190565b61354d613547613540836109af565b8094613519565b916109b5565b5f915b83831061355d5750505050565b61357a61357460019261356f8561351e565b611175565b9261352b565b92019190613550565b906135918161060093613531565b0190565b906135b56135ae926135a5610362565b93848092613583565b038361104b565b565b6135c090613595565b90565b6135cb61350c565b506135d660116135b7565b90565b6135e86135ee919392936105f1565b926105f1565b916135fa8382026105f1565b92818404149015171561360957565b612510565b613616611e6c565b5061361f611e6c565b50613628611e6c565b50613631611c42565b5061364561363f6009611ed5565b156103c1565b6137695761366e6136604261365a600a611e84565b90612524565b61366861165c565b9061255d565b906136b061367c600a611e84565b6136aa61369c61368c600b611e84565b6136966001612843565b9061262c565b6136a461165c565b906135d9565b9061262c565b6136ba600b611e84565b6136d36136cd6136c8610cf7565b6105f1565b916105f1565b105f1461375b576136f86136f260116136ec600b611e84565b906109b8565b906109ff565b5b9261371561370f61370a600b611e84565b6105f1565b916105f1565b1180613731575b91613727600b611e84565b9193929193929190565b5061373c600b611e84565b61375561374f61374a610cf7565b6105f1565b916105f1565b1061371c565b6137645f612601565b6136f9565b5f905f915f9161378b61378561377f5f94612601565b95612601565b93612601565b9190565b7f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c990565b91946137fb613805929897956137f160a0966137e761380c9a6137dd60c08a019e5f8b0190610835565b60208901906104e3565b60408701906104e3565b606085019061067a565b608083019061067a565b019061067a565b565b60200190565b91602061383592949361382e60408201965f8301906104e3565b01906104e3565b565b96959193929490944261385261384c836105f1565b916105f1565b1161390c57906138bb6138c49493926138a361386c61378f565b6138948c80948c9161387e8d91613e98565b9192613888610362565b978896602088016137b3565b6020820181038252038261104b565b6138b56138af82610506565b9161380e565b20613ecb565b92909192613ee8565b806138d76138d1876104d7565b916104d7565b036138ec57506138ea9293919091613a03565b565b84906139085f9283926325c0072360e11b845260048401613814565b0390fd5b613927905f91829163313c898160e11b835260048301610687565b0390fd5b906139469161394161393c826123ea565b613a13565b613948565b565b9061395291613d54565b50565b9061395f9161392b565b565b9061396b9061285f565b5f5260205260405f2090565b61399c916139926139979261398a611e6c565b506001613961565b6132e1565b611e84565b90565b6139a7611c42565b506139b2600b611e84565b6139cb6139c56139c0610cf7565b6105f1565b916105f1565b101590565b6139d8611c42565b506139f26139ec6301ffc9a760e01b610374565b91610374565b1490565b6139fe611d7a565b503390565b91613a119291600192613f0f565b565b613a2590613a1f6139f6565b90614041565b565b604090613a50613a579496959396613a4660608401985f8501906104e3565b602083019061067a565b019061067a565b565b90613a6491036105f1565b90565b929192613a75818390613977565b9081613a8a613a845f196105f1565b916105f1565b10613a97575b5050509050565b81613aaa613aa4876105f1565b916105f1565b10613ad057613ac79394613abf919392613a59565b905f92613f0f565b805f8080613a90565b50613aef849291925f938493637dc7a0d960e11b855260048501613a27565b0390fd5b9182613b0f613b09613b045f611f80565b6104d7565b916104d7565b14613b695781613b2f613b29613b245f611f80565b6104d7565b916104d7565b14613b4257613b409291909161408a565b565b613b65613b4e5f611f80565b5f91829163ec442f0560e01b8352600483016115f3565b0390fd5b613b8c613b755f611f80565b5f918291634b637e8f60e11b8352600483016115f3565b0390fd5b80613bab613ba5613ba05f611f80565b6104d7565b916104d7565b14613bc757613bc591613bbd5f611f80565b91909161408a565b565b613bea613bd35f611f80565b5f91829163ec442f0560e01b8352600483016115f3565b0390fd5b613bf6611c42565b50613c0b613c0582849061345c565b156103c1565b5f14613c9457613c336001613c2e5f613c26600586906123b0565b018590613446565b6121d5565b90613c3c6139f6565b90613c79613c73613c6d7f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d956123a4565b9261285f565b9261285f565b92613c82610362565b80613c8c816106d1565b0390a4600190565b50505f90565b613ca26123a0565b50613cac30613333565b613cde613cd87f00000000000000000000000000000000000000000000000000000000000000006104d7565b916104d7565b1480613d1a575b5f14613d0f577f000000000000000000000000000000000000000000000000000000000000000090565b613d1761426a565b90565b5046613d4e613d487f00000000000000000000000000000000000000000000000000000000000000006105f1565b916105f1565b14613ce5565b613d5c611c42565b50613d6881839061345c565b5f14613df057613d8f5f613d8a5f613d82600586906123b0565b018590613446565b6121d5565b90613d986139f6565b90613dd5613dcf613dc97ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b956123a4565b9261285f565b9261285f565b92613dde610362565b80613de8816106d1565b0390a4600190565b50505f90565b613e0d613e1291613e05611e6c565b5060086132e1565b611e84565b90565b90565b613e20611c86565b50613e557f0000000000000000000000000000000000000000000000000000000000000000613e4f6006613e15565b90614404565b90565b613e60611c86565b50613e957f0000000000000000000000000000000000000000000000000000000000000000613e8f6007613e15565b90614404565b90565b613eac90613ea4611e6c565b5060086132e1565b613ec8613eb882611e84565b91613ec28361261d565b9061222a565b90565b613ee590613ed76123a0565b50613ee0613c9a565b614452565b90565b92613f0392613f0c94613ef9611d7a565b5092909192614508565b90929192614633565b90565b909281613f2c613f26613f215f611f80565b6104d7565b916104d7565b14613ff75783613f4c613f46613f415f611f80565b6104d7565b916104d7565b14613fd057613f7083613f6b613f6460018690613961565b87906132e1565b61222a565b613f7a575b505050565b919091613fc5613fb3613fad7f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259361285f565b9361285f565b93613fbc610362565b91829182610687565b0390a35f8080613f75565b613ff3613fdc5f611f80565b5f918291634a1406b160e11b8352600483016115f3565b0390fd5b61401a6140035f611f80565b5f91829163e602df0560e01b8352600483016115f3565b0390fd5b91602061403f92949361403860408201965f8301906104e3565b0190610835565b565b9061405661405083839061345c565b156103c1565b61405e575050565b6140785f92839263e2517d3f60e01b84526004840161401e565b0390fd5b9061408791016105f1565b90565b919091806140a86140a261409d5f611f80565b6104d7565b916104d7565b145f14614189576140cc6140c5836140c06002611e84565b61262c565b600261222a565b5b826140e86140e26140dd5f611f80565b6104d7565b916104d7565b145f1461415d5761410c614105836141006002611e84565b613a59565b600261222a565b5b9190916141586141466141407fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9361285f565b9361285f565b9361414f610362565b91829182610687565b0390a3565b6141848261417e61416f5f87906132e1565b9161417983611e84565b61407c565b9061222a565b61410d565b61419c6141975f83906132e1565b611e84565b806141af6141a9856105f1565b916105f1565b106141d7576141c26141d2918490613a59565b6141cd5f84906132e1565b61222a565b6140cd565b906141f59091925f93849363391434e360e21b855260048501613a27565b0390fd5b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b90959492614268946142576142619261424d60809661424360a088019c5f890190610835565b6020870190610835565b6040850190610835565b606083019061067a565b01906104e3565b565b6142726123a0565b5061427b6141f9565b6142f27f0000000000000000000000000000000000000000000000000000000000000000916142e37f0000000000000000000000000000000000000000000000000000000000000000466142ce30613333565b916142d7610362565b9687956020870161421d565b6020820181038252038261104b565b6143046142fe82610506565b9161380e565b2090565b90565b61431f61431a61432492614308565b6114d1565b6107f1565b90565b61433160ff61430b565b90565b5f5260205f2090565b905f929180549061435761435083610f62565b8094611c8b565b916001811690815f146143ae5750600114614372575b505050565b61437f9192939450614334565b915f925b81841061439657505001905f808061436d565b60018160209295939554848601520191019290614383565b92949550505060ff19168252151560200201905f808061436d565b906143d39161433d565b90565b906143f66143ef926143e6610362565b938480926143c9565b038361104b565b565b614401906143d6565b90565b9061440d611c86565b50614417826123a4565b61443061442a614425614327565b6107f1565b916107f1565b14155f14614445575061444290614789565b90565b61444f91506143f8565b90565b60429161445d6123a0565b50604051917f19010000000000000000000000000000000000000000000000000000000000008352600283015260228201522090565b5f90565b6144a36144a891611d87565b61220b565b90565b90565b6144c26144bd6144c7926144ab565b61077c565b6105f1565b90565b6144ff614506946144f56060949897956144eb608086019a5f870190610835565b6020850190610926565b6040830190610835565b0190610835565b565b939293614513611d7a565b5061451c614493565b506145256123a0565b5061452f85614497565b61456161455b7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a06144ae565b916105f1565b116145ee5790614584602094955f9493929361457b610362565b948594856144ca565b838052039060015afa156145e95761459c5f516114d1565b806145b76145b16145ac5f611f80565b6104d7565b916104d7565b146145cd575f916145c75f6114d6565b91929190565b506145d75f611f80565b6001916145e35f6114d6565b91929190565b612830565b5050506145fa5f611f80565b9060039291929190565b634e487b7160e01b5f52602160045260245ffd5b6004111561462257565b614604565b9061463182614618565b565b806146466146405f614627565b91614627565b145f14614651575050565b8061466561465f6001614627565b91614627565b145f14614688575f63f645eedf60e01b815280614684600482016106d1565b0390fd5b8061469c6146966002614627565b91614627565b145f146146ca576146c66146af83614497565b5f91829163fce698f760e01b835260048301610687565b0390fd5b6146dd6146d76003614627565b91614627565b146146e55750565b614700905f9182916335e2f38360e21b835260048301610842565b0390fd5b90565b61471b61471661472092614704565b61077c565b6105f1565b90565b67ffffffffffffffff81116147415761473d602091610444565b0190565b611037565b9061475861475383614723565b61333f565b918252565b369037565b9061478761476f83614746565b9260208061477d8693614723565b920191039061475d565b565b614791611c86565b5061479b816147f4565b906147ae6147a96020614707565b614762565b918252602082015290565b6147cd6147c86147d292614308565b61077c565b6105f1565b90565b90565b6147ec6147e76147f1926147d5565b61077c565b6105f1565b90565b61480961480e91614803611e6c565b506123a4565b614497565b61481860ff6147b9565b168061482d614827601f6147d8565b916105f1565b116148355790565b5f632cd44ac360e21b81528061484d600482016106d1565b0390fd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x01``@R4a\0sWa\0\x1Ba\0\x15a\x01TV[\x91a\x05\x01V[a\0#a\0xV[aHQa\x17\x1A\x829`\x80Q\x81a<\xED\x01R`\xA0Q\x81a=$\x01R`\xC0Q\x81a<\xB4\x01R`\xE0Q\x81aB\x80\x01Ra\x01\0Q\x81aB\xA5\x01Ra\x01 Q\x81a>&\x01Ra\x01@Q\x81a>f\x01RaHQ\x90\xF3[a\0~V[`@Q\x90V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\0\xAA\x90a\0\x82V[\x81\x01\x90\x81\x10`\x01\x80`@\x1B\x03\x82\x11\x17a\0\xC2W`@RV[a\0\x8CV[\x90a\0\xDAa\0\xD3a\0xV[\x92\x83a\0\xA0V[V[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\0\xF4\x90a\0\xE0V[\x90V[a\x01\0\x81a\0\xEBV[\x03a\x01\x07WV[_\x80\xFD[\x90PQ\x90a\x01\x18\x82a\0\xF7V[V[\x90\x91``\x82\x84\x03\x12a\x01OWa\x01La\x015\x84_\x85\x01a\x01\x0BV[\x93a\x01C\x81` \x86\x01a\x01\x0BV[\x93`@\x01a\x01\x0BV[\x90V[a\0\xDCV[a\x01ra_k\x808\x03\x80a\x01g\x81a\0\xC7V[\x92\x839\x81\x01\x90a\x01\x1AV[\x90\x91\x92V[`\x01\x80`@\x1B\x03\x81\x11a\x01\x93Wa\x01\x8F` \x91a\0\x82V[\x01\x90V[a\0\x8CV[\x90a\x01\xAAa\x01\xA5\x83a\x01wV[a\0\xC7V[\x91\x82RV[_\x7FSyndicate\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x01\xE0`\ta\x01\x98V[\x90a\x01\xED` \x83\x01a\x01\xAFV[V[a\x01\xF7a\x01\xD6V[\x90V[_\x7FSYND\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x02+`\x04a\x01\x98V[\x90a\x028` \x83\x01a\x01\xFAV[V[a\x02Ba\x02!V[\x90V[\x90V[\x90V[a\x02_a\x02Za\x02d\x92a\x02EV[a\x02HV[a\0\xE0V[\x90V[a\x02p\x90a\x02KV[\x90V[` \x91\x81R\x01\x90V[` \x7Fress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FDefault admin cannot be zero add_\x82\x01R\x01RV[a\x02\xD6`$`@\x92a\x02sV[a\x02\xDF\x81a\x02|V[\x01\x90V[a\x02\xF8\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x02\xC9V[\x90V[\x15a\x03\x02WV[a\x03\na\0xV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x03 `\x04\x82\x01a\x02\xE3V[\x03\x90\xFD[` \x7Fo address\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FFoundation address cannot be zer_\x82\x01R\x01RV[a\x03~`)`@\x92a\x02sV[a\x03\x87\x81a\x03$V[\x01\x90V[a\x03\xA0\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x03qV[\x90V[\x15a\x03\xAAWV[a\x03\xB2a\0xV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x03\xC8`\x04\x82\x01a\x03\x8BV[\x03\x90\xFD[` \x7F address\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FEmissions manager cannot be zero_\x82\x01R\x01RV[a\x04&`(`@\x92a\x02sV[a\x04/\x81a\x03\xCCV[\x01\x90V[a\x04H\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x04\x19V[\x90V[\x15a\x04RWV[a\x04Za\0xV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x04p`\x04\x82\x01a\x043V[\x03\x90\xFD[\x90V[_\x1B\x90V[a\x04\x90a\x04\x8Ba\x04\x95\x92a\x02EV[a\x04wV[a\x04tV[\x90V[a\x04\xA1_a\x04|V[\x90V[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[\x90V[\x90V[a\x04\xE2a\x04\xDDa\x04\xE7\x92a\x04\xC8V[a\x02HV[a\x04\xCBV[\x90V[a\x04\xFEjJr=\xC6\xB4\x0B\x8A\x9A\0\0\0a\x04\xCEV[\x90V[a\x05\xC6\x92a\x05\xA9a\x05\xB7\x92a\x05-a\x05\x17a\x01\xEFV[a\x05\x1Fa\x01\xEFV[a\x05'a\x02:V[\x91a\x06\x1BV[a\x05R\x81a\x05Ka\x05Ea\x05@_a\x02gV[a\0\xEBV[\x91a\0\xEBV[\x14\x15a\x02\xFBV[a\x05w\x85a\x05pa\x05ja\x05e_a\x02gV[a\0\xEBV[\x91a\0\xEBV[\x14\x15a\x03\xA3V[a\x05\x9C\x83a\x05\x95a\x05\x8Fa\x05\x8A_a\x02gV[a\0\xEBV[\x91a\0\xEBV[\x14\x15a\x04KV[a\x05\xA4a\x04\x98V[a\n<V[Pa\x05\xB2a\x04\xA4V[a\n<V[Pa\x05\xC0a\x04\xEAV[\x90a\x0B\nV[a\x05\xCEa\x0ExV[V[_\x7F1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x06\x01`\x01a\x01\x98V[\x90a\x06\x0E` \x83\x01a\x05\xD0V[V[a\x06\x18a\x05\xF7V[\x90V[\x90a\x06/\x92\x91a\x06)a\x06\x10V[\x90a\x061V[V[\x90a\x06=\x93\x92\x91a\x06\x83V[V[\x90V[\x90V[` \x01\x90V[Q\x90V[a\x06ca\x06^a\x06h\x92a\0\xE0V[a\x02HV[a\0\xE0V[\x90V[a\x06t\x90a\x06OV[\x90V[a\x06\x80\x90a\x06kV[\x90V[a\x06\x94a\x06\xE4\x94a\x06\xC9\x93\x94a\x07\x18V[a\x06\xA8\x81a\x06\xA2`\x06a\x06?V[\x90a\x11PV[a\x01 Ra\x06\xC0\x83a\x06\xBA`\x07a\x06?V[\x90a\x11PV[a\x01@Ra\x06BV[a\x06\xDBa\x06\xD5\x82a\x06KV[\x91a\x06EV[ `\xE0Ra\x06BV[a\x06\xF6a\x06\xF0\x82a\x06KV[\x91a\x06EV[ a\x01\0RF`\xA0Ra\x07\x07a\x12UV[`\x80Ra\x07\x130a\x06wV[`\xC0RV[\x90a\x07\"\x91a\x07$V[V[\x90a\x07.\x91a\x070V[V[\x90a\x07:\x91a\t\x8DV[V[Q\x90V[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x07tW[` \x83\x10\x14a\x07oWV[a\x07@V[\x91`\x7F\x16\x91a\x07dV[_R` _ \x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a\x07\xB0\x91\x02\x91a\x07\xAA_\x19\x84a\x07\x91V[\x92a\x07\x91V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x07\xCEa\x07\xC9a\x07\xD3\x92a\x04\xCBV[a\x02HV[a\x04\xCBV[\x90V[\x90V[\x91\x90a\x07\xEFa\x07\xEAa\x07\xF7\x93a\x07\xBAV[a\x07\xD6V[\x90\x83Ta\x07\x95V[\x90UV[_\x90V[a\x08\x11\x91a\x08\x0Ba\x07\xFBV[\x91a\x07\xD9V[V[[\x81\x81\x10a\x08\x1FWPPV[\x80a\x08,_`\x01\x93a\x07\xFFV[\x01a\x08\x14V[\x91\x90`\x1F\x81\x11a\x08BW[PPPV[a\x08Na\x08s\x93a\x07~V[\x90` a\x08Z\x84a\x07\x87V[\x83\x01\x93\x10a\x08{W[a\x08l\x90a\x07\x87V[\x01\x90a\x08\x13V[_\x80\x80a\x08=V[\x91Pa\x08l\x81\x92\x90Pa\x08cV[\x1C\x90V[\x90a\x08\x9D\x90_\x19\x90`\x08\x02a\x08\x89V[\x19\x16\x90V[\x81a\x08\xAC\x91a\x08\x8DV[\x90`\x02\x02\x17\x90V[\x90a\x08\xBE\x81a\x07<V[\x90`\x01\x80`@\x1B\x03\x82\x11a\t|Wa\x08\xE0\x82a\x08\xDA\x85Ta\x07TV[\x85a\x082V[` \x90`\x1F\x83\x11`\x01\x14a\t\x14W\x91\x80\x91a\t\x03\x93_\x92a\t\x08W[PPa\x08\xA2V[\x90U[V[\x90\x91P\x01Q_\x80a\x08\xFCV[`\x1F\x19\x83\x16\x91a\t#\x85a\x07~V[\x92_[\x81\x81\x10a\tdWP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\tJW[PPP\x02\x01\x90Ua\t\x06V[a\tZ\x91\x01Q`\x1F\x84\x16\x90a\x08\x8DV[\x90U_\x80\x80a\t>V[\x91\x93` `\x01\x81\x92\x87\x87\x01Q\x81U\x01\x95\x01\x92\x01a\t&V[a\0\x8CV[\x90a\t\x8B\x91a\x08\xB4V[V[\x90a\t\x9Ca\t\xA3\x92`\x03a\t\x81V[`\x04a\t\x81V[V[_\x90V[\x15\x15\x90V[a\t\xB7\x90a\x04tV[\x90V[\x90a\t\xC4\x90a\t\xAEV[_R` R`@_ \x90V[a\t\xD9\x90a\x06kV[\x90V[\x90a\t\xE6\x90a\t\xD0V[_R` R`@_ \x90V[\x90a\t\xFE`\xFF\x91a\x04wV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\n\x11\x90a\t\xA9V[\x90V[\x90V[\x90a\n,a\n'a\n3\x92a\n\x08V[a\n\x14V[\x82Ta\t\xF2V[\x90UV[_\x01\x90V[a\nDa\t\xA5V[Pa\nYa\nS\x82\x84\x90a\x12\xF2V[\x15a\t\xA9V[_\x14a\n\xE2Wa\n\x81`\x01a\n|_a\nt`\x05\x86\x90a\t\xBAV[\x01\x85\x90a\t\xDCV[a\n\x17V[\x90a\n\x8Aa\x13 V[\x90a\n\xC7a\n\xC1a\n\xBB\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\t\xAEV[\x92a\t\xD0V[\x92a\t\xD0V[\x92a\n\xD0a\0xV[\x80a\n\xDA\x81a\n7V[\x03\x90\xA4`\x01\x90V[PP_\x90V[a\n\xF1\x90a\0\xEBV[\x90RV[\x91\x90a\x0B\x08\x90_` \x85\x01\x94\x01\x90a\n\xE8V[V[\x80a\x0B%a\x0B\x1Fa\x0B\x1A_a\x02gV[a\0\xEBV[\x91a\0\xEBV[\x14a\x0BAWa\x0B?\x91a\x0B7_a\x02gV[\x91\x90\x91a\x149V[V[a\x0Bda\x0BM_a\x02gV[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\n\xF5V[\x03\x90\xFD[a\x0B|a\x0Bwa\x0B\x81\x92a\x02EV[a\x02HV[a\x04\xCBV[\x90V[`\x01a\x0B\x90\x91\x01a\x04\xCBV[\x90V[\x90V[a\x0B\xAAa\x0B\xA5a\x0B\xAF\x92a\x0B\x93V[a\x02HV[a\x04\xCBV[\x90V[\x90V[a\x0B\xC9a\x0B\xC4a\x0B\xCE\x92a\x0B\xB2V[a\x02HV[a\x04\xCBV[\x90V[a\x0B\xE4i\x8F\x95oiz\xA4\x92<\0\0a\x0B\xB5V[\x90V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[P`0\x90V[\x90V[a\x0C\r\x81a\x0B\xFBV[\x82\x10\x15a\x0C'Wa\x0C\x1F`\x01\x91a\x0C\x01V[\x91\x02\x01\x90_\x90V[a\x0B\xE7V[\x90V[a\x0CCa\x0C>a\x0CH\x92a\x0C,V[a\x02HV[a\x04\xCBV[\x90V[\x90V[a\x0Cba\x0C]a\x0Cg\x92a\x0CKV[a\x02HV[a\x04\xCBV[\x90V[a\x0C}iV&v\x0C\x16b\xBE$\0\0a\x0CNV[\x90V[\x90V[a\x0C\x97a\x0C\x92a\x0C\x9C\x92a\x0C\x80V[a\x02HV[a\x04\xCBV[\x90V[\x90V[a\x0C\xB6a\x0C\xB1a\x0C\xBB\x92a\x0C\x9FV[a\x02HV[a\x04\xCBV[\x90V[a\x0C\xD1i3\xB0\xB0\0\xFE\xC5\x93\x90\0\0a\x0C\xA2V[\x90V[\x90V[a\x0C\xEBa\x0C\xE6a\x0C\xF0\x92a\x0C\xD4V[a\x02HV[a\x04\xCBV[\x90V[\x90V[a\r\na\r\x05a\r\x0F\x92a\x0C\xF3V[a\x02HV[a\x04\xCBV[\x90V[a\r%i\x1F\x03\x9C\xCDe\xA9\xBE\xF0\0\0a\x0C\xF6V[\x90V[\x90V[a\r?a\r:a\rD\x92a\r(V[a\x02HV[a\x04\xCBV[\x90V[\x90V[a\r^a\rYa\rc\x92a\rGV[a\x02HV[a\x04\xCBV[\x90V[a\ryi\x12\x9B\xC4{<\xFFr\x90\0\0a\rJV[\x90V[\x90V[a\r\x93a\r\x8Ea\r\x98\x92a\r|V[a\x02HV[a\x04\xCBV[\x90V[\x90V[a\r\xB2a\r\xADa\r\xB7\x92a\r\x9BV[a\x02HV[a\x04\xCBV[\x90V[a\r\xCDi\x0B*H=m\xAD\xEE\x18\0\0a\r\x9EV[\x90V[\x90V[a\r\xE7a\r\xE2a\r\xEC\x92a\r\xD0V[a\x02HV[a\x04\xCBV[\x90V[\x90V[a\x0E\x06a\x0E\x01a\x0E\x0B\x92a\r\xEFV[a\x02HV[a\x04\xCBV[\x90V[a\x0E!i\x06\xB2\xEF\xD1:\x96*l\0\0a\r\xF2V[\x90V[\x90V[a\x0E;a\x0E6a\x0E@\x92a\x0E$V[a\x02HV[a\x04\xCBV[\x90V[\x90V[a\x0EZa\x0EUa\x0E_\x92a\x0ECV[a\x02HV[a\x04\xCBV[\x90V[a\x0Eui\x04\x04\xF6JVZ\x19t\0\0a\x0EFV[\x90V[a\x0E\x81_a\x0BhV[[\x80a\x0E\x96a\x0E\x90`\x06a\x0B\x96V[\x91a\x04\xCBV[\x10\x15a\x0E\xC7Wa\x0E\xC2\x90a\x0E\xBDa\x0E\xABa\x0B\xD1V[a\x0E\xB7`\x11\x84\x90a\x0C\x04V[\x90a\x07\xD9V[a\x0B\x84V[a\x0E\x82V[Pa\x0E\xD2`\x06a\x0B\x96V[[\x80a\x0E\xE7a\x0E\xE1`\x0Ca\x0C/V[\x91a\x04\xCBV[\x10\x15a\x0F\x18Wa\x0F\x13\x90a\x0F\x0Ea\x0E\xFCa\x0CjV[a\x0F\x08`\x11\x84\x90a\x0C\x04V[\x90a\x07\xD9V[a\x0B\x84V[a\x0E\xD3V[Pa\x0F#`\x0Ca\x0C/V[[\x80a\x0F8a\x0F2`\x12a\x0C\x83V[\x91a\x04\xCBV[\x10\x15a\x0FiWa\x0Fd\x90a\x0F_a\x0FMa\x0C\xBEV[a\x0FY`\x11\x84\x90a\x0C\x04V[\x90a\x07\xD9V[a\x0B\x84V[a\x0F$V[Pa\x0Ft`\x12a\x0C\x83V[[\x80a\x0F\x89a\x0F\x83`\x18a\x0C\xD7V[\x91a\x04\xCBV[\x10\x15a\x0F\xBAWa\x0F\xB5\x90a\x0F\xB0a\x0F\x9Ea\r\x12V[a\x0F\xAA`\x11\x84\x90a\x0C\x04V[\x90a\x07\xD9V[a\x0B\x84V[a\x0FuV[Pa\x0F\xC5`\x18a\x0C\xD7V[[\x80a\x0F\xDAa\x0F\xD4`\x1Ea\r+V[\x91a\x04\xCBV[\x10\x15a\x10\x0BWa\x10\x06\x90a\x10\x01a\x0F\xEFa\rfV[a\x0F\xFB`\x11\x84\x90a\x0C\x04V[\x90a\x07\xD9V[a\x0B\x84V[a\x0F\xC6V[Pa\x10\x16`\x1Ea\r+V[[\x80a\x10+a\x10%`$a\r\x7FV[\x91a\x04\xCBV[\x10\x15a\x10\\Wa\x10W\x90a\x10Ra\x10@a\r\xBAV[a\x10L`\x11\x84\x90a\x0C\x04V[\x90a\x07\xD9V[a\x0B\x84V[a\x10\x17V[Pa\x10g`$a\r\x7FV[[\x80a\x10|a\x10v`*a\r\xD3V[\x91a\x04\xCBV[\x10\x15a\x10\xADWa\x10\xA8\x90a\x10\xA3a\x10\x91a\x0E\x0EV[a\x10\x9D`\x11\x84\x90a\x0C\x04V[\x90a\x07\xD9V[a\x0B\x84V[a\x10hV[Pa\x10\xB8`*a\r\xD3V[[\x80a\x10\xCDa\x10\xC7`0a\x0E'V[\x91a\x04\xCBV[\x10\x15a\x10\xFEWa\x10\xF9\x90a\x10\xF4a\x10\xE2a\x0EbV[a\x10\xEE`\x11\x84\x90a\x0C\x04V[\x90a\x07\xD9V[a\x0B\x84V[a\x10\xB9V[PV[_\x90V[\x90V[a\x11\x1Ca\x11\x17a\x11!\x92a\x11\x05V[a\x02HV[a\x04\xCBV[\x90V[\x90V[a\x11;a\x116a\x11@\x92a\x11$V[a\x04wV[a\x04tV[\x90V[a\x11M`\xFFa\x11'V[\x90V[\x90a\x11Ya\x11\x01V[Pa\x11ka\x11f\x83a\x06BV[a\x06KV[a\x11~a\x11x` a\x11\x08V[\x91a\x04\xCBV[\x10_\x14a\x11\x92WPa\x11\x8F\x90a\x16\x8FV[\x90V[_a\x11\xA0a\x11\xA6\x93\x92a\x15\xA8V[\x01a\t\x81V[a\x11\xB6a\x11\xB1a\x11CV[a\t\xAEV[\x90V[_\x90V[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[a\x11\xEB\x90Qa\x04tV[\x90V[a\x11\xF7\x90a\x04tV[\x90RV[a\x12\x04\x90a\x04\xCBV[\x90RV[\x90\x95\x94\x92a\x12S\x94a\x12Ba\x12L\x92a\x128`\x80\x96a\x12.`\xA0\x88\x01\x9C_\x89\x01\x90a\x11\xEEV[` \x87\x01\x90a\x11\xEEV[`@\x85\x01\x90a\x11\xEEV[``\x83\x01\x90a\x11\xFBV[\x01\x90a\n\xE8V[V[a\x12]a\x11\xB9V[Pa\x12fa\x11\xBDV[a\x12\xB0a\x12s`\xE0a\x11\xE1V[\x91a\x12\xA1a\x12\x82a\x01\0a\x11\xE1V[Fa\x12\x8C0a\x06wV[\x91a\x12\x95a\0xV[\x96\x87\x95` \x87\x01a\x12\x08V[` \x82\x01\x81\x03\x82R\x03\x82a\0\xA0V[a\x12\xC2a\x12\xBC\x82a\x06KV[\x91a\x06EV[ \x90V[_\x1C\x90V[`\xFF\x16\x90V[a\x12\xDDa\x12\xE2\x91a\x12\xC6V[a\x12\xCBV[\x90V[a\x12\xEF\x90Ta\x12\xD1V[\x90V[a\x13\x19\x91_a\x13\x0Ea\x13\x14\x93a\x13\x06a\t\xA5V[P`\x05a\t\xBAV[\x01a\t\xDCV[a\x12\xE5V[\x90V[_\x90V[a\x13(a\x13\x1CV[P3\x90V[\x90a\x137\x90a\t\xD0V[_R` R`@_ \x90V[\x90V[a\x13Ra\x13W\x91a\x12\xC6V[a\x13CV[\x90V[a\x13d\x90Ta\x13FV[\x90V[`@\x90a\x13\x90a\x13\x97\x94\x96\x95\x93\x96a\x13\x86``\x84\x01\x98_\x85\x01\x90a\n\xE8V[` \x83\x01\x90a\x11\xFBV[\x01\x90a\x11\xFBV[V[\x90a\x13\xA4\x91\x03a\x04\xCBV[\x90V[\x90a\x13\xB3_\x19\x91a\x04wV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x13\xD2a\x13\xCDa\x13\xD9\x92a\x07\xBAV[a\x07\xD6V[\x82Ta\x13\xA7V[\x90UV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x14\0a\x14\x06\x91\x93\x92\x93a\x04\xCBV[\x92a\x04\xCBV[\x82\x01\x80\x92\x11a\x14\x11WV[a\x13\xDDV[\x90a\x14!\x91\x01a\x04\xCBV[\x90V[\x91\x90a\x147\x90_` \x85\x01\x94\x01\x90a\x11\xFBV[V[\x91\x90\x91\x80a\x14Wa\x14Qa\x14L_a\x02gV[a\0\xEBV[\x91a\0\xEBV[\x14_\x14a\x158Wa\x14{a\x14t\x83a\x14o`\x02a\x13ZV[a\x13\xF1V[`\x02a\x13\xBDV[[\x82a\x14\x97a\x14\x91a\x14\x8C_a\x02gV[a\0\xEBV[\x91a\0\xEBV[\x14_\x14a\x15\x0CWa\x14\xBBa\x14\xB4\x83a\x14\xAF`\x02a\x13ZV[a\x13\x99V[`\x02a\x13\xBDV[[\x91\x90\x91a\x15\x07a\x14\xF5a\x14\xEF\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a\t\xD0V[\x93a\t\xD0V[\x93a\x14\xFEa\0xV[\x91\x82\x91\x82a\x14$V[\x03\x90\xA3V[a\x153\x82a\x15-a\x15\x1E_\x87\x90a\x13-V[\x91a\x15(\x83a\x13ZV[a\x14\x16V[\x90a\x13\xBDV[a\x14\xBCV[a\x15Ka\x15F_\x83\x90a\x13-V[a\x13ZV[\x80a\x15^a\x15X\x85a\x04\xCBV[\x91a\x04\xCBV[\x10a\x15\x86Wa\x15qa\x15\x81\x91\x84\x90a\x13\x99V[a\x15|_\x84\x90a\x13-V[a\x13\xBDV[a\x14|V[\x90a\x15\xA4\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01a\x13gV[\x03\x90\xFD[\x90V[\x90V[a\x15\xC2a\x15\xBDa\x15\xC7\x92a\x15\xABV[a\x02HV[a\x04\xCBV[\x90V[\x90\x82_\x93\x92\x82^\x01RV[a\x15\xF4a\x15\xFD` \x93a\x16\x02\x93a\x15\xEB\x81a\x07<V[\x93\x84\x80\x93a\x02sV[\x95\x86\x91\x01a\x15\xCAV[a\0\x82V[\x01\x90V[a\x16\x1B\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x15\xD5V[\x90V[a\x168a\x163a\x16-\x83a\x06KV[\x92a\x06EV[a\x11\xE1V[\x90` \x81\x10a\x16FW[P\x90V[a\x16X\x90_\x19\x90` \x03`\x08\x02a\x07\x91V[\x16_a\x16BV[a\x16ka\x16p\x91a\x12\xC6V[a\x07\xBAV[\x90V[a\x16\x87a\x16\x82a\x16\x8C\x92a\x04\xCBV[a\x04wV[a\x04tV[\x90V[a\x16\x97a\x11\x01V[Pa\x16\xA1\x81a\x06BV[\x90a\x16\xAB\x82a\x06KV[a\x16\xBEa\x16\xB8`\x1Fa\x15\xAEV[\x91a\x04\xCBV[\x11a\x16\xF3WPa\x16\xEB\x81a\x16\xE5a\x16\xDFa\x16\xDAa\x16\xF0\x95a\x16\x1EV[a\x16_V[\x91a\x06KV[\x17a\x16sV[a\t\xAEV[\x90V[a\x17\x15\x90a\x16\xFFa\0xV[\x91\x82\x91c0Z'\xA9`\xE0\x1B\x83R`\x04\x83\x01a\x16\x06V[\x03\x90\xFD\xFE`\x80`@R`\x046\x10\x15a\0\x13W[a\x1C>V[a\0\x1D_5a\x03\\V[\x80c\x01\xFF\xC9\xA7\x14a\x03WW\x80c\x06\xFD\xDE\x03\x14a\x03RW\x80c\x07\xA1\xD5\xFA\x14a\x03MW\x80c\t^\xA7\xB3\x14a\x03HW\x80c\x18\x16\r\xDD\x14a\x03CW\x80c\x1B\x02\xF8E\x14a\x03>W\x80c#\xB8r\xDD\x14a\x039W\x80c#\xE1\x13L\x14a\x034W\x80c$\x8A\x9C\xA3\x14a\x03/W\x80c(N\x133\x14a\x03*W\x80c//\xF1]\x14a\x03%W\x80c1<\xE5g\x14a\x03 W\x80c3M\x0B\xBD\x14a\x03\x1BW\x80c6D\xE5\x15\x14a\x03\x16W\x80c6V\x8A\xBE\x14a\x03\x11W\x80cH\xB0\xDA\xA6\x14a\x03\x0CW\x80cK\xDD6\xCE\x14a\x03\x07W\x80cS\xB6J\xCB\x14a\x03\x02W\x80cZ\xDF\0!\x14a\x02\xFDW\x80c_\x15\xC3\xC9\x14a\x02\xF8W\x80cl\xA01\x9B\x14a\x02\xF3W\x80cl\xF0\x16%\x14a\x02\xEEW\x80co?Q\xD9\x14a\x02\xE9W\x80cp\xA0\x821\x14a\x02\xE4W\x80cvg\x18\x08\x14a\x02\xDFW\x80c{:\x12\x86\x14a\x02\xDAW\x80c~\xCE\xBE\0\x14a\x02\xD5W\x80c\x84\xB0\x19n\x14a\x02\xD0W\x80c\x90-U\xA5\x14a\x02\xCBW\x80c\x91\xD1HT\x14a\x02\xC6W\x80c\x95\xD8\x9BA\x14a\x02\xC1W\x80c\x9B~\xF6K\x14a\x02\xBCW\x80c\xA0&Y\x9A\x14a\x02\xB7W\x80c\xA1\xFA\xB7e\x14a\x02\xB2W\x80c\xA2\x17\xFD\xDF\x14a\x02\xADW\x80c\xA3*\xDE\xF8\x14a\x02\xA8W\x80c\xA3\xC5s\xEB\x14a\x02\xA3W\x80c\xA7\x0B\x9F\x0C\x14a\x02\x9EW\x80c\xA9\x05\x9C\xBB\x14a\x02\x99W\x80c\xAF*\xA6;\x14a\x02\x94W\x80c\xB5\x18\xA6\x87\x14a\x02\x8FW\x80c\xBA\xBC9O\x14a\x02\x8AW\x80c\xBD\x02\xDC%\x14a\x02\x85W\x80c\xC1#\x03\xB3\x14a\x02\x80W\x80c\xC5P\x0C\xC3\x14a\x02{W\x80c\xD5\x05\xAC\xCF\x14a\x02vW\x80c\xD5Gt\x1F\x14a\x02qW\x80c\xDDb\xED>\x14a\x02lW\x80c\xDD\x8C>]\x14a\x02gW\x80c\xE3\xAB\xDF\xCB\x14a\x02bW\x80c\xE7\x7F\x9C\xEC\x14a\x02]Wc\xF5\x08\xE1\x9D\x03a\0\x0EWa\x1C\tV[a\x1B\xC5V[a\x1B\x81V[a\x1B\x1DV[a\x1A\xE7V[a\x1A\x86V[a\x1ALV[a\x19\x84V[a\x18\xFBV[a\x18\x86V[a\x18>V[a\x17\xCBV[a\x17VV[a\x16\xABV[a\x16vV[a\x16\x08V[a\x15~V[a\x15\tV[a\x14\x99V[a\x14$V[a\x13\xAFV[a\x139V[a\x13\x03V[a\x12\xCEV[a\x12QV[a\x11\nV[a\x10\xD5V[a\x0F\x06V[a\x0E\xC2V[a\x0EoV[a\r\xFAV[a\r\x84V[a\r\x0FV[a\x0C\xA3V[a\x0C.V[a\x0B\x1BV[a\n\xE6V[a\n\xA3V[a\nnV[a\n9V[a\tHV[a\x08\xECV[a\x08\x8CV[a\x08WV[a\x07\xBCV[a\x07CV[a\x06\xD6V[a\x06\x9CV[a\x06DV[a\x05\x95V[a\x04\x97V[a\x03\xE8V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x03\x89\x81a\x03tV[\x03a\x03\x90WV[_\x80\xFD[\x90P5\x90a\x03\xA1\x82a\x03\x80V[V[\x90` \x82\x82\x03\x12a\x03\xBCWa\x03\xB9\x91_\x01a\x03\x94V[\x90V[a\x03lV[\x15\x15\x90V[a\x03\xCF\x90a\x03\xC1V[\x90RV[\x91\x90a\x03\xE6\x90_` \x85\x01\x94\x01\x90a\x03\xC6V[V[4a\x04\x18Wa\x04\x14a\x04\x03a\x03\xFE6`\x04a\x03\xA3V[a\x1CFV[a\x04\x0Ba\x03bV[\x91\x82\x91\x82a\x03\xD3V[\x03\x90\xF3[a\x03hV[_\x91\x03\x12a\x04'WV[a\x03lV[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x04ma\x04v` \x93a\x04{\x93a\x04d\x81a\x04,V[\x93\x84\x80\x93a\x040V[\x95\x86\x91\x01a\x049V[a\x04DV[\x01\x90V[a\x04\x94\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x04NV[\x90V[4a\x04\xC7Wa\x04\xA76`\x04a\x04\x1DV[a\x04\xC3a\x04\xB2a\x1DdV[a\x04\xBAa\x03bV[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xF3[a\x03hV[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x04\xE0\x90a\x04\xCCV[\x90V[a\x04\xEC\x90a\x04\xD7V[\x90RV[c\xFF\xFF\xFF\xFF\x16\x90V[a\x05\x02\x90a\x04\xF0V[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[a\x052a\x05;` \x93a\x05@\x93a\x05)\x81a\x05\x06V[\x93\x84\x80\x93a\x05\nV[\x95\x86\x91\x01a\x049V[a\x04DV[\x01\x90V[\x91\x93a\x05{a\x05\x92\x96\x94a\x05qa\x05\x85\x94\x97a\x05g`\xA0\x88\x01\x99_\x89\x01\x90a\x04\xE3V[` \x87\x01\x90a\x04\xE3V[`@\x85\x01\x90a\x04\xE3V[``\x83\x01\x90a\x04\xF9V[`\x80\x81\x84\x03\x91\x01Ra\x05\x13V[\x90V[4a\x05\xC9Wa\x05\xA56`\x04a\x04\x1DV[a\x05\xC5a\x05\xB0a\x1D\xE0V[\x91a\x05\xBC\x95\x93\x95a\x03bV[\x95\x86\x95\x86a\x05DV[\x03\x90\xF3[a\x03hV[a\x05\xD7\x81a\x04\xD7V[\x03a\x05\xDEWV[_\x80\xFD[\x90P5\x90a\x05\xEF\x82a\x05\xCEV[V[\x90V[a\x05\xFD\x81a\x05\xF1V[\x03a\x06\x04WV[_\x80\xFD[\x90P5\x90a\x06\x15\x82a\x05\xF4V[V[\x91\x90`@\x83\x82\x03\x12a\x06?W\x80a\x063a\x06<\x92_\x86\x01a\x05\xE2V[\x93` \x01a\x06\x08V[\x90V[a\x03lV[4a\x06uWa\x06qa\x06`a\x06Z6`\x04a\x06\x17V[\x90a\x1EJV[a\x06ha\x03bV[\x91\x82\x91\x82a\x03\xD3V[\x03\x90\xF3[a\x03hV[a\x06\x83\x90a\x05\xF1V[\x90RV[\x91\x90a\x06\x9A\x90_` \x85\x01\x94\x01\x90a\x06zV[V[4a\x06\xCCWa\x06\xAC6`\x04a\x04\x1DV[a\x06\xC8a\x06\xB7a\x1E\x91V[a\x06\xBFa\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[_\x01\x90V[4a\x07\x04Wa\x06\xE66`\x04a\x04\x1DV[a\x06\xEEa#gV[a\x06\xF6a\x03bV[\x80a\x07\0\x81a\x06\xD1V[\x03\x90\xF3[a\x03hV[\x90\x91``\x82\x84\x03\x12a\x07>Wa\x07;a\x07$\x84_\x85\x01a\x05\xE2V[\x93a\x072\x81` \x86\x01a\x05\xE2V[\x93`@\x01a\x06\x08V[\x90V[a\x03lV[4a\x07tWa\x07pa\x07_a\x07Y6`\x04a\x07\tV[\x91a#qV[a\x07ga\x03bV[\x91\x82\x91\x82a\x03\xD3V[\x03\x90\xF3[a\x03hV[\x90V[\x90V[a\x07\x93a\x07\x8Ea\x07\x98\x92a\x07yV[a\x07|V[a\x05\xF1V[\x90V[a\x07\xAEi\x04\x04\xF6JVZ\x19t\0\0a\x07\x7FV[\x90V[a\x07\xB9a\x07\x9BV[\x90V[4a\x07\xECWa\x07\xCC6`\x04a\x04\x1DV[a\x07\xE8a\x07\xD7a\x07\xB1V[a\x07\xDFa\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[\x90V[a\x07\xFD\x81a\x07\xF1V[\x03a\x08\x04WV[_\x80\xFD[\x90P5\x90a\x08\x15\x82a\x07\xF4V[V[\x90` \x82\x82\x03\x12a\x080Wa\x08-\x91_\x01a\x08\x08V[\x90V[a\x03lV[a\x08>\x90a\x07\xF1V[\x90RV[\x91\x90a\x08U\x90_` \x85\x01\x94\x01\x90a\x085V[V[4a\x08\x87Wa\x08\x83a\x08ra\x08m6`\x04a\x08\x17V[a#\xEAV[a\x08za\x03bV[\x91\x82\x91\x82a\x08BV[\x03\x90\xF3[a\x03hV[4a\x08\xBAWa\x08\x9C6`\x04a\x04\x1DV[a\x08\xA4a(\x8EV[a\x08\xACa\x03bV[\x80a\x08\xB6\x81a\x06\xD1V[\x03\x90\xF3[a\x03hV[\x91\x90`@\x83\x82\x03\x12a\x08\xE7W\x80a\x08\xDBa\x08\xE4\x92_\x86\x01a\x08\x08V[\x93` \x01a\x05\xE2V[\x90V[a\x03lV[4a\t\x1BWa\t\x05a\x08\xFF6`\x04a\x08\xBFV[\x90a+\xEFV[a\t\ra\x03bV[\x80a\t\x17\x81a\x06\xD1V[\x03\x90\xF3[a\x03hV[`\xFF\x16\x90V[a\t/\x90a\t V[\x90RV[\x91\x90a\tF\x90_` \x85\x01\x94\x01\x90a\t&V[V[4a\txWa\tX6`\x04a\x04\x1DV[a\tta\tca,\x1EV[a\tka\x03bV[\x91\x82\x91\x82a\t3V[\x03\x90\xF3[a\x03hV[\x90` \x82\x82\x03\x12a\t\x96Wa\t\x93\x91_\x01a\x06\x08V[\x90V[a\x03lV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[P`0\x90V[\x90V[a\t\xC1\x81a\t\xAFV[\x82\x10\x15a\t\xDBWa\t\xD3`\x01\x91a\t\xB5V[\x91\x02\x01\x90_\x90V[a\t\x9BV[\x1C\x90V[\x90V[a\t\xF7\x90`\x08a\t\xFC\x93\x02a\t\xE0V[a\t\xE4V[\x90V[\x90a\n\n\x91Ta\t\xE7V[\x90V[`\x11a\n\x18\x81a\t\xAFV[\x82\x10\x15a\n5Wa\n2\x91a\n,\x91a\t\xB8V[\x90a\t\xFFV[\x90V[_\x80\xFD[4a\niWa\nea\nTa\nO6`\x04a\t}V[a\n\rV[a\n\\a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[4a\n\x9EWa\n~6`\x04a\x04\x1DV[a\n\x9Aa\n\x89a,4V[a\n\x91a\x03bV[\x91\x82\x91\x82a\x08BV[\x03\x90\xF3[a\x03hV[4a\n\xD2Wa\n\xBCa\n\xB66`\x04a\x08\xBFV[\x90a,HV[a\n\xC4a\x03bV[\x80a\n\xCE\x81a\x06\xD1V[\x03\x90\xF3[a\x03hV[a\n\xE3`\n_\x90a\t\xFFV[\x90V[4a\x0B\x16Wa\n\xF66`\x04a\x04\x1DV[a\x0B\x12a\x0B\x01a\n\xD7V[a\x0B\ta\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[4a\x0BKWa\x0B+6`\x04a\x04\x1DV[a\x0BGa\x0B6a,\x90V[a\x0B>a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[a\x0BY\x81a\x04\xF0V[\x03a\x0B`WV[_\x80\xFD[\x90P5\x90a\x0Bq\x82a\x0BPV[V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x0B\xB9W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x0B\xB4W` \x01\x92`\x01\x83\x02\x84\x01\x11a\x0B\xAFWV[a\x0B{V[a\x0BwV[a\x0BsV[\x91\x90\x91`\xA0\x81\x84\x03\x12a\x0C)Wa\x0B\xD7\x83_\x83\x01a\x05\xE2V[\x92a\x0B\xE5\x81` \x84\x01a\x05\xE2V[\x92a\x0B\xF3\x82`@\x85\x01a\x05\xE2V[\x92a\x0C\x01\x83``\x83\x01a\x0BdV[\x92`\x80\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x0C$Wa\x0C \x92\x01a\x0B\x7FV[\x90\x91V[a\x03pV[a\x03lV[4a\x0CcWa\x0CMa\x0CA6`\x04a\x0B\xBEV[\x94\x93\x90\x93\x92\x91\x92a2\xD1V[a\x0CUa\x03bV[\x80a\x0C_\x81a\x06\xD1V[\x03\x90\xF3[a\x03hV[`\xFF\x16\x90V[a\x0C~\x90`\x08a\x0C\x83\x93\x02a\t\xE0V[a\x0ChV[\x90V[\x90a\x0C\x91\x91Ta\x0CnV[\x90V[a\x0C\xA0`\t_\x90a\x0C\x86V[\x90V[4a\x0C\xD3Wa\x0C\xB36`\x04a\x04\x1DV[a\x0C\xCFa\x0C\xBEa\x0C\x94V[a\x0C\xC6a\x03bV[\x91\x82\x91\x82a\x03\xD3V[\x03\x90\xF3[a\x03hV[\x90V[a\x0C\xEFa\x0C\xEAa\x0C\xF4\x92a\x0C\xD8V[a\x07|V[a\x05\xF1V[\x90V[a\r\x01`0a\x0C\xDBV[\x90V[a\r\x0Ca\x0C\xF7V[\x90V[4a\r?Wa\r\x1F6`\x04a\x04\x1DV[a\r;a\r*a\r\x04V[a\r2a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[\x90V[a\r[a\rVa\r`\x92a\rDV[a\x07|V[a\x05\xF1V[\x90V[a\rvi\x1F\x03\x9C\xCDe\xA9\xBE\xF0\0\0a\rGV[\x90V[a\r\x81a\rcV[\x90V[4a\r\xB4Wa\r\x946`\x04a\x04\x1DV[a\r\xB0a\r\x9Fa\ryV[a\r\xA7a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[\x90V[a\r\xD0a\r\xCBa\r\xD5\x92a\r\xB9V[a\x07|V[a\x05\xF1V[\x90V[a\r\xECj\x08E\x95\x16\x14\x01HJ\0\0\0a\r\xBCV[\x90V[a\r\xF7a\r\xD8V[\x90V[4a\x0E*Wa\x0E\n6`\x04a\x04\x1DV[a\x0E&a\x0E\x15a\r\xEFV[a\x0E\x1Da\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[\x90V[a\x0EFa\x0EAa\x0EK\x92a\x0E/V[a\x07|V[a\x05\xF1V[\x90V[a\x0Eai\x12\x9B\xC4{<\xFFr\x90\0\0a\x0E2V[\x90V[a\x0Ela\x0ENV[\x90V[4a\x0E\x9FWa\x0E\x7F6`\x04a\x04\x1DV[a\x0E\x9Ba\x0E\x8Aa\x0EdV[a\x0E\x92a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[\x90` \x82\x82\x03\x12a\x0E\xBDWa\x0E\xBA\x91_\x01a\x05\xE2V[\x90V[a\x03lV[4a\x0E\xF2Wa\x0E\xEEa\x0E\xDDa\x0E\xD86`\x04a\x0E\xA4V[a2\xF7V[a\x0E\xE5a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[a\x0F\x03`\x0B_\x90a\t\xFFV[\x90V[4a\x0F6Wa\x0F\x166`\x04a\x04\x1DV[a\x0F2a\x0F!a\x0E\xF7V[a\x0F)a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x0F\x82W[` \x83\x10\x14a\x0F}WV[a\x0FNV[\x91`\x7F\x16\x91a\x0FrV[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x0F\xB8a\x0F\xB1\x83a\x0FbV[\x80\x94a\x0F\x8CV[\x91`\x01\x81\x16\x90\x81_\x14a\x10\x0FWP`\x01\x14a\x0F\xD3W[PPPV[a\x0F\xE0\x91\x92\x93\x94Pa\x0F\x95V[\x91_\x92[\x81\x84\x10a\x0F\xF7WPP\x01\x90_\x80\x80a\x0F\xCEV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x0F\xE4V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x0F\xCEV[\x90a\x104\x91a\x0F\x9EV[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x10U\x90a\x04DV[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x10oW`@RV[a\x107V[\x90a\x10\x94a\x10\x8D\x92a\x10\x84a\x03bV[\x93\x84\x80\x92a\x10*V[\x03\x83a\x10KV[V[\x90_\x10a\x10\xA9Wa\x10\xA6\x90a\x10tV[\x90V[a\x0F;V[a\x10\xBA`\x10_\x90a\x10\x96V[\x90V[a\x10\xD2\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x05\x13V[\x90V[4a\x11\x05Wa\x10\xE56`\x04a\x04\x1DV[a\x11\x01a\x10\xF0a\x10\xAEV[a\x10\xF8a\x03bV[\x91\x82\x91\x82a\x10\xBDV[\x03\x90\xF3[a\x03hV[4a\x11:Wa\x116a\x11%a\x11 6`\x04a\x0E\xA4V[a3\x15V[a\x11-a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[`\xFF`\xF8\x1B\x16\x90V[a\x11Q\x90a\x11?V[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\x11q\x90a\x05\xF1V[\x90RV[\x90a\x11\x82\x81` \x93a\x11hV[\x01\x90V[` \x01\x90V[\x90a\x11\xA9a\x11\xA3a\x11\x9C\x84a\x11UV[\x80\x93a\x11YV[\x92a\x11bV[\x90_[\x81\x81\x10a\x11\xB9WPPP\x90V[\x90\x91\x92a\x11\xD2a\x11\xCC`\x01\x92\x86Qa\x11uV[\x94a\x11\x86V[\x91\x01\x91\x90\x91a\x11\xACV[\x93\x95\x91\x94a\x12-a\x12\"a\x12A\x95a\x12\x14a\x127\x95a\x12N\x9C\x9Aa\x12\x07`\xE0\x8C\x01\x92_\x8D\x01\x90a\x11HV[\x8A\x82\x03` \x8C\x01Ra\x04NV[\x90\x88\x82\x03`@\x8A\x01Ra\x04NV[\x97``\x87\x01\x90a\x06zV[`\x80\x85\x01\x90a\x04\xE3V[`\xA0\x83\x01\x90a\x085V[`\xC0\x81\x84\x03\x91\x01Ra\x11\x8CV[\x90V[4a\x12\x88Wa\x12a6`\x04a\x04\x1DV[a\x12\x84a\x12la3\xBCV[\x93a\x12{\x97\x95\x97\x93\x91\x93a\x03bV[\x97\x88\x97\x88a\x11\xDCV[\x03\x90\xF3[a\x03hV[\x90V[a\x12\xA4a\x12\x9Fa\x12\xA9\x92a\x12\x8DV[a\x07|V[a\x05\xF1V[\x90V[a\x12\xC0jR\xB7\xD2\xDC\xC8\x0C\xD2\xE4\0\0\0a\x12\x90V[\x90V[a\x12\xCBa\x12\xACV[\x90V[4a\x12\xFEWa\x12\xDE6`\x04a\x04\x1DV[a\x12\xFAa\x12\xE9a\x12\xC3V[a\x12\xF1a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[4a\x134Wa\x130a\x13\x1Fa\x13\x196`\x04a\x08\xBFV[\x90a4\\V[a\x13'a\x03bV[\x91\x82\x91\x82a\x03\xD3V[\x03\x90\xF3[a\x03hV[4a\x13iWa\x13I6`\x04a\x04\x1DV[a\x13ea\x13Ta4\x86V[a\x13\\a\x03bV[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xF3[a\x03hV[\x90V[a\x13\x85a\x13\x80a\x13\x8A\x92a\x13nV[a\x07|V[a\x05\xF1V[\x90V[a\x13\xA1jJr=\xC6\xB4\x0B\x8A\x9A\0\0\0a\x13qV[\x90V[a\x13\xACa\x13\x8DV[\x90V[4a\x13\xDFWa\x13\xBF6`\x04a\x04\x1DV[a\x13\xDBa\x13\xCAa\x13\xA4V[a\x13\xD2a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[\x90V[a\x13\xFBa\x13\xF6a\x14\0\x92a\x13\xE4V[a\x07|V[a\x05\xF1V[\x90V[a\x14\x16iV&v\x0C\x16b\xBE$\0\0a\x13\xE7V[\x90V[a\x14!a\x14\x03V[\x90V[4a\x14TWa\x1446`\x04a\x04\x1DV[a\x14Pa\x14?a\x14\x19V[a\x14Ga\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[\x90V[a\x14pa\x14ka\x14u\x92a\x14YV[a\x07|V[a\x05\xF1V[\x90V[a\x14\x8Bi\x0B*H=m\xAD\xEE\x18\0\0a\x14\\V[\x90V[a\x14\x96a\x14xV[\x90V[4a\x14\xC9Wa\x14\xA96`\x04a\x04\x1DV[a\x14\xC5a\x14\xB4a\x14\x8EV[a\x14\xBCa\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[\x90V[_\x1B\x90V[a\x14\xEAa\x14\xE5a\x14\xEF\x92a\x14\xCEV[a\x14\xD1V[a\x07\xF1V[\x90V[a\x14\xFB_a\x14\xD6V[\x90V[a\x15\x06a\x14\xF2V[\x90V[4a\x159Wa\x15\x196`\x04a\x04\x1DV[a\x155a\x15$a\x14\xFEV[a\x15,a\x03bV[\x91\x82\x91\x82a\x08BV[\x03\x90\xF3[a\x03hV[\x90V[a\x15Ua\x15Pa\x15Z\x92a\x15>V[a\x07|V[a\x05\xF1V[\x90V[a\x15pi3\xB0\xB0\0\xFE\xC5\x93\x90\0\0a\x15AV[\x90V[a\x15{a\x15]V[\x90V[4a\x15\xAEWa\x15\x8E6`\x04a\x04\x1DV[a\x15\xAAa\x15\x99a\x15sV[a\x15\xA1a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x15\xCE\x90`\x08a\x15\xD3\x93\x02a\t\xE0V[a\x15\xB3V[\x90V[\x90a\x15\xE1\x91Ta\x15\xBEV[\x90V[a\x15\xF0`\r_\x90a\x15\xD6V[\x90V[\x91\x90a\x16\x06\x90_` \x85\x01\x94\x01\x90a\x04\xE3V[V[4a\x168Wa\x16\x186`\x04a\x04\x1DV[a\x164a\x16#a\x15\xE4V[a\x16+a\x03bV[\x91\x82\x91\x82a\x15\xF3V[\x03\x90\xF3[a\x03hV[\x90V[a\x16Ta\x16Oa\x16Y\x92a\x16=V[a\x07|V[a\x05\xF1V[\x90V[a\x16hb'\x8D\0a\x16@V[\x90V[a\x16sa\x16\\V[\x90V[4a\x16\xA6Wa\x16\x866`\x04a\x04\x1DV[a\x16\xA2a\x16\x91a\x16kV[a\x16\x99a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[4a\x16\xDCWa\x16\xD8a\x16\xC7a\x16\xC16`\x04a\x06\x17V[\x90a4\x9CV[a\x16\xCFa\x03bV[\x91\x82\x91\x82a\x03\xD3V[\x03\x90\xF3[a\x03hV[P`0\x90V[\x90P\x90V[\x90V[` \x01\x90V[a\x17\x11a\x17\x0Ba\x17\x04\x83a\x16\xE1V[\x80\x94a\x16\xE7V[\x91a\x16\xECV[_\x91[\x83\x83\x10a\x17!WPPPPV[a\x177a\x171`\x01\x92\x84Qa\x11uV[\x92a\x16\xEFV[\x92\x01\x91\x90a\x17\x14V[\x91\x90a\x17T\x90_a\x06\0\x85\x01\x94\x01\x90a\x16\xF5V[V[4a\x17\x86Wa\x17f6`\x04a\x04\x1DV[a\x17\x82a\x17qa5\xC3V[a\x17ya\x03bV[\x91\x82\x91\x82a\x17@V[\x03\x90\xF3[a\x03hV[\x90V[a\x17\xA2a\x17\x9Da\x17\xA7\x92a\x17\x8BV[a\x07|V[a\x05\xF1V[\x90V[a\x17\xBDi\x06\xB2\xEF\xD1:\x96*l\0\0a\x17\x8EV[\x90V[a\x17\xC8a\x17\xAAV[\x90V[4a\x17\xFBWa\x17\xDB6`\x04a\x04\x1DV[a\x17\xF7a\x17\xE6a\x17\xC0V[a\x17\xEEa\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[a\x185a\x18<\x94a\x18+``\x94\x98\x97\x95a\x18!`\x80\x86\x01\x9A_\x87\x01\x90a\x06zV[` \x85\x01\x90a\x06zV[`@\x83\x01\x90a\x06zV[\x01\x90a\x03\xC6V[V[4a\x18rWa\x18N6`\x04a\x04\x1DV[a\x18na\x18Ya6\x0EV[\x90a\x18e\x94\x92\x94a\x03bV[\x94\x85\x94\x85a\x18\0V[\x03\x90\xF3[a\x03hV[a\x18\x83`\x0F_\x90a\x15\xD6V[\x90V[4a\x18\xB6Wa\x18\x966`\x04a\x04\x1DV[a\x18\xB2a\x18\xA1a\x18wV[a\x18\xA9a\x03bV[\x91\x82\x91\x82a\x15\xF3V[\x03\x90\xF3[a\x03hV[\x90V[a\x18\xD2a\x18\xCDa\x18\xD7\x92a\x18\xBBV[a\x07|V[a\x05\xF1V[\x90V[a\x18\xEDi\x8F\x95oiz\xA4\x92<\0\0a\x18\xBEV[\x90V[a\x18\xF8a\x18\xDAV[\x90V[4a\x19+Wa\x19\x0B6`\x04a\x04\x1DV[a\x19'a\x19\x16a\x18\xF0V[a\x19\x1Ea\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[c\xFF\xFF\xFF\xFF\x16\x90V[a\x19I\x90`\x08a\x19N\x93\x02a\t\xE0V[a\x190V[\x90V[\x90a\x19\\\x91Ta\x199V[\x90V[a\x19l`\x0F`\x14\x90a\x19QV[\x90V[\x91\x90a\x19\x82\x90_` \x85\x01\x94\x01\x90a\x04\xF9V[V[4a\x19\xB4Wa\x19\x946`\x04a\x04\x1DV[a\x19\xB0a\x19\x9Fa\x19_V[a\x19\xA7a\x03bV[\x91\x82\x91\x82a\x19oV[\x03\x90\xF3[a\x03hV[a\x19\xC2\x81a\t V[\x03a\x19\xC9WV[_\x80\xFD[\x90P5\x90a\x19\xDA\x82a\x19\xB9V[V[`\xE0\x81\x83\x03\x12a\x1AGWa\x19\xF2\x82_\x83\x01a\x05\xE2V[\x92a\x1A\0\x83` \x84\x01a\x05\xE2V[\x92a\x1A\x0E\x81`@\x85\x01a\x06\x08V[\x92a\x1A\x1C\x82``\x83\x01a\x06\x08V[\x92a\x1ADa\x1A-\x84`\x80\x85\x01a\x19\xCDV[\x93a\x1A;\x81`\xA0\x86\x01a\x08\x08V[\x93`\xC0\x01a\x08\x08V[\x90V[a\x03lV[4a\x1A\x81Wa\x1Aka\x1A_6`\x04a\x19\xDCV[\x95\x94\x90\x94\x93\x91\x93a87V[a\x1Asa\x03bV[\x80a\x1A}\x81a\x06\xD1V[\x03\x90\xF3[a\x03hV[4a\x1A\xB5Wa\x1A\x9Fa\x1A\x996`\x04a\x08\xBFV[\x90a9UV[a\x1A\xA7a\x03bV[\x80a\x1A\xB1\x81a\x06\xD1V[\x03\x90\xF3[a\x03hV[\x91\x90`@\x83\x82\x03\x12a\x1A\xE2W\x80a\x1A\xD6a\x1A\xDF\x92_\x86\x01a\x05\xE2V[\x93` \x01a\x05\xE2V[\x90V[a\x03lV[4a\x1B\x18Wa\x1B\x14a\x1B\x03a\x1A\xFD6`\x04a\x1A\xBAV[\x90a9wV[a\x1B\x0Ba\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[4a\x1BMWa\x1B-6`\x04a\x04\x1DV[a\x1BIa\x1B8a9\x9FV[a\x1B@a\x03bV[\x91\x82\x91\x82a\x03\xD3V[\x03\x90\xF3[a\x03hV[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[a\x1B~a\x1BRV[\x90V[4a\x1B\xB1Wa\x1B\x916`\x04a\x04\x1DV[a\x1B\xADa\x1B\x9Ca\x1BvV[a\x1B\xA4a\x03bV[\x91\x82\x91\x82a\x08BV[\x03\x90\xF3[a\x03hV[a\x1B\xC2`\x0E_\x90a\x15\xD6V[\x90V[4a\x1B\xF5Wa\x1B\xD56`\x04a\x04\x1DV[a\x1B\xF1a\x1B\xE0a\x1B\xB6V[a\x1B\xE8a\x03bV[\x91\x82\x91\x82a\x15\xF3V[\x03\x90\xF3[a\x03hV[a\x1C\x06`\x0C_\x90a\t\xFFV[\x90V[4a\x1C9Wa\x1C\x196`\x04a\x04\x1DV[a\x1C5a\x1C$a\x1B\xFAV[a\x1C,a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[_\x80\xFD[_\x90V[a\x1CNa\x1CBV[P\x80a\x1Cia\x1Cccye\xDB\x0B`\xE0\x1Ba\x03tV[\x91a\x03tV[\x14\x90\x81\x15a\x1CvW[P\x90V[a\x1C\x80\x91Pa9\xD0V[_a\x1CrV[``\x90V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x1C\xB7a\x1C\xB0\x83a\x0FbV[\x80\x94a\x1C\x8BV[\x91`\x01\x81\x16\x90\x81_\x14a\x1D\x0EWP`\x01\x14a\x1C\xD2W[PPPV[a\x1C\xDF\x91\x92\x93\x94Pa\x1C\x94V[\x91_\x92[\x81\x84\x10a\x1C\xF6WPP\x01\x90_\x80\x80a\x1C\xCDV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x1C\xE3V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x1C\xCDV[\x90a\x1D3\x91a\x1C\x9DV[\x90V[\x90a\x1DVa\x1DO\x92a\x1DFa\x03bV[\x93\x84\x80\x92a\x1D)V[\x03\x83a\x10KV[V[a\x1Da\x90a\x1D6V[\x90V[a\x1Dla\x1C\x86V[Pa\x1Dw`\x03a\x1DXV[\x90V[_\x90V[_\x90V[``\x90V[_\x1C\x90V[a\x1D\x98a\x1D\x9D\x91a\x1D\x87V[a\x15\xB3V[\x90V[a\x1D\xAA\x90Ta\x1D\x8CV[\x90V[`\xA0\x1C\x90V[a\x1D\xBFa\x1D\xC4\x91a\x1D\xADV[a\x190V[\x90V[a\x1D\xD1\x90Ta\x1D\xB3V[\x90V[a\x1D\xDD\x90a\x10tV[\x90V[a\x1D\xE8a\x1DzV[Pa\x1D\xF1a\x1DzV[Pa\x1D\xFAa\x1DzV[Pa\x1E\x03a\x1D~V[Pa\x1E\x0Ca\x1D\x82V[Pa\x1E\x17`\ra\x1D\xA0V[a\x1E!`\x0Ea\x1D\xA0V[\x91a\x1E,`\x0Fa\x1D\xA0V[\x91a\x1E7`\x0Fa\x1D\xC7V[\x91a\x1EG`\x10\x92\x95\x94\x93\x92a\x1D\xD4V[\x90V[a\x1Eg\x91a\x1EVa\x1CBV[Pa\x1E_a9\xF6V[\x91\x90\x91a:\x03V[`\x01\x90V[_\x90V[a\x1E|a\x1E\x81\x91a\x1D\x87V[a\t\xE4V[\x90V[a\x1E\x8E\x90Ta\x1EpV[\x90V[a\x1E\x99a\x1ElV[Pa\x1E\xA4`\x02a\x1E\x84V[\x90V[a\x1E\xB7a\x1E\xB2a\x1BRV[a:\x13V[a\x1E\xBFa\"JV[V[a\x1E\xCDa\x1E\xD2\x91a\x1D\x87V[a\x0ChV[\x90V[a\x1E\xDF\x90Ta\x1E\xC1V[\x90V[_\x7FEmissions already started\0\0\0\0\0\0\0\x91\x01RV[a\x1F\x16`\x19` \x92a\x040V[a\x1F\x1F\x81a\x1E\xE2V[\x01\x90V[a\x1F8\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x1F\tV[\x90V[\x15a\x1FBWV[a\x1FJa\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x1F``\x04\x82\x01a\x1F#V[\x03\x90\xFD[a\x1Fxa\x1Fsa\x1F}\x92a\x14\xCEV[a\x07|V[a\x04\xCCV[\x90V[a\x1F\x89\x90a\x1FdV[\x90V[_\x7FBridge address not set\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x1F\xC0`\x16` \x92a\x040V[a\x1F\xC9\x81a\x1F\x8CV[\x01\x90V[a\x1F\xE2\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x1F\xB3V[\x90V[\x15a\x1F\xECWV[a\x1F\xF4a\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a \n`\x04\x82\x01a\x1F\xCDV[\x03\x90\xFD[_\x7FL2 token address not set\0\0\0\0\0\0\0\0\x91\x01RV[a B`\x18` \x92a\x040V[a K\x81a \x0EV[\x01\x90V[a d\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra 5V[\x90V[\x15a nWV[a va\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a \x8C`\x04\x82\x01a OV[\x03\x90\xFD[_\x7FL2 destination address not set\0\0\x91\x01RV[a \xC4`\x1E` \x92a\x040V[a \xCD\x81a \x90V[\x01\x90V[a \xE6\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra \xB7V[\x90V[\x15a \xF0WV[a \xF8a\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a!\x0E`\x04\x82\x01a \xD1V[\x03\x90\xFD[a!&a!!a!+\x92a\x14\xCEV[a\x07|V[a\x04\xF0V[\x90V[_\x7FBridge gas limit not set\0\0\0\0\0\0\0\0\x91\x01RV[a!b`\x18` \x92a\x040V[a!k\x81a!.V[\x01\x90V[a!\x84\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra!UV[\x90V[\x15a!\x8EWV[a!\x96a\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a!\xAC`\x04\x82\x01a!oV[\x03\x90\xFD[\x90a!\xBC`\xFF\x91a\x14\xD1V[\x91\x81\x19\x16\x91\x16\x17\x90V[a!\xCF\x90a\x03\xC1V[\x90V[\x90V[\x90a!\xEAa!\xE5a!\xF1\x92a!\xC6V[a!\xD2V[\x82Ta!\xB0V[\x90UV[\x90a\"\x01_\x19\x91a\x14\xD1V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\"\x1Fa\"\x1Aa\"$\x92a\x05\xF1V[a\x07|V[a\x05\xF1V[\x90V[\x90V[\x90a\"?a\":a\"F\x92a\"\x0BV[a\"'V[\x82Ta!\xF5V[\x90UV[a\"ea\"`a\"Z`\ta\x1E\xD5V[\x15a\x03\xC1V[a\x1F;V[a\"\x93a\"r`\ra\x1D\xA0V[a\"\x8Ca\"\x86a\"\x81_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14\x15a\x1F\xE5V[a\"\xC1a\"\xA0`\x0Ea\x1D\xA0V[a\"\xBAa\"\xB4a\"\xAF_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14\x15a gV[a\"\xEFa\"\xCE`\x0Fa\x1D\xA0V[a\"\xE8a\"\xE2a\"\xDD_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14\x15a \xE9V[a#\x14a\"\xFC`\x0Fa\x1D\xC7V[a#\x0Ea#\x08_a!\x12V[\x91a\x04\xF0V[\x11a!\x87V[a# `\x01`\ta!\xD5V[a#+B`\na\"*V[Ba#b\x7F\x11\x94\xB04\xCF\xA9\xABX\x07IJ\x1D\\f}\x8B\x0En\x97\xF3\x88\x88t*\xA3\x87\x1A2 4\x11`\x91a#Ya\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xA1V[a#oa\x1E\xA7V[V[\x91a#\x9B\x92a#~a\x1CBV[Pa#\x93a#\x8Aa9\xF6V[\x82\x90\x84\x91a:gV[\x91\x90\x91a:\xF3V[`\x01\x90V[_\x90V[a#\xAD\x90a\x07\xF1V[\x90V[\x90a#\xBA\x90a#\xA4V[_R` R`@_ \x90V[\x90V[a#\xD5a#\xDA\x91a\x1D\x87V[a#\xC6V[\x90V[a#\xE7\x90Ta#\xC9V[\x90V[`\x01a$\x03a$\t\x92a#\xFBa#\xA0V[P`\x05a#\xB0V[\x01a#\xDDV[\x90V[_\x7FEmissions not started\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a$@`\x15` \x92a\x040V[a$I\x81a$\x0CV[\x01\x90V[a$b\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra$3V[\x90V[\x15a$lWV[a$ta\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a$\x8A`\x04\x82\x01a$MV[\x03\x90\xFD[_\x7FAll emissions completed\0\0\0\0\0\0\0\0\0\x91\x01RV[a$\xC2`\x17` \x92a\x040V[a$\xCB\x81a$\x8EV[\x01\x90V[a$\xE4\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra$\xB5V[\x90V[\x15a$\xEEWV[a$\xF6a\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a%\x0C`\x04\x82\x01a$\xCFV[\x03\x90\xFD[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a%3a%9\x91\x93\x92\x93a\x05\xF1V[\x92a\x05\xF1V[\x82\x03\x91\x82\x11a%DWV[a%\x10V[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a%ia%o\x91a\x05\xF1V[\x91a\x05\xF1V[\x90\x81\x15a%zW\x04\x90V[a%IV[_\x7FCurrent epoch already minted\0\0\0\0\x91\x01RV[a%\xB3`\x1C` \x92a\x040V[a%\xBC\x81a%\x7FV[\x01\x90V[a%\xD5\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra%\xA6V[\x90V[\x15a%\xDFWV[a%\xE7a\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a%\xFD`\x04\x82\x01a%\xC0V[\x03\x90\xFD[a&\x15a&\x10a&\x1A\x92a\x14\xCEV[a\x07|V[a\x05\xF1V[\x90V[`\x01a&)\x91\x01a\x05\xF1V[\x90V[a&;a&A\x91\x93\x92\x93a\x05\xF1V[\x92a\x05\xF1V[\x82\x01\x80\x92\x11a&LWV[a%\x10V[_\x7FCannot exceed emissions supply\0\0\x91\x01RV[a&\x85`\x1E` \x92a\x040V[a&\x8E\x81a&QV[\x01\x90V[a&\xA7\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra&xV[\x90V[\x15a&\xB1WV[a&\xB9a\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a&\xCF`\x04\x82\x01a&\x92V[\x03\x90\xFD[a&\xE7a&\xE2a&\xEC\x92a\x04\xCCV[a\x07|V[a\x04\xCCV[\x90V[a&\xF8\x90a&\xD3V[\x90V[a'\x04\x90a&\xEFV[\x90V[a'\x10\x90a&\xD3V[\x90V[a'\x1C\x90a'\x07V[\x90V[a'(\x90a&\xEFV[\x90V[_\x80\xFD[`\xE0\x1B\x90V[_\x91\x03\x12a'?WV[a\x03lV[\x90_\x92\x91\x80T\x90a'^a'W\x83a\x0FbV[\x80\x94a\x05\nV[\x91`\x01\x81\x16\x90\x81_\x14a'\xB5WP`\x01\x14a'yW[PPPV[a'\x86\x91\x92\x93\x94Pa\x0F\x95V[\x91_\x92[\x81\x84\x10a'\x9DWPP\x01\x90_\x80\x80a'tV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a'\x8AV[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a'tV[\x92a(-\x96\x94a(\x0Ca(\x16\x92a(\x02a( \x96\x99\x95\x99a'\xF8`\xC0\x8A\x01\x9B_\x8B\x01\x90a\x04\xE3V[` \x89\x01\x90a\x04\xE3V[`@\x87\x01\x90a\x04\xE3V[``\x85\x01\x90a\x06zV[`\x80\x83\x01\x90a\x04\xF9V[`\xA0\x81\x84\x03\x91\x01Ra'DV[\x90V[a(8a\x03bV[=_\x82>=\x90\xFD[\x90V[a(Wa(Ra(\\\x92a(@V[a\x07|V[a\x05\xF1V[\x90V[a(h\x90a&\xEFV[\x90V[\x91` a(\x8C\x92\x94\x93a(\x85`@\x82\x01\x96_\x83\x01\x90a\x06zV[\x01\x90a\x06zV[V[a(\xA0a(\x9B`\ta\x1E\xD5V[a$eV[a(\xCCa(\xAD`\x0Ba\x1E\x84V[a(\xC6a(\xC0a(\xBBa\x0C\xF7V[a\x05\xF1V[\x91a\x05\xF1V[\x10a$\xE7V[a))a(\xF4a(\xE6Ba(\xE0`\na\x1E\x84V[\x90a%$V[a(\xEEa\x16\\V[\x90a%]V[a)\x19\x81a)\x13a)\ra)\x08`\x0Ba\x1E\x84V[a\x05\xF1V[\x91a\x05\xF1V[\x11a%\xD8V[a)#`\x0Ba\x1E\x84V[\x90a%$V[\x90\x81a)Wa)Qa)La)<a\x0C\xF7V[a)F`\x0Ba\x1E\x84V[\x90a%$V[a\x05\xF1V[\x91a\x05\xF1V[\x11a+\xA2W[a)f_a&\x01V[\x90a)p_a&\x01V[\x91[\x82a)\x85a)\x7F\x86a\x05\xF1V[\x91a\x05\xF1V[\x10\x15a)\xCCWa)\xC0a)\xC6\x91a)\xBAa)\xB4`\x11a)\xAEa)\xA7`\x0Ba\x1E\x84V[\x89\x90a&,V[\x90a\t\xB8V[\x90a\t\xFFV[\x90a&,V[\x92a&\x1DV[\x91a)rV[\x91P\x91a*\x1Ca*#\x91a*\ra)\xEDa)\xE6`\x0Ca\x1E\x84V[\x86\x90a&,V[a*\x06a*\0a)\xFBa\r\xD8V[a\x05\xF1V[\x91a\x05\xF1V[\x11\x15a&\xAAV[a*\x17`\x0Ba\x1E\x84V[a&,V[`\x0Ba\"*V[a*@a*9\x82a*4`\x0Ca\x1E\x84V[a&,V[`\x0Ca\"*V[a*Sa*L0a&\xFBV[\x82\x90a;\x90V[a*pa*_0a&\xFBV[a*i`\ra\x1D\xA0V[\x83\x91a:\x03V[a*\x8Aa*\x85a*\x80`\ra\x1D\xA0V[a'\x13V[a'\x1FV[cT\n\xBFsa*\x980a&\xFBV[a*\xA2`\x0Ea\x1D\xA0V[\x92a*\xAD`\x0Fa\x1D\xA0V[\x92\x85a*\xB9`\x0Fa\x1D\xC7V[\x91`\x10\x95\x84;\x15a+\x9DW_\x96a*\xE4\x94\x88\x94a*\xEF\x93a*\xD8a\x03bV[\x9B\x8C\x9A\x8B\x99\x8A\x98a'/V[\x88R`\x04\x88\x01a'\xD0V[\x03\x92Z\xF1\x80\x15a+\x98Wa+lW[Pa+\x1Ca+\x0C`\x0Ba\x1E\x84V[a+\x16`\x01a(CV[\x90a%$V[\x90a+'`\x0Fa\x1D\xA0V[\x90a+R\x7F4\xB7=\x0C\x96\xE9\xFFMS\x11CH\x17\xC8\xEC\xC90\xE7\xD2x,[\xDE.y\xDCD\xB0YgU\xBB\x92a(_V[\x92a+ga+^a\x03bV[\x92\x83\x92\x83a(kV[\x03\x90\xA2V[a+\x8B\x90_=\x81\x11a+\x91W[a+\x83\x81\x83a\x10KV[\x81\x01\x90a'5V[_a*\xFEV[P=a+yV[a(0V[a'+V[\x90Pa+\xBFa+\xAFa\x0C\xF7V[a+\xB9`\x0Ba\x1E\x84V[\x90a%$V[\x90a)]V[\x90a+\xE0\x91a+\xDBa+\xD6\x82a#\xEAV[a:\x13V[a+\xE2V[V[\x90a+\xEC\x91a;\xEEV[PV[\x90a+\xF9\x91a+\xC5V[V[_\x90V[\x90V[a,\x16a,\x11a,\x1B\x92a+\xFFV[a\x07|V[a\t V[\x90V[a,&a+\xFBV[Pa,1`\x12a,\x02V[\x90V[a,<a#\xA0V[Pa,Ea<\x9AV[\x90V[\x90\x80a,ca,]a,Xa9\xF6V[a\x04\xD7V[\x91a\x04\xD7V[\x03a,tWa,q\x91a=TV[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a,\x8C`\x04\x82\x01a\x06\xD1V[\x03\x90\xFD[a,\x98a\x1ElV[Pa,\xB4a,\xA4a\r\xD8V[a,\xAE`\x0Ca\x1E\x84V[\x90a%$V[\x90V[\x90a,\xD5\x95\x94\x93\x92\x91a,\xD0a,\xCBa\x14\xF2V[a:\x13V[a1\xB0V[V[_\x7FBridge address cannot be zero\0\0\0\x91\x01RV[a-\x0B`\x1D` \x92a\x040V[a-\x14\x81a,\xD7V[\x01\x90V[a--\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra,\xFEV[\x90V[\x15a-7WV[a-?a\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a-U`\x04\x82\x01a-\x18V[\x03\x90\xFD[_\x7FL2 token address cannot be zero\0\x91\x01RV[a-\x8D`\x1F` \x92a\x040V[a-\x96\x81a-YV[\x01\x90V[a-\xAF\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra-\x80V[\x90V[\x15a-\xB9WV[a-\xC1a\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a-\xD7`\x04\x82\x01a-\x9AV[\x03\x90\xFD[` \x7F zero\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FL2 destination address cannot be_\x82\x01R\x01RV[a.5`%`@\x92a\x040V[a.>\x81a-\xDBV[\x01\x90V[a.W\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra.(V[\x90V[\x15a.aWV[a.ia\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a.\x7F`\x04\x82\x01a.BV[\x03\x90\xFD[` \x7Fero\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FGas limit must be greater than z_\x82\x01R\x01RV[a.\xDD`#`@\x92a\x040V[a.\xE6\x81a.\x83V[\x01\x90V[a.\xFF\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra.\xD0V[\x90V[\x15a/\tWV[a/\x11a\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a/'`\x04\x82\x01a.\xEAV[\x03\x90\xFD[\x90a/<`\x01\x80`\xA0\x1B\x03\x91a\x14\xD1V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x90a/^a/Ya/e\x92a(_V[a/FV[\x82Ta/+V[\x90UV[`\xA0\x1B\x90V[\x90a/\x81c\xFF\xFF\xFF\xFF`\xA0\x1B\x91a/iV[\x91\x81\x19\x16\x91\x16\x17\x90V[a/\x9Fa/\x9Aa/\xA4\x92a\x04\xF0V[a\x07|V[a\x04\xF0V[\x90V[\x90V[\x90a/\xBFa/\xBAa/\xC6\x92a/\x8BV[a/\xA7V[\x82Ta/oV[\x90UV[P\x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a/\xF7\x91\x02\x91a/\xF1_\x19\x84a/\xD8V[\x92a/\xD8V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a0\x17a0\x12a0\x1F\x93a\"\x0BV[a\"'V[\x90\x83Ta/\xDCV[\x90UV[a05\x91a0/a\x1ElV[\x91a0\x01V[V[[\x81\x81\x10a0CWPPV[\x80a0P_`\x01\x93a0#V[\x01a08V[\x91\x90`\x1F\x81\x11a0fW[PPPV[a0ra0\x97\x93a\x0F\x95V[\x90` a0~\x84a/\xCEV[\x83\x01\x93\x10a0\x9FW[a0\x90\x90a/\xCEV[\x01\x90a07V[_\x80\x80a0aV[\x91Pa0\x90\x81\x92\x90Pa0\x87V[\x90a0\xBD\x90_\x19\x90`\x08\x02a\t\xE0V[\x19\x16\x90V[\x81a0\xCC\x91a0\xADV[\x90`\x02\x02\x17\x90V[\x91a0\xDF\x90\x82a/\xCAV[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a1\x9EWa1\x03\x82a0\xFD\x85Ta\x0FbV[\x85a0VV[_\x90`\x1F\x83\x11`\x01\x14a16W\x91\x80\x91a1%\x93_\x92a1*W[PPa0\xC2V[\x90U[V[\x90\x91P\x015_\x80a1\x1EV[`\x1F\x19\x83\x16\x91a1E\x85a\x0F\x95V[\x92_[\x81\x81\x10a1\x86WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a1lW[PPP\x02\x01\x90Ua1(V[a1|\x91\x015`\x1F\x84\x16\x90a0\xADV[\x90U_\x80\x80a1`V[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a1HV[a\x107V[\x90a1\xAE\x92\x91a0\xD4V[V[\x91\x92\x93\x94a2w\x91\x95a1\xDE\x84a1\xD7a1\xD1a1\xCC_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14\x15a-0V[a2\x03\x87a1\xFCa1\xF6a1\xF1_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14\x15a-\xB2V[a2(\x85a2!a2\x1Ba2\x16_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14\x15a.ZV[a2D\x86a2>a28_a!\x12V[\x91a\x04\xF0V[\x11a/\x02V[a2O\x84`\ra/IV[a2Z\x87`\x0Ea/IV[a2e\x85`\x0Fa/IV[a2p\x86`\x0Fa/\xAAV[`\x10a1\xA3V[\x92\x90\x91\x92a2\xCCa2\xBAa2\xB4a2\xAE\x7F\x02\xD9\xF99uT\xA2\x9B\xBA\x1C\xC5\x0E]\xD3\nU\xBD@\xE4\xD0c\xF2~Km\xD6F\xD2\x8D\x81\x04`\x94a(_V[\x94a(_V[\x94a(_V[\x94a2\xC3a\x03bV[\x91\x82\x91\x82a\x19oV[\x03\x90\xA4V[\x90a2\xDF\x95\x94\x93\x92\x91a,\xB7V[V[\x90a2\xEB\x90a(_V[_R` R`@_ \x90V[a3\ra3\x12\x91a3\x06a\x1ElV[P_a2\xE1V[a\x1E\x84V[\x90V[a3'\x90a3!a\x1ElV[Pa=\xF6V[\x90V[_\x90V[``\x90V[a3<\x90a&\xEFV[\x90V[\x90a3Ra3Ka\x03bV[\x92\x83a\x10KV[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a3lW` \x80\x91\x02\x01\x90V[a\x107V[\x90a3\x83a3~\x83a3TV[a3?V[\x91\x82RV[6\x907V[\x90a3\xB2a3\x9A\x83a3qV[\x92` \x80a3\xA8\x86\x93a3TV[\x92\x01\x91\x03\x90a3\x88V[V[`\x0F`\xF8\x1B\x90V[a3\xC4a3*V[Pa3\xCDa\x1C\x86V[Pa3\xD6a\x1C\x86V[Pa3\xDFa\x1ElV[Pa3\xE8a\x1DzV[Pa3\xF1a#\xA0V[Pa3\xFAa3.V[Pa4\x03a>\x18V[\x90a4\x0Ca>XV[\x90F\x90a4\x180a33V[\x90a4\"_a\x14\xD6V[\x90a44a4/_a&\x01V[a3\x8DV[\x90a4=a3\xB4V[\x96\x95\x94\x93\x92\x91\x90V[\x90a4P\x90a(_V[_R` R`@_ \x90V[a4\x83\x91_a4xa4~\x93a4pa\x1CBV[P`\x05a#\xB0V[\x01a4FV[a\x1E\xD5V[\x90V[a4\x8Ea\x1C\x86V[Pa4\x99`\x04a\x1DXV[\x90V[a4\xB9\x91a4\xA8a\x1CBV[Pa4\xB1a9\xF6V[\x91\x90\x91a:\xF3V[`\x01\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a4\xD3W` \x02\x90V[a\x107V[a4\xE4a4\xE9\x91a4\xBEV[a3?V[\x90V[\x90a5\na4\xF9\x83a4\xD8V[\x92a5\x04\x84\x91a4\xBEV[\x90a3\x88V[V[a5\x16`0a4\xECV[\x90V[\x90P\x90V[a5(\x90Ta\x1EpV[\x90V[`\x01\x01\x90V[a5Ma5Ga5@\x83a\t\xAFV[\x80\x94a5\x19V[\x91a\t\xB5V[_\x91[\x83\x83\x10a5]WPPPPV[a5za5t`\x01\x92a5o\x85a5\x1EV[a\x11uV[\x92a5+V[\x92\x01\x91\x90a5PV[\x90a5\x91\x81a\x06\0\x93a51V[\x01\x90V[\x90a5\xB5a5\xAE\x92a5\xA5a\x03bV[\x93\x84\x80\x92a5\x83V[\x03\x83a\x10KV[V[a5\xC0\x90a5\x95V[\x90V[a5\xCBa5\x0CV[Pa5\xD6`\x11a5\xB7V[\x90V[a5\xE8a5\xEE\x91\x93\x92\x93a\x05\xF1V[\x92a\x05\xF1V[\x91a5\xFA\x83\x82\x02a\x05\xF1V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a6\tWV[a%\x10V[a6\x16a\x1ElV[Pa6\x1Fa\x1ElV[Pa6(a\x1ElV[Pa61a\x1CBV[Pa6Ea6?`\ta\x1E\xD5V[\x15a\x03\xC1V[a7iWa6na6`Ba6Z`\na\x1E\x84V[\x90a%$V[a6ha\x16\\V[\x90a%]V[\x90a6\xB0a6|`\na\x1E\x84V[a6\xAAa6\x9Ca6\x8C`\x0Ba\x1E\x84V[a6\x96`\x01a(CV[\x90a&,V[a6\xA4a\x16\\V[\x90a5\xD9V[\x90a&,V[a6\xBA`\x0Ba\x1E\x84V[a6\xD3a6\xCDa6\xC8a\x0C\xF7V[a\x05\xF1V[\x91a\x05\xF1V[\x10_\x14a7[Wa6\xF8a6\xF2`\x11a6\xEC`\x0Ba\x1E\x84V[\x90a\t\xB8V[\x90a\t\xFFV[[\x92a7\x15a7\x0Fa7\n`\x0Ba\x1E\x84V[a\x05\xF1V[\x91a\x05\xF1V[\x11\x80a71W[\x91a7'`\x0Ba\x1E\x84V[\x91\x93\x92\x91\x93\x92\x91\x90V[Pa7<`\x0Ba\x1E\x84V[a7Ua7Oa7Ja\x0C\xF7V[a\x05\xF1V[\x91a\x05\xF1V[\x10a7\x1CV[a7d_a&\x01V[a6\xF9V[_\x90_\x91_\x91a7\x8Ba7\x85a7\x7F_\x94a&\x01V[\x95a&\x01V[\x93a&\x01V[\x91\x90V[\x7Fnq\xED\xAE\x12\xB1\xB9\x7FM\x1F`7\x0F\xEF\x10\x10_\xA2\xFA\xAE\x01&\x11J\x16\x9Cd\x84]a&\xC9\x90V[\x91\x94a7\xFBa8\x05\x92\x98\x97\x95a7\xF1`\xA0\x96a7\xE7a8\x0C\x9Aa7\xDD`\xC0\x8A\x01\x9E_\x8B\x01\x90a\x085V[` \x89\x01\x90a\x04\xE3V[`@\x87\x01\x90a\x04\xE3V[``\x85\x01\x90a\x06zV[`\x80\x83\x01\x90a\x06zV[\x01\x90a\x06zV[V[` \x01\x90V[\x91` a85\x92\x94\x93a8.`@\x82\x01\x96_\x83\x01\x90a\x04\xE3V[\x01\x90a\x04\xE3V[V[\x96\x95\x91\x93\x92\x94\x90\x94Ba8Ra8L\x83a\x05\xF1V[\x91a\x05\xF1V[\x11a9\x0CW\x90a8\xBBa8\xC4\x94\x93\x92a8\xA3a8la7\x8FV[a8\x94\x8C\x80\x94\x8C\x91a8~\x8D\x91a>\x98V[\x91\x92a8\x88a\x03bV[\x97\x88\x96` \x88\x01a7\xB3V[` \x82\x01\x81\x03\x82R\x03\x82a\x10KV[a8\xB5a8\xAF\x82a\x05\x06V[\x91a8\x0EV[ a>\xCBV[\x92\x90\x91\x92a>\xE8V[\x80a8\xD7a8\xD1\x87a\x04\xD7V[\x91a\x04\xD7V[\x03a8\xECWPa8\xEA\x92\x93\x91\x90\x91a:\x03V[V[\x84\x90a9\x08_\x92\x83\x92c%\xC0\x07#`\xE1\x1B\x84R`\x04\x84\x01a8\x14V[\x03\x90\xFD[a9'\x90_\x91\x82\x91c1<\x89\x81`\xE1\x1B\x83R`\x04\x83\x01a\x06\x87V[\x03\x90\xFD[\x90a9F\x91a9Aa9<\x82a#\xEAV[a:\x13V[a9HV[V[\x90a9R\x91a=TV[PV[\x90a9_\x91a9+V[V[\x90a9k\x90a(_V[_R` R`@_ \x90V[a9\x9C\x91a9\x92a9\x97\x92a9\x8Aa\x1ElV[P`\x01a9aV[a2\xE1V[a\x1E\x84V[\x90V[a9\xA7a\x1CBV[Pa9\xB2`\x0Ba\x1E\x84V[a9\xCBa9\xC5a9\xC0a\x0C\xF7V[a\x05\xF1V[\x91a\x05\xF1V[\x10\x15\x90V[a9\xD8a\x1CBV[Pa9\xF2a9\xECc\x01\xFF\xC9\xA7`\xE0\x1Ba\x03tV[\x91a\x03tV[\x14\x90V[a9\xFEa\x1DzV[P3\x90V[\x91a:\x11\x92\x91`\x01\x92a?\x0FV[V[a:%\x90a:\x1Fa9\xF6V[\x90a@AV[V[`@\x90a:Pa:W\x94\x96\x95\x93\x96a:F``\x84\x01\x98_\x85\x01\x90a\x04\xE3V[` \x83\x01\x90a\x06zV[\x01\x90a\x06zV[V[\x90a:d\x91\x03a\x05\xF1V[\x90V[\x92\x91\x92a:u\x81\x83\x90a9wV[\x90\x81a:\x8Aa:\x84_\x19a\x05\xF1V[\x91a\x05\xF1V[\x10a:\x97W[PPP\x90PV[\x81a:\xAAa:\xA4\x87a\x05\xF1V[\x91a\x05\xF1V[\x10a:\xD0Wa:\xC7\x93\x94a:\xBF\x91\x93\x92a:YV[\x90_\x92a?\x0FV[\x80_\x80\x80a:\x90V[Pa:\xEF\x84\x92\x91\x92_\x93\x84\x93c}\xC7\xA0\xD9`\xE1\x1B\x85R`\x04\x85\x01a:'V[\x03\x90\xFD[\x91\x82a;\x0Fa;\ta;\x04_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14a;iW\x81a;/a;)a;$_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14a;BWa;@\x92\x91\x90\x91a@\x8AV[V[a;ea;N_a\x1F\x80V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x15\xF3V[\x03\x90\xFD[a;\x8Ca;u_a\x1F\x80V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x15\xF3V[\x03\x90\xFD[\x80a;\xABa;\xA5a;\xA0_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14a;\xC7Wa;\xC5\x91a;\xBD_a\x1F\x80V[\x91\x90\x91a@\x8AV[V[a;\xEAa;\xD3_a\x1F\x80V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x15\xF3V[\x03\x90\xFD[a;\xF6a\x1CBV[Pa<\x0Ba<\x05\x82\x84\x90a4\\V[\x15a\x03\xC1V[_\x14a<\x94Wa<3`\x01a<._a<&`\x05\x86\x90a#\xB0V[\x01\x85\x90a4FV[a!\xD5V[\x90a<<a9\xF6V[\x90a<ya<sa<m\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a#\xA4V[\x92a(_V[\x92a(_V[\x92a<\x82a\x03bV[\x80a<\x8C\x81a\x06\xD1V[\x03\x90\xA4`\x01\x90V[PP_\x90V[a<\xA2a#\xA0V[Pa<\xAC0a33V[a<\xDEa<\xD8\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04\xD7V[\x91a\x04\xD7V[\x14\x80a=\x1AW[_\x14a=\x0FW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[a=\x17aBjV[\x90V[PFa=Na=H\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x05\xF1V[\x91a\x05\xF1V[\x14a<\xE5V[a=\\a\x1CBV[Pa=h\x81\x83\x90a4\\V[_\x14a=\xF0Wa=\x8F_a=\x8A_a=\x82`\x05\x86\x90a#\xB0V[\x01\x85\x90a4FV[a!\xD5V[\x90a=\x98a9\xF6V[\x90a=\xD5a=\xCFa=\xC9\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a#\xA4V[\x92a(_V[\x92a(_V[\x92a=\xDEa\x03bV[\x80a=\xE8\x81a\x06\xD1V[\x03\x90\xA4`\x01\x90V[PP_\x90V[a>\ra>\x12\x91a>\x05a\x1ElV[P`\x08a2\xE1V[a\x1E\x84V[\x90V[\x90V[a> a\x1C\x86V[Pa>U\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a>O`\x06a>\x15V[\x90aD\x04V[\x90V[a>`a\x1C\x86V[Pa>\x95\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a>\x8F`\x07a>\x15V[\x90aD\x04V[\x90V[a>\xAC\x90a>\xA4a\x1ElV[P`\x08a2\xE1V[a>\xC8a>\xB8\x82a\x1E\x84V[\x91a>\xC2\x83a&\x1DV[\x90a\"*V[\x90V[a>\xE5\x90a>\xD7a#\xA0V[Pa>\xE0a<\x9AV[aDRV[\x90V[\x92a?\x03\x92a?\x0C\x94a>\xF9a\x1DzV[P\x92\x90\x91\x92aE\x08V[\x90\x92\x91\x92aF3V[\x90V[\x90\x92\x81a?,a?&a?!_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14a?\xF7W\x83a?La?Fa?A_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14a?\xD0Wa?p\x83a?ka?d`\x01\x86\x90a9aV[\x87\x90a2\xE1V[a\"*V[a?zW[PPPV[\x91\x90\x91a?\xC5a?\xB3a?\xAD\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%\x93a(_V[\x93a(_V[\x93a?\xBCa\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xA3_\x80\x80a?uV[a?\xF3a?\xDC_a\x1F\x80V[_\x91\x82\x91cJ\x14\x06\xB1`\xE1\x1B\x83R`\x04\x83\x01a\x15\xF3V[\x03\x90\xFD[a@\x1Aa@\x03_a\x1F\x80V[_\x91\x82\x91c\xE6\x02\xDF\x05`\xE0\x1B\x83R`\x04\x83\x01a\x15\xF3V[\x03\x90\xFD[\x91` a@?\x92\x94\x93a@8`@\x82\x01\x96_\x83\x01\x90a\x04\xE3V[\x01\x90a\x085V[V[\x90a@Va@P\x83\x83\x90a4\\V[\x15a\x03\xC1V[a@^WPPV[a@x_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01a@\x1EV[\x03\x90\xFD[\x90a@\x87\x91\x01a\x05\xF1V[\x90V[\x91\x90\x91\x80a@\xA8a@\xA2a@\x9D_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14_\x14aA\x89Wa@\xCCa@\xC5\x83a@\xC0`\x02a\x1E\x84V[a&,V[`\x02a\"*V[[\x82a@\xE8a@\xE2a@\xDD_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14_\x14aA]WaA\x0CaA\x05\x83aA\0`\x02a\x1E\x84V[a:YV[`\x02a\"*V[[\x91\x90\x91aAXaAFaA@\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a(_V[\x93a(_V[\x93aAOa\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xA3V[aA\x84\x82aA~aAo_\x87\x90a2\xE1V[\x91aAy\x83a\x1E\x84V[a@|V[\x90a\"*V[aA\rV[aA\x9CaA\x97_\x83\x90a2\xE1V[a\x1E\x84V[\x80aA\xAFaA\xA9\x85a\x05\xF1V[\x91a\x05\xF1V[\x10aA\xD7WaA\xC2aA\xD2\x91\x84\x90a:YV[aA\xCD_\x84\x90a2\xE1V[a\"*V[a@\xCDV[\x90aA\xF5\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01a:'V[\x03\x90\xFD[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[\x90\x95\x94\x92aBh\x94aBWaBa\x92aBM`\x80\x96aBC`\xA0\x88\x01\x9C_\x89\x01\x90a\x085V[` \x87\x01\x90a\x085V[`@\x85\x01\x90a\x085V[``\x83\x01\x90a\x06zV[\x01\x90a\x04\xE3V[V[aBra#\xA0V[PaB{aA\xF9V[aB\xF2\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91aB\xE3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0FaB\xCE0a33V[\x91aB\xD7a\x03bV[\x96\x87\x95` \x87\x01aB\x1DV[` \x82\x01\x81\x03\x82R\x03\x82a\x10KV[aC\x04aB\xFE\x82a\x05\x06V[\x91a8\x0EV[ \x90V[\x90V[aC\x1FaC\x1AaC$\x92aC\x08V[a\x14\xD1V[a\x07\xF1V[\x90V[aC1`\xFFaC\x0BV[\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90aCWaCP\x83a\x0FbV[\x80\x94a\x1C\x8BV[\x91`\x01\x81\x16\x90\x81_\x14aC\xAEWP`\x01\x14aCrW[PPPV[aC\x7F\x91\x92\x93\x94PaC4V[\x91_\x92[\x81\x84\x10aC\x96WPP\x01\x90_\x80\x80aCmV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90aC\x83V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80aCmV[\x90aC\xD3\x91aC=V[\x90V[\x90aC\xF6aC\xEF\x92aC\xE6a\x03bV[\x93\x84\x80\x92aC\xC9V[\x03\x83a\x10KV[V[aD\x01\x90aC\xD6V[\x90V[\x90aD\ra\x1C\x86V[PaD\x17\x82a#\xA4V[aD0aD*aD%aC'V[a\x07\xF1V[\x91a\x07\xF1V[\x14\x15_\x14aDEWPaDB\x90aG\x89V[\x90V[aDO\x91PaC\xF8V[\x90V[`B\x91aD]a#\xA0V[P`@Q\x91\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R`\x02\x83\x01R`\"\x82\x01R \x90V[_\x90V[aD\xA3aD\xA8\x91a\x1D\x87V[a\"\x0BV[\x90V[\x90V[aD\xC2aD\xBDaD\xC7\x92aD\xABV[a\x07|V[a\x05\xF1V[\x90V[aD\xFFaE\x06\x94aD\xF5``\x94\x98\x97\x95aD\xEB`\x80\x86\x01\x9A_\x87\x01\x90a\x085V[` \x85\x01\x90a\t&V[`@\x83\x01\x90a\x085V[\x01\x90a\x085V[V[\x93\x92\x93aE\x13a\x1DzV[PaE\x1CaD\x93V[PaE%a#\xA0V[PaE/\x85aD\x97V[aEaaE[\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0aD\xAEV[\x91a\x05\xF1V[\x11aE\xEEW\x90aE\x84` \x94\x95_\x94\x93\x92\x93aE{a\x03bV[\x94\x85\x94\x85aD\xCAV[\x83\x80R\x03\x90`\x01Z\xFA\x15aE\xE9WaE\x9C_Qa\x14\xD1V[\x80aE\xB7aE\xB1aE\xAC_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14aE\xCDW_\x91aE\xC7_a\x14\xD6V[\x91\x92\x91\x90V[PaE\xD7_a\x1F\x80V[`\x01\x91aE\xE3_a\x14\xD6V[\x91\x92\x91\x90V[a(0V[PPPaE\xFA_a\x1F\x80V[\x90`\x03\x92\x91\x92\x91\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x04\x11\x15aF\"WV[aF\x04V[\x90aF1\x82aF\x18V[V[\x80aFFaF@_aF'V[\x91aF'V[\x14_\x14aFQWPPV[\x80aFeaF_`\x01aF'V[\x91aF'V[\x14_\x14aF\x88W_c\xF6E\xEE\xDF`\xE0\x1B\x81R\x80aF\x84`\x04\x82\x01a\x06\xD1V[\x03\x90\xFD[\x80aF\x9CaF\x96`\x02aF'V[\x91aF'V[\x14_\x14aF\xCAWaF\xC6aF\xAF\x83aD\x97V[_\x91\x82\x91c\xFC\xE6\x98\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x06\x87V[\x03\x90\xFD[aF\xDDaF\xD7`\x03aF'V[\x91aF'V[\x14aF\xE5WPV[aG\0\x90_\x91\x82\x91c5\xE2\xF3\x83`\xE2\x1B\x83R`\x04\x83\x01a\x08BV[\x03\x90\xFD[\x90V[aG\x1BaG\x16aG \x92aG\x04V[a\x07|V[a\x05\xF1V[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11aGAWaG=` \x91a\x04DV[\x01\x90V[a\x107V[\x90aGXaGS\x83aG#V[a3?V[\x91\x82RV[6\x907V[\x90aG\x87aGo\x83aGFV[\x92` \x80aG}\x86\x93aG#V[\x92\x01\x91\x03\x90aG]V[V[aG\x91a\x1C\x86V[PaG\x9B\x81aG\xF4V[\x90aG\xAEaG\xA9` aG\x07V[aGbV[\x91\x82R` \x82\x01R\x90V[aG\xCDaG\xC8aG\xD2\x92aC\x08V[a\x07|V[a\x05\xF1V[\x90V[\x90V[aG\xECaG\xE7aG\xF1\x92aG\xD5V[a\x07|V[a\x05\xF1V[\x90V[aH\taH\x0E\x91aH\x03a\x1ElV[Pa#\xA4V[aD\x97V[aH\x18`\xFFaG\xB9V[\x16\x80aH-aH'`\x1FaG\xD8V[\x91a\x05\xF1V[\x11aH5W\x90V[_c,\xD4J\xC3`\xE2\x1B\x81R\x80aHM`\x04\x82\x01a\x06\xD1V[\x03\x90\xFD",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610013575b611c3e565b61001d5f3561035c565b806301ffc9a71461035757806306fdde031461035257806307a1d5fa1461034d578063095ea7b31461034857806318160ddd146103435780631b02f8451461033e57806323b872dd1461033957806323e1134c14610334578063248a9ca31461032f578063284e13331461032a5780632f2ff15d14610325578063313ce56714610320578063334d0bbd1461031b5780633644e5151461031657806336568abe1461031157806348b0daa61461030c5780634bdd36ce1461030757806353b64acb146103025780635adf0021146102fd5780635f15c3c9146102f85780636ca0319b146102f35780636cf01625146102ee5780636f3f51d9146102e957806370a08231146102e457806376671808146102df5780637b3a1286146102da5780637ecebe00146102d557806384b0196e146102d0578063902d55a5146102cb57806391d14854146102c657806395d89b41146102c15780639b7ef64b146102bc578063a026599a146102b7578063a1fab765146102b2578063a217fddf146102ad578063a32adef8146102a8578063a3c573eb146102a3578063a70b9f0c1461029e578063a9059cbb14610299578063af2aa63b14610294578063b518a6871461028f578063babc394f1461028a578063bd02dc2514610285578063c12303b314610280578063c5500cc31461027b578063d505accf14610276578063d547741f14610271578063dd62ed3e1461026c578063dd8c3e5d14610267578063e3abdfcb14610262578063e77f9cec1461025d5763f508e19d0361000e57611c09565b611bc5565b611b81565b611b1d565b611ae7565b611a86565b611a4c565b611984565b6118fb565b611886565b61183e565b6117cb565b611756565b6116ab565b611676565b611608565b61157e565b611509565b611499565b611424565b6113af565b611339565b611303565b6112ce565b611251565b61110a565b6110d5565b610f06565b610ec2565b610e6f565b610dfa565b610d84565b610d0f565b610ca3565b610c2e565b610b1b565b610ae6565b610aa3565b610a6e565b610a39565b610948565b6108ec565b61088c565b610857565b6107bc565b610743565b6106d6565b61069c565b610644565b610595565b610497565b6103e8565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61038981610374565b0361039057565b5f80fd5b905035906103a182610380565b565b906020828203126103bc576103b9915f01610394565b90565b61036c565b151590565b6103cf906103c1565b9052565b91906103e6905f602085019401906103c6565b565b34610418576104146104036103fe3660046103a3565b611c46565b61040b610362565b918291826103d3565b0390f35b610368565b5f91031261042757565b61036c565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b61046d61047660209361047b936104648161042c565b93848093610430565b95869101610439565b610444565b0190565b6104949160208201915f81840391015261044e565b90565b346104c7576104a736600461041d565b6104c36104b2611d64565b6104ba610362565b9182918261047f565b0390f35b610368565b60018060a01b031690565b6104e0906104cc565b90565b6104ec906104d7565b9052565b63ffffffff1690565b610502906104f0565b9052565b5190565b60209181520190565b61053261053b6020936105409361052981610506565b9384809361050a565b95869101610439565b610444565b0190565b919361057b6105929694610571610585949761056760a08801995f8901906104e3565b60208701906104e3565b60408501906104e3565b60608301906104f9565b6080818403910152610513565b90565b346105c9576105a536600461041d565b6105c56105b0611de0565b916105bc959395610362565b95869586610544565b0390f35b610368565b6105d7816104d7565b036105de57565b5f80fd5b905035906105ef826105ce565b565b90565b6105fd816105f1565b0361060457565b5f80fd5b90503590610615826105f4565b565b919060408382031261063f578061063361063c925f86016105e2565b93602001610608565b90565b61036c565b346106755761067161066061065a366004610617565b90611e4a565b610668610362565b918291826103d3565b0390f35b610368565b610683906105f1565b9052565b919061069a905f6020850194019061067a565b565b346106cc576106ac36600461041d565b6106c86106b7611e91565b6106bf610362565b91829182610687565b0390f35b610368565b5f0190565b34610704576106e636600461041d565b6106ee612367565b6106f6610362565b80610700816106d1565b0390f35b610368565b909160608284031261073e5761073b610724845f85016105e2565b9361073281602086016105e2565b93604001610608565b90565b61036c565b346107745761077061075f610759366004610709565b91612371565b610767610362565b918291826103d3565b0390f35b610368565b90565b90565b61079361078e61079892610779565b61077c565b6105f1565b90565b6107ae690404f64a565a1974000061077f565b90565b6107b961079b565b90565b346107ec576107cc36600461041d565b6107e86107d76107b1565b6107df610362565b91829182610687565b0390f35b610368565b90565b6107fd816107f1565b0361080457565b5f80fd5b90503590610815826107f4565b565b906020828203126108305761082d915f01610808565b90565b61036c565b61083e906107f1565b9052565b9190610855905f60208501940190610835565b565b346108875761088361087261086d366004610817565b6123ea565b61087a610362565b91829182610842565b0390f35b610368565b346108ba5761089c36600461041d565b6108a461288e565b6108ac610362565b806108b6816106d1565b0390f35b610368565b91906040838203126108e757806108db6108e4925f8601610808565b936020016105e2565b90565b61036c565b3461091b576109056108ff3660046108bf565b90612bef565b61090d610362565b80610917816106d1565b0390f35b610368565b60ff1690565b61092f90610920565b9052565b9190610946905f60208501940190610926565b565b346109785761095836600461041d565b610974610963612c1e565b61096b610362565b91829182610933565b0390f35b610368565b9060208282031261099657610993915f01610608565b90565b61036c565b634e487b7160e01b5f52603260045260245ffd5b50603090565b90565b6109c1816109af565b8210156109db576109d36001916109b5565b910201905f90565b61099b565b1c90565b90565b6109f79060086109fc93026109e0565b6109e4565b90565b90610a0a91546109e7565b90565b6011610a18816109af565b821015610a3557610a3291610a2c916109b8565b906109ff565b90565b5f80fd5b34610a6957610a65610a54610a4f36600461097d565b610a0d565b610a5c610362565b91829182610687565b0390f35b610368565b34610a9e57610a7e36600461041d565b610a9a610a89612c34565b610a91610362565b91829182610842565b0390f35b610368565b34610ad257610abc610ab63660046108bf565b90612c48565b610ac4610362565b80610ace816106d1565b0390f35b610368565b610ae3600a5f906109ff565b90565b34610b1657610af636600461041d565b610b12610b01610ad7565b610b09610362565b91829182610687565b0390f35b610368565b34610b4b57610b2b36600461041d565b610b47610b36612c90565b610b3e610362565b91829182610687565b0390f35b610368565b610b59816104f0565b03610b6057565b5f80fd5b90503590610b7182610b50565b565b5f80fd5b5f80fd5b5f80fd5b909182601f83011215610bb95781359167ffffffffffffffff8311610bb4576020019260018302840111610baf57565b610b7b565b610b77565b610b73565b91909160a081840312610c2957610bd7835f83016105e2565b92610be581602084016105e2565b92610bf382604085016105e2565b92610c018360608301610b64565b92608082013567ffffffffffffffff8111610c2457610c209201610b7f565b9091565b610370565b61036c565b34610c6357610c4d610c41366004610bbe565b949390939291926132d1565b610c55610362565b80610c5f816106d1565b0390f35b610368565b60ff1690565b610c7e906008610c8393026109e0565b610c68565b90565b90610c919154610c6e565b90565b610ca060095f90610c86565b90565b34610cd357610cb336600461041d565b610ccf610cbe610c94565b610cc6610362565b918291826103d3565b0390f35b610368565b90565b610cef610cea610cf492610cd8565b61077c565b6105f1565b90565b610d016030610cdb565b90565b610d0c610cf7565b90565b34610d3f57610d1f36600461041d565b610d3b610d2a610d04565b610d32610362565b91829182610687565b0390f35b610368565b90565b610d5b610d56610d6092610d44565b61077c565b6105f1565b90565b610d76691f039ccd65a9bef00000610d47565b90565b610d81610d63565b90565b34610db457610d9436600461041d565b610db0610d9f610d79565b610da7610362565b91829182610687565b0390f35b610368565b90565b610dd0610dcb610dd592610db9565b61077c565b6105f1565b90565b610dec6a084595161401484a000000610dbc565b90565b610df7610dd8565b90565b34610e2a57610e0a36600461041d565b610e26610e15610def565b610e1d610362565b91829182610687565b0390f35b610368565b90565b610e46610e41610e4b92610e2f565b61077c565b6105f1565b90565b610e6169129bc47b3cff72900000610e32565b90565b610e6c610e4e565b90565b34610e9f57610e7f36600461041d565b610e9b610e8a610e64565b610e92610362565b91829182610687565b0390f35b610368565b90602082820312610ebd57610eba915f016105e2565b90565b61036c565b34610ef257610eee610edd610ed8366004610ea4565b6132f7565b610ee5610362565b91829182610687565b0390f35b610368565b610f03600b5f906109ff565b90565b34610f3657610f1636600461041d565b610f32610f21610ef7565b610f29610362565b91829182610687565b0390f35b610368565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610f82575b6020831014610f7d57565b610f4e565b91607f1691610f72565b60209181520190565b5f5260205f2090565b905f9291805490610fb8610fb183610f62565b8094610f8c565b916001811690815f1461100f5750600114610fd3575b505050565b610fe09192939450610f95565b915f925b818410610ff757505001905f8080610fce565b60018160209295939554848601520191019290610fe4565b92949550505060ff19168252151560200201905f8080610fce565b9061103491610f9e565b90565b634e487b7160e01b5f52604160045260245ffd5b9061105590610444565b810190811067ffffffffffffffff82111761106f57604052565b611037565b9061109461108d92611084610362565b9384809261102a565b038361104b565b565b905f106110a9576110a690611074565b90565b610f3b565b6110ba60105f90611096565b90565b6110d29160208201915f818403910152610513565b90565b34611105576110e536600461041d565b6111016110f06110ae565b6110f8610362565b918291826110bd565b0390f35b610368565b3461113a57611136611125611120366004610ea4565b613315565b61112d610362565b91829182610687565b0390f35b610368565b60ff60f81b1690565b6111519061113f565b9052565b5190565b60209181520190565b60200190565b611171906105f1565b9052565b9061118281602093611168565b0190565b60200190565b906111a96111a361119c84611155565b8093611159565b92611162565b905f5b8181106111b95750505090565b9091926111d26111cc6001928651611175565b94611186565b91019190916111ac565b9395919461122d611222611241956112146112379561124e9c9a61120760e08c01925f8d0190611148565b8a820360208c015261044e565b9088820360408a015261044e565b97606087019061067a565b60808501906104e3565b60a0830190610835565b60c081840391015261118c565b90565b346112885761126136600461041d565b61128461126c6133bc565b9361127b979597939193610362565b978897886111dc565b0390f35b610368565b90565b6112a461129f6112a99261128d565b61077c565b6105f1565b90565b6112c06a52b7d2dcc80cd2e4000000611290565b90565b6112cb6112ac565b90565b346112fe576112de36600461041d565b6112fa6112e96112c3565b6112f1610362565b91829182610687565b0390f35b610368565b346113345761133061131f6113193660046108bf565b9061345c565b611327610362565b918291826103d3565b0390f35b610368565b346113695761134936600461041d565b611365611354613486565b61135c610362565b9182918261047f565b0390f35b610368565b90565b61138561138061138a9261136e565b61077c565b6105f1565b90565b6113a16a4a723dc6b40b8a9a000000611371565b90565b6113ac61138d565b90565b346113df576113bf36600461041d565b6113db6113ca6113a4565b6113d2610362565b91829182610687565b0390f35b610368565b90565b6113fb6113f6611400926113e4565b61077c565b6105f1565b90565b611416695626760c1662be2400006113e7565b90565b611421611403565b90565b346114545761143436600461041d565b61145061143f611419565b611447610362565b91829182610687565b0390f35b610368565b90565b61147061146b61147592611459565b61077c565b6105f1565b90565b61148b690b2a483d6dadee18000061145c565b90565b611496611478565b90565b346114c9576114a936600461041d565b6114c56114b461148e565b6114bc610362565b91829182610687565b0390f35b610368565b90565b5f1b90565b6114ea6114e56114ef926114ce565b6114d1565b6107f1565b90565b6114fb5f6114d6565b90565b6115066114f2565b90565b346115395761151936600461041d565b6115356115246114fe565b61152c610362565b91829182610842565b0390f35b610368565b90565b61155561155061155a9261153e565b61077c565b6105f1565b90565b6115706933b0b000fec593900000611541565b90565b61157b61155d565b90565b346115ae5761158e36600461041d565b6115aa611599611573565b6115a1610362565b91829182610687565b0390f35b610368565b60018060a01b031690565b6115ce9060086115d393026109e0565b6115b3565b90565b906115e191546115be565b90565b6115f0600d5f906115d6565b90565b9190611606905f602085019401906104e3565b565b346116385761161836600461041d565b6116346116236115e4565b61162b610362565b918291826115f3565b0390f35b610368565b90565b61165461164f6116599261163d565b61077c565b6105f1565b90565b61166862278d00611640565b90565b61167361165c565b90565b346116a65761168636600461041d565b6116a261169161166b565b611699610362565b91829182610687565b0390f35b610368565b346116dc576116d86116c76116c1366004610617565b9061349c565b6116cf610362565b918291826103d3565b0390f35b610368565b50603090565b905090565b90565b60200190565b61171161170b611704836116e1565b80946116e7565b916116ec565b5f915b8383106117215750505050565b6117376117316001928451611175565b926116ef565b92019190611714565b9190611754905f61060085019401906116f5565b565b346117865761176636600461041d565b6117826117716135c3565b611779610362565b91829182611740565b0390f35b610368565b90565b6117a261179d6117a79261178b565b61077c565b6105f1565b90565b6117bd6906b2efd13a962a6c000061178e565b90565b6117c86117aa565b90565b346117fb576117db36600461041d565b6117f76117e66117c0565b6117ee610362565b91829182610687565b0390f35b610368565b61183561183c9461182b606094989795611821608086019a5f87019061067a565b602085019061067a565b604083019061067a565b01906103c6565b565b346118725761184e36600461041d565b61186e61185961360e565b90611865949294610362565b94859485611800565b0390f35b610368565b611883600f5f906115d6565b90565b346118b65761189636600461041d565b6118b26118a1611877565b6118a9610362565b918291826115f3565b0390f35b610368565b90565b6118d26118cd6118d7926118bb565b61077c565b6105f1565b90565b6118ed698f956f697aa4923c00006118be565b90565b6118f86118da565b90565b3461192b5761190b36600461041d565b6119276119166118f0565b61191e610362565b91829182610687565b0390f35b610368565b63ffffffff1690565b61194990600861194e93026109e0565b611930565b90565b9061195c9154611939565b90565b61196c600f601490611951565b90565b9190611982905f602085019401906104f9565b565b346119b45761199436600461041d565b6119b061199f61195f565b6119a7610362565b9182918261196f565b0390f35b610368565b6119c281610920565b036119c957565b5f80fd5b905035906119da826119b9565b565b60e081830312611a47576119f2825f83016105e2565b92611a0083602084016105e2565b92611a0e8160408501610608565b92611a1c8260608301610608565b92611a44611a2d84608085016119cd565b93611a3b8160a08601610808565b9360c001610808565b90565b61036c565b34611a8157611a6b611a5f3660046119dc565b95949094939193613837565b611a73610362565b80611a7d816106d1565b0390f35b610368565b34611ab557611a9f611a993660046108bf565b90613955565b611aa7610362565b80611ab1816106d1565b0390f35b610368565b9190604083820312611ae25780611ad6611adf925f86016105e2565b936020016105e2565b90565b61036c565b34611b1857611b14611b03611afd366004611aba565b90613977565b611b0b610362565b91829182610687565b0390f35b610368565b34611b4d57611b2d36600461041d565b611b49611b3861399f565b611b40610362565b918291826103d3565b0390f35b610368565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b611b7e611b52565b90565b34611bb157611b9136600461041d565b611bad611b9c611b76565b611ba4610362565b91829182610842565b0390f35b610368565b611bc2600e5f906115d6565b90565b34611bf557611bd536600461041d565b611bf1611be0611bb6565b611be8610362565b918291826115f3565b0390f35b610368565b611c06600c5f906109ff565b90565b34611c3957611c1936600461041d565b611c35611c24611bfa565b611c2c610362565b91829182610687565b0390f35b610368565b5f80fd5b5f90565b611c4e611c42565b5080611c69611c63637965db0b60e01b610374565b91610374565b14908115611c76575b5090565b611c8091506139d0565b5f611c72565b606090565b60209181520190565b5f5260205f2090565b905f9291805490611cb7611cb083610f62565b8094611c8b565b916001811690815f14611d0e5750600114611cd2575b505050565b611cdf9192939450611c94565b915f925b818410611cf657505001905f8080611ccd565b60018160209295939554848601520191019290611ce3565b92949550505060ff19168252151560200201905f8080611ccd565b90611d3391611c9d565b90565b90611d56611d4f92611d46610362565b93848092611d29565b038361104b565b565b611d6190611d36565b90565b611d6c611c86565b50611d776003611d58565b90565b5f90565b5f90565b606090565b5f1c90565b611d98611d9d91611d87565b6115b3565b90565b611daa9054611d8c565b90565b60a01c90565b611dbf611dc491611dad565b611930565b90565b611dd19054611db3565b90565b611ddd90611074565b90565b611de8611d7a565b50611df1611d7a565b50611dfa611d7a565b50611e03611d7e565b50611e0c611d82565b50611e17600d611da0565b611e21600e611da0565b91611e2c600f611da0565b91611e37600f611dc7565b91611e4760109295949392611dd4565b90565b611e6791611e56611c42565b50611e5f6139f6565b919091613a03565b600190565b5f90565b611e7c611e8191611d87565b6109e4565b90565b611e8e9054611e70565b90565b611e99611e6c565b50611ea46002611e84565b90565b611eb7611eb2611b52565b613a13565b611ebf61224a565b565b611ecd611ed291611d87565b610c68565b90565b611edf9054611ec1565b90565b5f7f456d697373696f6e7320616c7265616479207374617274656400000000000000910152565b611f166019602092610430565b611f1f81611ee2565b0190565b611f389060208101905f818303910152611f09565b90565b15611f4257565b611f4a610362565b62461bcd60e51b815280611f6060048201611f23565b0390fd5b611f78611f73611f7d926114ce565b61077c565b6104cc565b90565b611f8990611f64565b90565b5f7f4272696467652061646472657373206e6f742073657400000000000000000000910152565b611fc06016602092610430565b611fc981611f8c565b0190565b611fe29060208101905f818303910152611fb3565b90565b15611fec57565b611ff4610362565b62461bcd60e51b81528061200a60048201611fcd565b0390fd5b5f7f4c3220746f6b656e2061646472657373206e6f74207365740000000000000000910152565b6120426018602092610430565b61204b8161200e565b0190565b6120649060208101905f818303910152612035565b90565b1561206e57565b612076610362565b62461bcd60e51b81528061208c6004820161204f565b0390fd5b5f7f4c322064657374696e6174696f6e2061646472657373206e6f74207365740000910152565b6120c4601e602092610430565b6120cd81612090565b0190565b6120e69060208101905f8183039101526120b7565b90565b156120f057565b6120f8610362565b62461bcd60e51b81528061210e600482016120d1565b0390fd5b61212661212161212b926114ce565b61077c565b6104f0565b90565b5f7f42726964676520676173206c696d6974206e6f74207365740000000000000000910152565b6121626018602092610430565b61216b8161212e565b0190565b6121849060208101905f818303910152612155565b90565b1561218e57565b612196610362565b62461bcd60e51b8152806121ac6004820161216f565b0390fd5b906121bc60ff916114d1565b9181191691161790565b6121cf906103c1565b90565b90565b906121ea6121e56121f1926121c6565b6121d2565b82546121b0565b9055565b906122015f19916114d1565b9181191691161790565b61221f61221a612224926105f1565b61077c565b6105f1565b90565b90565b9061223f61223a6122469261220b565b612227565b82546121f5565b9055565b61226561226061225a6009611ed5565b156103c1565b611f3b565b612293612272600d611da0565b61228c6122866122815f611f80565b6104d7565b916104d7565b1415611fe5565b6122c16122a0600e611da0565b6122ba6122b46122af5f611f80565b6104d7565b916104d7565b1415612067565b6122ef6122ce600f611da0565b6122e86122e26122dd5f611f80565b6104d7565b916104d7565b14156120e9565b6123146122fc600f611dc7565b61230e6123085f612112565b916104f0565b11612187565b612320600160096121d5565b61232b42600a61222a565b426123627f1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a322034116091612359610362565b91829182610687565b0390a1565b61236f611ea7565b565b9161239b9261237e611c42565b5061239361238a6139f6565b82908491613a67565b919091613af3565b600190565b5f90565b6123ad906107f1565b90565b906123ba906123a4565b5f5260205260405f2090565b90565b6123d56123da91611d87565b6123c6565b90565b6123e790546123c9565b90565b6001612403612409926123fb6123a0565b5060056123b0565b016123dd565b90565b5f7f456d697373696f6e73206e6f7420737461727465640000000000000000000000910152565b6124406015602092610430565b6124498161240c565b0190565b6124629060208101905f818303910152612433565b90565b1561246c57565b612474610362565b62461bcd60e51b81528061248a6004820161244d565b0390fd5b5f7f416c6c20656d697373696f6e7320636f6d706c65746564000000000000000000910152565b6124c26017602092610430565b6124cb8161248e565b0190565b6124e49060208101905f8183039101526124b5565b90565b156124ee57565b6124f6610362565b62461bcd60e51b81528061250c600482016124cf565b0390fd5b634e487b7160e01b5f52601160045260245ffd5b612533612539919392936105f1565b926105f1565b820391821161254457565b612510565b634e487b7160e01b5f52601260045260245ffd5b61256961256f916105f1565b916105f1565b90811561257a570490565b612549565b5f7f43757272656e742065706f636820616c7265616479206d696e74656400000000910152565b6125b3601c602092610430565b6125bc8161257f565b0190565b6125d59060208101905f8183039101526125a6565b90565b156125df57565b6125e7610362565b62461bcd60e51b8152806125fd600482016125c0565b0390fd5b61261561261061261a926114ce565b61077c565b6105f1565b90565b600161262991016105f1565b90565b61263b612641919392936105f1565b926105f1565b820180921161264c57565b612510565b5f7f43616e6e6f742065786365656420656d697373696f6e7320737570706c790000910152565b612685601e602092610430565b61268e81612651565b0190565b6126a79060208101905f818303910152612678565b90565b156126b157565b6126b9610362565b62461bcd60e51b8152806126cf60048201612692565b0390fd5b6126e76126e26126ec926104cc565b61077c565b6104cc565b90565b6126f8906126d3565b90565b612704906126ef565b90565b612710906126d3565b90565b61271c90612707565b90565b612728906126ef565b90565b5f80fd5b60e01b90565b5f91031261273f57565b61036c565b905f929180549061275e61275783610f62565b809461050a565b916001811690815f146127b55750600114612779575b505050565b6127869192939450610f95565b915f925b81841061279d57505001905f8080612774565b6001816020929593955484860152019101929061278a565b92949550505060ff19168252151560200201905f8080612774565b9261282d969461280c61281692612802612820969995996127f860c08a019b5f8b01906104e3565b60208901906104e3565b60408701906104e3565b606085019061067a565b60808301906104f9565b60a0818403910152612744565b90565b612838610362565b3d5f823e3d90fd5b90565b61285761285261285c92612840565b61077c565b6105f1565b90565b612868906126ef565b90565b91602061288c92949361288560408201965f83019061067a565b019061067a565b565b6128a061289b6009611ed5565b612465565b6128cc6128ad600b611e84565b6128c66128c06128bb610cf7565b6105f1565b916105f1565b106124e7565b6129296128f46128e6426128e0600a611e84565b90612524565b6128ee61165c565b9061255d565b6129198161291361290d612908600b611e84565b6105f1565b916105f1565b116125d8565b612923600b611e84565b90612524565b908161295761295161294c61293c610cf7565b612946600b611e84565b90612524565b6105f1565b916105f1565b11612ba2575b6129665f612601565b906129705f612601565b915b8261298561297f866105f1565b916105f1565b10156129cc576129c06129c6916129ba6129b460116129ae6129a7600b611e84565b899061262c565b906109b8565b906109ff565b9061262c565b9261261d565b91612972565b915091612a1c612a2391612a0d6129ed6129e6600c611e84565b869061262c565b612a06612a006129fb610dd8565b6105f1565b916105f1565b11156126aa565b612a17600b611e84565b61262c565b600b61222a565b612a40612a3982612a34600c611e84565b61262c565b600c61222a565b612a53612a4c306126fb565b8290613b90565b612a70612a5f306126fb565b612a69600d611da0565b8391613a03565b612a8a612a85612a80600d611da0565b612713565b61271f565b63540abf73612a98306126fb565b612aa2600e611da0565b92612aad600f611da0565b9285612ab9600f611dc7565b91601095843b15612b9d575f96612ae4948894612aef93612ad8610362565b9b8c9a8b998a9861272f565b8852600488016127d0565b03925af18015612b9857612b6c575b50612b1c612b0c600b611e84565b612b166001612843565b90612524565b90612b27600f611da0565b90612b527f34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb9261285f565b92612b67612b5e610362565b9283928361286b565b0390a2565b612b8b905f3d8111612b91575b612b83818361104b565b810190612735565b5f612afe565b503d612b79565b612830565b61272b565b9050612bbf612baf610cf7565b612bb9600b611e84565b90612524565b9061295d565b90612be091612bdb612bd6826123ea565b613a13565b612be2565b565b90612bec91613bee565b50565b90612bf991612bc5565b565b5f90565b90565b612c16612c11612c1b92612bff565b61077c565b610920565b90565b612c26612bfb565b50612c316012612c02565b90565b612c3c6123a0565b50612c45613c9a565b90565b9080612c63612c5d612c586139f6565b6104d7565b916104d7565b03612c7457612c7191613d54565b50565b5f63334bd91960e11b815280612c8c600482016106d1565b0390fd5b612c98611e6c565b50612cb4612ca4610dd8565b612cae600c611e84565b90612524565b90565b90612cd59594939291612cd0612ccb6114f2565b613a13565b6131b0565b565b5f7f42726964676520616464726573732063616e6e6f74206265207a65726f000000910152565b612d0b601d602092610430565b612d1481612cd7565b0190565b612d2d9060208101905f818303910152612cfe565b90565b15612d3757565b612d3f610362565b62461bcd60e51b815280612d5560048201612d18565b0390fd5b5f7f4c3220746f6b656e20616464726573732063616e6e6f74206265207a65726f00910152565b612d8d601f602092610430565b612d9681612d59565b0190565b612daf9060208101905f818303910152612d80565b90565b15612db957565b612dc1610362565b62461bcd60e51b815280612dd760048201612d9a565b0390fd5b60207f207a65726f000000000000000000000000000000000000000000000000000000917f4c322064657374696e6174696f6e20616464726573732063616e6e6f742062655f8201520152565b612e356025604092610430565b612e3e81612ddb565b0190565b612e579060208101905f818303910152612e28565b90565b15612e6157565b612e69610362565b62461bcd60e51b815280612e7f60048201612e42565b0390fd5b60207f65726f0000000000000000000000000000000000000000000000000000000000917f476173206c696d6974206d7573742062652067726561746572207468616e207a5f8201520152565b612edd6023604092610430565b612ee681612e83565b0190565b612eff9060208101905f818303910152612ed0565b90565b15612f0957565b612f11610362565b62461bcd60e51b815280612f2760048201612eea565b0390fd5b90612f3c60018060a01b03916114d1565b9181191691161790565b90565b90612f5e612f59612f659261285f565b612f46565b8254612f2b565b9055565b60a01b90565b90612f8163ffffffff60a01b91612f69565b9181191691161790565b612f9f612f9a612fa4926104f0565b61077c565b6104f0565b90565b90565b90612fbf612fba612fc692612f8b565b612fa7565b8254612f6f565b9055565b5090565b601f602091010490565b1b90565b91906008612ff7910291612ff15f1984612fd8565b92612fd8565b9181191691161790565b919061301761301261301f9361220b565b612227565b908354612fdc565b9055565b6130359161302f611e6c565b91613001565b565b5b818110613043575050565b806130505f600193613023565b01613038565b9190601f8111613066575b505050565b61307261309793610f95565b90602061307e84612fce565b8301931061309f575b61309090612fce565b0190613037565b5f8080613061565b915061309081929050613087565b906130bd905f19906008026109e0565b191690565b816130cc916130ad565b906002021790565b916130df9082612fca565b9067ffffffffffffffff821161319e57613103826130fd8554610f62565b85613056565b5f90601f831160011461313657918091613125935f9261312a575b50506130c2565b90555b565b90915001355f8061311e565b601f1983169161314585610f95565b925f5b8181106131865750916002939185600196941061316c575b50505002019055613128565b61317c910135601f8416906130ad565b90555f8080613160565b91936020600181928787013581550195019201613148565b611037565b906131ae92916130d4565b565b9192939461327791956131de846131d76131d16131cc5f611f80565b6104d7565b916104d7565b1415612d30565b613203876131fc6131f66131f15f611f80565b6104d7565b916104d7565b1415612db2565b6132288561322161321b6132165f611f80565b6104d7565b916104d7565b1415612e5a565b6132448661323e6132385f612112565b916104f0565b11612f02565b61324f84600d612f49565b61325a87600e612f49565b61326585600f612f49565b61327086600f612faa565b60106131a3565b929091926132cc6132ba6132b46132ae7f02d9f9397554a29bba1cc50e5dd30a55bd40e4d063f27e4b6dd646d28d8104609461285f565b9461285f565b9461285f565b946132c3610362565b9182918261196f565b0390a4565b906132df9594939291612cb7565b565b906132eb9061285f565b5f5260205260405f2090565b61330d61331291613306611e6c565b505f6132e1565b611e84565b90565b61332790613321611e6c565b50613df6565b90565b5f90565b606090565b61333c906126ef565b90565b9061335261334b610362565b928361104b565b565b67ffffffffffffffff811161336c5760208091020190565b611037565b9061338361337e83613354565b61333f565b918252565b369037565b906133b261339a83613371565b926020806133a88693613354565b9201910390613388565b565b600f60f81b90565b6133c461332a565b506133cd611c86565b506133d6611c86565b506133df611e6c565b506133e8611d7a565b506133f16123a0565b506133fa61332e565b50613403613e18565b9061340c613e58565b90469061341830613333565b906134225f6114d6565b9061343461342f5f612601565b61338d565b9061343d6133b4565b96959493929190565b906134509061285f565b5f5260205260405f2090565b613483915f61347861347e93613470611c42565b5060056123b0565b01613446565b611ed5565b90565b61348e611c86565b506134996004611d58565b90565b6134b9916134a8611c42565b506134b16139f6565b919091613af3565b600190565b67ffffffffffffffff81116134d35760200290565b611037565b6134e46134e9916134be565b61333f565b90565b9061350a6134f9836134d8565b9261350484916134be565b90613388565b565b61351660306134ec565b90565b905090565b6135289054611e70565b90565b60010190565b61354d613547613540836109af565b8094613519565b916109b5565b5f915b83831061355d5750505050565b61357a61357460019261356f8561351e565b611175565b9261352b565b92019190613550565b906135918161060093613531565b0190565b906135b56135ae926135a5610362565b93848092613583565b038361104b565b565b6135c090613595565b90565b6135cb61350c565b506135d660116135b7565b90565b6135e86135ee919392936105f1565b926105f1565b916135fa8382026105f1565b92818404149015171561360957565b612510565b613616611e6c565b5061361f611e6c565b50613628611e6c565b50613631611c42565b5061364561363f6009611ed5565b156103c1565b6137695761366e6136604261365a600a611e84565b90612524565b61366861165c565b9061255d565b906136b061367c600a611e84565b6136aa61369c61368c600b611e84565b6136966001612843565b9061262c565b6136a461165c565b906135d9565b9061262c565b6136ba600b611e84565b6136d36136cd6136c8610cf7565b6105f1565b916105f1565b105f1461375b576136f86136f260116136ec600b611e84565b906109b8565b906109ff565b5b9261371561370f61370a600b611e84565b6105f1565b916105f1565b1180613731575b91613727600b611e84565b9193929193929190565b5061373c600b611e84565b61375561374f61374a610cf7565b6105f1565b916105f1565b1061371c565b6137645f612601565b6136f9565b5f905f915f9161378b61378561377f5f94612601565b95612601565b93612601565b9190565b7f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c990565b91946137fb613805929897956137f160a0966137e761380c9a6137dd60c08a019e5f8b0190610835565b60208901906104e3565b60408701906104e3565b606085019061067a565b608083019061067a565b019061067a565b565b60200190565b91602061383592949361382e60408201965f8301906104e3565b01906104e3565b565b96959193929490944261385261384c836105f1565b916105f1565b1161390c57906138bb6138c49493926138a361386c61378f565b6138948c80948c9161387e8d91613e98565b9192613888610362565b978896602088016137b3565b6020820181038252038261104b565b6138b56138af82610506565b9161380e565b20613ecb565b92909192613ee8565b806138d76138d1876104d7565b916104d7565b036138ec57506138ea9293919091613a03565b565b84906139085f9283926325c0072360e11b845260048401613814565b0390fd5b613927905f91829163313c898160e11b835260048301610687565b0390fd5b906139469161394161393c826123ea565b613a13565b613948565b565b9061395291613d54565b50565b9061395f9161392b565b565b9061396b9061285f565b5f5260205260405f2090565b61399c916139926139979261398a611e6c565b506001613961565b6132e1565b611e84565b90565b6139a7611c42565b506139b2600b611e84565b6139cb6139c56139c0610cf7565b6105f1565b916105f1565b101590565b6139d8611c42565b506139f26139ec6301ffc9a760e01b610374565b91610374565b1490565b6139fe611d7a565b503390565b91613a119291600192613f0f565b565b613a2590613a1f6139f6565b90614041565b565b604090613a50613a579496959396613a4660608401985f8501906104e3565b602083019061067a565b019061067a565b565b90613a6491036105f1565b90565b929192613a75818390613977565b9081613a8a613a845f196105f1565b916105f1565b10613a97575b5050509050565b81613aaa613aa4876105f1565b916105f1565b10613ad057613ac79394613abf919392613a59565b905f92613f0f565b805f8080613a90565b50613aef849291925f938493637dc7a0d960e11b855260048501613a27565b0390fd5b9182613b0f613b09613b045f611f80565b6104d7565b916104d7565b14613b695781613b2f613b29613b245f611f80565b6104d7565b916104d7565b14613b4257613b409291909161408a565b565b613b65613b4e5f611f80565b5f91829163ec442f0560e01b8352600483016115f3565b0390fd5b613b8c613b755f611f80565b5f918291634b637e8f60e11b8352600483016115f3565b0390fd5b80613bab613ba5613ba05f611f80565b6104d7565b916104d7565b14613bc757613bc591613bbd5f611f80565b91909161408a565b565b613bea613bd35f611f80565b5f91829163ec442f0560e01b8352600483016115f3565b0390fd5b613bf6611c42565b50613c0b613c0582849061345c565b156103c1565b5f14613c9457613c336001613c2e5f613c26600586906123b0565b018590613446565b6121d5565b90613c3c6139f6565b90613c79613c73613c6d7f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d956123a4565b9261285f565b9261285f565b92613c82610362565b80613c8c816106d1565b0390a4600190565b50505f90565b613ca26123a0565b50613cac30613333565b613cde613cd87f00000000000000000000000000000000000000000000000000000000000000006104d7565b916104d7565b1480613d1a575b5f14613d0f577f000000000000000000000000000000000000000000000000000000000000000090565b613d1761426a565b90565b5046613d4e613d487f00000000000000000000000000000000000000000000000000000000000000006105f1565b916105f1565b14613ce5565b613d5c611c42565b50613d6881839061345c565b5f14613df057613d8f5f613d8a5f613d82600586906123b0565b018590613446565b6121d5565b90613d986139f6565b90613dd5613dcf613dc97ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b956123a4565b9261285f565b9261285f565b92613dde610362565b80613de8816106d1565b0390a4600190565b50505f90565b613e0d613e1291613e05611e6c565b5060086132e1565b611e84565b90565b90565b613e20611c86565b50613e557f0000000000000000000000000000000000000000000000000000000000000000613e4f6006613e15565b90614404565b90565b613e60611c86565b50613e957f0000000000000000000000000000000000000000000000000000000000000000613e8f6007613e15565b90614404565b90565b613eac90613ea4611e6c565b5060086132e1565b613ec8613eb882611e84565b91613ec28361261d565b9061222a565b90565b613ee590613ed76123a0565b50613ee0613c9a565b614452565b90565b92613f0392613f0c94613ef9611d7a565b5092909192614508565b90929192614633565b90565b909281613f2c613f26613f215f611f80565b6104d7565b916104d7565b14613ff75783613f4c613f46613f415f611f80565b6104d7565b916104d7565b14613fd057613f7083613f6b613f6460018690613961565b87906132e1565b61222a565b613f7a575b505050565b919091613fc5613fb3613fad7f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259361285f565b9361285f565b93613fbc610362565b91829182610687565b0390a35f8080613f75565b613ff3613fdc5f611f80565b5f918291634a1406b160e11b8352600483016115f3565b0390fd5b61401a6140035f611f80565b5f91829163e602df0560e01b8352600483016115f3565b0390fd5b91602061403f92949361403860408201965f8301906104e3565b0190610835565b565b9061405661405083839061345c565b156103c1565b61405e575050565b6140785f92839263e2517d3f60e01b84526004840161401e565b0390fd5b9061408791016105f1565b90565b919091806140a86140a261409d5f611f80565b6104d7565b916104d7565b145f14614189576140cc6140c5836140c06002611e84565b61262c565b600261222a565b5b826140e86140e26140dd5f611f80565b6104d7565b916104d7565b145f1461415d5761410c614105836141006002611e84565b613a59565b600261222a565b5b9190916141586141466141407fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9361285f565b9361285f565b9361414f610362565b91829182610687565b0390a3565b6141848261417e61416f5f87906132e1565b9161417983611e84565b61407c565b9061222a565b61410d565b61419c6141975f83906132e1565b611e84565b806141af6141a9856105f1565b916105f1565b106141d7576141c26141d2918490613a59565b6141cd5f84906132e1565b61222a565b6140cd565b906141f59091925f93849363391434e360e21b855260048501613a27565b0390fd5b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b90959492614268946142576142619261424d60809661424360a088019c5f890190610835565b6020870190610835565b6040850190610835565b606083019061067a565b01906104e3565b565b6142726123a0565b5061427b6141f9565b6142f27f0000000000000000000000000000000000000000000000000000000000000000916142e37f0000000000000000000000000000000000000000000000000000000000000000466142ce30613333565b916142d7610362565b9687956020870161421d565b6020820181038252038261104b565b6143046142fe82610506565b9161380e565b2090565b90565b61431f61431a61432492614308565b6114d1565b6107f1565b90565b61433160ff61430b565b90565b5f5260205f2090565b905f929180549061435761435083610f62565b8094611c8b565b916001811690815f146143ae5750600114614372575b505050565b61437f9192939450614334565b915f925b81841061439657505001905f808061436d565b60018160209295939554848601520191019290614383565b92949550505060ff19168252151560200201905f808061436d565b906143d39161433d565b90565b906143f66143ef926143e6610362565b938480926143c9565b038361104b565b565b614401906143d6565b90565b9061440d611c86565b50614417826123a4565b61443061442a614425614327565b6107f1565b916107f1565b14155f14614445575061444290614789565b90565b61444f91506143f8565b90565b60429161445d6123a0565b50604051917f19010000000000000000000000000000000000000000000000000000000000008352600283015260228201522090565b5f90565b6144a36144a891611d87565b61220b565b90565b90565b6144c26144bd6144c7926144ab565b61077c565b6105f1565b90565b6144ff614506946144f56060949897956144eb608086019a5f870190610835565b6020850190610926565b6040830190610835565b0190610835565b565b939293614513611d7a565b5061451c614493565b506145256123a0565b5061452f85614497565b61456161455b7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a06144ae565b916105f1565b116145ee5790614584602094955f9493929361457b610362565b948594856144ca565b838052039060015afa156145e95761459c5f516114d1565b806145b76145b16145ac5f611f80565b6104d7565b916104d7565b146145cd575f916145c75f6114d6565b91929190565b506145d75f611f80565b6001916145e35f6114d6565b91929190565b612830565b5050506145fa5f611f80565b9060039291929190565b634e487b7160e01b5f52602160045260245ffd5b6004111561462257565b614604565b9061463182614618565b565b806146466146405f614627565b91614627565b145f14614651575050565b8061466561465f6001614627565b91614627565b145f14614688575f63f645eedf60e01b815280614684600482016106d1565b0390fd5b8061469c6146966002614627565b91614627565b145f146146ca576146c66146af83614497565b5f91829163fce698f760e01b835260048301610687565b0390fd5b6146dd6146d76003614627565b91614627565b146146e55750565b614700905f9182916335e2f38360e21b835260048301610842565b0390fd5b90565b61471b61471661472092614704565b61077c565b6105f1565b90565b67ffffffffffffffff81116147415761473d602091610444565b0190565b611037565b9061475861475383614723565b61333f565b918252565b369037565b9061478761476f83614746565b9260208061477d8693614723565b920191039061475d565b565b614791611c86565b5061479b816147f4565b906147ae6147a96020614707565b614762565b918252602082015290565b6147cd6147c86147d292614308565b61077c565b6105f1565b90565b90565b6147ec6147e76147f1926147d5565b61077c565b6105f1565b90565b61480961480e91614803611e6c565b506123a4565b614497565b61481860ff6147b9565b168061482d614827601f6147d8565b916105f1565b116148355790565b5f632cd44ac360e21b81528061484d600482016106d1565b0390fd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x13W[a\x1C>V[a\0\x1D_5a\x03\\V[\x80c\x01\xFF\xC9\xA7\x14a\x03WW\x80c\x06\xFD\xDE\x03\x14a\x03RW\x80c\x07\xA1\xD5\xFA\x14a\x03MW\x80c\t^\xA7\xB3\x14a\x03HW\x80c\x18\x16\r\xDD\x14a\x03CW\x80c\x1B\x02\xF8E\x14a\x03>W\x80c#\xB8r\xDD\x14a\x039W\x80c#\xE1\x13L\x14a\x034W\x80c$\x8A\x9C\xA3\x14a\x03/W\x80c(N\x133\x14a\x03*W\x80c//\xF1]\x14a\x03%W\x80c1<\xE5g\x14a\x03 W\x80c3M\x0B\xBD\x14a\x03\x1BW\x80c6D\xE5\x15\x14a\x03\x16W\x80c6V\x8A\xBE\x14a\x03\x11W\x80cH\xB0\xDA\xA6\x14a\x03\x0CW\x80cK\xDD6\xCE\x14a\x03\x07W\x80cS\xB6J\xCB\x14a\x03\x02W\x80cZ\xDF\0!\x14a\x02\xFDW\x80c_\x15\xC3\xC9\x14a\x02\xF8W\x80cl\xA01\x9B\x14a\x02\xF3W\x80cl\xF0\x16%\x14a\x02\xEEW\x80co?Q\xD9\x14a\x02\xE9W\x80cp\xA0\x821\x14a\x02\xE4W\x80cvg\x18\x08\x14a\x02\xDFW\x80c{:\x12\x86\x14a\x02\xDAW\x80c~\xCE\xBE\0\x14a\x02\xD5W\x80c\x84\xB0\x19n\x14a\x02\xD0W\x80c\x90-U\xA5\x14a\x02\xCBW\x80c\x91\xD1HT\x14a\x02\xC6W\x80c\x95\xD8\x9BA\x14a\x02\xC1W\x80c\x9B~\xF6K\x14a\x02\xBCW\x80c\xA0&Y\x9A\x14a\x02\xB7W\x80c\xA1\xFA\xB7e\x14a\x02\xB2W\x80c\xA2\x17\xFD\xDF\x14a\x02\xADW\x80c\xA3*\xDE\xF8\x14a\x02\xA8W\x80c\xA3\xC5s\xEB\x14a\x02\xA3W\x80c\xA7\x0B\x9F\x0C\x14a\x02\x9EW\x80c\xA9\x05\x9C\xBB\x14a\x02\x99W\x80c\xAF*\xA6;\x14a\x02\x94W\x80c\xB5\x18\xA6\x87\x14a\x02\x8FW\x80c\xBA\xBC9O\x14a\x02\x8AW\x80c\xBD\x02\xDC%\x14a\x02\x85W\x80c\xC1#\x03\xB3\x14a\x02\x80W\x80c\xC5P\x0C\xC3\x14a\x02{W\x80c\xD5\x05\xAC\xCF\x14a\x02vW\x80c\xD5Gt\x1F\x14a\x02qW\x80c\xDDb\xED>\x14a\x02lW\x80c\xDD\x8C>]\x14a\x02gW\x80c\xE3\xAB\xDF\xCB\x14a\x02bW\x80c\xE7\x7F\x9C\xEC\x14a\x02]Wc\xF5\x08\xE1\x9D\x03a\0\x0EWa\x1C\tV[a\x1B\xC5V[a\x1B\x81V[a\x1B\x1DV[a\x1A\xE7V[a\x1A\x86V[a\x1ALV[a\x19\x84V[a\x18\xFBV[a\x18\x86V[a\x18>V[a\x17\xCBV[a\x17VV[a\x16\xABV[a\x16vV[a\x16\x08V[a\x15~V[a\x15\tV[a\x14\x99V[a\x14$V[a\x13\xAFV[a\x139V[a\x13\x03V[a\x12\xCEV[a\x12QV[a\x11\nV[a\x10\xD5V[a\x0F\x06V[a\x0E\xC2V[a\x0EoV[a\r\xFAV[a\r\x84V[a\r\x0FV[a\x0C\xA3V[a\x0C.V[a\x0B\x1BV[a\n\xE6V[a\n\xA3V[a\nnV[a\n9V[a\tHV[a\x08\xECV[a\x08\x8CV[a\x08WV[a\x07\xBCV[a\x07CV[a\x06\xD6V[a\x06\x9CV[a\x06DV[a\x05\x95V[a\x04\x97V[a\x03\xE8V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x03\x89\x81a\x03tV[\x03a\x03\x90WV[_\x80\xFD[\x90P5\x90a\x03\xA1\x82a\x03\x80V[V[\x90` \x82\x82\x03\x12a\x03\xBCWa\x03\xB9\x91_\x01a\x03\x94V[\x90V[a\x03lV[\x15\x15\x90V[a\x03\xCF\x90a\x03\xC1V[\x90RV[\x91\x90a\x03\xE6\x90_` \x85\x01\x94\x01\x90a\x03\xC6V[V[4a\x04\x18Wa\x04\x14a\x04\x03a\x03\xFE6`\x04a\x03\xA3V[a\x1CFV[a\x04\x0Ba\x03bV[\x91\x82\x91\x82a\x03\xD3V[\x03\x90\xF3[a\x03hV[_\x91\x03\x12a\x04'WV[a\x03lV[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x04ma\x04v` \x93a\x04{\x93a\x04d\x81a\x04,V[\x93\x84\x80\x93a\x040V[\x95\x86\x91\x01a\x049V[a\x04DV[\x01\x90V[a\x04\x94\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x04NV[\x90V[4a\x04\xC7Wa\x04\xA76`\x04a\x04\x1DV[a\x04\xC3a\x04\xB2a\x1DdV[a\x04\xBAa\x03bV[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xF3[a\x03hV[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x04\xE0\x90a\x04\xCCV[\x90V[a\x04\xEC\x90a\x04\xD7V[\x90RV[c\xFF\xFF\xFF\xFF\x16\x90V[a\x05\x02\x90a\x04\xF0V[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[a\x052a\x05;` \x93a\x05@\x93a\x05)\x81a\x05\x06V[\x93\x84\x80\x93a\x05\nV[\x95\x86\x91\x01a\x049V[a\x04DV[\x01\x90V[\x91\x93a\x05{a\x05\x92\x96\x94a\x05qa\x05\x85\x94\x97a\x05g`\xA0\x88\x01\x99_\x89\x01\x90a\x04\xE3V[` \x87\x01\x90a\x04\xE3V[`@\x85\x01\x90a\x04\xE3V[``\x83\x01\x90a\x04\xF9V[`\x80\x81\x84\x03\x91\x01Ra\x05\x13V[\x90V[4a\x05\xC9Wa\x05\xA56`\x04a\x04\x1DV[a\x05\xC5a\x05\xB0a\x1D\xE0V[\x91a\x05\xBC\x95\x93\x95a\x03bV[\x95\x86\x95\x86a\x05DV[\x03\x90\xF3[a\x03hV[a\x05\xD7\x81a\x04\xD7V[\x03a\x05\xDEWV[_\x80\xFD[\x90P5\x90a\x05\xEF\x82a\x05\xCEV[V[\x90V[a\x05\xFD\x81a\x05\xF1V[\x03a\x06\x04WV[_\x80\xFD[\x90P5\x90a\x06\x15\x82a\x05\xF4V[V[\x91\x90`@\x83\x82\x03\x12a\x06?W\x80a\x063a\x06<\x92_\x86\x01a\x05\xE2V[\x93` \x01a\x06\x08V[\x90V[a\x03lV[4a\x06uWa\x06qa\x06`a\x06Z6`\x04a\x06\x17V[\x90a\x1EJV[a\x06ha\x03bV[\x91\x82\x91\x82a\x03\xD3V[\x03\x90\xF3[a\x03hV[a\x06\x83\x90a\x05\xF1V[\x90RV[\x91\x90a\x06\x9A\x90_` \x85\x01\x94\x01\x90a\x06zV[V[4a\x06\xCCWa\x06\xAC6`\x04a\x04\x1DV[a\x06\xC8a\x06\xB7a\x1E\x91V[a\x06\xBFa\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[_\x01\x90V[4a\x07\x04Wa\x06\xE66`\x04a\x04\x1DV[a\x06\xEEa#gV[a\x06\xF6a\x03bV[\x80a\x07\0\x81a\x06\xD1V[\x03\x90\xF3[a\x03hV[\x90\x91``\x82\x84\x03\x12a\x07>Wa\x07;a\x07$\x84_\x85\x01a\x05\xE2V[\x93a\x072\x81` \x86\x01a\x05\xE2V[\x93`@\x01a\x06\x08V[\x90V[a\x03lV[4a\x07tWa\x07pa\x07_a\x07Y6`\x04a\x07\tV[\x91a#qV[a\x07ga\x03bV[\x91\x82\x91\x82a\x03\xD3V[\x03\x90\xF3[a\x03hV[\x90V[\x90V[a\x07\x93a\x07\x8Ea\x07\x98\x92a\x07yV[a\x07|V[a\x05\xF1V[\x90V[a\x07\xAEi\x04\x04\xF6JVZ\x19t\0\0a\x07\x7FV[\x90V[a\x07\xB9a\x07\x9BV[\x90V[4a\x07\xECWa\x07\xCC6`\x04a\x04\x1DV[a\x07\xE8a\x07\xD7a\x07\xB1V[a\x07\xDFa\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[\x90V[a\x07\xFD\x81a\x07\xF1V[\x03a\x08\x04WV[_\x80\xFD[\x90P5\x90a\x08\x15\x82a\x07\xF4V[V[\x90` \x82\x82\x03\x12a\x080Wa\x08-\x91_\x01a\x08\x08V[\x90V[a\x03lV[a\x08>\x90a\x07\xF1V[\x90RV[\x91\x90a\x08U\x90_` \x85\x01\x94\x01\x90a\x085V[V[4a\x08\x87Wa\x08\x83a\x08ra\x08m6`\x04a\x08\x17V[a#\xEAV[a\x08za\x03bV[\x91\x82\x91\x82a\x08BV[\x03\x90\xF3[a\x03hV[4a\x08\xBAWa\x08\x9C6`\x04a\x04\x1DV[a\x08\xA4a(\x8EV[a\x08\xACa\x03bV[\x80a\x08\xB6\x81a\x06\xD1V[\x03\x90\xF3[a\x03hV[\x91\x90`@\x83\x82\x03\x12a\x08\xE7W\x80a\x08\xDBa\x08\xE4\x92_\x86\x01a\x08\x08V[\x93` \x01a\x05\xE2V[\x90V[a\x03lV[4a\t\x1BWa\t\x05a\x08\xFF6`\x04a\x08\xBFV[\x90a+\xEFV[a\t\ra\x03bV[\x80a\t\x17\x81a\x06\xD1V[\x03\x90\xF3[a\x03hV[`\xFF\x16\x90V[a\t/\x90a\t V[\x90RV[\x91\x90a\tF\x90_` \x85\x01\x94\x01\x90a\t&V[V[4a\txWa\tX6`\x04a\x04\x1DV[a\tta\tca,\x1EV[a\tka\x03bV[\x91\x82\x91\x82a\t3V[\x03\x90\xF3[a\x03hV[\x90` \x82\x82\x03\x12a\t\x96Wa\t\x93\x91_\x01a\x06\x08V[\x90V[a\x03lV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[P`0\x90V[\x90V[a\t\xC1\x81a\t\xAFV[\x82\x10\x15a\t\xDBWa\t\xD3`\x01\x91a\t\xB5V[\x91\x02\x01\x90_\x90V[a\t\x9BV[\x1C\x90V[\x90V[a\t\xF7\x90`\x08a\t\xFC\x93\x02a\t\xE0V[a\t\xE4V[\x90V[\x90a\n\n\x91Ta\t\xE7V[\x90V[`\x11a\n\x18\x81a\t\xAFV[\x82\x10\x15a\n5Wa\n2\x91a\n,\x91a\t\xB8V[\x90a\t\xFFV[\x90V[_\x80\xFD[4a\niWa\nea\nTa\nO6`\x04a\t}V[a\n\rV[a\n\\a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[4a\n\x9EWa\n~6`\x04a\x04\x1DV[a\n\x9Aa\n\x89a,4V[a\n\x91a\x03bV[\x91\x82\x91\x82a\x08BV[\x03\x90\xF3[a\x03hV[4a\n\xD2Wa\n\xBCa\n\xB66`\x04a\x08\xBFV[\x90a,HV[a\n\xC4a\x03bV[\x80a\n\xCE\x81a\x06\xD1V[\x03\x90\xF3[a\x03hV[a\n\xE3`\n_\x90a\t\xFFV[\x90V[4a\x0B\x16Wa\n\xF66`\x04a\x04\x1DV[a\x0B\x12a\x0B\x01a\n\xD7V[a\x0B\ta\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[4a\x0BKWa\x0B+6`\x04a\x04\x1DV[a\x0BGa\x0B6a,\x90V[a\x0B>a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[a\x0BY\x81a\x04\xF0V[\x03a\x0B`WV[_\x80\xFD[\x90P5\x90a\x0Bq\x82a\x0BPV[V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x0B\xB9W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x0B\xB4W` \x01\x92`\x01\x83\x02\x84\x01\x11a\x0B\xAFWV[a\x0B{V[a\x0BwV[a\x0BsV[\x91\x90\x91`\xA0\x81\x84\x03\x12a\x0C)Wa\x0B\xD7\x83_\x83\x01a\x05\xE2V[\x92a\x0B\xE5\x81` \x84\x01a\x05\xE2V[\x92a\x0B\xF3\x82`@\x85\x01a\x05\xE2V[\x92a\x0C\x01\x83``\x83\x01a\x0BdV[\x92`\x80\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x0C$Wa\x0C \x92\x01a\x0B\x7FV[\x90\x91V[a\x03pV[a\x03lV[4a\x0CcWa\x0CMa\x0CA6`\x04a\x0B\xBEV[\x94\x93\x90\x93\x92\x91\x92a2\xD1V[a\x0CUa\x03bV[\x80a\x0C_\x81a\x06\xD1V[\x03\x90\xF3[a\x03hV[`\xFF\x16\x90V[a\x0C~\x90`\x08a\x0C\x83\x93\x02a\t\xE0V[a\x0ChV[\x90V[\x90a\x0C\x91\x91Ta\x0CnV[\x90V[a\x0C\xA0`\t_\x90a\x0C\x86V[\x90V[4a\x0C\xD3Wa\x0C\xB36`\x04a\x04\x1DV[a\x0C\xCFa\x0C\xBEa\x0C\x94V[a\x0C\xC6a\x03bV[\x91\x82\x91\x82a\x03\xD3V[\x03\x90\xF3[a\x03hV[\x90V[a\x0C\xEFa\x0C\xEAa\x0C\xF4\x92a\x0C\xD8V[a\x07|V[a\x05\xF1V[\x90V[a\r\x01`0a\x0C\xDBV[\x90V[a\r\x0Ca\x0C\xF7V[\x90V[4a\r?Wa\r\x1F6`\x04a\x04\x1DV[a\r;a\r*a\r\x04V[a\r2a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[\x90V[a\r[a\rVa\r`\x92a\rDV[a\x07|V[a\x05\xF1V[\x90V[a\rvi\x1F\x03\x9C\xCDe\xA9\xBE\xF0\0\0a\rGV[\x90V[a\r\x81a\rcV[\x90V[4a\r\xB4Wa\r\x946`\x04a\x04\x1DV[a\r\xB0a\r\x9Fa\ryV[a\r\xA7a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[\x90V[a\r\xD0a\r\xCBa\r\xD5\x92a\r\xB9V[a\x07|V[a\x05\xF1V[\x90V[a\r\xECj\x08E\x95\x16\x14\x01HJ\0\0\0a\r\xBCV[\x90V[a\r\xF7a\r\xD8V[\x90V[4a\x0E*Wa\x0E\n6`\x04a\x04\x1DV[a\x0E&a\x0E\x15a\r\xEFV[a\x0E\x1Da\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[\x90V[a\x0EFa\x0EAa\x0EK\x92a\x0E/V[a\x07|V[a\x05\xF1V[\x90V[a\x0Eai\x12\x9B\xC4{<\xFFr\x90\0\0a\x0E2V[\x90V[a\x0Ela\x0ENV[\x90V[4a\x0E\x9FWa\x0E\x7F6`\x04a\x04\x1DV[a\x0E\x9Ba\x0E\x8Aa\x0EdV[a\x0E\x92a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[\x90` \x82\x82\x03\x12a\x0E\xBDWa\x0E\xBA\x91_\x01a\x05\xE2V[\x90V[a\x03lV[4a\x0E\xF2Wa\x0E\xEEa\x0E\xDDa\x0E\xD86`\x04a\x0E\xA4V[a2\xF7V[a\x0E\xE5a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[a\x0F\x03`\x0B_\x90a\t\xFFV[\x90V[4a\x0F6Wa\x0F\x166`\x04a\x04\x1DV[a\x0F2a\x0F!a\x0E\xF7V[a\x0F)a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x0F\x82W[` \x83\x10\x14a\x0F}WV[a\x0FNV[\x91`\x7F\x16\x91a\x0FrV[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x0F\xB8a\x0F\xB1\x83a\x0FbV[\x80\x94a\x0F\x8CV[\x91`\x01\x81\x16\x90\x81_\x14a\x10\x0FWP`\x01\x14a\x0F\xD3W[PPPV[a\x0F\xE0\x91\x92\x93\x94Pa\x0F\x95V[\x91_\x92[\x81\x84\x10a\x0F\xF7WPP\x01\x90_\x80\x80a\x0F\xCEV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x0F\xE4V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x0F\xCEV[\x90a\x104\x91a\x0F\x9EV[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x10U\x90a\x04DV[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x10oW`@RV[a\x107V[\x90a\x10\x94a\x10\x8D\x92a\x10\x84a\x03bV[\x93\x84\x80\x92a\x10*V[\x03\x83a\x10KV[V[\x90_\x10a\x10\xA9Wa\x10\xA6\x90a\x10tV[\x90V[a\x0F;V[a\x10\xBA`\x10_\x90a\x10\x96V[\x90V[a\x10\xD2\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x05\x13V[\x90V[4a\x11\x05Wa\x10\xE56`\x04a\x04\x1DV[a\x11\x01a\x10\xF0a\x10\xAEV[a\x10\xF8a\x03bV[\x91\x82\x91\x82a\x10\xBDV[\x03\x90\xF3[a\x03hV[4a\x11:Wa\x116a\x11%a\x11 6`\x04a\x0E\xA4V[a3\x15V[a\x11-a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[`\xFF`\xF8\x1B\x16\x90V[a\x11Q\x90a\x11?V[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\x11q\x90a\x05\xF1V[\x90RV[\x90a\x11\x82\x81` \x93a\x11hV[\x01\x90V[` \x01\x90V[\x90a\x11\xA9a\x11\xA3a\x11\x9C\x84a\x11UV[\x80\x93a\x11YV[\x92a\x11bV[\x90_[\x81\x81\x10a\x11\xB9WPPP\x90V[\x90\x91\x92a\x11\xD2a\x11\xCC`\x01\x92\x86Qa\x11uV[\x94a\x11\x86V[\x91\x01\x91\x90\x91a\x11\xACV[\x93\x95\x91\x94a\x12-a\x12\"a\x12A\x95a\x12\x14a\x127\x95a\x12N\x9C\x9Aa\x12\x07`\xE0\x8C\x01\x92_\x8D\x01\x90a\x11HV[\x8A\x82\x03` \x8C\x01Ra\x04NV[\x90\x88\x82\x03`@\x8A\x01Ra\x04NV[\x97``\x87\x01\x90a\x06zV[`\x80\x85\x01\x90a\x04\xE3V[`\xA0\x83\x01\x90a\x085V[`\xC0\x81\x84\x03\x91\x01Ra\x11\x8CV[\x90V[4a\x12\x88Wa\x12a6`\x04a\x04\x1DV[a\x12\x84a\x12la3\xBCV[\x93a\x12{\x97\x95\x97\x93\x91\x93a\x03bV[\x97\x88\x97\x88a\x11\xDCV[\x03\x90\xF3[a\x03hV[\x90V[a\x12\xA4a\x12\x9Fa\x12\xA9\x92a\x12\x8DV[a\x07|V[a\x05\xF1V[\x90V[a\x12\xC0jR\xB7\xD2\xDC\xC8\x0C\xD2\xE4\0\0\0a\x12\x90V[\x90V[a\x12\xCBa\x12\xACV[\x90V[4a\x12\xFEWa\x12\xDE6`\x04a\x04\x1DV[a\x12\xFAa\x12\xE9a\x12\xC3V[a\x12\xF1a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[4a\x134Wa\x130a\x13\x1Fa\x13\x196`\x04a\x08\xBFV[\x90a4\\V[a\x13'a\x03bV[\x91\x82\x91\x82a\x03\xD3V[\x03\x90\xF3[a\x03hV[4a\x13iWa\x13I6`\x04a\x04\x1DV[a\x13ea\x13Ta4\x86V[a\x13\\a\x03bV[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xF3[a\x03hV[\x90V[a\x13\x85a\x13\x80a\x13\x8A\x92a\x13nV[a\x07|V[a\x05\xF1V[\x90V[a\x13\xA1jJr=\xC6\xB4\x0B\x8A\x9A\0\0\0a\x13qV[\x90V[a\x13\xACa\x13\x8DV[\x90V[4a\x13\xDFWa\x13\xBF6`\x04a\x04\x1DV[a\x13\xDBa\x13\xCAa\x13\xA4V[a\x13\xD2a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[\x90V[a\x13\xFBa\x13\xF6a\x14\0\x92a\x13\xE4V[a\x07|V[a\x05\xF1V[\x90V[a\x14\x16iV&v\x0C\x16b\xBE$\0\0a\x13\xE7V[\x90V[a\x14!a\x14\x03V[\x90V[4a\x14TWa\x1446`\x04a\x04\x1DV[a\x14Pa\x14?a\x14\x19V[a\x14Ga\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[\x90V[a\x14pa\x14ka\x14u\x92a\x14YV[a\x07|V[a\x05\xF1V[\x90V[a\x14\x8Bi\x0B*H=m\xAD\xEE\x18\0\0a\x14\\V[\x90V[a\x14\x96a\x14xV[\x90V[4a\x14\xC9Wa\x14\xA96`\x04a\x04\x1DV[a\x14\xC5a\x14\xB4a\x14\x8EV[a\x14\xBCa\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[\x90V[_\x1B\x90V[a\x14\xEAa\x14\xE5a\x14\xEF\x92a\x14\xCEV[a\x14\xD1V[a\x07\xF1V[\x90V[a\x14\xFB_a\x14\xD6V[\x90V[a\x15\x06a\x14\xF2V[\x90V[4a\x159Wa\x15\x196`\x04a\x04\x1DV[a\x155a\x15$a\x14\xFEV[a\x15,a\x03bV[\x91\x82\x91\x82a\x08BV[\x03\x90\xF3[a\x03hV[\x90V[a\x15Ua\x15Pa\x15Z\x92a\x15>V[a\x07|V[a\x05\xF1V[\x90V[a\x15pi3\xB0\xB0\0\xFE\xC5\x93\x90\0\0a\x15AV[\x90V[a\x15{a\x15]V[\x90V[4a\x15\xAEWa\x15\x8E6`\x04a\x04\x1DV[a\x15\xAAa\x15\x99a\x15sV[a\x15\xA1a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x15\xCE\x90`\x08a\x15\xD3\x93\x02a\t\xE0V[a\x15\xB3V[\x90V[\x90a\x15\xE1\x91Ta\x15\xBEV[\x90V[a\x15\xF0`\r_\x90a\x15\xD6V[\x90V[\x91\x90a\x16\x06\x90_` \x85\x01\x94\x01\x90a\x04\xE3V[V[4a\x168Wa\x16\x186`\x04a\x04\x1DV[a\x164a\x16#a\x15\xE4V[a\x16+a\x03bV[\x91\x82\x91\x82a\x15\xF3V[\x03\x90\xF3[a\x03hV[\x90V[a\x16Ta\x16Oa\x16Y\x92a\x16=V[a\x07|V[a\x05\xF1V[\x90V[a\x16hb'\x8D\0a\x16@V[\x90V[a\x16sa\x16\\V[\x90V[4a\x16\xA6Wa\x16\x866`\x04a\x04\x1DV[a\x16\xA2a\x16\x91a\x16kV[a\x16\x99a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[4a\x16\xDCWa\x16\xD8a\x16\xC7a\x16\xC16`\x04a\x06\x17V[\x90a4\x9CV[a\x16\xCFa\x03bV[\x91\x82\x91\x82a\x03\xD3V[\x03\x90\xF3[a\x03hV[P`0\x90V[\x90P\x90V[\x90V[` \x01\x90V[a\x17\x11a\x17\x0Ba\x17\x04\x83a\x16\xE1V[\x80\x94a\x16\xE7V[\x91a\x16\xECV[_\x91[\x83\x83\x10a\x17!WPPPPV[a\x177a\x171`\x01\x92\x84Qa\x11uV[\x92a\x16\xEFV[\x92\x01\x91\x90a\x17\x14V[\x91\x90a\x17T\x90_a\x06\0\x85\x01\x94\x01\x90a\x16\xF5V[V[4a\x17\x86Wa\x17f6`\x04a\x04\x1DV[a\x17\x82a\x17qa5\xC3V[a\x17ya\x03bV[\x91\x82\x91\x82a\x17@V[\x03\x90\xF3[a\x03hV[\x90V[a\x17\xA2a\x17\x9Da\x17\xA7\x92a\x17\x8BV[a\x07|V[a\x05\xF1V[\x90V[a\x17\xBDi\x06\xB2\xEF\xD1:\x96*l\0\0a\x17\x8EV[\x90V[a\x17\xC8a\x17\xAAV[\x90V[4a\x17\xFBWa\x17\xDB6`\x04a\x04\x1DV[a\x17\xF7a\x17\xE6a\x17\xC0V[a\x17\xEEa\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[a\x185a\x18<\x94a\x18+``\x94\x98\x97\x95a\x18!`\x80\x86\x01\x9A_\x87\x01\x90a\x06zV[` \x85\x01\x90a\x06zV[`@\x83\x01\x90a\x06zV[\x01\x90a\x03\xC6V[V[4a\x18rWa\x18N6`\x04a\x04\x1DV[a\x18na\x18Ya6\x0EV[\x90a\x18e\x94\x92\x94a\x03bV[\x94\x85\x94\x85a\x18\0V[\x03\x90\xF3[a\x03hV[a\x18\x83`\x0F_\x90a\x15\xD6V[\x90V[4a\x18\xB6Wa\x18\x966`\x04a\x04\x1DV[a\x18\xB2a\x18\xA1a\x18wV[a\x18\xA9a\x03bV[\x91\x82\x91\x82a\x15\xF3V[\x03\x90\xF3[a\x03hV[\x90V[a\x18\xD2a\x18\xCDa\x18\xD7\x92a\x18\xBBV[a\x07|V[a\x05\xF1V[\x90V[a\x18\xEDi\x8F\x95oiz\xA4\x92<\0\0a\x18\xBEV[\x90V[a\x18\xF8a\x18\xDAV[\x90V[4a\x19+Wa\x19\x0B6`\x04a\x04\x1DV[a\x19'a\x19\x16a\x18\xF0V[a\x19\x1Ea\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[c\xFF\xFF\xFF\xFF\x16\x90V[a\x19I\x90`\x08a\x19N\x93\x02a\t\xE0V[a\x190V[\x90V[\x90a\x19\\\x91Ta\x199V[\x90V[a\x19l`\x0F`\x14\x90a\x19QV[\x90V[\x91\x90a\x19\x82\x90_` \x85\x01\x94\x01\x90a\x04\xF9V[V[4a\x19\xB4Wa\x19\x946`\x04a\x04\x1DV[a\x19\xB0a\x19\x9Fa\x19_V[a\x19\xA7a\x03bV[\x91\x82\x91\x82a\x19oV[\x03\x90\xF3[a\x03hV[a\x19\xC2\x81a\t V[\x03a\x19\xC9WV[_\x80\xFD[\x90P5\x90a\x19\xDA\x82a\x19\xB9V[V[`\xE0\x81\x83\x03\x12a\x1AGWa\x19\xF2\x82_\x83\x01a\x05\xE2V[\x92a\x1A\0\x83` \x84\x01a\x05\xE2V[\x92a\x1A\x0E\x81`@\x85\x01a\x06\x08V[\x92a\x1A\x1C\x82``\x83\x01a\x06\x08V[\x92a\x1ADa\x1A-\x84`\x80\x85\x01a\x19\xCDV[\x93a\x1A;\x81`\xA0\x86\x01a\x08\x08V[\x93`\xC0\x01a\x08\x08V[\x90V[a\x03lV[4a\x1A\x81Wa\x1Aka\x1A_6`\x04a\x19\xDCV[\x95\x94\x90\x94\x93\x91\x93a87V[a\x1Asa\x03bV[\x80a\x1A}\x81a\x06\xD1V[\x03\x90\xF3[a\x03hV[4a\x1A\xB5Wa\x1A\x9Fa\x1A\x996`\x04a\x08\xBFV[\x90a9UV[a\x1A\xA7a\x03bV[\x80a\x1A\xB1\x81a\x06\xD1V[\x03\x90\xF3[a\x03hV[\x91\x90`@\x83\x82\x03\x12a\x1A\xE2W\x80a\x1A\xD6a\x1A\xDF\x92_\x86\x01a\x05\xE2V[\x93` \x01a\x05\xE2V[\x90V[a\x03lV[4a\x1B\x18Wa\x1B\x14a\x1B\x03a\x1A\xFD6`\x04a\x1A\xBAV[\x90a9wV[a\x1B\x0Ba\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[4a\x1BMWa\x1B-6`\x04a\x04\x1DV[a\x1BIa\x1B8a9\x9FV[a\x1B@a\x03bV[\x91\x82\x91\x82a\x03\xD3V[\x03\x90\xF3[a\x03hV[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[a\x1B~a\x1BRV[\x90V[4a\x1B\xB1Wa\x1B\x916`\x04a\x04\x1DV[a\x1B\xADa\x1B\x9Ca\x1BvV[a\x1B\xA4a\x03bV[\x91\x82\x91\x82a\x08BV[\x03\x90\xF3[a\x03hV[a\x1B\xC2`\x0E_\x90a\x15\xD6V[\x90V[4a\x1B\xF5Wa\x1B\xD56`\x04a\x04\x1DV[a\x1B\xF1a\x1B\xE0a\x1B\xB6V[a\x1B\xE8a\x03bV[\x91\x82\x91\x82a\x15\xF3V[\x03\x90\xF3[a\x03hV[a\x1C\x06`\x0C_\x90a\t\xFFV[\x90V[4a\x1C9Wa\x1C\x196`\x04a\x04\x1DV[a\x1C5a\x1C$a\x1B\xFAV[a\x1C,a\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xF3[a\x03hV[_\x80\xFD[_\x90V[a\x1CNa\x1CBV[P\x80a\x1Cia\x1Cccye\xDB\x0B`\xE0\x1Ba\x03tV[\x91a\x03tV[\x14\x90\x81\x15a\x1CvW[P\x90V[a\x1C\x80\x91Pa9\xD0V[_a\x1CrV[``\x90V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x1C\xB7a\x1C\xB0\x83a\x0FbV[\x80\x94a\x1C\x8BV[\x91`\x01\x81\x16\x90\x81_\x14a\x1D\x0EWP`\x01\x14a\x1C\xD2W[PPPV[a\x1C\xDF\x91\x92\x93\x94Pa\x1C\x94V[\x91_\x92[\x81\x84\x10a\x1C\xF6WPP\x01\x90_\x80\x80a\x1C\xCDV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x1C\xE3V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x1C\xCDV[\x90a\x1D3\x91a\x1C\x9DV[\x90V[\x90a\x1DVa\x1DO\x92a\x1DFa\x03bV[\x93\x84\x80\x92a\x1D)V[\x03\x83a\x10KV[V[a\x1Da\x90a\x1D6V[\x90V[a\x1Dla\x1C\x86V[Pa\x1Dw`\x03a\x1DXV[\x90V[_\x90V[_\x90V[``\x90V[_\x1C\x90V[a\x1D\x98a\x1D\x9D\x91a\x1D\x87V[a\x15\xB3V[\x90V[a\x1D\xAA\x90Ta\x1D\x8CV[\x90V[`\xA0\x1C\x90V[a\x1D\xBFa\x1D\xC4\x91a\x1D\xADV[a\x190V[\x90V[a\x1D\xD1\x90Ta\x1D\xB3V[\x90V[a\x1D\xDD\x90a\x10tV[\x90V[a\x1D\xE8a\x1DzV[Pa\x1D\xF1a\x1DzV[Pa\x1D\xFAa\x1DzV[Pa\x1E\x03a\x1D~V[Pa\x1E\x0Ca\x1D\x82V[Pa\x1E\x17`\ra\x1D\xA0V[a\x1E!`\x0Ea\x1D\xA0V[\x91a\x1E,`\x0Fa\x1D\xA0V[\x91a\x1E7`\x0Fa\x1D\xC7V[\x91a\x1EG`\x10\x92\x95\x94\x93\x92a\x1D\xD4V[\x90V[a\x1Eg\x91a\x1EVa\x1CBV[Pa\x1E_a9\xF6V[\x91\x90\x91a:\x03V[`\x01\x90V[_\x90V[a\x1E|a\x1E\x81\x91a\x1D\x87V[a\t\xE4V[\x90V[a\x1E\x8E\x90Ta\x1EpV[\x90V[a\x1E\x99a\x1ElV[Pa\x1E\xA4`\x02a\x1E\x84V[\x90V[a\x1E\xB7a\x1E\xB2a\x1BRV[a:\x13V[a\x1E\xBFa\"JV[V[a\x1E\xCDa\x1E\xD2\x91a\x1D\x87V[a\x0ChV[\x90V[a\x1E\xDF\x90Ta\x1E\xC1V[\x90V[_\x7FEmissions already started\0\0\0\0\0\0\0\x91\x01RV[a\x1F\x16`\x19` \x92a\x040V[a\x1F\x1F\x81a\x1E\xE2V[\x01\x90V[a\x1F8\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x1F\tV[\x90V[\x15a\x1FBWV[a\x1FJa\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x1F``\x04\x82\x01a\x1F#V[\x03\x90\xFD[a\x1Fxa\x1Fsa\x1F}\x92a\x14\xCEV[a\x07|V[a\x04\xCCV[\x90V[a\x1F\x89\x90a\x1FdV[\x90V[_\x7FBridge address not set\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x1F\xC0`\x16` \x92a\x040V[a\x1F\xC9\x81a\x1F\x8CV[\x01\x90V[a\x1F\xE2\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x1F\xB3V[\x90V[\x15a\x1F\xECWV[a\x1F\xF4a\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a \n`\x04\x82\x01a\x1F\xCDV[\x03\x90\xFD[_\x7FL2 token address not set\0\0\0\0\0\0\0\0\x91\x01RV[a B`\x18` \x92a\x040V[a K\x81a \x0EV[\x01\x90V[a d\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra 5V[\x90V[\x15a nWV[a va\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a \x8C`\x04\x82\x01a OV[\x03\x90\xFD[_\x7FL2 destination address not set\0\0\x91\x01RV[a \xC4`\x1E` \x92a\x040V[a \xCD\x81a \x90V[\x01\x90V[a \xE6\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra \xB7V[\x90V[\x15a \xF0WV[a \xF8a\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a!\x0E`\x04\x82\x01a \xD1V[\x03\x90\xFD[a!&a!!a!+\x92a\x14\xCEV[a\x07|V[a\x04\xF0V[\x90V[_\x7FBridge gas limit not set\0\0\0\0\0\0\0\0\x91\x01RV[a!b`\x18` \x92a\x040V[a!k\x81a!.V[\x01\x90V[a!\x84\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra!UV[\x90V[\x15a!\x8EWV[a!\x96a\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a!\xAC`\x04\x82\x01a!oV[\x03\x90\xFD[\x90a!\xBC`\xFF\x91a\x14\xD1V[\x91\x81\x19\x16\x91\x16\x17\x90V[a!\xCF\x90a\x03\xC1V[\x90V[\x90V[\x90a!\xEAa!\xE5a!\xF1\x92a!\xC6V[a!\xD2V[\x82Ta!\xB0V[\x90UV[\x90a\"\x01_\x19\x91a\x14\xD1V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\"\x1Fa\"\x1Aa\"$\x92a\x05\xF1V[a\x07|V[a\x05\xF1V[\x90V[\x90V[\x90a\"?a\":a\"F\x92a\"\x0BV[a\"'V[\x82Ta!\xF5V[\x90UV[a\"ea\"`a\"Z`\ta\x1E\xD5V[\x15a\x03\xC1V[a\x1F;V[a\"\x93a\"r`\ra\x1D\xA0V[a\"\x8Ca\"\x86a\"\x81_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14\x15a\x1F\xE5V[a\"\xC1a\"\xA0`\x0Ea\x1D\xA0V[a\"\xBAa\"\xB4a\"\xAF_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14\x15a gV[a\"\xEFa\"\xCE`\x0Fa\x1D\xA0V[a\"\xE8a\"\xE2a\"\xDD_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14\x15a \xE9V[a#\x14a\"\xFC`\x0Fa\x1D\xC7V[a#\x0Ea#\x08_a!\x12V[\x91a\x04\xF0V[\x11a!\x87V[a# `\x01`\ta!\xD5V[a#+B`\na\"*V[Ba#b\x7F\x11\x94\xB04\xCF\xA9\xABX\x07IJ\x1D\\f}\x8B\x0En\x97\xF3\x88\x88t*\xA3\x87\x1A2 4\x11`\x91a#Ya\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xA1V[a#oa\x1E\xA7V[V[\x91a#\x9B\x92a#~a\x1CBV[Pa#\x93a#\x8Aa9\xF6V[\x82\x90\x84\x91a:gV[\x91\x90\x91a:\xF3V[`\x01\x90V[_\x90V[a#\xAD\x90a\x07\xF1V[\x90V[\x90a#\xBA\x90a#\xA4V[_R` R`@_ \x90V[\x90V[a#\xD5a#\xDA\x91a\x1D\x87V[a#\xC6V[\x90V[a#\xE7\x90Ta#\xC9V[\x90V[`\x01a$\x03a$\t\x92a#\xFBa#\xA0V[P`\x05a#\xB0V[\x01a#\xDDV[\x90V[_\x7FEmissions not started\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a$@`\x15` \x92a\x040V[a$I\x81a$\x0CV[\x01\x90V[a$b\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra$3V[\x90V[\x15a$lWV[a$ta\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a$\x8A`\x04\x82\x01a$MV[\x03\x90\xFD[_\x7FAll emissions completed\0\0\0\0\0\0\0\0\0\x91\x01RV[a$\xC2`\x17` \x92a\x040V[a$\xCB\x81a$\x8EV[\x01\x90V[a$\xE4\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra$\xB5V[\x90V[\x15a$\xEEWV[a$\xF6a\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a%\x0C`\x04\x82\x01a$\xCFV[\x03\x90\xFD[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a%3a%9\x91\x93\x92\x93a\x05\xF1V[\x92a\x05\xF1V[\x82\x03\x91\x82\x11a%DWV[a%\x10V[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a%ia%o\x91a\x05\xF1V[\x91a\x05\xF1V[\x90\x81\x15a%zW\x04\x90V[a%IV[_\x7FCurrent epoch already minted\0\0\0\0\x91\x01RV[a%\xB3`\x1C` \x92a\x040V[a%\xBC\x81a%\x7FV[\x01\x90V[a%\xD5\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra%\xA6V[\x90V[\x15a%\xDFWV[a%\xE7a\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a%\xFD`\x04\x82\x01a%\xC0V[\x03\x90\xFD[a&\x15a&\x10a&\x1A\x92a\x14\xCEV[a\x07|V[a\x05\xF1V[\x90V[`\x01a&)\x91\x01a\x05\xF1V[\x90V[a&;a&A\x91\x93\x92\x93a\x05\xF1V[\x92a\x05\xF1V[\x82\x01\x80\x92\x11a&LWV[a%\x10V[_\x7FCannot exceed emissions supply\0\0\x91\x01RV[a&\x85`\x1E` \x92a\x040V[a&\x8E\x81a&QV[\x01\x90V[a&\xA7\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra&xV[\x90V[\x15a&\xB1WV[a&\xB9a\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a&\xCF`\x04\x82\x01a&\x92V[\x03\x90\xFD[a&\xE7a&\xE2a&\xEC\x92a\x04\xCCV[a\x07|V[a\x04\xCCV[\x90V[a&\xF8\x90a&\xD3V[\x90V[a'\x04\x90a&\xEFV[\x90V[a'\x10\x90a&\xD3V[\x90V[a'\x1C\x90a'\x07V[\x90V[a'(\x90a&\xEFV[\x90V[_\x80\xFD[`\xE0\x1B\x90V[_\x91\x03\x12a'?WV[a\x03lV[\x90_\x92\x91\x80T\x90a'^a'W\x83a\x0FbV[\x80\x94a\x05\nV[\x91`\x01\x81\x16\x90\x81_\x14a'\xB5WP`\x01\x14a'yW[PPPV[a'\x86\x91\x92\x93\x94Pa\x0F\x95V[\x91_\x92[\x81\x84\x10a'\x9DWPP\x01\x90_\x80\x80a'tV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a'\x8AV[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a'tV[\x92a(-\x96\x94a(\x0Ca(\x16\x92a(\x02a( \x96\x99\x95\x99a'\xF8`\xC0\x8A\x01\x9B_\x8B\x01\x90a\x04\xE3V[` \x89\x01\x90a\x04\xE3V[`@\x87\x01\x90a\x04\xE3V[``\x85\x01\x90a\x06zV[`\x80\x83\x01\x90a\x04\xF9V[`\xA0\x81\x84\x03\x91\x01Ra'DV[\x90V[a(8a\x03bV[=_\x82>=\x90\xFD[\x90V[a(Wa(Ra(\\\x92a(@V[a\x07|V[a\x05\xF1V[\x90V[a(h\x90a&\xEFV[\x90V[\x91` a(\x8C\x92\x94\x93a(\x85`@\x82\x01\x96_\x83\x01\x90a\x06zV[\x01\x90a\x06zV[V[a(\xA0a(\x9B`\ta\x1E\xD5V[a$eV[a(\xCCa(\xAD`\x0Ba\x1E\x84V[a(\xC6a(\xC0a(\xBBa\x0C\xF7V[a\x05\xF1V[\x91a\x05\xF1V[\x10a$\xE7V[a))a(\xF4a(\xE6Ba(\xE0`\na\x1E\x84V[\x90a%$V[a(\xEEa\x16\\V[\x90a%]V[a)\x19\x81a)\x13a)\ra)\x08`\x0Ba\x1E\x84V[a\x05\xF1V[\x91a\x05\xF1V[\x11a%\xD8V[a)#`\x0Ba\x1E\x84V[\x90a%$V[\x90\x81a)Wa)Qa)La)<a\x0C\xF7V[a)F`\x0Ba\x1E\x84V[\x90a%$V[a\x05\xF1V[\x91a\x05\xF1V[\x11a+\xA2W[a)f_a&\x01V[\x90a)p_a&\x01V[\x91[\x82a)\x85a)\x7F\x86a\x05\xF1V[\x91a\x05\xF1V[\x10\x15a)\xCCWa)\xC0a)\xC6\x91a)\xBAa)\xB4`\x11a)\xAEa)\xA7`\x0Ba\x1E\x84V[\x89\x90a&,V[\x90a\t\xB8V[\x90a\t\xFFV[\x90a&,V[\x92a&\x1DV[\x91a)rV[\x91P\x91a*\x1Ca*#\x91a*\ra)\xEDa)\xE6`\x0Ca\x1E\x84V[\x86\x90a&,V[a*\x06a*\0a)\xFBa\r\xD8V[a\x05\xF1V[\x91a\x05\xF1V[\x11\x15a&\xAAV[a*\x17`\x0Ba\x1E\x84V[a&,V[`\x0Ba\"*V[a*@a*9\x82a*4`\x0Ca\x1E\x84V[a&,V[`\x0Ca\"*V[a*Sa*L0a&\xFBV[\x82\x90a;\x90V[a*pa*_0a&\xFBV[a*i`\ra\x1D\xA0V[\x83\x91a:\x03V[a*\x8Aa*\x85a*\x80`\ra\x1D\xA0V[a'\x13V[a'\x1FV[cT\n\xBFsa*\x980a&\xFBV[a*\xA2`\x0Ea\x1D\xA0V[\x92a*\xAD`\x0Fa\x1D\xA0V[\x92\x85a*\xB9`\x0Fa\x1D\xC7V[\x91`\x10\x95\x84;\x15a+\x9DW_\x96a*\xE4\x94\x88\x94a*\xEF\x93a*\xD8a\x03bV[\x9B\x8C\x9A\x8B\x99\x8A\x98a'/V[\x88R`\x04\x88\x01a'\xD0V[\x03\x92Z\xF1\x80\x15a+\x98Wa+lW[Pa+\x1Ca+\x0C`\x0Ba\x1E\x84V[a+\x16`\x01a(CV[\x90a%$V[\x90a+'`\x0Fa\x1D\xA0V[\x90a+R\x7F4\xB7=\x0C\x96\xE9\xFFMS\x11CH\x17\xC8\xEC\xC90\xE7\xD2x,[\xDE.y\xDCD\xB0YgU\xBB\x92a(_V[\x92a+ga+^a\x03bV[\x92\x83\x92\x83a(kV[\x03\x90\xA2V[a+\x8B\x90_=\x81\x11a+\x91W[a+\x83\x81\x83a\x10KV[\x81\x01\x90a'5V[_a*\xFEV[P=a+yV[a(0V[a'+V[\x90Pa+\xBFa+\xAFa\x0C\xF7V[a+\xB9`\x0Ba\x1E\x84V[\x90a%$V[\x90a)]V[\x90a+\xE0\x91a+\xDBa+\xD6\x82a#\xEAV[a:\x13V[a+\xE2V[V[\x90a+\xEC\x91a;\xEEV[PV[\x90a+\xF9\x91a+\xC5V[V[_\x90V[\x90V[a,\x16a,\x11a,\x1B\x92a+\xFFV[a\x07|V[a\t V[\x90V[a,&a+\xFBV[Pa,1`\x12a,\x02V[\x90V[a,<a#\xA0V[Pa,Ea<\x9AV[\x90V[\x90\x80a,ca,]a,Xa9\xF6V[a\x04\xD7V[\x91a\x04\xD7V[\x03a,tWa,q\x91a=TV[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a,\x8C`\x04\x82\x01a\x06\xD1V[\x03\x90\xFD[a,\x98a\x1ElV[Pa,\xB4a,\xA4a\r\xD8V[a,\xAE`\x0Ca\x1E\x84V[\x90a%$V[\x90V[\x90a,\xD5\x95\x94\x93\x92\x91a,\xD0a,\xCBa\x14\xF2V[a:\x13V[a1\xB0V[V[_\x7FBridge address cannot be zero\0\0\0\x91\x01RV[a-\x0B`\x1D` \x92a\x040V[a-\x14\x81a,\xD7V[\x01\x90V[a--\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra,\xFEV[\x90V[\x15a-7WV[a-?a\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a-U`\x04\x82\x01a-\x18V[\x03\x90\xFD[_\x7FL2 token address cannot be zero\0\x91\x01RV[a-\x8D`\x1F` \x92a\x040V[a-\x96\x81a-YV[\x01\x90V[a-\xAF\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra-\x80V[\x90V[\x15a-\xB9WV[a-\xC1a\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a-\xD7`\x04\x82\x01a-\x9AV[\x03\x90\xFD[` \x7F zero\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FL2 destination address cannot be_\x82\x01R\x01RV[a.5`%`@\x92a\x040V[a.>\x81a-\xDBV[\x01\x90V[a.W\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra.(V[\x90V[\x15a.aWV[a.ia\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a.\x7F`\x04\x82\x01a.BV[\x03\x90\xFD[` \x7Fero\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FGas limit must be greater than z_\x82\x01R\x01RV[a.\xDD`#`@\x92a\x040V[a.\xE6\x81a.\x83V[\x01\x90V[a.\xFF\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra.\xD0V[\x90V[\x15a/\tWV[a/\x11a\x03bV[bF\x1B\xCD`\xE5\x1B\x81R\x80a/'`\x04\x82\x01a.\xEAV[\x03\x90\xFD[\x90a/<`\x01\x80`\xA0\x1B\x03\x91a\x14\xD1V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x90a/^a/Ya/e\x92a(_V[a/FV[\x82Ta/+V[\x90UV[`\xA0\x1B\x90V[\x90a/\x81c\xFF\xFF\xFF\xFF`\xA0\x1B\x91a/iV[\x91\x81\x19\x16\x91\x16\x17\x90V[a/\x9Fa/\x9Aa/\xA4\x92a\x04\xF0V[a\x07|V[a\x04\xF0V[\x90V[\x90V[\x90a/\xBFa/\xBAa/\xC6\x92a/\x8BV[a/\xA7V[\x82Ta/oV[\x90UV[P\x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a/\xF7\x91\x02\x91a/\xF1_\x19\x84a/\xD8V[\x92a/\xD8V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a0\x17a0\x12a0\x1F\x93a\"\x0BV[a\"'V[\x90\x83Ta/\xDCV[\x90UV[a05\x91a0/a\x1ElV[\x91a0\x01V[V[[\x81\x81\x10a0CWPPV[\x80a0P_`\x01\x93a0#V[\x01a08V[\x91\x90`\x1F\x81\x11a0fW[PPPV[a0ra0\x97\x93a\x0F\x95V[\x90` a0~\x84a/\xCEV[\x83\x01\x93\x10a0\x9FW[a0\x90\x90a/\xCEV[\x01\x90a07V[_\x80\x80a0aV[\x91Pa0\x90\x81\x92\x90Pa0\x87V[\x90a0\xBD\x90_\x19\x90`\x08\x02a\t\xE0V[\x19\x16\x90V[\x81a0\xCC\x91a0\xADV[\x90`\x02\x02\x17\x90V[\x91a0\xDF\x90\x82a/\xCAV[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a1\x9EWa1\x03\x82a0\xFD\x85Ta\x0FbV[\x85a0VV[_\x90`\x1F\x83\x11`\x01\x14a16W\x91\x80\x91a1%\x93_\x92a1*W[PPa0\xC2V[\x90U[V[\x90\x91P\x015_\x80a1\x1EV[`\x1F\x19\x83\x16\x91a1E\x85a\x0F\x95V[\x92_[\x81\x81\x10a1\x86WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a1lW[PPP\x02\x01\x90Ua1(V[a1|\x91\x015`\x1F\x84\x16\x90a0\xADV[\x90U_\x80\x80a1`V[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a1HV[a\x107V[\x90a1\xAE\x92\x91a0\xD4V[V[\x91\x92\x93\x94a2w\x91\x95a1\xDE\x84a1\xD7a1\xD1a1\xCC_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14\x15a-0V[a2\x03\x87a1\xFCa1\xF6a1\xF1_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14\x15a-\xB2V[a2(\x85a2!a2\x1Ba2\x16_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14\x15a.ZV[a2D\x86a2>a28_a!\x12V[\x91a\x04\xF0V[\x11a/\x02V[a2O\x84`\ra/IV[a2Z\x87`\x0Ea/IV[a2e\x85`\x0Fa/IV[a2p\x86`\x0Fa/\xAAV[`\x10a1\xA3V[\x92\x90\x91\x92a2\xCCa2\xBAa2\xB4a2\xAE\x7F\x02\xD9\xF99uT\xA2\x9B\xBA\x1C\xC5\x0E]\xD3\nU\xBD@\xE4\xD0c\xF2~Km\xD6F\xD2\x8D\x81\x04`\x94a(_V[\x94a(_V[\x94a(_V[\x94a2\xC3a\x03bV[\x91\x82\x91\x82a\x19oV[\x03\x90\xA4V[\x90a2\xDF\x95\x94\x93\x92\x91a,\xB7V[V[\x90a2\xEB\x90a(_V[_R` R`@_ \x90V[a3\ra3\x12\x91a3\x06a\x1ElV[P_a2\xE1V[a\x1E\x84V[\x90V[a3'\x90a3!a\x1ElV[Pa=\xF6V[\x90V[_\x90V[``\x90V[a3<\x90a&\xEFV[\x90V[\x90a3Ra3Ka\x03bV[\x92\x83a\x10KV[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a3lW` \x80\x91\x02\x01\x90V[a\x107V[\x90a3\x83a3~\x83a3TV[a3?V[\x91\x82RV[6\x907V[\x90a3\xB2a3\x9A\x83a3qV[\x92` \x80a3\xA8\x86\x93a3TV[\x92\x01\x91\x03\x90a3\x88V[V[`\x0F`\xF8\x1B\x90V[a3\xC4a3*V[Pa3\xCDa\x1C\x86V[Pa3\xD6a\x1C\x86V[Pa3\xDFa\x1ElV[Pa3\xE8a\x1DzV[Pa3\xF1a#\xA0V[Pa3\xFAa3.V[Pa4\x03a>\x18V[\x90a4\x0Ca>XV[\x90F\x90a4\x180a33V[\x90a4\"_a\x14\xD6V[\x90a44a4/_a&\x01V[a3\x8DV[\x90a4=a3\xB4V[\x96\x95\x94\x93\x92\x91\x90V[\x90a4P\x90a(_V[_R` R`@_ \x90V[a4\x83\x91_a4xa4~\x93a4pa\x1CBV[P`\x05a#\xB0V[\x01a4FV[a\x1E\xD5V[\x90V[a4\x8Ea\x1C\x86V[Pa4\x99`\x04a\x1DXV[\x90V[a4\xB9\x91a4\xA8a\x1CBV[Pa4\xB1a9\xF6V[\x91\x90\x91a:\xF3V[`\x01\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a4\xD3W` \x02\x90V[a\x107V[a4\xE4a4\xE9\x91a4\xBEV[a3?V[\x90V[\x90a5\na4\xF9\x83a4\xD8V[\x92a5\x04\x84\x91a4\xBEV[\x90a3\x88V[V[a5\x16`0a4\xECV[\x90V[\x90P\x90V[a5(\x90Ta\x1EpV[\x90V[`\x01\x01\x90V[a5Ma5Ga5@\x83a\t\xAFV[\x80\x94a5\x19V[\x91a\t\xB5V[_\x91[\x83\x83\x10a5]WPPPPV[a5za5t`\x01\x92a5o\x85a5\x1EV[a\x11uV[\x92a5+V[\x92\x01\x91\x90a5PV[\x90a5\x91\x81a\x06\0\x93a51V[\x01\x90V[\x90a5\xB5a5\xAE\x92a5\xA5a\x03bV[\x93\x84\x80\x92a5\x83V[\x03\x83a\x10KV[V[a5\xC0\x90a5\x95V[\x90V[a5\xCBa5\x0CV[Pa5\xD6`\x11a5\xB7V[\x90V[a5\xE8a5\xEE\x91\x93\x92\x93a\x05\xF1V[\x92a\x05\xF1V[\x91a5\xFA\x83\x82\x02a\x05\xF1V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a6\tWV[a%\x10V[a6\x16a\x1ElV[Pa6\x1Fa\x1ElV[Pa6(a\x1ElV[Pa61a\x1CBV[Pa6Ea6?`\ta\x1E\xD5V[\x15a\x03\xC1V[a7iWa6na6`Ba6Z`\na\x1E\x84V[\x90a%$V[a6ha\x16\\V[\x90a%]V[\x90a6\xB0a6|`\na\x1E\x84V[a6\xAAa6\x9Ca6\x8C`\x0Ba\x1E\x84V[a6\x96`\x01a(CV[\x90a&,V[a6\xA4a\x16\\V[\x90a5\xD9V[\x90a&,V[a6\xBA`\x0Ba\x1E\x84V[a6\xD3a6\xCDa6\xC8a\x0C\xF7V[a\x05\xF1V[\x91a\x05\xF1V[\x10_\x14a7[Wa6\xF8a6\xF2`\x11a6\xEC`\x0Ba\x1E\x84V[\x90a\t\xB8V[\x90a\t\xFFV[[\x92a7\x15a7\x0Fa7\n`\x0Ba\x1E\x84V[a\x05\xF1V[\x91a\x05\xF1V[\x11\x80a71W[\x91a7'`\x0Ba\x1E\x84V[\x91\x93\x92\x91\x93\x92\x91\x90V[Pa7<`\x0Ba\x1E\x84V[a7Ua7Oa7Ja\x0C\xF7V[a\x05\xF1V[\x91a\x05\xF1V[\x10a7\x1CV[a7d_a&\x01V[a6\xF9V[_\x90_\x91_\x91a7\x8Ba7\x85a7\x7F_\x94a&\x01V[\x95a&\x01V[\x93a&\x01V[\x91\x90V[\x7Fnq\xED\xAE\x12\xB1\xB9\x7FM\x1F`7\x0F\xEF\x10\x10_\xA2\xFA\xAE\x01&\x11J\x16\x9Cd\x84]a&\xC9\x90V[\x91\x94a7\xFBa8\x05\x92\x98\x97\x95a7\xF1`\xA0\x96a7\xE7a8\x0C\x9Aa7\xDD`\xC0\x8A\x01\x9E_\x8B\x01\x90a\x085V[` \x89\x01\x90a\x04\xE3V[`@\x87\x01\x90a\x04\xE3V[``\x85\x01\x90a\x06zV[`\x80\x83\x01\x90a\x06zV[\x01\x90a\x06zV[V[` \x01\x90V[\x91` a85\x92\x94\x93a8.`@\x82\x01\x96_\x83\x01\x90a\x04\xE3V[\x01\x90a\x04\xE3V[V[\x96\x95\x91\x93\x92\x94\x90\x94Ba8Ra8L\x83a\x05\xF1V[\x91a\x05\xF1V[\x11a9\x0CW\x90a8\xBBa8\xC4\x94\x93\x92a8\xA3a8la7\x8FV[a8\x94\x8C\x80\x94\x8C\x91a8~\x8D\x91a>\x98V[\x91\x92a8\x88a\x03bV[\x97\x88\x96` \x88\x01a7\xB3V[` \x82\x01\x81\x03\x82R\x03\x82a\x10KV[a8\xB5a8\xAF\x82a\x05\x06V[\x91a8\x0EV[ a>\xCBV[\x92\x90\x91\x92a>\xE8V[\x80a8\xD7a8\xD1\x87a\x04\xD7V[\x91a\x04\xD7V[\x03a8\xECWPa8\xEA\x92\x93\x91\x90\x91a:\x03V[V[\x84\x90a9\x08_\x92\x83\x92c%\xC0\x07#`\xE1\x1B\x84R`\x04\x84\x01a8\x14V[\x03\x90\xFD[a9'\x90_\x91\x82\x91c1<\x89\x81`\xE1\x1B\x83R`\x04\x83\x01a\x06\x87V[\x03\x90\xFD[\x90a9F\x91a9Aa9<\x82a#\xEAV[a:\x13V[a9HV[V[\x90a9R\x91a=TV[PV[\x90a9_\x91a9+V[V[\x90a9k\x90a(_V[_R` R`@_ \x90V[a9\x9C\x91a9\x92a9\x97\x92a9\x8Aa\x1ElV[P`\x01a9aV[a2\xE1V[a\x1E\x84V[\x90V[a9\xA7a\x1CBV[Pa9\xB2`\x0Ba\x1E\x84V[a9\xCBa9\xC5a9\xC0a\x0C\xF7V[a\x05\xF1V[\x91a\x05\xF1V[\x10\x15\x90V[a9\xD8a\x1CBV[Pa9\xF2a9\xECc\x01\xFF\xC9\xA7`\xE0\x1Ba\x03tV[\x91a\x03tV[\x14\x90V[a9\xFEa\x1DzV[P3\x90V[\x91a:\x11\x92\x91`\x01\x92a?\x0FV[V[a:%\x90a:\x1Fa9\xF6V[\x90a@AV[V[`@\x90a:Pa:W\x94\x96\x95\x93\x96a:F``\x84\x01\x98_\x85\x01\x90a\x04\xE3V[` \x83\x01\x90a\x06zV[\x01\x90a\x06zV[V[\x90a:d\x91\x03a\x05\xF1V[\x90V[\x92\x91\x92a:u\x81\x83\x90a9wV[\x90\x81a:\x8Aa:\x84_\x19a\x05\xF1V[\x91a\x05\xF1V[\x10a:\x97W[PPP\x90PV[\x81a:\xAAa:\xA4\x87a\x05\xF1V[\x91a\x05\xF1V[\x10a:\xD0Wa:\xC7\x93\x94a:\xBF\x91\x93\x92a:YV[\x90_\x92a?\x0FV[\x80_\x80\x80a:\x90V[Pa:\xEF\x84\x92\x91\x92_\x93\x84\x93c}\xC7\xA0\xD9`\xE1\x1B\x85R`\x04\x85\x01a:'V[\x03\x90\xFD[\x91\x82a;\x0Fa;\ta;\x04_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14a;iW\x81a;/a;)a;$_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14a;BWa;@\x92\x91\x90\x91a@\x8AV[V[a;ea;N_a\x1F\x80V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x15\xF3V[\x03\x90\xFD[a;\x8Ca;u_a\x1F\x80V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x15\xF3V[\x03\x90\xFD[\x80a;\xABa;\xA5a;\xA0_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14a;\xC7Wa;\xC5\x91a;\xBD_a\x1F\x80V[\x91\x90\x91a@\x8AV[V[a;\xEAa;\xD3_a\x1F\x80V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x15\xF3V[\x03\x90\xFD[a;\xF6a\x1CBV[Pa<\x0Ba<\x05\x82\x84\x90a4\\V[\x15a\x03\xC1V[_\x14a<\x94Wa<3`\x01a<._a<&`\x05\x86\x90a#\xB0V[\x01\x85\x90a4FV[a!\xD5V[\x90a<<a9\xF6V[\x90a<ya<sa<m\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a#\xA4V[\x92a(_V[\x92a(_V[\x92a<\x82a\x03bV[\x80a<\x8C\x81a\x06\xD1V[\x03\x90\xA4`\x01\x90V[PP_\x90V[a<\xA2a#\xA0V[Pa<\xAC0a33V[a<\xDEa<\xD8\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04\xD7V[\x91a\x04\xD7V[\x14\x80a=\x1AW[_\x14a=\x0FW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[a=\x17aBjV[\x90V[PFa=Na=H\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x05\xF1V[\x91a\x05\xF1V[\x14a<\xE5V[a=\\a\x1CBV[Pa=h\x81\x83\x90a4\\V[_\x14a=\xF0Wa=\x8F_a=\x8A_a=\x82`\x05\x86\x90a#\xB0V[\x01\x85\x90a4FV[a!\xD5V[\x90a=\x98a9\xF6V[\x90a=\xD5a=\xCFa=\xC9\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a#\xA4V[\x92a(_V[\x92a(_V[\x92a=\xDEa\x03bV[\x80a=\xE8\x81a\x06\xD1V[\x03\x90\xA4`\x01\x90V[PP_\x90V[a>\ra>\x12\x91a>\x05a\x1ElV[P`\x08a2\xE1V[a\x1E\x84V[\x90V[\x90V[a> a\x1C\x86V[Pa>U\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a>O`\x06a>\x15V[\x90aD\x04V[\x90V[a>`a\x1C\x86V[Pa>\x95\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a>\x8F`\x07a>\x15V[\x90aD\x04V[\x90V[a>\xAC\x90a>\xA4a\x1ElV[P`\x08a2\xE1V[a>\xC8a>\xB8\x82a\x1E\x84V[\x91a>\xC2\x83a&\x1DV[\x90a\"*V[\x90V[a>\xE5\x90a>\xD7a#\xA0V[Pa>\xE0a<\x9AV[aDRV[\x90V[\x92a?\x03\x92a?\x0C\x94a>\xF9a\x1DzV[P\x92\x90\x91\x92aE\x08V[\x90\x92\x91\x92aF3V[\x90V[\x90\x92\x81a?,a?&a?!_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14a?\xF7W\x83a?La?Fa?A_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14a?\xD0Wa?p\x83a?ka?d`\x01\x86\x90a9aV[\x87\x90a2\xE1V[a\"*V[a?zW[PPPV[\x91\x90\x91a?\xC5a?\xB3a?\xAD\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%\x93a(_V[\x93a(_V[\x93a?\xBCa\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xA3_\x80\x80a?uV[a?\xF3a?\xDC_a\x1F\x80V[_\x91\x82\x91cJ\x14\x06\xB1`\xE1\x1B\x83R`\x04\x83\x01a\x15\xF3V[\x03\x90\xFD[a@\x1Aa@\x03_a\x1F\x80V[_\x91\x82\x91c\xE6\x02\xDF\x05`\xE0\x1B\x83R`\x04\x83\x01a\x15\xF3V[\x03\x90\xFD[\x91` a@?\x92\x94\x93a@8`@\x82\x01\x96_\x83\x01\x90a\x04\xE3V[\x01\x90a\x085V[V[\x90a@Va@P\x83\x83\x90a4\\V[\x15a\x03\xC1V[a@^WPPV[a@x_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01a@\x1EV[\x03\x90\xFD[\x90a@\x87\x91\x01a\x05\xF1V[\x90V[\x91\x90\x91\x80a@\xA8a@\xA2a@\x9D_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14_\x14aA\x89Wa@\xCCa@\xC5\x83a@\xC0`\x02a\x1E\x84V[a&,V[`\x02a\"*V[[\x82a@\xE8a@\xE2a@\xDD_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14_\x14aA]WaA\x0CaA\x05\x83aA\0`\x02a\x1E\x84V[a:YV[`\x02a\"*V[[\x91\x90\x91aAXaAFaA@\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a(_V[\x93a(_V[\x93aAOa\x03bV[\x91\x82\x91\x82a\x06\x87V[\x03\x90\xA3V[aA\x84\x82aA~aAo_\x87\x90a2\xE1V[\x91aAy\x83a\x1E\x84V[a@|V[\x90a\"*V[aA\rV[aA\x9CaA\x97_\x83\x90a2\xE1V[a\x1E\x84V[\x80aA\xAFaA\xA9\x85a\x05\xF1V[\x91a\x05\xF1V[\x10aA\xD7WaA\xC2aA\xD2\x91\x84\x90a:YV[aA\xCD_\x84\x90a2\xE1V[a\"*V[a@\xCDV[\x90aA\xF5\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01a:'V[\x03\x90\xFD[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[\x90\x95\x94\x92aBh\x94aBWaBa\x92aBM`\x80\x96aBC`\xA0\x88\x01\x9C_\x89\x01\x90a\x085V[` \x87\x01\x90a\x085V[`@\x85\x01\x90a\x085V[``\x83\x01\x90a\x06zV[\x01\x90a\x04\xE3V[V[aBra#\xA0V[PaB{aA\xF9V[aB\xF2\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91aB\xE3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0FaB\xCE0a33V[\x91aB\xD7a\x03bV[\x96\x87\x95` \x87\x01aB\x1DV[` \x82\x01\x81\x03\x82R\x03\x82a\x10KV[aC\x04aB\xFE\x82a\x05\x06V[\x91a8\x0EV[ \x90V[\x90V[aC\x1FaC\x1AaC$\x92aC\x08V[a\x14\xD1V[a\x07\xF1V[\x90V[aC1`\xFFaC\x0BV[\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90aCWaCP\x83a\x0FbV[\x80\x94a\x1C\x8BV[\x91`\x01\x81\x16\x90\x81_\x14aC\xAEWP`\x01\x14aCrW[PPPV[aC\x7F\x91\x92\x93\x94PaC4V[\x91_\x92[\x81\x84\x10aC\x96WPP\x01\x90_\x80\x80aCmV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90aC\x83V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80aCmV[\x90aC\xD3\x91aC=V[\x90V[\x90aC\xF6aC\xEF\x92aC\xE6a\x03bV[\x93\x84\x80\x92aC\xC9V[\x03\x83a\x10KV[V[aD\x01\x90aC\xD6V[\x90V[\x90aD\ra\x1C\x86V[PaD\x17\x82a#\xA4V[aD0aD*aD%aC'V[a\x07\xF1V[\x91a\x07\xF1V[\x14\x15_\x14aDEWPaDB\x90aG\x89V[\x90V[aDO\x91PaC\xF8V[\x90V[`B\x91aD]a#\xA0V[P`@Q\x91\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R`\x02\x83\x01R`\"\x82\x01R \x90V[_\x90V[aD\xA3aD\xA8\x91a\x1D\x87V[a\"\x0BV[\x90V[\x90V[aD\xC2aD\xBDaD\xC7\x92aD\xABV[a\x07|V[a\x05\xF1V[\x90V[aD\xFFaE\x06\x94aD\xF5``\x94\x98\x97\x95aD\xEB`\x80\x86\x01\x9A_\x87\x01\x90a\x085V[` \x85\x01\x90a\t&V[`@\x83\x01\x90a\x085V[\x01\x90a\x085V[V[\x93\x92\x93aE\x13a\x1DzV[PaE\x1CaD\x93V[PaE%a#\xA0V[PaE/\x85aD\x97V[aEaaE[\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0aD\xAEV[\x91a\x05\xF1V[\x11aE\xEEW\x90aE\x84` \x94\x95_\x94\x93\x92\x93aE{a\x03bV[\x94\x85\x94\x85aD\xCAV[\x83\x80R\x03\x90`\x01Z\xFA\x15aE\xE9WaE\x9C_Qa\x14\xD1V[\x80aE\xB7aE\xB1aE\xAC_a\x1F\x80V[a\x04\xD7V[\x91a\x04\xD7V[\x14aE\xCDW_\x91aE\xC7_a\x14\xD6V[\x91\x92\x91\x90V[PaE\xD7_a\x1F\x80V[`\x01\x91aE\xE3_a\x14\xD6V[\x91\x92\x91\x90V[a(0V[PPPaE\xFA_a\x1F\x80V[\x90`\x03\x92\x91\x92\x91\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x04\x11\x15aF\"WV[aF\x04V[\x90aF1\x82aF\x18V[V[\x80aFFaF@_aF'V[\x91aF'V[\x14_\x14aFQWPPV[\x80aFeaF_`\x01aF'V[\x91aF'V[\x14_\x14aF\x88W_c\xF6E\xEE\xDF`\xE0\x1B\x81R\x80aF\x84`\x04\x82\x01a\x06\xD1V[\x03\x90\xFD[\x80aF\x9CaF\x96`\x02aF'V[\x91aF'V[\x14_\x14aF\xCAWaF\xC6aF\xAF\x83aD\x97V[_\x91\x82\x91c\xFC\xE6\x98\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x06\x87V[\x03\x90\xFD[aF\xDDaF\xD7`\x03aF'V[\x91aF'V[\x14aF\xE5WPV[aG\0\x90_\x91\x82\x91c5\xE2\xF3\x83`\xE2\x1B\x83R`\x04\x83\x01a\x08BV[\x03\x90\xFD[\x90V[aG\x1BaG\x16aG \x92aG\x04V[a\x07|V[a\x05\xF1V[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11aGAWaG=` \x91a\x04DV[\x01\x90V[a\x107V[\x90aGXaGS\x83aG#V[a3?V[\x91\x82RV[6\x907V[\x90aG\x87aGo\x83aGFV[\x92` \x80aG}\x86\x93aG#V[\x92\x01\x91\x03\x90aG]V[V[aG\x91a\x1C\x86V[PaG\x9B\x81aG\xF4V[\x90aG\xAEaG\xA9` aG\x07V[aGbV[\x91\x82R` \x82\x01R\x90V[aG\xCDaG\xC8aG\xD2\x92aC\x08V[a\x07|V[a\x05\xF1V[\x90V[\x90V[aG\xECaG\xE7aG\xF1\x92aG\xD5V[a\x07|V[a\x05\xF1V[\x90V[aH\taH\x0E\x91aH\x03a\x1ElV[Pa#\xA4V[aD\x97V[aH\x18`\xFFaG\xB9V[\x16\x80aH-aH'`\x1FaG\xD8V[\x91a\x05\xF1V[\x11aH5W\x90V[_c,\xD4J\xC3`\xE2\x1B\x81R\x80aHM`\x04\x82\x01a\x06\xD1V[\x03\x90\xFD",
    );
    /**Custom error with signature `AccessControlBadConfirmation()` and selector `0x6697b232`.
```solidity
error AccessControlBadConfirmation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlBadConfirmation {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlBadConfirmation>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlBadConfirmation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlBadConfirmation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlBadConfirmation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlBadConfirmation()";
            const SELECTOR: [u8; 4] = [102u8, 151u8, 178u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `AccessControlUnauthorizedAccount(address,bytes32)` and selector `0xe2517d3f`.
```solidity
error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub neededRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlUnauthorizedAccount) -> Self {
                (value.account, value.neededRole)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    neededRole: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlUnauthorizedAccount(address,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 81u8, 125u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.neededRole),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignature()` and selector `0xf645eedf`.
```solidity
error ECDSAInvalidSignature();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignature {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignature()";
            const SELECTOR: [u8; 4] = [246u8, 69u8, 238u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureLength(uint256)` and selector `0xfce698f7`.
```solidity
error ECDSAInvalidSignatureLength(uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureLength {
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureLength) -> Self {
                (value.length,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ECDSAInvalidSignatureLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { length: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureLength(uint256)";
            const SELECTOR: [u8; 4] = [252u8, 230u8, 152u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureS(bytes32)` and selector `0xd78bce0c`.
```solidity
error ECDSAInvalidSignatureS(bytes32 s);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureS {
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureS> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureS) -> Self {
                (value.s,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignatureS {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { s: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureS {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureS(bytes32)";
            const SELECTOR: [u8; 4] = [215u8, 139u8, 206u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InsufficientAllowance(address,uint256,uint256)` and selector `0xfb8f41b2`.
```solidity
error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InsufficientAllowance {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub allowance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InsufficientAllowance>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InsufficientAllowance) -> Self {
                (value.spender, value.allowance, value.needed)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC20InsufficientAllowance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    spender: tuple.0,
                    allowance: tuple.1,
                    needed: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InsufficientAllowance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InsufficientAllowance(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [251u8, 143u8, 65u8, 178u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allowance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.needed),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InsufficientBalance(address,uint256,uint256)` and selector `0xe450d38c`.
```solidity
error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InsufficientBalance {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub balance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InsufficientBalance>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InsufficientBalance) -> Self {
                (value.sender, value.balance, value.needed)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC20InsufficientBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    sender: tuple.0,
                    balance: tuple.1,
                    needed: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InsufficientBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InsufficientBalance(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [228u8, 80u8, 211u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.needed),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidApprover(address)` and selector `0xe602df05`.
```solidity
error ERC20InvalidApprover(address approver);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidApprover {
        #[allow(missing_docs)]
        pub approver: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidApprover> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidApprover) -> Self {
                (value.approver,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidApprover {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { approver: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidApprover {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidApprover(address)";
            const SELECTOR: [u8; 4] = [230u8, 2u8, 223u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.approver,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidReceiver(address)` and selector `0xec442f05`.
```solidity
error ERC20InvalidReceiver(address receiver);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidReceiver {
        #[allow(missing_docs)]
        pub receiver: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidReceiver> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidReceiver) -> Self {
                (value.receiver,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidReceiver {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { receiver: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidReceiver {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidReceiver(address)";
            const SELECTOR: [u8; 4] = [236u8, 68u8, 47u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.receiver,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidSender(address)` and selector `0x96c6fd1e`.
```solidity
error ERC20InvalidSender(address sender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidSender {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidSender> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidSender) -> Self {
                (value.sender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidSender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { sender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidSender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidSender(address)";
            const SELECTOR: [u8; 4] = [150u8, 198u8, 253u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidSpender(address)` and selector `0x94280d62`.
```solidity
error ERC20InvalidSpender(address spender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidSpender {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidSpender> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidSpender) -> Self {
                (value.spender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidSpender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { spender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidSpender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidSpender(address)";
            const SELECTOR: [u8; 4] = [148u8, 40u8, 13u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC2612ExpiredSignature(uint256)` and selector `0x62791302`.
```solidity
error ERC2612ExpiredSignature(uint256 deadline);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC2612ExpiredSignature {
        #[allow(missing_docs)]
        pub deadline: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC2612ExpiredSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ERC2612ExpiredSignature) -> Self {
                (value.deadline,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC2612ExpiredSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { deadline: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC2612ExpiredSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC2612ExpiredSignature(uint256)";
            const SELECTOR: [u8; 4] = [98u8, 121u8, 19u8, 2u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deadline),
                )
            }
        }
    };
    /**Custom error with signature `ERC2612InvalidSigner(address,address)` and selector `0x4b800e46`.
```solidity
error ERC2612InvalidSigner(address signer, address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC2612InvalidSigner {
        #[allow(missing_docs)]
        pub signer: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC2612InvalidSigner> for UnderlyingRustTuple<'_> {
            fn from(value: ERC2612InvalidSigner) -> Self {
                (value.signer, value.owner)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC2612InvalidSigner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    signer: tuple.0,
                    owner: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC2612InvalidSigner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC2612InvalidSigner(address,address)";
            const SELECTOR: [u8; 4] = [75u8, 128u8, 14u8, 70u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signer,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `InvalidAccountNonce(address,uint256)` and selector `0x752d88c0`.
```solidity
error InvalidAccountNonce(address account, uint256 currentNonce);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidAccountNonce {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub currentNonce: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidAccountNonce> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidAccountNonce) -> Self {
                (value.account, value.currentNonce)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidAccountNonce {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    currentNonce: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidAccountNonce {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidAccountNonce(address,uint256)";
            const SELECTOR: [u8; 4] = [117u8, 45u8, 136u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.currentNonce),
                )
            }
        }
    };
    /**Custom error with signature `InvalidShortString()` and selector `0xb3512b0c`.
```solidity
error InvalidShortString();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidShortString {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidShortString> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidShortString) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidShortString {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidShortString {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidShortString()";
            const SELECTOR: [u8; 4] = [179u8, 81u8, 43u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `StringTooLong(string)` and selector `0x305a27a9`.
```solidity
error StringTooLong(string str);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct StringTooLong {
        #[allow(missing_docs)]
        pub str: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<StringTooLong> for UnderlyingRustTuple<'_> {
            fn from(value: StringTooLong) -> Self {
                (value.str,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for StringTooLong {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { str: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for StringTooLong {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "StringTooLong(string)";
            const SELECTOR: [u8; 4] = [48u8, 90u8, 39u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.str,
                    ),
                )
            }
        }
    };
    /**Event with signature `Approval(address,address,uint256)` and selector `0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925`.
```solidity
event Approval(address indexed owner, address indexed spender, uint256 value);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Approval {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Approval {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Approval(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                140u8,
                91u8,
                225u8,
                229u8,
                235u8,
                236u8,
                125u8,
                91u8,
                209u8,
                79u8,
                113u8,
                66u8,
                125u8,
                30u8,
                132u8,
                243u8,
                221u8,
                3u8,
                20u8,
                192u8,
                247u8,
                178u8,
                41u8,
                30u8,
                91u8,
                32u8,
                10u8,
                200u8,
                199u8,
                195u8,
                185u8,
                37u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    owner: topics.1,
                    spender: topics.2,
                    value: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.owner.clone(), self.spender.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.owner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.spender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Approval {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Approval> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Approval) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeConfigurationUpdated(address,address,address,uint32)` and selector `0x02d9f9397554a29bba1cc50e5dd30a55bd40e4d063f27e4b6dd646d28d810460`.
```solidity
event BridgeConfigurationUpdated(address indexed bridgeAddress, address indexed l2TokenAddress, address indexed l2DestinationAddress, uint32 gasLimit);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeConfigurationUpdated {
        #[allow(missing_docs)]
        pub bridgeAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub l2TokenAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub l2DestinationAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub gasLimit: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeConfigurationUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeConfigurationUpdated(address,address,address,uint32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                2u8,
                217u8,
                249u8,
                57u8,
                117u8,
                84u8,
                162u8,
                155u8,
                186u8,
                28u8,
                197u8,
                14u8,
                93u8,
                211u8,
                10u8,
                85u8,
                189u8,
                64u8,
                228u8,
                208u8,
                99u8,
                242u8,
                126u8,
                75u8,
                109u8,
                214u8,
                70u8,
                210u8,
                141u8,
                129u8,
                4u8,
                96u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    bridgeAddress: topics.1,
                    l2TokenAddress: topics.2,
                    l2DestinationAddress: topics.3,
                    gasLimit: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasLimit),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.bridgeAddress.clone(),
                    self.l2TokenAddress.clone(),
                    self.l2DestinationAddress.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridgeAddress,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.l2TokenAddress,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.l2DestinationAddress,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeConfigurationUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeConfigurationUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &BridgeConfigurationUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EIP712DomainChanged()` and selector `0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31`.
```solidity
event EIP712DomainChanged();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EIP712DomainChanged {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EIP712DomainChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EIP712DomainChanged()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                10u8,
                99u8,
                135u8,
                201u8,
                234u8,
                54u8,
                40u8,
                184u8,
                138u8,
                99u8,
                59u8,
                180u8,
                243u8,
                177u8,
                81u8,
                119u8,
                15u8,
                112u8,
                8u8,
                81u8,
                23u8,
                161u8,
                95u8,
                155u8,
                243u8,
                120u8,
                124u8,
                218u8,
                83u8,
                241u8,
                61u8,
                49u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EIP712DomainChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EIP712DomainChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EIP712DomainChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionMinted(uint256,uint256,address)` and selector `0x34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb`.
```solidity
event EmissionMinted(uint256 epoch, uint256 amount, address indexed l2DestinationAddress);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionMinted {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub l2DestinationAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionMinted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "EmissionMinted(uint256,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                52u8,
                183u8,
                61u8,
                12u8,
                150u8,
                233u8,
                255u8,
                77u8,
                83u8,
                17u8,
                67u8,
                72u8,
                23u8,
                200u8,
                236u8,
                201u8,
                48u8,
                231u8,
                210u8,
                120u8,
                44u8,
                91u8,
                222u8,
                46u8,
                121u8,
                220u8,
                68u8,
                176u8,
                89u8,
                103u8,
                85u8,
                187u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    epoch: data.0,
                    amount: data.1,
                    l2DestinationAddress: topics.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epoch),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.l2DestinationAddress.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.l2DestinationAddress,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionMinted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionMinted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionMinted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionsStarted(uint256)` and selector `0x1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a3220341160`.
```solidity
event EmissionsStarted(uint256 startTime);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionsStarted {
        #[allow(missing_docs)]
        pub startTime: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionsStarted {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EmissionsStarted(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                17u8,
                148u8,
                176u8,
                52u8,
                207u8,
                169u8,
                171u8,
                88u8,
                7u8,
                73u8,
                74u8,
                29u8,
                92u8,
                102u8,
                125u8,
                139u8,
                14u8,
                110u8,
                151u8,
                243u8,
                136u8,
                136u8,
                116u8,
                42u8,
                163u8,
                135u8,
                26u8,
                50u8,
                32u8,
                52u8,
                17u8,
                96u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { startTime: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startTime),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionsStarted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionsStarted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionsStarted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Transfer(address,address,uint256)` and selector `0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef`.
```solidity
event Transfer(address indexed from, address indexed to, uint256 value);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Transfer {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Transfer {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Transfer(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                221u8,
                242u8,
                82u8,
                173u8,
                27u8,
                226u8,
                200u8,
                155u8,
                105u8,
                194u8,
                176u8,
                104u8,
                252u8,
                55u8,
                141u8,
                170u8,
                149u8,
                43u8,
                167u8,
                241u8,
                99u8,
                196u8,
                161u8,
                22u8,
                40u8,
                245u8,
                90u8,
                77u8,
                245u8,
                35u8,
                179u8,
                239u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    from: topics.1,
                    to: topics.2,
                    value: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.from.clone(), self.to.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.from,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.to,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Transfer {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Transfer> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Transfer) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address defaultAdmin, address syndFoundationAddress, address emissionsManager);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub defaultAdmin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub syndFoundationAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub emissionsManager: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value.defaultAdmin,
                        value.syndFoundationAddress,
                        value.emissionsManager,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        defaultAdmin: tuple.0,
                        syndFoundationAddress: tuple.1,
                        emissionsManager: tuple.2,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.defaultAdmin,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.syndFoundationAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.emissionsManager,
                    ),
                )
            }
        }
    };
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall {}
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DEFAULT_ADMIN_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DOMAIN_SEPARATOR()` and selector `0x3644e515`.
```solidity
function DOMAIN_SEPARATOR() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DOMAIN_SEPARATORCall {}
    ///Container type for the return parameters of the [`DOMAIN_SEPARATOR()`](DOMAIN_SEPARATORCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DOMAIN_SEPARATORReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DOMAIN_SEPARATORCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DOMAIN_SEPARATORCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DOMAIN_SEPARATORCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DOMAIN_SEPARATORReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DOMAIN_SEPARATORReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DOMAIN_SEPARATORReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DOMAIN_SEPARATORCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DOMAIN_SEPARATORReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DOMAIN_SEPARATOR()";
            const SELECTOR: [u8; 4] = [54u8, 68u8, 229u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSIONS_MANAGER_ROLE()` and selector `0xe3abdfcb`.
```solidity
function EMISSIONS_MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_MANAGER_ROLECall {}
    ///Container type for the return parameters of the [`EMISSIONS_MANAGER_ROLE()`](EMISSIONS_MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_MANAGER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_MANAGER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSIONS_MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSIONS_MANAGER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSIONS_MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [227u8, 171u8, 223u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSIONS_SUPPLY()` and selector `0x6cf01625`.
```solidity
function EMISSIONS_SUPPLY() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_SUPPLYCall {}
    ///Container type for the return parameters of the [`EMISSIONS_SUPPLY()`](EMISSIONS_SUPPLYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_SUPPLYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_SUPPLYCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_SUPPLYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_SUPPLYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_SUPPLYReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_SUPPLYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_SUPPLYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSIONS_SUPPLYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSIONS_SUPPLYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSIONS_SUPPLY()";
            const SELECTOR: [u8; 4] = [108u8, 240u8, 22u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSION_AMOUNT_1()` and selector `0xc12303b3`.
```solidity
function EMISSION_AMOUNT_1() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_AMOUNT_1Call {}
    ///Container type for the return parameters of the [`EMISSION_AMOUNT_1()`](EMISSION_AMOUNT_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_AMOUNT_1Return {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_AMOUNT_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_AMOUNT_1Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_AMOUNT_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_AMOUNT_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_AMOUNT_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_AMOUNT_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSION_AMOUNT_1Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSION_AMOUNT_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSION_AMOUNT_1()";
            const SELECTOR: [u8; 4] = [193u8, 35u8, 3u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSION_AMOUNT_2()` and selector `0xa026599a`.
```solidity
function EMISSION_AMOUNT_2() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_AMOUNT_2Call {}
    ///Container type for the return parameters of the [`EMISSION_AMOUNT_2()`](EMISSION_AMOUNT_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_AMOUNT_2Return {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_AMOUNT_2Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_AMOUNT_2Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_AMOUNT_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_AMOUNT_2Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_AMOUNT_2Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_AMOUNT_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSION_AMOUNT_2Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSION_AMOUNT_2Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSION_AMOUNT_2()";
            const SELECTOR: [u8; 4] = [160u8, 38u8, 89u8, 154u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSION_AMOUNT_3()` and selector `0xa32adef8`.
```solidity
function EMISSION_AMOUNT_3() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_AMOUNT_3Call {}
    ///Container type for the return parameters of the [`EMISSION_AMOUNT_3()`](EMISSION_AMOUNT_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_AMOUNT_3Return {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_AMOUNT_3Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_AMOUNT_3Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_AMOUNT_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_AMOUNT_3Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_AMOUNT_3Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_AMOUNT_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSION_AMOUNT_3Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSION_AMOUNT_3Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSION_AMOUNT_3()";
            const SELECTOR: [u8; 4] = [163u8, 42u8, 222u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSION_AMOUNT_4()` and selector `0x6ca0319b`.
```solidity
function EMISSION_AMOUNT_4() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_AMOUNT_4Call {}
    ///Container type for the return parameters of the [`EMISSION_AMOUNT_4()`](EMISSION_AMOUNT_4Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_AMOUNT_4Return {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_AMOUNT_4Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_AMOUNT_4Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_AMOUNT_4Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_AMOUNT_4Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_AMOUNT_4Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_AMOUNT_4Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSION_AMOUNT_4Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSION_AMOUNT_4Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSION_AMOUNT_4()";
            const SELECTOR: [u8; 4] = [108u8, 160u8, 49u8, 155u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSION_AMOUNT_5()` and selector `0x6f3f51d9`.
```solidity
function EMISSION_AMOUNT_5() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_AMOUNT_5Call {}
    ///Container type for the return parameters of the [`EMISSION_AMOUNT_5()`](EMISSION_AMOUNT_5Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_AMOUNT_5Return {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_AMOUNT_5Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_AMOUNT_5Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_AMOUNT_5Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_AMOUNT_5Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_AMOUNT_5Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_AMOUNT_5Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSION_AMOUNT_5Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSION_AMOUNT_5Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSION_AMOUNT_5()";
            const SELECTOR: [u8; 4] = [111u8, 63u8, 81u8, 217u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSION_AMOUNT_6()` and selector `0xa1fab765`.
```solidity
function EMISSION_AMOUNT_6() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_AMOUNT_6Call {}
    ///Container type for the return parameters of the [`EMISSION_AMOUNT_6()`](EMISSION_AMOUNT_6Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_AMOUNT_6Return {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_AMOUNT_6Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_AMOUNT_6Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_AMOUNT_6Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_AMOUNT_6Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_AMOUNT_6Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_AMOUNT_6Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSION_AMOUNT_6Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSION_AMOUNT_6Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSION_AMOUNT_6()";
            const SELECTOR: [u8; 4] = [161u8, 250u8, 183u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSION_AMOUNT_7()` and selector `0xb518a687`.
```solidity
function EMISSION_AMOUNT_7() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_AMOUNT_7Call {}
    ///Container type for the return parameters of the [`EMISSION_AMOUNT_7()`](EMISSION_AMOUNT_7Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_AMOUNT_7Return {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_AMOUNT_7Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_AMOUNT_7Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_AMOUNT_7Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_AMOUNT_7Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_AMOUNT_7Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_AMOUNT_7Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSION_AMOUNT_7Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSION_AMOUNT_7Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSION_AMOUNT_7()";
            const SELECTOR: [u8; 4] = [181u8, 24u8, 166u8, 135u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSION_AMOUNT_8()` and selector `0x23e1134c`.
```solidity
function EMISSION_AMOUNT_8() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_AMOUNT_8Call {}
    ///Container type for the return parameters of the [`EMISSION_AMOUNT_8()`](EMISSION_AMOUNT_8Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_AMOUNT_8Return {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_AMOUNT_8Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_AMOUNT_8Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_AMOUNT_8Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_AMOUNT_8Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_AMOUNT_8Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_AMOUNT_8Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSION_AMOUNT_8Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSION_AMOUNT_8Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSION_AMOUNT_8()";
            const SELECTOR: [u8; 4] = [35u8, 225u8, 19u8, 76u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EPOCH_DURATION()` and selector `0xa70b9f0c`.
```solidity
function EPOCH_DURATION() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EPOCH_DURATIONCall {}
    ///Container type for the return parameters of the [`EPOCH_DURATION()`](EPOCH_DURATIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EPOCH_DURATIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EPOCH_DURATIONCall> for UnderlyingRustTuple<'_> {
                fn from(value: EPOCH_DURATIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for EPOCH_DURATIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EPOCH_DURATIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EPOCH_DURATIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EPOCH_DURATIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EPOCH_DURATIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EPOCH_DURATIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EPOCH_DURATION()";
            const SELECTOR: [u8; 4] = [167u8, 11u8, 159u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `INITIAL_MINT_SUPPLY()` and selector `0x9b7ef64b`.
```solidity
function INITIAL_MINT_SUPPLY() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INITIAL_MINT_SUPPLYCall {}
    ///Container type for the return parameters of the [`INITIAL_MINT_SUPPLY()`](INITIAL_MINT_SUPPLYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INITIAL_MINT_SUPPLYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INITIAL_MINT_SUPPLYCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: INITIAL_MINT_SUPPLYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for INITIAL_MINT_SUPPLYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INITIAL_MINT_SUPPLYReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: INITIAL_MINT_SUPPLYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for INITIAL_MINT_SUPPLYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for INITIAL_MINT_SUPPLYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = INITIAL_MINT_SUPPLYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "INITIAL_MINT_SUPPLY()";
            const SELECTOR: [u8; 4] = [155u8, 126u8, 246u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `TOTAL_EPOCHS()` and selector `0x5f15c3c9`.
```solidity
function TOTAL_EPOCHS() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_EPOCHSCall {}
    ///Container type for the return parameters of the [`TOTAL_EPOCHS()`](TOTAL_EPOCHSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_EPOCHSReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_EPOCHSCall> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_EPOCHSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_EPOCHSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_EPOCHSReturn> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_EPOCHSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_EPOCHSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TOTAL_EPOCHSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = TOTAL_EPOCHSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TOTAL_EPOCHS()";
            const SELECTOR: [u8; 4] = [95u8, 21u8, 195u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `TOTAL_SUPPLY()` and selector `0x902d55a5`.
```solidity
function TOTAL_SUPPLY() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_SUPPLYCall {}
    ///Container type for the return parameters of the [`TOTAL_SUPPLY()`](TOTAL_SUPPLYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_SUPPLYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_SUPPLYCall> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_SUPPLYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_SUPPLYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_SUPPLYReturn> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_SUPPLYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_SUPPLYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TOTAL_SUPPLYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = TOTAL_SUPPLYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TOTAL_SUPPLY()";
            const SELECTOR: [u8; 4] = [144u8, 45u8, 85u8, 165u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `allowance(address,address)` and selector `0xdd62ed3e`.
```solidity
function allowance(address owner, address spender) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowanceCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`allowance(address,address)`](allowanceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowanceReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowanceCall> for UnderlyingRustTuple<'_> {
                fn from(value: allowanceCall) -> Self {
                    (value.owner, value.spender)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        spender: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowanceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: allowanceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allowanceCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = allowanceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allowance(address,address)";
            const SELECTOR: [u8; 4] = [221u8, 98u8, 237u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `approve(address,uint256)` and selector `0x095ea7b3`.
```solidity
function approve(address spender, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveCall {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`approve(address,uint256)`](approveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveCall> for UnderlyingRustTuple<'_> {
                fn from(value: approveCall) -> Self {
                    (value.spender, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        spender: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveReturn> for UnderlyingRustTuple<'_> {
                fn from(value: approveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for approveCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = approveReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "approve(address,uint256)";
            const SELECTOR: [u8; 4] = [9u8, 94u8, 167u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `balanceOf(address)` and selector `0x70a08231`.
```solidity
function balanceOf(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`balanceOf(address)`](balanceOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for balanceOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = balanceOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "balanceOf(address)";
            const SELECTOR: [u8; 4] = [112u8, 160u8, 130u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeAddress()` and selector `0xa3c573eb`.
```solidity
function bridgeAddress() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeAddressCall {}
    ///Container type for the return parameters of the [`bridgeAddress()`](bridgeAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeAddressReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeAddressCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeAddressCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeAddressReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeAddressCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeAddressReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeAddress()";
            const SELECTOR: [u8; 4] = [163u8, 197u8, 115u8, 235u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeExtraData()` and selector `0x7b3a1286`.
```solidity
function bridgeExtraData() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeExtraDataCall {}
    ///Container type for the return parameters of the [`bridgeExtraData()`](bridgeExtraDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeExtraDataReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeExtraDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeExtraDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeExtraDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeExtraDataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: bridgeExtraDataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for bridgeExtraDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeExtraDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeExtraDataReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeExtraData()";
            const SELECTOR: [u8; 4] = [123u8, 58u8, 18u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeGasLimit()` and selector `0xc5500cc3`.
```solidity
function bridgeGasLimit() external view returns (uint32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeGasLimitCall {}
    ///Container type for the return parameters of the [`bridgeGasLimit()`](bridgeGasLimitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeGasLimitReturn {
        #[allow(missing_docs)]
        pub _0: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeGasLimitCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeGasLimitCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeGasLimitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeGasLimitReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: bridgeGasLimitReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for bridgeGasLimitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeGasLimitCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeGasLimitReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeGasLimit()";
            const SELECTOR: [u8; 4] = [197u8, 80u8, 12u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `currentEpoch()` and selector `0x76671808`.
```solidity
function currentEpoch() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentEpochCall {}
    ///Container type for the return parameters of the [`currentEpoch()`](currentEpochCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentEpochReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentEpochCall> for UnderlyingRustTuple<'_> {
                fn from(value: currentEpochCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentEpochCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentEpochReturn> for UnderlyingRustTuple<'_> {
                fn from(value: currentEpochReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentEpochReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for currentEpochCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = currentEpochReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "currentEpoch()";
            const SELECTOR: [u8; 4] = [118u8, 103u8, 24u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `decimals()` and selector `0x313ce567`.
```solidity
function decimals() external view returns (uint8);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decimalsCall {}
    ///Container type for the return parameters of the [`decimals()`](decimalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decimalsReturn {
        #[allow(missing_docs)]
        pub _0: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decimalsCall> for UnderlyingRustTuple<'_> {
                fn from(value: decimalsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decimalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decimalsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: decimalsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decimalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for decimalsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = decimalsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "decimals()";
            const SELECTOR: [u8; 4] = [49u8, 60u8, 229u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `eip712Domain()` and selector `0x84b0196e`.
```solidity
function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainCall {}
    ///Container type for the return parameters of the [`eip712Domain()`](eip712DomainCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainReturn {
        #[allow(missing_docs)]
        pub fields: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub version: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub verifyingContract: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub salt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub extensions: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainCall> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainReturn> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainReturn) -> Self {
                    (
                        value.fields,
                        value.name,
                        value.version,
                        value.chainId,
                        value.verifyingContract,
                        value.salt,
                        value.extensions,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        fields: tuple.0,
                        name: tuple.1,
                        version: tuple.2,
                        chainId: tuple.3,
                        verifyingContract: tuple.4,
                        salt: tuple.5,
                        extensions: tuple.6,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for eip712DomainCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = eip712DomainReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "eip712Domain()";
            const SELECTOR: [u8; 4] = [132u8, 176u8, 25u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionSchedule(uint256)` and selector `0x334d0bbd`.
```solidity
function emissionSchedule(uint256) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionScheduleCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`emissionSchedule(uint256)`](emissionScheduleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionScheduleReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionScheduleCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionScheduleCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionScheduleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionScheduleReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionScheduleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionScheduleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionScheduleCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionScheduleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionSchedule(uint256)";
            const SELECTOR: [u8; 4] = [51u8, 77u8, 11u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsStartTime()` and selector `0x48b0daa6`.
```solidity
function emissionsStartTime() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartTimeCall {}
    ///Container type for the return parameters of the [`emissionsStartTime()`](emissionsStartTimeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartTimeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartTimeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartTimeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartTimeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartTimeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartTimeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartTimeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsStartTimeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsStartTimeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsStartTime()";
            const SELECTOR: [u8; 4] = [72u8, 176u8, 218u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsStarted()` and selector `0x5adf0021`.
```solidity
function emissionsStarted() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartedCall {}
    ///Container type for the return parameters of the [`emissionsStarted()`](emissionsStartedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsStartedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsStartedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsStarted()";
            const SELECTOR: [u8; 4] = [90u8, 223u8, 0u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeConfiguration()` and selector `0x07a1d5fa`.
```solidity
function getBridgeConfiguration() external view returns (address bridgeAddr, address l2TokenAddr, address l2DestAddr, uint32 gasLimit, bytes memory extraData);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeConfigurationCall {}
    ///Container type for the return parameters of the [`getBridgeConfiguration()`](getBridgeConfigurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeConfigurationReturn {
        #[allow(missing_docs)]
        pub bridgeAddr: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub l2TokenAddr: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub l2DestAddr: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub gasLimit: u32,
        #[allow(missing_docs)]
        pub extraData: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeConfigurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeConfigurationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeConfigurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                u32,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeConfigurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeConfigurationReturn) -> Self {
                    (
                        value.bridgeAddr,
                        value.l2TokenAddr,
                        value.l2DestAddr,
                        value.gasLimit,
                        value.extraData,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeConfigurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        bridgeAddr: tuple.0,
                        l2TokenAddr: tuple.1,
                        l2DestAddr: tuple.2,
                        gasLimit: tuple.3,
                        extraData: tuple.4,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeConfigurationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeConfigurationReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeConfiguration()";
            const SELECTOR: [u8; 4] = [7u8, 161u8, 213u8, 250u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCurrentEpochInfo()` and selector `0xbabc394f`.
```solidity
function getCurrentEpochInfo() external view returns (uint256 epoch, uint256 nextEmissionTime, uint256 nextEmissionAmount, bool canMintEmission);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochInfoCall {}
    ///Container type for the return parameters of the [`getCurrentEpochInfo()`](getCurrentEpochInfoCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochInfoReturn {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nextEmissionTime: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nextEmissionAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub canMintEmission: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochInfoCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochInfoCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentEpochInfoCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                bool,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochInfoReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochInfoReturn) -> Self {
                    (
                        value.epoch,
                        value.nextEmissionTime,
                        value.nextEmissionAmount,
                        value.canMintEmission,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentEpochInfoReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epoch: tuple.0,
                        nextEmissionTime: tuple.1,
                        nextEmissionAmount: tuple.2,
                        canMintEmission: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentEpochInfoCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCurrentEpochInfoReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentEpochInfo()";
            const SELECTOR: [u8; 4] = [186u8, 188u8, 57u8, 79u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getEmissionSchedule()` and selector `0xaf2aa63b`.
```solidity
function getEmissionSchedule() external view returns (uint256[48] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEmissionScheduleCall {}
    ///Container type for the return parameters of the [`getEmissionSchedule()`](getEmissionScheduleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEmissionScheduleReturn {
        #[allow(missing_docs)]
        pub _0: [alloy::sol_types::private::primitives::aliases::U256; 48usize],
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEmissionScheduleCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEmissionScheduleCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEmissionScheduleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    48usize,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                [alloy::sol_types::private::primitives::aliases::U256; 48usize],
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEmissionScheduleReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEmissionScheduleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEmissionScheduleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getEmissionScheduleCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getEmissionScheduleReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    48usize,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getEmissionSchedule()";
            const SELECTOR: [u8; 4] = [175u8, 42u8, 166u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRemainingEmissions()` and selector `0x4bdd36ce`.
```solidity
function getRemainingEmissions() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRemainingEmissionsCall {}
    ///Container type for the return parameters of the [`getRemainingEmissions()`](getRemainingEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRemainingEmissionsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRemainingEmissionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRemainingEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRemainingEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRemainingEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRemainingEmissionsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRemainingEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRemainingEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRemainingEmissionsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRemainingEmissions()";
            const SELECTOR: [u8; 4] = [75u8, 221u8, 54u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRoleAdminReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasRoleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isEmissionComplete()` and selector `0xdd8c3e5d`.
```solidity
function isEmissionComplete() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isEmissionCompleteCall {}
    ///Container type for the return parameters of the [`isEmissionComplete()`](isEmissionCompleteCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isEmissionCompleteReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isEmissionCompleteCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isEmissionCompleteCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isEmissionCompleteCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isEmissionCompleteReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isEmissionCompleteReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isEmissionCompleteReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isEmissionCompleteCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isEmissionCompleteReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isEmissionComplete()";
            const SELECTOR: [u8; 4] = [221u8, 140u8, 62u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `l2DestinationAddress()` and selector `0xbd02dc25`.
```solidity
function l2DestinationAddress() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct l2DestinationAddressCall {}
    ///Container type for the return parameters of the [`l2DestinationAddress()`](l2DestinationAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct l2DestinationAddressReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<l2DestinationAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: l2DestinationAddressCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for l2DestinationAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<l2DestinationAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: l2DestinationAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for l2DestinationAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for l2DestinationAddressCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = l2DestinationAddressReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "l2DestinationAddress()";
            const SELECTOR: [u8; 4] = [189u8, 2u8, 220u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `l2TokenAddress()` and selector `0xe77f9cec`.
```solidity
function l2TokenAddress() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct l2TokenAddressCall {}
    ///Container type for the return parameters of the [`l2TokenAddress()`](l2TokenAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct l2TokenAddressReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<l2TokenAddressCall> for UnderlyingRustTuple<'_> {
                fn from(value: l2TokenAddressCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for l2TokenAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<l2TokenAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: l2TokenAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for l2TokenAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for l2TokenAddressCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = l2TokenAddressReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "l2TokenAddress()";
            const SELECTOR: [u8; 4] = [231u8, 127u8, 156u8, 236u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mintEmission()` and selector `0x284e1333`.
```solidity
function mintEmission() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintEmissionCall {}
    ///Container type for the return parameters of the [`mintEmission()`](mintEmissionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintEmissionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintEmissionCall> for UnderlyingRustTuple<'_> {
                fn from(value: mintEmissionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintEmissionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintEmissionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: mintEmissionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintEmissionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintEmissionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintEmissionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mintEmission()";
            const SELECTOR: [u8; 4] = [40u8, 78u8, 19u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `name()` and selector `0x06fdde03`.
```solidity
function name() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nameCall {}
    ///Container type for the return parameters of the [`name()`](nameCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nameReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nameCall> for UnderlyingRustTuple<'_> {
                fn from(value: nameCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nameReturn> for UnderlyingRustTuple<'_> {
                fn from(value: nameReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nameCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = nameReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "name()";
            const SELECTOR: [u8; 4] = [6u8, 253u8, 222u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `nonces(address)` and selector `0x7ecebe00`.
```solidity
function nonces(address owner) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct noncesCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`nonces(address)`](noncesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct noncesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<noncesCall> for UnderlyingRustTuple<'_> {
                fn from(value: noncesCall) -> Self {
                    (value.owner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for noncesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { owner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<noncesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: noncesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for noncesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for noncesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = noncesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nonces(address)";
            const SELECTOR: [u8; 4] = [126u8, 206u8, 190u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `permit(address,address,uint256,uint256,uint8,bytes32,bytes32)` and selector `0xd505accf`.
```solidity
function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct permitCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub deadline: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub v: u8,
        #[allow(missing_docs)]
        pub r: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`permit(address,address,uint256,uint256,uint8,bytes32,bytes32)`](permitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct permitReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<permitCall> for UnderlyingRustTuple<'_> {
                fn from(value: permitCall) -> Self {
                    (
                        value.owner,
                        value.spender,
                        value.value,
                        value.deadline,
                        value.v,
                        value.r,
                        value.s,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for permitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        spender: tuple.1,
                        value: tuple.2,
                        deadline: tuple.3,
                        v: tuple.4,
                        r: tuple.5,
                        s: tuple.6,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<permitReturn> for UnderlyingRustTuple<'_> {
                fn from(value: permitReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for permitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for permitCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = permitReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [213u8, 5u8, 172u8, 207u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deadline),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.v),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.r),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address callerConfirmation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub callerConfirmation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.callerConfirmation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        callerConfirmation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callerConfirmation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeConfiguration(address,address,address,uint32,bytes)` and selector `0x53b64acb`.
```solidity
function setBridgeConfiguration(address _bridgeAddress, address _l2TokenAddress, address _l2DestinationAddress, uint32 _gasLimit, bytes memory _extraData) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeConfigurationCall {
        #[allow(missing_docs)]
        pub _bridgeAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _l2TokenAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _l2DestinationAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _gasLimit: u32,
        #[allow(missing_docs)]
        pub _extraData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`setBridgeConfiguration(address,address,address,uint32,bytes)`](setBridgeConfigurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeConfigurationReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                u32,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeConfigurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeConfigurationCall) -> Self {
                    (
                        value._bridgeAddress,
                        value._l2TokenAddress,
                        value._l2DestinationAddress,
                        value._gasLimit,
                        value._extraData,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBridgeConfigurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _bridgeAddress: tuple.0,
                        _l2TokenAddress: tuple.1,
                        _l2DestinationAddress: tuple.2,
                        _gasLimit: tuple.3,
                        _extraData: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeConfigurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeConfigurationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBridgeConfigurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeConfigurationCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeConfigurationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeConfiguration(address,address,address,uint32,bytes)";
            const SELECTOR: [u8; 4] = [83u8, 182u8, 74u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridgeAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._l2TokenAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._l2DestinationAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._gasLimit),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._extraData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `startEmissions()` and selector `0x1b02f845`.
```solidity
function startEmissions() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startEmissionsCall {}
    ///Container type for the return parameters of the [`startEmissions()`](startEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startEmissionsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startEmissionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: startEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: startEmissionsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for startEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for startEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = startEmissionsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "startEmissions()";
            const SELECTOR: [u8; 4] = [27u8, 2u8, 248u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = supportsInterfaceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `symbol()` and selector `0x95d89b41`.
```solidity
function symbol() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct symbolCall {}
    ///Container type for the return parameters of the [`symbol()`](symbolCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct symbolReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<symbolCall> for UnderlyingRustTuple<'_> {
                fn from(value: symbolCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<symbolReturn> for UnderlyingRustTuple<'_> {
                fn from(value: symbolReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for symbolCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = symbolReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "symbol()";
            const SELECTOR: [u8; 4] = [149u8, 216u8, 155u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `totalEmissionsMinted()` and selector `0xf508e19d`.
```solidity
function totalEmissionsMinted() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalEmissionsMintedCall {}
    ///Container type for the return parameters of the [`totalEmissionsMinted()`](totalEmissionsMintedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalEmissionsMintedReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalEmissionsMintedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: totalEmissionsMintedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for totalEmissionsMintedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalEmissionsMintedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: totalEmissionsMintedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for totalEmissionsMintedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalEmissionsMintedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = totalEmissionsMintedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalEmissionsMinted()";
            const SELECTOR: [u8; 4] = [245u8, 8u8, 225u8, 157u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `totalSupply()` and selector `0x18160ddd`.
```solidity
function totalSupply() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalSupplyCall {}
    ///Container type for the return parameters of the [`totalSupply()`](totalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalSupplyCall> for UnderlyingRustTuple<'_> {
                fn from(value: totalSupplyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalSupplyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: totalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalSupplyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = totalSupplyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalSupply()";
            const SELECTOR: [u8; 4] = [24u8, 22u8, 13u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transfer(address,uint256)` and selector `0xa9059cbb`.
```solidity
function transfer(address to, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`transfer(address,uint256)`](transferCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferCall) -> Self {
                    (value.to, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transfer(address,uint256)";
            const SELECTOR: [u8; 4] = [169u8, 5u8, 156u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferFrom(address,address,uint256)` and selector `0x23b872dd`.
```solidity
function transferFrom(address from, address to, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferFromCall {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`transferFrom(address,address,uint256)`](transferFromCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferFromReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromCall) -> Self {
                    (value.from, value.to, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        to: tuple.1,
                        value: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferFromCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferFromReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferFrom(address,address,uint256)";
            const SELECTOR: [u8; 4] = [35u8, 184u8, 114u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`SyndicateToken`](self) function calls.
    pub enum SyndicateTokenCalls {
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        DOMAIN_SEPARATOR(DOMAIN_SEPARATORCall),
        #[allow(missing_docs)]
        EMISSIONS_MANAGER_ROLE(EMISSIONS_MANAGER_ROLECall),
        #[allow(missing_docs)]
        EMISSIONS_SUPPLY(EMISSIONS_SUPPLYCall),
        #[allow(missing_docs)]
        EMISSION_AMOUNT_1(EMISSION_AMOUNT_1Call),
        #[allow(missing_docs)]
        EMISSION_AMOUNT_2(EMISSION_AMOUNT_2Call),
        #[allow(missing_docs)]
        EMISSION_AMOUNT_3(EMISSION_AMOUNT_3Call),
        #[allow(missing_docs)]
        EMISSION_AMOUNT_4(EMISSION_AMOUNT_4Call),
        #[allow(missing_docs)]
        EMISSION_AMOUNT_5(EMISSION_AMOUNT_5Call),
        #[allow(missing_docs)]
        EMISSION_AMOUNT_6(EMISSION_AMOUNT_6Call),
        #[allow(missing_docs)]
        EMISSION_AMOUNT_7(EMISSION_AMOUNT_7Call),
        #[allow(missing_docs)]
        EMISSION_AMOUNT_8(EMISSION_AMOUNT_8Call),
        #[allow(missing_docs)]
        EPOCH_DURATION(EPOCH_DURATIONCall),
        #[allow(missing_docs)]
        INITIAL_MINT_SUPPLY(INITIAL_MINT_SUPPLYCall),
        #[allow(missing_docs)]
        TOTAL_EPOCHS(TOTAL_EPOCHSCall),
        #[allow(missing_docs)]
        TOTAL_SUPPLY(TOTAL_SUPPLYCall),
        #[allow(missing_docs)]
        allowance(allowanceCall),
        #[allow(missing_docs)]
        approve(approveCall),
        #[allow(missing_docs)]
        balanceOf(balanceOfCall),
        #[allow(missing_docs)]
        bridgeAddress(bridgeAddressCall),
        #[allow(missing_docs)]
        bridgeExtraData(bridgeExtraDataCall),
        #[allow(missing_docs)]
        bridgeGasLimit(bridgeGasLimitCall),
        #[allow(missing_docs)]
        currentEpoch(currentEpochCall),
        #[allow(missing_docs)]
        decimals(decimalsCall),
        #[allow(missing_docs)]
        eip712Domain(eip712DomainCall),
        #[allow(missing_docs)]
        emissionSchedule(emissionScheduleCall),
        #[allow(missing_docs)]
        emissionsStartTime(emissionsStartTimeCall),
        #[allow(missing_docs)]
        emissionsStarted(emissionsStartedCall),
        #[allow(missing_docs)]
        getBridgeConfiguration(getBridgeConfigurationCall),
        #[allow(missing_docs)]
        getCurrentEpochInfo(getCurrentEpochInfoCall),
        #[allow(missing_docs)]
        getEmissionSchedule(getEmissionScheduleCall),
        #[allow(missing_docs)]
        getRemainingEmissions(getRemainingEmissionsCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        isEmissionComplete(isEmissionCompleteCall),
        #[allow(missing_docs)]
        l2DestinationAddress(l2DestinationAddressCall),
        #[allow(missing_docs)]
        l2TokenAddress(l2TokenAddressCall),
        #[allow(missing_docs)]
        mintEmission(mintEmissionCall),
        #[allow(missing_docs)]
        name(nameCall),
        #[allow(missing_docs)]
        nonces(noncesCall),
        #[allow(missing_docs)]
        permit(permitCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        setBridgeConfiguration(setBridgeConfigurationCall),
        #[allow(missing_docs)]
        startEmissions(startEmissionsCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
        #[allow(missing_docs)]
        symbol(symbolCall),
        #[allow(missing_docs)]
        totalEmissionsMinted(totalEmissionsMintedCall),
        #[allow(missing_docs)]
        totalSupply(totalSupplyCall),
        #[allow(missing_docs)]
        transfer(transferCall),
        #[allow(missing_docs)]
        transferFrom(transferFromCall),
    }
    #[automatically_derived]
    impl SyndicateTokenCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 255u8, 201u8, 167u8],
            [6u8, 253u8, 222u8, 3u8],
            [7u8, 161u8, 213u8, 250u8],
            [9u8, 94u8, 167u8, 179u8],
            [24u8, 22u8, 13u8, 221u8],
            [27u8, 2u8, 248u8, 69u8],
            [35u8, 184u8, 114u8, 221u8],
            [35u8, 225u8, 19u8, 76u8],
            [36u8, 138u8, 156u8, 163u8],
            [40u8, 78u8, 19u8, 51u8],
            [47u8, 47u8, 241u8, 93u8],
            [49u8, 60u8, 229u8, 103u8],
            [51u8, 77u8, 11u8, 189u8],
            [54u8, 68u8, 229u8, 21u8],
            [54u8, 86u8, 138u8, 190u8],
            [72u8, 176u8, 218u8, 166u8],
            [75u8, 221u8, 54u8, 206u8],
            [83u8, 182u8, 74u8, 203u8],
            [90u8, 223u8, 0u8, 33u8],
            [95u8, 21u8, 195u8, 201u8],
            [108u8, 160u8, 49u8, 155u8],
            [108u8, 240u8, 22u8, 37u8],
            [111u8, 63u8, 81u8, 217u8],
            [112u8, 160u8, 130u8, 49u8],
            [118u8, 103u8, 24u8, 8u8],
            [123u8, 58u8, 18u8, 134u8],
            [126u8, 206u8, 190u8, 0u8],
            [132u8, 176u8, 25u8, 110u8],
            [144u8, 45u8, 85u8, 165u8],
            [145u8, 209u8, 72u8, 84u8],
            [149u8, 216u8, 155u8, 65u8],
            [155u8, 126u8, 246u8, 75u8],
            [160u8, 38u8, 89u8, 154u8],
            [161u8, 250u8, 183u8, 101u8],
            [162u8, 23u8, 253u8, 223u8],
            [163u8, 42u8, 222u8, 248u8],
            [163u8, 197u8, 115u8, 235u8],
            [167u8, 11u8, 159u8, 12u8],
            [169u8, 5u8, 156u8, 187u8],
            [175u8, 42u8, 166u8, 59u8],
            [181u8, 24u8, 166u8, 135u8],
            [186u8, 188u8, 57u8, 79u8],
            [189u8, 2u8, 220u8, 37u8],
            [193u8, 35u8, 3u8, 179u8],
            [197u8, 80u8, 12u8, 195u8],
            [213u8, 5u8, 172u8, 207u8],
            [213u8, 71u8, 116u8, 31u8],
            [221u8, 98u8, 237u8, 62u8],
            [221u8, 140u8, 62u8, 93u8],
            [227u8, 171u8, 223u8, 203u8],
            [231u8, 127u8, 156u8, 236u8],
            [245u8, 8u8, 225u8, 157u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateTokenCalls {
        const NAME: &'static str = "SyndicateTokenCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 52usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DOMAIN_SEPARATOR(_) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSIONS_MANAGER_ROLE(_) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSIONS_SUPPLY(_) => {
                    <EMISSIONS_SUPPLYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSION_AMOUNT_1(_) => {
                    <EMISSION_AMOUNT_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSION_AMOUNT_2(_) => {
                    <EMISSION_AMOUNT_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSION_AMOUNT_3(_) => {
                    <EMISSION_AMOUNT_3Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSION_AMOUNT_4(_) => {
                    <EMISSION_AMOUNT_4Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSION_AMOUNT_5(_) => {
                    <EMISSION_AMOUNT_5Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSION_AMOUNT_6(_) => {
                    <EMISSION_AMOUNT_6Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSION_AMOUNT_7(_) => {
                    <EMISSION_AMOUNT_7Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSION_AMOUNT_8(_) => {
                    <EMISSION_AMOUNT_8Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EPOCH_DURATION(_) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::INITIAL_MINT_SUPPLY(_) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TOTAL_EPOCHS(_) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TOTAL_SUPPLY(_) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::allowance(_) => {
                    <allowanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::approve(_) => <approveCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::balanceOf(_) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeAddress(_) => {
                    <bridgeAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeExtraData(_) => {
                    <bridgeExtraDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeGasLimit(_) => {
                    <bridgeGasLimitCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::currentEpoch(_) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::decimals(_) => <decimalsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::eip712Domain(_) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionSchedule(_) => {
                    <emissionScheduleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsStartTime(_) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsStarted(_) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeConfiguration(_) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCurrentEpochInfo(_) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getEmissionSchedule(_) => {
                    <getEmissionScheduleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRemainingEmissions(_) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isEmissionComplete(_) => {
                    <isEmissionCompleteCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::l2DestinationAddress(_) => {
                    <l2DestinationAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::l2TokenAddress(_) => {
                    <l2TokenAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::mintEmission(_) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::name(_) => <nameCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::nonces(_) => <noncesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::permit(_) => <permitCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeConfiguration(_) => {
                    <setBridgeConfigurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::startEmissions(_) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::symbol(_) => <symbolCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::totalEmissionsMinted(_) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::totalSupply(_) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transfer(_) => <transferCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::transferFrom(_) => {
                    <transferFromCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<SyndicateTokenCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn name(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <nameCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::name)
                    }
                    name
                },
                {
                    fn getBridgeConfiguration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getBridgeConfiguration)
                    }
                    getBridgeConfiguration
                },
                {
                    fn approve(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <approveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::approve)
                    }
                    approve
                },
                {
                    fn totalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <totalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::totalSupply)
                    }
                    totalSupply
                },
                {
                    fn startEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <startEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::startEmissions)
                    }
                    startEmissions
                },
                {
                    fn transferFrom(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <transferFromCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::transferFrom)
                    }
                    transferFrom
                },
                {
                    fn EMISSION_AMOUNT_8(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EMISSION_AMOUNT_8Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EMISSION_AMOUNT_8)
                    }
                    EMISSION_AMOUNT_8
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn mintEmission(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <mintEmissionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::mintEmission)
                    }
                    mintEmission
                },
                {
                    fn grantRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn decimals(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <decimalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::decimals)
                    }
                    decimals
                },
                {
                    fn emissionSchedule(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionScheduleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionSchedule)
                    }
                    emissionSchedule
                },
                {
                    fn DOMAIN_SEPARATOR(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::DOMAIN_SEPARATOR)
                    }
                    DOMAIN_SEPARATOR
                },
                {
                    fn renounceRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn emissionsStartTime(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionsStartTime)
                    }
                    emissionsStartTime
                },
                {
                    fn getRemainingEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getRemainingEmissions)
                    }
                    getRemainingEmissions
                },
                {
                    fn setBridgeConfiguration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <setBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::setBridgeConfiguration)
                    }
                    setBridgeConfiguration
                },
                {
                    fn emissionsStarted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionsStartedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionsStarted)
                    }
                    emissionsStarted
                },
                {
                    fn TOTAL_EPOCHS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::TOTAL_EPOCHS)
                    }
                    TOTAL_EPOCHS
                },
                {
                    fn EMISSION_AMOUNT_4(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EMISSION_AMOUNT_4Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EMISSION_AMOUNT_4)
                    }
                    EMISSION_AMOUNT_4
                },
                {
                    fn EMISSIONS_SUPPLY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EMISSIONS_SUPPLYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EMISSIONS_SUPPLY)
                    }
                    EMISSIONS_SUPPLY
                },
                {
                    fn EMISSION_AMOUNT_5(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EMISSION_AMOUNT_5Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EMISSION_AMOUNT_5)
                    }
                    EMISSION_AMOUNT_5
                },
                {
                    fn balanceOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::balanceOf)
                    }
                    balanceOf
                },
                {
                    fn currentEpoch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <currentEpochCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::currentEpoch)
                    }
                    currentEpoch
                },
                {
                    fn bridgeExtraData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <bridgeExtraDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::bridgeExtraData)
                    }
                    bridgeExtraData
                },
                {
                    fn nonces(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <noncesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::nonces)
                    }
                    nonces
                },
                {
                    fn eip712Domain(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <eip712DomainCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::eip712Domain)
                    }
                    eip712Domain
                },
                {
                    fn TOTAL_SUPPLY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::TOTAL_SUPPLY)
                    }
                    TOTAL_SUPPLY
                },
                {
                    fn hasRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn symbol(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <symbolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::symbol)
                    }
                    symbol
                },
                {
                    fn INITIAL_MINT_SUPPLY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::INITIAL_MINT_SUPPLY)
                    }
                    INITIAL_MINT_SUPPLY
                },
                {
                    fn EMISSION_AMOUNT_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EMISSION_AMOUNT_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EMISSION_AMOUNT_2)
                    }
                    EMISSION_AMOUNT_2
                },
                {
                    fn EMISSION_AMOUNT_6(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EMISSION_AMOUNT_6Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EMISSION_AMOUNT_6)
                    }
                    EMISSION_AMOUNT_6
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn EMISSION_AMOUNT_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EMISSION_AMOUNT_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EMISSION_AMOUNT_3)
                    }
                    EMISSION_AMOUNT_3
                },
                {
                    fn bridgeAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <bridgeAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::bridgeAddress)
                    }
                    bridgeAddress
                },
                {
                    fn EPOCH_DURATION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EPOCH_DURATION)
                    }
                    EPOCH_DURATION
                },
                {
                    fn transfer(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <transferCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::transfer)
                    }
                    transfer
                },
                {
                    fn getEmissionSchedule(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getEmissionScheduleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getEmissionSchedule)
                    }
                    getEmissionSchedule
                },
                {
                    fn EMISSION_AMOUNT_7(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EMISSION_AMOUNT_7Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EMISSION_AMOUNT_7)
                    }
                    EMISSION_AMOUNT_7
                },
                {
                    fn getCurrentEpochInfo(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getCurrentEpochInfo)
                    }
                    getCurrentEpochInfo
                },
                {
                    fn l2DestinationAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <l2DestinationAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::l2DestinationAddress)
                    }
                    l2DestinationAddress
                },
                {
                    fn EMISSION_AMOUNT_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EMISSION_AMOUNT_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EMISSION_AMOUNT_1)
                    }
                    EMISSION_AMOUNT_1
                },
                {
                    fn bridgeGasLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <bridgeGasLimitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::bridgeGasLimit)
                    }
                    bridgeGasLimit
                },
                {
                    fn permit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <permitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::permit)
                    }
                    permit
                },
                {
                    fn revokeRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn allowance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <allowanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::allowance)
                    }
                    allowance
                },
                {
                    fn isEmissionComplete(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <isEmissionCompleteCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::isEmissionComplete)
                    }
                    isEmissionComplete
                },
                {
                    fn EMISSIONS_MANAGER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EMISSIONS_MANAGER_ROLE)
                    }
                    EMISSIONS_MANAGER_ROLE
                },
                {
                    fn l2TokenAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <l2TokenAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::l2TokenAddress)
                    }
                    l2TokenAddress
                },
                {
                    fn totalEmissionsMinted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::totalEmissionsMinted)
                    }
                    totalEmissionsMinted
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DOMAIN_SEPARATOR(inner) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSIONS_MANAGER_ROLE(inner) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSIONS_SUPPLY(inner) => {
                    <EMISSIONS_SUPPLYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSION_AMOUNT_1(inner) => {
                    <EMISSION_AMOUNT_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSION_AMOUNT_2(inner) => {
                    <EMISSION_AMOUNT_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSION_AMOUNT_3(inner) => {
                    <EMISSION_AMOUNT_3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSION_AMOUNT_4(inner) => {
                    <EMISSION_AMOUNT_4Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSION_AMOUNT_5(inner) => {
                    <EMISSION_AMOUNT_5Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSION_AMOUNT_6(inner) => {
                    <EMISSION_AMOUNT_6Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSION_AMOUNT_7(inner) => {
                    <EMISSION_AMOUNT_7Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSION_AMOUNT_8(inner) => {
                    <EMISSION_AMOUNT_8Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EPOCH_DURATION(inner) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::INITIAL_MINT_SUPPLY(inner) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TOTAL_EPOCHS(inner) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TOTAL_SUPPLY(inner) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::allowance(inner) => {
                    <allowanceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::bridgeAddress(inner) => {
                    <bridgeAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridgeExtraData(inner) => {
                    <bridgeExtraDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridgeGasLimit(inner) => {
                    <bridgeGasLimitCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::currentEpoch(inner) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::decimals(inner) => {
                    <decimalsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionSchedule(inner) => {
                    <emissionScheduleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsStartTime(inner) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsStarted(inner) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeConfiguration(inner) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCurrentEpochInfo(inner) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getEmissionSchedule(inner) => {
                    <getEmissionScheduleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRemainingEmissions(inner) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isEmissionComplete(inner) => {
                    <isEmissionCompleteCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::l2DestinationAddress(inner) => {
                    <l2DestinationAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::l2TokenAddress(inner) => {
                    <l2TokenAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::mintEmission(inner) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::name(inner) => {
                    <nameCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::nonces(inner) => {
                    <noncesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::permit(inner) => {
                    <permitCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setBridgeConfiguration(inner) => {
                    <setBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::startEmissions(inner) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::symbol(inner) => {
                    <symbolCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::totalEmissionsMinted(inner) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::totalSupply(inner) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transfer(inner) => {
                    <transferCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DOMAIN_SEPARATOR(inner) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSIONS_MANAGER_ROLE(inner) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSIONS_SUPPLY(inner) => {
                    <EMISSIONS_SUPPLYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSION_AMOUNT_1(inner) => {
                    <EMISSION_AMOUNT_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSION_AMOUNT_2(inner) => {
                    <EMISSION_AMOUNT_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSION_AMOUNT_3(inner) => {
                    <EMISSION_AMOUNT_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSION_AMOUNT_4(inner) => {
                    <EMISSION_AMOUNT_4Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSION_AMOUNT_5(inner) => {
                    <EMISSION_AMOUNT_5Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSION_AMOUNT_6(inner) => {
                    <EMISSION_AMOUNT_6Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSION_AMOUNT_7(inner) => {
                    <EMISSION_AMOUNT_7Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSION_AMOUNT_8(inner) => {
                    <EMISSION_AMOUNT_8Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EPOCH_DURATION(inner) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::INITIAL_MINT_SUPPLY(inner) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TOTAL_EPOCHS(inner) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TOTAL_SUPPLY(inner) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::allowance(inner) => {
                    <allowanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeAddress(inner) => {
                    <bridgeAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeExtraData(inner) => {
                    <bridgeExtraDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeGasLimit(inner) => {
                    <bridgeGasLimitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::currentEpoch(inner) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::decimals(inner) => {
                    <decimalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionSchedule(inner) => {
                    <emissionScheduleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsStartTime(inner) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsStarted(inner) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeConfiguration(inner) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCurrentEpochInfo(inner) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getEmissionSchedule(inner) => {
                    <getEmissionScheduleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRemainingEmissions(inner) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::isEmissionComplete(inner) => {
                    <isEmissionCompleteCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::l2DestinationAddress(inner) => {
                    <l2DestinationAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::l2TokenAddress(inner) => {
                    <l2TokenAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mintEmission(inner) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::name(inner) => {
                    <nameCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::nonces(inner) => {
                    <noncesCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::permit(inner) => {
                    <permitCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeConfiguration(inner) => {
                    <setBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::startEmissions(inner) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::symbol(inner) => {
                    <symbolCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::totalEmissionsMinted(inner) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::totalSupply(inner) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transfer(inner) => {
                    <transferCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`SyndicateToken`](self) custom errors.
    pub enum SyndicateTokenErrors {
        #[allow(missing_docs)]
        AccessControlBadConfirmation(AccessControlBadConfirmation),
        #[allow(missing_docs)]
        AccessControlUnauthorizedAccount(AccessControlUnauthorizedAccount),
        #[allow(missing_docs)]
        ECDSAInvalidSignature(ECDSAInvalidSignature),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureLength(ECDSAInvalidSignatureLength),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureS(ECDSAInvalidSignatureS),
        #[allow(missing_docs)]
        ERC20InsufficientAllowance(ERC20InsufficientAllowance),
        #[allow(missing_docs)]
        ERC20InsufficientBalance(ERC20InsufficientBalance),
        #[allow(missing_docs)]
        ERC20InvalidApprover(ERC20InvalidApprover),
        #[allow(missing_docs)]
        ERC20InvalidReceiver(ERC20InvalidReceiver),
        #[allow(missing_docs)]
        ERC20InvalidSender(ERC20InvalidSender),
        #[allow(missing_docs)]
        ERC20InvalidSpender(ERC20InvalidSpender),
        #[allow(missing_docs)]
        ERC2612ExpiredSignature(ERC2612ExpiredSignature),
        #[allow(missing_docs)]
        ERC2612InvalidSigner(ERC2612InvalidSigner),
        #[allow(missing_docs)]
        InvalidAccountNonce(InvalidAccountNonce),
        #[allow(missing_docs)]
        InvalidShortString(InvalidShortString),
        #[allow(missing_docs)]
        StringTooLong(StringTooLong),
    }
    #[automatically_derived]
    impl SyndicateTokenErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [48u8, 90u8, 39u8, 169u8],
            [75u8, 128u8, 14u8, 70u8],
            [98u8, 121u8, 19u8, 2u8],
            [102u8, 151u8, 178u8, 50u8],
            [117u8, 45u8, 136u8, 192u8],
            [148u8, 40u8, 13u8, 98u8],
            [150u8, 198u8, 253u8, 30u8],
            [179u8, 81u8, 43u8, 12u8],
            [215u8, 139u8, 206u8, 12u8],
            [226u8, 81u8, 125u8, 63u8],
            [228u8, 80u8, 211u8, 140u8],
            [230u8, 2u8, 223u8, 5u8],
            [236u8, 68u8, 47u8, 5u8],
            [246u8, 69u8, 238u8, 223u8],
            [251u8, 143u8, 65u8, 178u8],
            [252u8, 230u8, 152u8, 247u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateTokenErrors {
        const NAME: &'static str = "SyndicateTokenErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 16usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccessControlBadConfirmation(_) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AccessControlUnauthorizedAccount(_) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignature(_) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureLength(_) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureS(_) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InsufficientAllowance(_) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InsufficientBalance(_) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidApprover(_) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidReceiver(_) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidSender(_) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidSpender(_) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC2612ExpiredSignature(_) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC2612InvalidSigner(_) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidAccountNonce(_) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidShortString(_) => {
                    <InvalidShortString as alloy_sol_types::SolError>::SELECTOR
                }
                Self::StringTooLong(_) => {
                    <StringTooLong as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<SyndicateTokenErrors>] = &[
                {
                    fn StringTooLong(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <StringTooLong as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::StringTooLong)
                    }
                    StringTooLong
                },
                {
                    fn ERC2612InvalidSigner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC2612InvalidSigner)
                    }
                    ERC2612InvalidSigner
                },
                {
                    fn ERC2612ExpiredSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC2612ExpiredSignature)
                    }
                    ERC2612ExpiredSignature
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::AccessControlBadConfirmation)
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn InvalidAccountNonce(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <InvalidAccountNonce as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::InvalidAccountNonce)
                    }
                    InvalidAccountNonce
                },
                {
                    fn ERC20InvalidSpender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InvalidSpender)
                    }
                    ERC20InvalidSpender
                },
                {
                    fn ERC20InvalidSender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InvalidSender as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InvalidSender)
                    }
                    ERC20InvalidSender
                },
                {
                    fn InvalidShortString(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <InvalidShortString as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::InvalidShortString)
                    }
                    InvalidShortString
                },
                {
                    fn ECDSAInvalidSignatureS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ECDSAInvalidSignatureS)
                    }
                    ECDSAInvalidSignatureS
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::AccessControlUnauthorizedAccount)
                    }
                    AccessControlUnauthorizedAccount
                },
                {
                    fn ERC20InsufficientBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InsufficientBalance)
                    }
                    ERC20InsufficientBalance
                },
                {
                    fn ERC20InvalidApprover(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InvalidApprover)
                    }
                    ERC20InvalidApprover
                },
                {
                    fn ERC20InvalidReceiver(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InvalidReceiver)
                    }
                    ERC20InvalidReceiver
                },
                {
                    fn ECDSAInvalidSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ECDSAInvalidSignature)
                    }
                    ECDSAInvalidSignature
                },
                {
                    fn ERC20InsufficientAllowance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InsufficientAllowance)
                    }
                    ERC20InsufficientAllowance
                },
                {
                    fn ECDSAInvalidSignatureLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ECDSAInvalidSignatureLength)
                    }
                    ECDSAInvalidSignatureLength
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InsufficientAllowance(inner) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InsufficientBalance(inner) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidApprover(inner) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidReceiver(inner) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidSender(inner) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidSpender(inner) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC2612ExpiredSignature(inner) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC2612InvalidSigner(inner) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidAccountNonce(inner) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidShortString(inner) => {
                    <InvalidShortString as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::StringTooLong(inner) => {
                    <StringTooLong as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InsufficientAllowance(inner) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InsufficientBalance(inner) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidApprover(inner) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidReceiver(inner) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidSender(inner) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidSpender(inner) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC2612ExpiredSignature(inner) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC2612InvalidSigner(inner) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidAccountNonce(inner) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidShortString(inner) => {
                    <InvalidShortString as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::StringTooLong(inner) => {
                    <StringTooLong as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`SyndicateToken`](self) events.
    pub enum SyndicateTokenEvents {
        #[allow(missing_docs)]
        Approval(Approval),
        #[allow(missing_docs)]
        BridgeConfigurationUpdated(BridgeConfigurationUpdated),
        #[allow(missing_docs)]
        EIP712DomainChanged(EIP712DomainChanged),
        #[allow(missing_docs)]
        EmissionMinted(EmissionMinted),
        #[allow(missing_docs)]
        EmissionsStarted(EmissionsStarted),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
        #[allow(missing_docs)]
        Transfer(Transfer),
    }
    #[automatically_derived]
    impl SyndicateTokenEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                2u8,
                217u8,
                249u8,
                57u8,
                117u8,
                84u8,
                162u8,
                155u8,
                186u8,
                28u8,
                197u8,
                14u8,
                93u8,
                211u8,
                10u8,
                85u8,
                189u8,
                64u8,
                228u8,
                208u8,
                99u8,
                242u8,
                126u8,
                75u8,
                109u8,
                214u8,
                70u8,
                210u8,
                141u8,
                129u8,
                4u8,
                96u8,
            ],
            [
                10u8,
                99u8,
                135u8,
                201u8,
                234u8,
                54u8,
                40u8,
                184u8,
                138u8,
                99u8,
                59u8,
                180u8,
                243u8,
                177u8,
                81u8,
                119u8,
                15u8,
                112u8,
                8u8,
                81u8,
                23u8,
                161u8,
                95u8,
                155u8,
                243u8,
                120u8,
                124u8,
                218u8,
                83u8,
                241u8,
                61u8,
                49u8,
            ],
            [
                17u8,
                148u8,
                176u8,
                52u8,
                207u8,
                169u8,
                171u8,
                88u8,
                7u8,
                73u8,
                74u8,
                29u8,
                92u8,
                102u8,
                125u8,
                139u8,
                14u8,
                110u8,
                151u8,
                243u8,
                136u8,
                136u8,
                116u8,
                42u8,
                163u8,
                135u8,
                26u8,
                50u8,
                32u8,
                52u8,
                17u8,
                96u8,
            ],
            [
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ],
            [
                52u8,
                183u8,
                61u8,
                12u8,
                150u8,
                233u8,
                255u8,
                77u8,
                83u8,
                17u8,
                67u8,
                72u8,
                23u8,
                200u8,
                236u8,
                201u8,
                48u8,
                231u8,
                210u8,
                120u8,
                44u8,
                91u8,
                222u8,
                46u8,
                121u8,
                220u8,
                68u8,
                176u8,
                89u8,
                103u8,
                85u8,
                187u8,
            ],
            [
                140u8,
                91u8,
                225u8,
                229u8,
                235u8,
                236u8,
                125u8,
                91u8,
                209u8,
                79u8,
                113u8,
                66u8,
                125u8,
                30u8,
                132u8,
                243u8,
                221u8,
                3u8,
                20u8,
                192u8,
                247u8,
                178u8,
                41u8,
                30u8,
                91u8,
                32u8,
                10u8,
                200u8,
                199u8,
                195u8,
                185u8,
                37u8,
            ],
            [
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ],
            [
                221u8,
                242u8,
                82u8,
                173u8,
                27u8,
                226u8,
                200u8,
                155u8,
                105u8,
                194u8,
                176u8,
                104u8,
                252u8,
                55u8,
                141u8,
                170u8,
                149u8,
                43u8,
                167u8,
                241u8,
                99u8,
                196u8,
                161u8,
                22u8,
                40u8,
                245u8,
                90u8,
                77u8,
                245u8,
                35u8,
                179u8,
                239u8,
            ],
            [
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for SyndicateTokenEvents {
        const NAME: &'static str = "SyndicateTokenEvents";
        const COUNT: usize = 9usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Approval as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Approval as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Approval)
                }
                Some(
                    <BridgeConfigurationUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeConfigurationUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeConfigurationUpdated)
                }
                Some(
                    <EIP712DomainChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EIP712DomainChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EIP712DomainChanged)
                }
                Some(<EmissionMinted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionMinted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionMinted)
                }
                Some(<EmissionsStarted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionsStarted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionsStarted)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleRevoked)
                }
                Some(<Transfer as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Transfer as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Transfer)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for SyndicateTokenEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeConfigurationUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EIP712DomainChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionMinted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionsStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeConfigurationUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EIP712DomainChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionMinted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionsStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`SyndicateToken`](self) contract instance.

See the [wrapper's documentation](`SyndicateTokenInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> SyndicateTokenInstance<T, P, N> {
        SyndicateTokenInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        defaultAdmin: alloy::sol_types::private::Address,
        syndFoundationAddress: alloy::sol_types::private::Address,
        emissionsManager: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<SyndicateTokenInstance<T, P, N>>,
    > {
        SyndicateTokenInstance::<
            T,
            P,
            N,
        >::deploy(provider, defaultAdmin, syndFoundationAddress, emissionsManager)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        defaultAdmin: alloy::sol_types::private::Address,
        syndFoundationAddress: alloy::sol_types::private::Address,
        emissionsManager: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        SyndicateTokenInstance::<
            T,
            P,
            N,
        >::deploy_builder(
            provider,
            defaultAdmin,
            syndFoundationAddress,
            emissionsManager,
        )
    }
    /**A [`SyndicateToken`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`SyndicateToken`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct SyndicateTokenInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for SyndicateTokenInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("SyndicateTokenInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`SyndicateToken`](self) contract instance.

See the [wrapper's documentation](`SyndicateTokenInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            defaultAdmin: alloy::sol_types::private::Address,
            syndFoundationAddress: alloy::sol_types::private::Address,
            emissionsManager: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<SyndicateTokenInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                defaultAdmin,
                syndFoundationAddress,
                emissionsManager,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            defaultAdmin: alloy::sol_types::private::Address,
            syndFoundationAddress: alloy::sol_types::private::Address,
            emissionsManager: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            defaultAdmin,
                            syndFoundationAddress,
                            emissionsManager,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> SyndicateTokenInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> SyndicateTokenInstance<T, P, N> {
            SyndicateTokenInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall {})
        }
        ///Creates a new call builder for the [`DOMAIN_SEPARATOR`] function.
        pub fn DOMAIN_SEPARATOR(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DOMAIN_SEPARATORCall, N> {
            self.call_builder(&DOMAIN_SEPARATORCall {})
        }
        ///Creates a new call builder for the [`EMISSIONS_MANAGER_ROLE`] function.
        pub fn EMISSIONS_MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSIONS_MANAGER_ROLECall, N> {
            self.call_builder(&EMISSIONS_MANAGER_ROLECall {})
        }
        ///Creates a new call builder for the [`EMISSIONS_SUPPLY`] function.
        pub fn EMISSIONS_SUPPLY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSIONS_SUPPLYCall, N> {
            self.call_builder(&EMISSIONS_SUPPLYCall {})
        }
        ///Creates a new call builder for the [`EMISSION_AMOUNT_1`] function.
        pub fn EMISSION_AMOUNT_1(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSION_AMOUNT_1Call, N> {
            self.call_builder(&EMISSION_AMOUNT_1Call {})
        }
        ///Creates a new call builder for the [`EMISSION_AMOUNT_2`] function.
        pub fn EMISSION_AMOUNT_2(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSION_AMOUNT_2Call, N> {
            self.call_builder(&EMISSION_AMOUNT_2Call {})
        }
        ///Creates a new call builder for the [`EMISSION_AMOUNT_3`] function.
        pub fn EMISSION_AMOUNT_3(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSION_AMOUNT_3Call, N> {
            self.call_builder(&EMISSION_AMOUNT_3Call {})
        }
        ///Creates a new call builder for the [`EMISSION_AMOUNT_4`] function.
        pub fn EMISSION_AMOUNT_4(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSION_AMOUNT_4Call, N> {
            self.call_builder(&EMISSION_AMOUNT_4Call {})
        }
        ///Creates a new call builder for the [`EMISSION_AMOUNT_5`] function.
        pub fn EMISSION_AMOUNT_5(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSION_AMOUNT_5Call, N> {
            self.call_builder(&EMISSION_AMOUNT_5Call {})
        }
        ///Creates a new call builder for the [`EMISSION_AMOUNT_6`] function.
        pub fn EMISSION_AMOUNT_6(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSION_AMOUNT_6Call, N> {
            self.call_builder(&EMISSION_AMOUNT_6Call {})
        }
        ///Creates a new call builder for the [`EMISSION_AMOUNT_7`] function.
        pub fn EMISSION_AMOUNT_7(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSION_AMOUNT_7Call, N> {
            self.call_builder(&EMISSION_AMOUNT_7Call {})
        }
        ///Creates a new call builder for the [`EMISSION_AMOUNT_8`] function.
        pub fn EMISSION_AMOUNT_8(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSION_AMOUNT_8Call, N> {
            self.call_builder(&EMISSION_AMOUNT_8Call {})
        }
        ///Creates a new call builder for the [`EPOCH_DURATION`] function.
        pub fn EPOCH_DURATION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EPOCH_DURATIONCall, N> {
            self.call_builder(&EPOCH_DURATIONCall {})
        }
        ///Creates a new call builder for the [`INITIAL_MINT_SUPPLY`] function.
        pub fn INITIAL_MINT_SUPPLY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, INITIAL_MINT_SUPPLYCall, N> {
            self.call_builder(&INITIAL_MINT_SUPPLYCall {})
        }
        ///Creates a new call builder for the [`TOTAL_EPOCHS`] function.
        pub fn TOTAL_EPOCHS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, TOTAL_EPOCHSCall, N> {
            self.call_builder(&TOTAL_EPOCHSCall {})
        }
        ///Creates a new call builder for the [`TOTAL_SUPPLY`] function.
        pub fn TOTAL_SUPPLY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, TOTAL_SUPPLYCall, N> {
            self.call_builder(&TOTAL_SUPPLYCall {})
        }
        ///Creates a new call builder for the [`allowance`] function.
        pub fn allowance(
            &self,
            owner: alloy::sol_types::private::Address,
            spender: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, allowanceCall, N> {
            self.call_builder(&allowanceCall { owner, spender })
        }
        ///Creates a new call builder for the [`approve`] function.
        pub fn approve(
            &self,
            spender: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, approveCall, N> {
            self.call_builder(&approveCall { spender, value })
        }
        ///Creates a new call builder for the [`balanceOf`] function.
        pub fn balanceOf(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, balanceOfCall, N> {
            self.call_builder(&balanceOfCall { account })
        }
        ///Creates a new call builder for the [`bridgeAddress`] function.
        pub fn bridgeAddress(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeAddressCall, N> {
            self.call_builder(&bridgeAddressCall {})
        }
        ///Creates a new call builder for the [`bridgeExtraData`] function.
        pub fn bridgeExtraData(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeExtraDataCall, N> {
            self.call_builder(&bridgeExtraDataCall {})
        }
        ///Creates a new call builder for the [`bridgeGasLimit`] function.
        pub fn bridgeGasLimit(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeGasLimitCall, N> {
            self.call_builder(&bridgeGasLimitCall {})
        }
        ///Creates a new call builder for the [`currentEpoch`] function.
        pub fn currentEpoch(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, currentEpochCall, N> {
            self.call_builder(&currentEpochCall {})
        }
        ///Creates a new call builder for the [`decimals`] function.
        pub fn decimals(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, decimalsCall, N> {
            self.call_builder(&decimalsCall {})
        }
        ///Creates a new call builder for the [`eip712Domain`] function.
        pub fn eip712Domain(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, eip712DomainCall, N> {
            self.call_builder(&eip712DomainCall {})
        }
        ///Creates a new call builder for the [`emissionSchedule`] function.
        pub fn emissionSchedule(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionScheduleCall, N> {
            self.call_builder(&emissionScheduleCall { _0 })
        }
        ///Creates a new call builder for the [`emissionsStartTime`] function.
        pub fn emissionsStartTime(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsStartTimeCall, N> {
            self.call_builder(&emissionsStartTimeCall {})
        }
        ///Creates a new call builder for the [`emissionsStarted`] function.
        pub fn emissionsStarted(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsStartedCall, N> {
            self.call_builder(&emissionsStartedCall {})
        }
        ///Creates a new call builder for the [`getBridgeConfiguration`] function.
        pub fn getBridgeConfiguration(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeConfigurationCall, N> {
            self.call_builder(&getBridgeConfigurationCall {})
        }
        ///Creates a new call builder for the [`getCurrentEpochInfo`] function.
        pub fn getCurrentEpochInfo(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getCurrentEpochInfoCall, N> {
            self.call_builder(&getCurrentEpochInfoCall {})
        }
        ///Creates a new call builder for the [`getEmissionSchedule`] function.
        pub fn getEmissionSchedule(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getEmissionScheduleCall, N> {
            self.call_builder(&getEmissionScheduleCall {})
        }
        ///Creates a new call builder for the [`getRemainingEmissions`] function.
        pub fn getRemainingEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRemainingEmissionsCall, N> {
            self.call_builder(&getRemainingEmissionsCall {})
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`isEmissionComplete`] function.
        pub fn isEmissionComplete(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, isEmissionCompleteCall, N> {
            self.call_builder(&isEmissionCompleteCall {})
        }
        ///Creates a new call builder for the [`l2DestinationAddress`] function.
        pub fn l2DestinationAddress(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, l2DestinationAddressCall, N> {
            self.call_builder(&l2DestinationAddressCall {})
        }
        ///Creates a new call builder for the [`l2TokenAddress`] function.
        pub fn l2TokenAddress(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, l2TokenAddressCall, N> {
            self.call_builder(&l2TokenAddressCall {})
        }
        ///Creates a new call builder for the [`mintEmission`] function.
        pub fn mintEmission(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintEmissionCall, N> {
            self.call_builder(&mintEmissionCall {})
        }
        ///Creates a new call builder for the [`name`] function.
        pub fn name(&self) -> alloy_contract::SolCallBuilder<T, &P, nameCall, N> {
            self.call_builder(&nameCall {})
        }
        ///Creates a new call builder for the [`nonces`] function.
        pub fn nonces(
            &self,
            owner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, noncesCall, N> {
            self.call_builder(&noncesCall { owner })
        }
        ///Creates a new call builder for the [`permit`] function.
        pub fn permit(
            &self,
            owner: alloy::sol_types::private::Address,
            spender: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
            deadline: alloy::sol_types::private::primitives::aliases::U256,
            v: u8,
            r: alloy::sol_types::private::FixedBytes<32>,
            s: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, permitCall, N> {
            self.call_builder(
                &permitCall {
                    owner,
                    spender,
                    value,
                    deadline,
                    v,
                    r,
                    s,
                },
            )
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            callerConfirmation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceRoleCall, N> {
            self.call_builder(
                &renounceRoleCall {
                    role,
                    callerConfirmation,
                },
            )
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`setBridgeConfiguration`] function.
        pub fn setBridgeConfiguration(
            &self,
            _bridgeAddress: alloy::sol_types::private::Address,
            _l2TokenAddress: alloy::sol_types::private::Address,
            _l2DestinationAddress: alloy::sol_types::private::Address,
            _gasLimit: u32,
            _extraData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeConfigurationCall, N> {
            self.call_builder(
                &setBridgeConfigurationCall {
                    _bridgeAddress,
                    _l2TokenAddress,
                    _l2DestinationAddress,
                    _gasLimit,
                    _extraData,
                },
            )
        }
        ///Creates a new call builder for the [`startEmissions`] function.
        pub fn startEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, startEmissionsCall, N> {
            self.call_builder(&startEmissionsCall {})
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<T, &P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`symbol`] function.
        pub fn symbol(&self) -> alloy_contract::SolCallBuilder<T, &P, symbolCall, N> {
            self.call_builder(&symbolCall {})
        }
        ///Creates a new call builder for the [`totalEmissionsMinted`] function.
        pub fn totalEmissionsMinted(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, totalEmissionsMintedCall, N> {
            self.call_builder(&totalEmissionsMintedCall {})
        }
        ///Creates a new call builder for the [`totalSupply`] function.
        pub fn totalSupply(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, totalSupplyCall, N> {
            self.call_builder(&totalSupplyCall {})
        }
        ///Creates a new call builder for the [`transfer`] function.
        pub fn transfer(
            &self,
            to: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferCall, N> {
            self.call_builder(&transferCall { to, value })
        }
        ///Creates a new call builder for the [`transferFrom`] function.
        pub fn transferFrom(
            &self,
            from: alloy::sol_types::private::Address,
            to: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferFromCall, N> {
            self.call_builder(
                &transferFromCall {
                    from,
                    to,
                    value,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Approval`] event.
        pub fn Approval_filter(&self) -> alloy_contract::Event<T, &P, Approval, N> {
            self.event_filter::<Approval>()
        }
        ///Creates a new event filter for the [`BridgeConfigurationUpdated`] event.
        pub fn BridgeConfigurationUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeConfigurationUpdated, N> {
            self.event_filter::<BridgeConfigurationUpdated>()
        }
        ///Creates a new event filter for the [`EIP712DomainChanged`] event.
        pub fn EIP712DomainChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EIP712DomainChanged, N> {
            self.event_filter::<EIP712DomainChanged>()
        }
        ///Creates a new event filter for the [`EmissionMinted`] event.
        pub fn EmissionMinted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionMinted, N> {
            self.event_filter::<EmissionMinted>()
        }
        ///Creates a new event filter for the [`EmissionsStarted`] event.
        pub fn EmissionsStarted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionsStarted, N> {
            self.event_filter::<EmissionsStarted>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
        ///Creates a new event filter for the [`Transfer`] event.
        pub fn Transfer_filter(&self) -> alloy_contract::Event<T, &P, Transfer, N> {
            self.event_filter::<Transfer>()
        }
    }
}
