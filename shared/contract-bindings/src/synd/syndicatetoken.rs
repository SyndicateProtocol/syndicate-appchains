///Module containing a contract's types and functions.
/**

```solidity
library Checkpoints {
    struct Checkpoint208 { uint48 _key; uint208 _value; }
}
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod Checkpoints {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /**```solidity
struct Checkpoint208 { uint48 _key; uint208 _value; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Checkpoint208 {
        #[allow(missing_docs)]
        pub _key: alloy::sol_types::private::primitives::aliases::U48,
        #[allow(missing_docs)]
        pub _value: alloy::sol_types::private::primitives::aliases::U208,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<48>,
            alloy::sol_types::sol_data::Uint<208>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U48,
            alloy::sol_types::private::primitives::aliases::U208,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Checkpoint208> for UnderlyingRustTuple<'_> {
            fn from(value: Checkpoint208) -> Self {
                (value._key, value._value)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Checkpoint208 {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    _key: tuple.0,
                    _value: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Checkpoint208 {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Checkpoint208 {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self._key),
                    <alloy::sol_types::sol_data::Uint<
                        208,
                    > as alloy_sol_types::SolType>::tokenize(&self._value),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Checkpoint208 {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Checkpoint208 {
            const NAME: &'static str = "Checkpoint208";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Checkpoint208(uint48 _key,uint208 _value)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self._key)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        208,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self._value)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Checkpoint208 {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust._key)
                    + <alloy::sol_types::sol_data::Uint<
                        208,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust._value,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    48,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._key,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    208,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._value,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`Checkpoints`](self) contract instance.

See the [wrapper's documentation](`CheckpointsInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> CheckpointsInstance<T, P, N> {
        CheckpointsInstance::<T, P, N>::new(address, provider)
    }
    /**A [`Checkpoints`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`Checkpoints`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct CheckpointsInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for CheckpointsInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("CheckpointsInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > CheckpointsInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`Checkpoints`](self) contract instance.

See the [wrapper's documentation](`CheckpointsInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> CheckpointsInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> CheckpointsInstance<T, P, N> {
            CheckpointsInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > CheckpointsInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > CheckpointsInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
/**

Generated by the following Solidity interface...
```solidity
library Checkpoints {
    struct Checkpoint208 {
        uint48 _key;
        uint208 _value;
    }
}

interface SyndicateToken {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error AllEmissionsCompleted();
    error BridgeNotAuthorized();
    error BridgeNotConfigured();
    error CheckpointUnorderedInsertion();
    error ECDSAInvalidSignature();
    error ECDSAInvalidSignatureLength(uint256 length);
    error ECDSAInvalidSignatureS(bytes32 s);
    error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);
    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
    error ERC20InvalidApprover(address approver);
    error ERC20InvalidReceiver(address receiver);
    error ERC20InvalidSender(address sender);
    error ERC20InvalidSpender(address spender);
    error ERC2612ExpiredSignature(uint256 deadline);
    error ERC2612InvalidSigner(address signer, address owner);
    error ERC5805FutureLookup(uint256 timepoint, uint48 clock);
    error ERC6372InconsistentClock();
    error EmissionsAlreadyStarted();
    error EmissionsNotActive();
    error EmissionsNotStarted();
    error EnforcedPause();
    error EpochAlreadyMinted();
    error ExceedsEmissionsSupply();
    error ExpectedPause();
    error InsufficientLimit();
    error InvalidAccountNonce(address account, uint256 currentNonce);
    error InvalidEpoch();
    error InvalidShortString();
    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);
    error StringTooLong(string str);
    error VotesExpiredSignature(uint256 expiry);
    error ZeroAddress();
    error ZeroAmount();
    error ZeroGasLimit();

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event BridgeAuthorized(address indexed bridge);
    event BridgeDataUpdated(bytes oldData, bytes newData);
    event BridgeDeauthorized(address indexed bridge);
    event BridgeLimitsSet(address indexed bridge, uint256 mintingLimit, uint256 burningLimit);
    event BridgeProxyUpdated(address indexed oldProxy, address indexed newProxy);
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);
    event EIP712DomainChanged();
    event EmissionMinted(uint256 epoch, uint256 amount, address indexed destination);
    event EmissionsPaused();
    event EmissionsResumed();
    event EmissionsStarted(uint256 startTime);
    event Paused(address account);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Unpaused(address account);

    constructor(address defaultAdmin, address syndFoundationAddress, address emissionsManager, address pauser);

    function BRIDGE_LIMIT_DURATION() external view returns (uint256);
    function BRIDGE_MANAGER_ROLE() external view returns (bytes32);
    function CLOCK_MODE() external view returns (string memory);
    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function EMISSIONS_MANAGER_ROLE() external view returns (bytes32);
    function EMISSIONS_SUPPLY() external view returns (uint256);
    function EPOCH_DURATION() external view returns (uint256);
    function INITIAL_MINT_SUPPLY() external view returns (uint256);
    function PAUSER_ROLE() external view returns (bytes32);
    function TOTAL_EPOCHS() external view returns (uint256);
    function TOTAL_SUPPLY() external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
    function authorizedBridges(address) external view returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function bridgeData() external view returns (bytes memory);
    function bridgeLimits(address) external view returns (uint256 mintingMaxLimit, uint256 mintingCurrentLimit, uint256 burningMaxLimit, uint256 burningCurrentLimit, uint256 lastUpdate);
    function bridgeProxy() external view returns (address);
    function burn(address _user, uint256 _amount) external;
    function burningCurrentLimitOf(address _bridge) external view returns (uint256);
    function burningMaxLimitOf(address _bridge) external view returns (uint256);
    function checkpoints(address account, uint32 pos) external view returns (Checkpoints.Checkpoint208 memory);
    function clock() external view returns (uint48);
    function currentEpoch() external view returns (uint256);
    function decimals() external view returns (uint8);
    function delegate(address delegatee) external;
    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;
    function delegates(address account) external view returns (address);
    function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
    function emissionSchedule(uint256) external view returns (uint256);
    function emissionsActive() external view returns (bool);
    function emissionsEnded() external view returns (bool);
    function emissionsStartTime() external view returns (uint256);
    function emissionsStarted() external view returns (bool);
    function getBridgeConfiguration() external view returns (address proxy, bytes memory data);
    function getBridgeInfo(address bridge) external view returns (bool authorized, uint256 mintingMax, uint256 mintingCurrent, uint256 burningMax, uint256 burningCurrent);
    function getBridgeUtilization(address bridge) external view returns (uint256 mintingUtilization, uint256 burningUtilization);
    function getCurrentEpochInfo() external view returns (uint256 epoch, uint256 nextEmissionTime, uint256 nextEmissionAmount, bool canMintEmission);
    function getCurrentTotalSupply() external view returns (uint256);
    function getEmissionSchedule() external view returns (uint256[48] memory);
    function getPastTotalSupply(uint256 blockNumber) external view returns (uint256);
    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);
    function getPastVotingPower(address account, uint256 blockNumber) external view returns (uint256);
    function getRemainingEmissions() external view returns (uint256);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function getVotes(address account) external view returns (uint256);
    function getVotingPower(address account) external view returns (uint256);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function isBridge(address bridge) external view returns (bool);
    function mint(address _user, uint256 _amount) external;
    function mintEmission() external;
    function mintingCurrentLimitOf(address _bridge) external view returns (uint256);
    function mintingMaxLimitOf(address _bridge) external view returns (uint256);
    function name() external view returns (string memory);
    function nonces(address owner) external view returns (uint256);
    function numCheckpoints(address account) external view returns (uint32);
    function pause() external;
    function pauseEmissions() external;
    function paused() external view returns (bool);
    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
    function renounceRole(bytes32 role, address callerConfirmation) external;
    function resumeEmissions() external;
    function revokeRole(bytes32 role, address account) external;
    function setBridgeData(bytes memory _bridgeData) external;
    function setBridgeProxy(address _bridgeProxy) external;
    function setLimits(address _bridge, uint256 _mintingLimit, uint256 _burningLimit) external;
    function startEmissions() external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function symbol() external view returns (string memory);
    function totalEmissionsMinted() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function unpause() external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "defaultAdmin",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "syndFoundationAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "emissionsManager",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "pauser",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "BRIDGE_LIMIT_DURATION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "BRIDGE_MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "CLOCK_MODE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DOMAIN_SEPARATOR",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSIONS_MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSIONS_SUPPLY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EPOCH_DURATION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "INITIAL_MINT_SUPPLY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PAUSER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TOTAL_EPOCHS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TOTAL_SUPPLY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "allowance",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "approve",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "authorizedBridges",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "balanceOf",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeData",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeLimits",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "mintingMaxLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "mintingCurrentLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "burningMaxLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "burningCurrentLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "lastUpdate",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeProxy",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "burn",
    "inputs": [
      {
        "name": "_user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "burningCurrentLimitOf",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "burningMaxLimitOf",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkpoints",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "pos",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Checkpoints.Checkpoint208",
        "components": [
          {
            "name": "_key",
            "type": "uint48",
            "internalType": "uint48"
          },
          {
            "name": "_value",
            "type": "uint208",
            "internalType": "uint208"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "clock",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint48",
        "internalType": "uint48"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "currentEpoch",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "decimals",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "delegate",
    "inputs": [
      {
        "name": "delegatee",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "delegateBySig",
    "inputs": [
      {
        "name": "delegatee",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "expiry",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "v",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "delegates",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "eip712Domain",
    "inputs": [],
    "outputs": [
      {
        "name": "fields",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "version",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "verifyingContract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "extensions",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionSchedule",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsActive",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsEnded",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsStartTime",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsStarted",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBridgeConfiguration",
    "inputs": [],
    "outputs": [
      {
        "name": "proxy",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBridgeInfo",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "authorized",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "mintingMax",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "mintingCurrent",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "burningMax",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "burningCurrent",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBridgeUtilization",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "mintingUtilization",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "burningUtilization",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCurrentEpochInfo",
    "inputs": [],
    "outputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nextEmissionTime",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nextEmissionAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "canMintEmission",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCurrentTotalSupply",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getEmissionSchedule",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256[48]",
        "internalType": "uint256[48]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPastTotalSupply",
    "inputs": [
      {
        "name": "blockNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPastVotes",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "timepoint",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPastVotingPower",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "blockNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRemainingEmissions",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVotes",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVotingPower",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isBridge",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "mint",
    "inputs": [
      {
        "name": "_user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "mintEmission",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "mintingCurrentLimitOf",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "mintingMaxLimitOf",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "name",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nonces",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "numCheckpoints",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "pauseEmissions",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "paused",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "permit",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "deadline",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "v",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "callerConfirmation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "resumeEmissions",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeData",
    "inputs": [
      {
        "name": "_bridgeData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeProxy",
    "inputs": [
      {
        "name": "_bridgeProxy",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setLimits",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_mintingLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_burningLimit",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "startEmissions",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "symbol",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "totalEmissionsMinted",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "totalSupply",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transfer",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferFrom",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "unpause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Approval",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeAuthorized",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeDataUpdated",
    "inputs": [
      {
        "name": "oldData",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      },
      {
        "name": "newData",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeDeauthorized",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeLimitsSet",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "mintingLimit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "burningLimit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeProxyUpdated",
    "inputs": [
      {
        "name": "oldProxy",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newProxy",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DelegateChanged",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "fromDelegate",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "toDelegate",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DelegateVotesChanged",
    "inputs": [
      {
        "name": "delegate",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "previousVotes",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "newVotes",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EIP712DomainChanged",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionMinted",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "destination",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionsPaused",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionsResumed",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionsStarted",
    "inputs": [
      {
        "name": "startTime",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Paused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Transfer",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Unpaused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccessControlBadConfirmation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AccessControlUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "neededRole",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "AllEmissionsCompleted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BridgeNotAuthorized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BridgeNotConfigured",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CheckpointUnorderedInsertion",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureLength",
    "inputs": [
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureS",
    "inputs": [
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20ExceededSafeSupply",
    "inputs": [
      {
        "name": "increasedSupply",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "cap",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InsufficientAllowance",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "allowance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InsufficientBalance",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidApprover",
    "inputs": [
      {
        "name": "approver",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidReceiver",
    "inputs": [
      {
        "name": "receiver",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidSender",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidSpender",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC2612ExpiredSignature",
    "inputs": [
      {
        "name": "deadline",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC2612InvalidSigner",
    "inputs": [
      {
        "name": "signer",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC5805FutureLookup",
    "inputs": [
      {
        "name": "timepoint",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "clock",
        "type": "uint48",
        "internalType": "uint48"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC6372InconsistentClock",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionsAlreadyStarted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionsNotActive",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionsNotStarted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EnforcedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EpochAlreadyMinted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExceedsEmissionsSupply",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExpectedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientLimit",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidAccountNonce",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "currentNonce",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidEpoch",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidShortString",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SafeCastOverflowedUintDowncast",
    "inputs": [
      {
        "name": "bits",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "StringTooLong",
    "inputs": [
      {
        "name": "str",
        "type": "string",
        "internalType": "string"
      }
    ]
  },
  {
    "type": "error",
    "name": "VotesExpiredSignature",
    "inputs": [
      {
        "name": "expiry",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAmount",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroGasLimit",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod SyndicateToken {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x610160604052346100765761001e610015610163565b9291909161035d565b61002661007b565b616f5661208d823960805181614b8e015260a05181614bc5015260c05181614b55015260e051816157550152610100518161577a01526101205181615307015261014051816153470152616f5690f35b610081565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906100ad90610085565b810190811060018060401b038211176100c557604052565b61008f565b906100dd6100d661007b565b92836100a3565b565b5f80fd5b60018060a01b031690565b6100f7906100e3565b90565b610103816100ee565b0361010a57565b5f80fd5b9050519061011b826100fa565b565b60808183031261015e57610133825f830161010e565b9261015b610144846020850161010e565b93610152816040860161010e565b9360600161010e565b90565b6100df565b610181618fe380380380610176816100ca565b92833981019061011d565b90919293565b60018060401b0381116101a35761019f602091610085565b0190565b61008f565b906101ba6101b583610187565b6100ca565b918252565b5f7f53796e6469636174650000000000000000000000000000000000000000000000910152565b6101f060096101a8565b906101fd602083016101bf565b565b6102076101e6565b90565b5f7f53594e4400000000000000000000000000000000000000000000000000000000910152565b61023b60046101a8565b906102486020830161020a565b565b610252610231565b90565b90565b90565b61026f61026a61027492610255565b610258565b6100e3565b90565b6102809061025b565b90565b5f0190565b90565b5f1b90565b6102a461029f6102a992610255565b61028b565b610288565b90565b6102b55f610290565b90565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b7f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a90565b90565b90565b61033e61033961034392610324565b610258565b610327565b90565b61035a6a4a723dc6b40b8a9a00000061032a565b90565b90919261037961036b6101ff565b61037361024a565b90610516565b8161039461038e6103895f610277565b6100ee565b916100ee565b146104b057826103b46103ae6103a95f610277565b6100ee565b916100ee565b1461049457836103d46103ce6103c95f610277565b6100ee565b916100ee565b1461047857806103f46103ee6103e95f610277565b6100ee565b916100ee565b1461045c5761043561044392610427610452966104196104126102ac565b84906109b9565b506104226102b8565b6109b9565b506104306102dc565b6109b9565b5061043e610300565b6109b9565b5061044c610346565b90610a87565b61045a610d8f565b565b5f63d92e233d60e01b81528061047460048201610283565b0390fd5b5f63d92e233d60e01b81528061049060048201610283565b0390fd5b5f63d92e233d60e01b8152806104ac60048201610283565b0390fd5b5f63d92e233d60e01b8152806104c860048201610283565b0390fd5b906104d860ff9161028b565b9181191691161790565b151590565b6104f0906104e2565b90565b90565b9061050b610506610512926104e7565b6104f3565b82546104cc565b9055565b906105209161052d565b61052b5f600e6104f6565b565b6105399181909161053b565b565b906105469291610548565b565b906105539291610555565b565b906105609291610562565b565b9061056d929161056f565b565b9061057a929161057c565b565b9061058792916105d4565b565b5f7f3100000000000000000000000000000000000000000000000000000000000000910152565b6105ba60016101a8565b906105c760208301610589565b565b6105d16105b0565b90565b906105e892916105e26105c9565b906105ea565b565b906105f693929161063c565b565b90565b90565b60200190565b5190565b61061c610617610621926100e3565b610258565b6100e3565b90565b61062d90610608565b90565b61063990610624565b90565b61064d61069d9461068293946106d1565b6106618161065b60066105f8565b90610fb9565b610120526106798361067360076105f8565b90610fb9565b610140526105fb565b61069461068e82610604565b916105fe565b2060e0526105fb565b6106af6106a982610604565b916105fe565b20610100524660a0526106c06110be565b6080526106cc30610630565b60c052565b906106db916106dd565b565b906106e7916106e9565b565b906106f391610959565b565b634e487b7160e01b5f525f60045260245ffd5b5190565b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610740575b602083101461073b57565b61070c565b91607f1691610730565b5f5260205f2090565b601f602091010490565b1b90565b9190600861077c9102916107765f198461075d565b9261075d565b9181191691161790565b61079a61079561079f92610327565b610258565b610327565b90565b90565b91906107bb6107b66107c393610786565b6107a2565b908354610761565b9055565b5f90565b6107dd916107d76107c7565b916107a5565b565b5b8181106107eb575050565b806107f85f6001936107cb565b016107e0565b9190601f811161080e575b505050565b61081a61083f9361074a565b90602061082684610753565b83019310610847575b61083890610753565b01906107df565b5f8080610809565b91506108388192905061082f565b1c90565b90610869905f1990600802610855565b191690565b8161087891610859565b906002021790565b9061088a81610708565b9060018060401b038211610948576108ac826108a68554610720565b856107fe565b602090601f83116001146108e0579180916108cf935f926108d4575b505061086e565b90555b565b90915001515f806108c8565b601f198316916108ef8561074a565b925f5b81811061093057509160029391856001969410610916575b505050020190556108d2565b610926910151601f841690610859565b90555f808061090a565b919360206001819287870151815501950192016108f2565b61008f565b9061095791610880565b565b9061096861096f92600361094d565b600461094d565b565b5f90565b61097e90610288565b90565b9061098b90610975565b5f5260205260405f2090565b6109a090610624565b90565b906109ad90610997565b5f5260205260405f2090565b6109c1610971565b506109d66109d082849061115b565b156104e2565b5f14610a5f576109fe60016109f95f6109f160058690610981565b0185906109a3565b6104f6565b90610a07611189565b90610a44610a3e610a387f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d95610975565b92610997565b92610997565b92610a4d61007b565b80610a5781610283565b0390a4600190565b50505f90565b610a6e906100ee565b9052565b9190610a85905f60208501940190610a65565b565b80610aa2610a9c610a975f610277565b6100ee565b916100ee565b14610abe57610abc91610ab45f610277565b919091611196565b565b610ae1610aca5f610277565b5f91829163ec442f0560e01b835260048301610a72565b0390fd5b60018060401b038111610af85760200290565b61008f565b610b09610b0e91610ae5565b6100ca565b90565b90565b610b28610b23610b2d92610b11565b610258565b610327565b90565b90610b3a90610327565b9052565b90565b610b55610b50610b5a92610b3e565b610258565b610327565b90565b90565b610b74610b6f610b7992610b5d565b610258565b610327565b90565b90565b610b93610b8e610b9892610b7c565b610258565b610327565b90565b90565b610bb2610bad610bb792610b9b565b610258565b610327565b90565b90565b610bd1610bcc610bd692610bba565b610258565b610327565b90565b90565b610bf0610beb610bf592610bd9565b610258565b610327565b90565b90565b610c0f610c0a610c1492610bf8565b610258565b610327565b90565b610c2b610c26610c3092610255565b610258565b610327565b90565b6001610c3f9101610327565b90565b90565b610c59610c54610c5e92610c42565b610258565b610327565b90565b90565b610c78610c73610c7d92610c61565b610258565b610327565b90565b634e487b7160e01b5f52601160045260245ffd5b610ca3610ca991939293610327565b92610327565b91610cb5838202610327565b928184041490151715610cc457565b610c80565b610cd8610cde91939293610327565b92610327565b8201809211610ce957565b610c80565b90565b610d05610d00610d0a92610cee565b610258565b610327565b90565b610d176030610cf1565b90565b634e487b7160e01b5f52603260045260245ffd5b50600890565b90610d3e82610d2e565b811015610d4c576020020190565b610d1a565b610d5b9051610327565b90565b50603090565b90565b610d7081610d5e565b821015610d8a57610d82600191610d64565b910201905f90565b610d1a565b610d996008610afd565b610db7610daf698f956f697aa4923c0000610b14565b5f8301610b30565b610dd6610dcd695626760c1662be240000610b41565b60208301610b30565b610df5610dec6933b0b000fec593900000610b60565b60408301610b30565b610e14610e0b691f039ccd65a9bef00000610b7f565b60608301610b30565b610e33610e2a69129bc47b3cff72900000610b9e565b60808301610b30565b610e52610e49690b2a483d6dadee180000610bbd565b60a08301610b30565b610e71610e686906b2efd13a962a6c0000610bdc565b60c08301610b30565b610e90610e87690404f64a565a19740000610bfb565b60e08301610b30565b610e995f610c17565b915b82610eaf610ea96008610c45565b91610327565b1015610f6557610ebe5f610c17565b5b80610ed3610ecd6006610c64565b91610327565b1015610f5457610f2190610efb610ef486610eee6006610c64565b90610c94565b8290610cc9565b80610f15610f0f610f0a610d0d565b610327565b91610327565b10610f26575b50610c33565b610ebf565b610f4e90610f48610f40610f3b888a90610d34565b610d51565b91600f610d67565b906107a5565b5f610f1b565b5091610f5f90610c33565b91610e9b565b915050565b5f90565b90565b610f85610f80610f8a92610f6e565b610258565b610327565b90565b90565b610fa4610f9f610fa992610f8d565b61028b565b610288565b90565b610fb660ff610f90565b90565b90610fc2610f6a565b50610fd4610fcf836105fb565b610604565b610fe7610fe16020610f71565b91610327565b105f14610ffb5750610ff890611295565b90565b5f61100961100f93926111a5565b0161094d565b61101f61101a610fac565b610975565b90565b5f90565b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b6110549051610288565b90565b61106090610288565b9052565b61106d90610327565b9052565b909594926110bc946110ab6110b5926110a160809661109760a088019c5f890190611057565b6020870190611057565b6040850190611057565b6060830190611064565b0190610a65565b565b6110c6611022565b506110cf611026565b6111196110dc60e061104a565b9161110a6110eb61010061104a565b466110f530610630565b916110fe61007b565b96879560208701611071565b602082018103825203826100a3565b61112b61112582610604565b916105fe565b2090565b5f1c90565b60ff1690565b61114661114b9161112f565b611134565b90565b611158905461113a565b90565b611182915f61117761117d9361116f610971565b506005610981565b016109a3565b61114e565b90565b5f90565b611191611185565b503390565b916111a392919091611342565b565b90565b90565b6111bf6111ba6111c4926111a8565b610258565b610327565b90565b60209181520190565b90825f9392825e0152565b6111fa611203602093611208936111f181610708565b938480936111c7565b958691016111d0565b610085565b0190565b6112219160208201915f8184039101526111db565b90565b61123e61123961123383610604565b926105fe565b61104a565b906020811061124c575b5090565b61125e905f199060200360080261075d565b165f611248565b6112716112769161112f565b610786565b90565b61128d61128861129292610327565b61028b565b610288565b90565b61129d610f6a565b506112a7816105fb565b906112b182610604565b6112c46112be601f6111ab565b91610327565b116112f957506112f1816112eb6112e56112e06112f695611224565b611265565b91610604565b17611279565b610975565b90565b61131b9061130561007b565b91829163305a27a960e01b83526004830161120c565b0390fd5b91602061134092949361133960408201965f830190611064565b0190611064565b565b9291611350848383916114a5565b8361136b6113656113605f610277565b6100ee565b916100ee565b14611380575b61137e9293919091611672565b565b611388611614565b93611391611651565b94806113a561139f88610327565b91610327565b116113b257509350611371565b85906113ce5f928392630e58ae9360e11b84526004840161131f565b0390fd5b906113dc90610997565b5f5260205260405f2090565b90565b6113f76113fc9161112f565b6113e8565b90565b61140990546113eb565b90565b60409061143561143c949695939661142b60608401985f850190610a65565b6020830190611064565b0190611064565b565b906114499103610327565b90565b906114585f199161028b565b9181191691161790565b9061147761147261147e92610786565b6107a2565b825461144c565b9055565b9061148d9101610327565b90565b91906114a3905f60208501940190611064565b565b919091806114c36114bd6114b85f610277565b6100ee565b916100ee565b145f146115a4576114e76114e0836114db60026113ff565b610cc9565b6002611462565b5b826115036114fd6114f85f610277565b6100ee565b916100ee565b145f14611578576115276115208361151b60026113ff565b61143e565b6002611462565b5b91909161157361156161155b7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef93610997565b93610997565b9361156a61007b565b91829182611490565b0390a3565b61159f8261159961158a5f87906113d2565b91611594836113ff565b611482565b90611462565b611528565b6115b76115b25f83906113d2565b6113ff565b806115ca6115c485610327565b91610327565b106115f2576115dd6115ed91849061143e565b6115e85f84906113d2565b611462565b6114e8565b906116109091925f93849363391434e360e21b85526004850161140c565b0390fd5b61161c6107c7565b5061162760026113ff565b90565b60018060d01b031690565b61164961164461164e9261162a565b610258565b610327565b90565b6116596107c7565b5061166960018060d01b03611635565b90565b90565b90565b916116ca6116c46116d1948061169861169261168d5f610277565b6100ee565b916100ee565b14611702575b846116b96116b36116ae5f610277565b6100ee565b916100ee565b146116d3575b6118fa565b926118fa565b909161192f565b565b6116fb600b60026116f56116ef6116e9896117e4565b9361166c565b9161166f565b90611837565b50506116bf565b61172a600b600161172461171e611718896117e4565b9361166c565b9161166f565b90611837565b505061169e565b5f90565b6117416117479161162a565b9161162a565b019060018060d01b03821161175857565b610c80565b906117709161176a611731565b50611735565b90565b90565b60ff1690565b61179061178b61179592611773565b610258565b611776565b90565b6117a19061177c565b9052565b9160206117c69294936117bf60408201965f830190611798565b0190611064565b565b6117dc6117d76117e192610327565b610258565b61162a565b90565b6117ec611731565b508061180661180060018060d01b03611635565b91610327565b1161181757611814906117c8565b90565b60d06118335f9283926306dfcc6560e41b8452600484016117a5565b0390fd5b9061186d6118739392611848611731565b50611851611731565b50809361186661185f611ae1565b9492611b8e565b909161205d565b91611c03565b91909190565b61188561188b9161162a565b9161162a565b90039060018060d01b03821161189d57565b610c80565b906118b5916118af611731565b50611879565b90565b906118c290610997565b5f5260205260405f2090565b60018060a01b031690565b6118e56118ea9161112f565b6118ce565b90565b6118f790546118d9565b90565b61191161191691611909611185565b5060096118b8565b6118ed565b90565b9061192390610997565b5f5260205260405f2090565b9190918061194561193f856100ee565b916100ee565b141580611ac3575b611957575b505050565b8061197261196c6119675f610277565b6100ee565b916100ee565b03611a33575b508161199461198e6119895f610277565b6100ee565b916100ee565b036119a0575b80611952565b6119e76119da6119e1926119b6600a8690611919565b906119d46119ce6119c86001936117e4565b9361166c565b9161166f565b90611837565b9290611635565b91611635565b919091611a147fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492610997565b92611a29611a2061007b565b9283928361131f565b0390a25f8061199a565b611a72611a78611a6b611a48600a8590611919565b6002611a65611a5f611a59896117e4565b9361166c565b9161166f565b90611837565b9290611635565b91611635565b919091611aa57fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492610997565b92611aba611ab161007b565b9283928361131f565b0390a25f611978565b5081611ad7611ad15f610c17565b91610327565b1161194d565b5f90565b611ae9611add565b50611af2611c32565b90565b5490565b90565b611b10611b0b611b1592611af9565b610258565b610327565b90565b611b27611b2d91939293610327565b92610327565b8203918211611b3857565b610c80565b90565b60301c90565b60018060d01b031690565b611b5d611b6291611b40565b611b46565b90565b611b6f9054611b51565b90565b611b86611b81611b8b92610255565b610258565b61162a565b90565b611b96611731565b50611ba25f8201611af5565b80611bb5611baf5f610c17565b91610327565b145f14611bcb575050611bc75f611b72565b5b90565b611bf85f91611bf3611bed84611bfe960192611be76001611afc565b90611b18565b91611b3d565b611c47565b01611b65565b611bc8565b91611c275f611c2c94611c14611731565b50611c1d611731565b5001929192611b3d565b611e38565b91909190565b611c3a611add565b50611c4443611ff6565b90565b5f5260205f200190565b5490565b611c5f60406100ca565b90565b65ffffffffffff1690565b90611c7790611c62565b9052565b90611c859061162a565b9052565b5f5260205f2090565b611c9b81611c51565b821015611cb557611cad600191611c89565b910201905f90565b610d1a565b611cc49051611c62565b90565b90611cd865ffffffffffff9161028b565b9181191691161790565b611cf6611cf1611cfb92611c62565b610258565b611c62565b90565b90565b90611d16611d11611d1d92611ce2565b611cfe565b8254611cc7565b9055565b611d2b905161162a565b90565b60301b90565b90611d4665ffffffffffff1991611d2e565b9181191691161790565b611d64611d5f611d699261162a565b610258565b61162a565b90565b90565b90611d84611d7f611d8b92611d50565b611d6c565b8254611d34565b9055565b90611db960205f611dbf94611db1828201611dab848801611cba565b90611d01565b019201611d21565b90611d6f565b565b9190611dd257611dd091611d8f565b565b6106f5565b9081549168010000000000000000831015611e075782611dff916001611e0595018155611c92565b90611dc1565b565b61008f565b65ffffffffffff1690565b611e23611e289161112f565b611e0c565b90565b611e359054611e17565b90565b90929192611e44611731565b50611e4d611731565b50611e5782611c51565b80611e6a611e645f610c17565b91610327565b115f14611f3a57611e9090611e8a8491611e846001611afc565b90611b18565b90611c47565b90611e9c5f8301611e2b565b92611ea85f8401611b65565b9380611ebc611eb685611c62565b91611c62565b11611f1e57611ed3611ecd84611c62565b91611c62565b145f14611eee575050611ee9905f859101611d6f565b5b9190565b611f199250611f1486611f0b611f02611c55565b945f8601611c6d565b60208401611c7b565b611dd7565b611eea565b5f632520601d60e01b815280611f3660048201610283565b0390fd5b50611f6591611f6085611f57611f4e611c55565b945f8601611c6d565b60208401611c7b565b611dd7565b611f6e5f611b72565b9190565b611f86611f81611f8b92611c62565b610258565b610327565b90565b611fa2611f9d611fa792610cee565b610258565b611776565b90565b611fb390611f8e565b9052565b916020611fd8929493611fd160408201965f830190611faa565b0190611064565b565b611fee611fe9611ff392610327565b610258565b611c62565b90565b611ffe611add565b508061201861201265ffffffffffff611f72565b91610327565b116120295761202690611fda565b90565b60306120455f9283926306dfcc6560e41b845260048401611fb7565b0390fd5b634e487b7160e01b5f52605160045260245ffd5b9190918060011461207c5760020361204957612078916118a2565b905b565b506120869161175d565b9061207a56fe60806040526004361015610013575b612367565b61001d5f356104dc565b806301ffc9a7146104d757806306fdde03146104d257806307a1d5fa146104cd578063095ea7b3146104c85780630c05f82c146104c357806313beaa5b146104be57806318160ddd146104b95780631b02f845146104b457806322a97d9c146104af57806323b872dd146104aa57806323e460d2146104a55780632481bb5c146104a0578063248a9ca31461049b578063284e1333146104965780632f2ff15d14610491578063313ce5671461048c578063334d0bbd14610487578063359b76fe146104825780633644e5151461047d57806336568abe146104785780633a46b1a8146104735780633f4ba83a1461046e57806340c10f191461046957806344e181aa1461046457806348b0daa61461045f5780634bdd36ce1461045a5780634bf5d7e914610455578063587cde1e146104505780635adf00211461044b5780635c19a95c146104465780635c975abb146104415780635f15c3c91461043c578063651fd268146104375780636c33bced146104325780636cf016251461042d5780636fc063be146104285780636fcfff451461042357806370a082311461041e578063726600ce1461041957806376671808146104145780637c790cab1461040f5780637ecebe001461040a5780638456cb591461040557806384b0196e146104005780638e539e8c146103fb578063902d55a5146103f657806391d14854146103f157806391ddadf4146103ec57806395d89b41146103e757806399127d9b146103e2578063998955d3146103dd5780639ab24eb0146103d85780639b7ef64b146103d35780639dc29fac146103ce578063a08d5654146103c9578063a217fddf146103c4578063a3d4485b146103bf578063a4d7e31d146103ba578063a571e184146103b5578063a70b9f0c146103b0578063a9059cbb146103ab578063af2aa63b146103a6578063b0ca253e146103a1578063babc394f1461039c578063bb4d443614610397578063c02ae75414610392578063c1eb71371461038d578063c3cda52014610388578063d505accf14610383578063d547741f1461037e578063dd62ed3e14610379578063e3abdfcb14610374578063e63ab1e91461036f578063f1127ed81461036a578063f508e19d146103655763f75e85120361000e57612332565b6122ce565b612289565b6121a6565b612142565b6120dd565b61207c565b612042565b611f98565b611edc565b611ea7565b611e72565b611e39565b611dc5565b611d90565b611ce5565b611cb0565b611c44565b611c0f565b611bda565b611b65565b611af6565b611a88565b611a53565b6119dd565b6119a8565b611973565b611905565b6118d0565b61186d565b611838565b6117dd565b6117a1565b61165c565b611627565b6115ee565b61156c565b611528565b6114f3565b6114be565b61145e565b6113fa565b611386565b611351565b61131c565b6112b0565b61127d565b611248565b611213565b6111c9565b611194565b61115f565b611117565b610fd7565b610fa4565b610f6e565b610f3a565b610f05565b610ed2565b610e9d565b610db0565b610d54565b610cf4565b610cbf565b610c24565b610a54565b6109fb565b61098c565b61091a565b6108e5565b6108b1565b6107f6565b610780565b6106d4565b610617565b610568565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b610509816104f4565b0361051057565b5f80fd5b9050359061052182610500565b565b9060208282031261053c57610539915f01610514565b90565b6104ec565b151590565b61054f90610541565b9052565b9190610566905f60208501940190610546565b565b346105985761059461058361057e366004610523565b612404565b61058b6104e2565b91829182610553565b0390f35b6104e8565b5f9103126105a757565b6104ec565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b6105ed6105f66020936105fb936105e4816105ac565b938480936105b0565b958691016105b9565b6105c4565b0190565b6106149160208201915f8184039101526105ce565b90565b346106475761062736600461059d565b610643610632612522565b61063a6104e2565b918291826105ff565b0390f35b6104e8565b60018060a01b031690565b6106609061064c565b90565b61066c90610657565b9052565b5190565b60209181520190565b61069c6106a56020936106aa9361069381610670565b93848093610674565b958691016105b9565b6105c4565b0190565b916106d1926106c460408201935f830190610663565b602081840391015261067d565b90565b34610705576106e436600461059d565b6106ec61256e565b906107016106f86104e2565b928392836106ae565b0390f35b6104e8565b61071381610657565b0361071a57565b5f80fd5b9050359061072b8261070a565b565b90565b6107398161072d565b0361074057565b5f80fd5b9050359061075182610730565b565b919060408382031261077b578061076f610778925f860161071e565b93602001610744565b90565b6104ec565b346107b1576107ad61079c610796366004610753565b90612598565b6107a46104e2565b91829182610553565b0390f35b6104e8565b906020828203126107cf576107cc915f0161071e565b90565b6104ec565b6107dd9061072d565b9052565b91906107f4905f602085019401906107d4565b565b346108265761082261081161080c3660046107b6565b6125be565b6108196104e2565b918291826107e1565b0390f35b6104e8565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156108715781359167ffffffffffffffff831161086c57602001926001830284011161086757565b610833565b61082f565b61082b565b906020828203126108a7575f82013567ffffffffffffffff81116108a25761089e9201610837565b9091565b6104f0565b6104ec565b5f0190565b346108e0576108ca6108c4366004610876565b906128af565b6108d26104e2565b806108dc816108ac565b0390f35b6104e8565b34610915576108f536600461059d565b6109116109006128bb565b6109086104e2565b918291826107e1565b0390f35b6104e8565b346109485761092a36600461059d565b610932612a7f565b61093a6104e2565b80610944816108ac565b0390f35b6104e8565b1c90565b60ff1690565b61096790600861096c930261094d565b610951565b90565b9061097a9154610957565b90565b610989603f5f9061096f565b90565b346109bc5761099c36600461059d565b6109b86109a761097d565b6109af6104e2565b91829182610553565b0390f35b6104e8565b90916060828403126109f6576109f36109dc845f850161071e565b936109ea816020860161071e565b93604001610744565b90565b6104ec565b34610a2c57610a28610a17610a113660046109c1565b91612a89565b610a1f6104e2565b91829182610553565b0390f35b6104e8565b916020610a52929493610a4b60408201965f8301906107d4565b01906107d4565b565b34610a8557610a6c610a673660046107b6565b612bba565b90610a81610a786104e2565b92839283610a31565b0390f35b6104e8565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610ad1575b6020831014610acc57565b610a9d565b91607f1691610ac1565b60209181520190565b5f5260205f2090565b905f9291805490610b07610b0083610ab1565b8094610adb565b916001811690815f14610b5e5750600114610b22575b505050565b610b2f9192939450610ae4565b915f925b818410610b4657505001905f8080610b1d565b60018160209295939554848601520191019290610b33565b92949550505060ff19168252151560200201905f8080610b1d565b90610b8391610aed565b90565b634e487b7160e01b5f52604160045260245ffd5b90610ba4906105c4565b810190811067ffffffffffffffff821117610bbe57604052565b610b86565b90610be3610bdc92610bd36104e2565b93848092610b79565b0383610b9a565b565b905f10610bf857610bf590610bc3565b90565b610a8a565b610c0960445f90610be5565b90565b610c219160208201915f81840391015261067d565b90565b34610c5457610c3436600461059d565b610c50610c3f610bfd565b610c476104e2565b91829182610c0c565b0390f35b6104e8565b90565b610c6581610c59565b03610c6c57565b5f80fd5b90503590610c7d82610c5c565b565b90602082820312610c9857610c95915f01610c70565b90565b6104ec565b610ca690610c59565b9052565b9190610cbd905f60208501940190610c9d565b565b34610cef57610ceb610cda610cd5366004610c7f565b612ddb565b610ce26104e2565b91829182610caa565b0390f35b6104e8565b34610d2257610d0436600461059d565b610d0c6132b2565b610d146104e2565b80610d1e816108ac565b0390f35b6104e8565b9190604083820312610d4f5780610d43610d4c925f8601610c70565b9360200161071e565b90565b6104ec565b34610d8357610d6d610d67366004610d27565b906132e6565b610d756104e2565b80610d7f816108ac565b0390f35b6104e8565b60ff1690565b610d9790610d88565b9052565b9190610dae905f60208501940190610d8e565b565b34610de057610dc036600461059d565b610ddc610dcb613315565b610dd36104e2565b91829182610d9b565b0390f35b6104e8565b90602082820312610dfe57610dfb915f01610744565b90565b6104ec565b634e487b7160e01b5f52603260045260245ffd5b50603090565b90565b610e2981610e17565b821015610e4357610e3b600191610e1d565b910201905f90565b610e03565b90565b610e5b906008610e60930261094d565b610e48565b90565b90610e6e9154610e4b565b90565b600f610e7c81610e17565b821015610e9957610e9691610e9091610e20565b90610e63565b90565b5f80fd5b34610ecd57610ec9610eb8610eb3366004610de5565b610e71565b610ec06104e2565b918291826107e1565b0390f35b6104e8565b34610f0057610ee236600461059d565b610eea6133c6565b610ef26104e2565b80610efc816108ac565b0390f35b6104e8565b34610f3557610f1536600461059d565b610f31610f206133d0565b610f286104e2565b91829182610caa565b0390f35b6104e8565b34610f6957610f53610f4d366004610d27565b906133e4565b610f5b6104e2565b80610f65816108ac565b0390f35b6104e8565b34610f9f57610f9b610f8a610f84366004610753565b90613461565b610f926104e2565b918291826107e1565b0390f35b6104e8565b34610fd257610fb436600461059d565b610fbc6134bf565b610fc46104e2565b80610fce816108ac565b0390f35b6104e8565b3461100657610ff0610fea366004610753565b906134c9565b610ff86104e2565b80611002816108ac565b0390f35b6104e8565b90565b61102261101d6110279261064c565b61100b565b61064c565b90565b6110339061100e565b90565b61103f9061102a565b90565b9061104c90611036565b5f5260205260405f2090565b5f1c90565b61106961106e91611058565b610e48565b90565b61107b905461105d565b90565b61108990600c611042565b6110945f8201611071565b916110a160018301611071565b916110ae60028201611071565b916110c760046110c060038501611071565b9301611071565b90565b909594926111159461110461110e926110fa6080966110f060a088019c5f8901906107d4565b60208701906107d4565b60408501906107d4565b60608301906107d4565b01906107d4565b565b3461114b5761114761113261112d3660046107b6565b61107e565b9161113e9593956104e2565b958695866110ca565b0390f35b6104e8565b61115c60405f90610e63565b90565b3461118f5761116f36600461059d565b61118b61117a611150565b6111826104e2565b918291826107e1565b0390f35b6104e8565b346111c4576111a436600461059d565b6111c06111af613600565b6111b76104e2565b918291826107e1565b0390f35b6104e8565b346111f9576111d936600461059d565b6111f56111e46136c1565b6111ec6104e2565b918291826105ff565b0390f35b6104e8565b9190611211905f60208501940190610663565b565b346112435761123f61122e6112293660046107b6565b61372d565b6112366104e2565b918291826111fe565b0390f35b6104e8565b346112785761125836600461059d565b61127461126361374c565b61126b6104e2565b91829182610553565b0390f35b6104e8565b346112ab576112956112903660046107b6565b613775565b61129d6104e2565b806112a7816108ac565b0390f35b6104e8565b346112e0576112c036600461059d565b6112dc6112cb613788565b6112d36104e2565b91829182610553565b0390f35b6104e8565b90565b6112fc6112f7611301926112e5565b61100b565b61072d565b90565b61130e60306112e8565b90565b611319611304565b90565b3461134c5761132c36600461059d565b611348611337611311565b61133f6104e2565b918291826107e1565b0390f35b6104e8565b346113815761137d61136c6113673660046107b6565b61379e565b6113746104e2565b918291826107e1565b0390f35b6104e8565b346113b45761139636600461059d565b61139e613855565b6113a66104e2565b806113b0816108ac565b0390f35b6104e8565b90565b6113d06113cb6113d5926113b9565b61100b565b61072d565b90565b6113ec6a084595161401484a0000006113bc565b90565b6113f76113d8565b90565b3461142a5761140a36600461059d565b6114266114156113ef565b61141d6104e2565b918291826107e1565b0390f35b6104e8565b9061143990611036565b5f5260205260405f2090565b61145b90611456600d915f9261142f565b61096f565b90565b3461148e5761148a6114796114743660046107b6565b611445565b6114816104e2565b91829182610553565b0390f35b6104e8565b63ffffffff1690565b6114a590611493565b9052565b91906114bc905f6020850194019061149c565b565b346114ee576114ea6114d96114d43660046107b6565b613863565b6114e16104e2565b918291826114a9565b0390f35b6104e8565b346115235761151f61150e6115093660046107b6565b61388e565b6115166104e2565b918291826107e1565b0390f35b6104e8565b346115585761155461154361153e3660046107b6565b6138ac565b61154b6104e2565b91829182610553565b0390f35b6104e8565b61156960415f90610e63565b90565b3461159c5761157c36600461059d565b61159861158761155d565b61158f6104e2565b918291826107e1565b0390f35b6104e8565b909594926115ec946115db6115e5926115d16080966115c760a088019c5f890190610546565b60208701906107d4565b60408501906107d4565b60608301906107d4565b01906107d4565b565b346116225761161e6116096116043660046107b6565b6138cb565b916116159593956104e2565b958695866115a1565b0390f35b6104e8565b346116575761165361164261163d3660046107b6565b613a3b565b61164a6104e2565b918291826107e1565b0390f35b6104e8565b3461168a5761166c36600461059d565b611674613a74565b61167c6104e2565b80611686816108ac565b0390f35b6104e8565b60ff60f81b1690565b6116a19061168f565b9052565b5190565b60209181520190565b60200190565b6116c19061072d565b9052565b906116d2816020936116b8565b0190565b60200190565b906116f96116f36116ec846116a5565b80936116a9565b926116b2565b905f5b8181106117095750505090565b90919261172261171c60019286516116c5565b946116d6565b91019190916116fc565b9395919461177d611772611791956117646117879561179e9c9a61175760e08c01925f8d0190611698565b8a820360208c01526105ce565b9088820360408a01526105ce565b9760608701906107d4565b6080850190610663565b60a0830190610c9d565b60c08184039101526116dc565b90565b346117d8576117b136600461059d565b6117d46117bc613afb565b936117cb9795979391936104e2565b9788978861172c565b0390f35b6104e8565b346117f2576117ed366004610de5565b613b85565b6104e8565b90565b61180e611809611813926117f7565b61100b565b61072d565b90565b61182a6a52b7d2dcc80cd2e40000006117fa565b90565b611835611816565b90565b346118685761184836600461059d565b61186461185361182d565b61185b6104e2565b918291826107e1565b0390f35b6104e8565b3461189e5761189a611889611883366004610d27565b90613b93565b6118916104e2565b91829182610553565b0390f35b6104e8565b65ffffffffffff1690565b6118b7906118a3565b9052565b91906118ce905f602085019401906118ae565b565b34611900576118e036600461059d565b6118fc6118eb613bc1565b6118f36104e2565b918291826118bb565b0390f35b6104e8565b346119355761191536600461059d565b611931611920613bd5565b6119286104e2565b918291826105ff565b0390f35b6104e8565b90565b61195161194c6119569261193a565b61100b565b61072d565b90565b6119656201518061193d565b90565b611970611959565b90565b346119a35761198336600461059d565b61199f61198e611968565b6119966104e2565b918291826107e1565b0390f35b6104e8565b346119d8576119d46119c36119be3660046107b6565b613beb565b6119cb6104e2565b918291826107e1565b0390f35b6104e8565b34611a0d57611a096119f86119f33660046107b6565b613c46565b611a006104e2565b918291826107e1565b0390f35b6104e8565b90565b611a29611a24611a2e92611a12565b61100b565b61072d565b90565b611a456a4a723dc6b40b8a9a000000611a15565b90565b611a50611a31565b90565b34611a8357611a6336600461059d565b611a7f611a6e611a48565b611a766104e2565b918291826107e1565b0390f35b6104e8565b34611ab757611aa1611a9b366004610753565b90613c75565b611aa96104e2565b80611ab3816108ac565b0390f35b6104e8565b9091606082840312611af157611aee611ad7845f850161071e565b93611ae58160208601610744565b93604001610744565b90565b6104ec565b34611b2557611b0f611b09366004611abc565b91614026565b611b176104e2565b80611b21816108ac565b0390f35b6104e8565b90565b5f1b90565b611b46611b41611b4b92611b2a565b611b2d565b610c59565b90565b611b575f611b32565b90565b611b62611b4e565b90565b34611b9557611b7536600461059d565b611b91611b80611b5a565b611b886104e2565b91829182610caa565b0390f35b6104e8565b60018060a01b031690565b611bb5906008611bba930261094d565b611b9a565b90565b90611bc89154611ba5565b90565b611bd760435f90611bbd565b90565b34611c0a57611bea36600461059d565b611c06611bf5611bcb565b611bfd6104e2565b918291826111fe565b0390f35b6104e8565b34611c3f57611c1f36600461059d565b611c3b611c2a614033565b611c326104e2565b91829182610553565b0390f35b6104e8565b34611c7257611c5c611c573660046107b6565b61415a565b611c646104e2565b80611c6e816108ac565b0390f35b6104e8565b90565b611c8e611c89611c9392611c77565b61100b565b61072d565b90565b611ca262278d00611c7a565b90565b611cad611c96565b90565b34611ce057611cc036600461059d565b611cdc611ccb611ca5565b611cd36104e2565b918291826107e1565b0390f35b6104e8565b34611d1657611d12611d01611cfb366004610753565b90614165565b611d096104e2565b91829182610553565b0390f35b6104e8565b50603090565b905090565b90565b60200190565b611d4b611d45611d3e83611d1b565b8094611d21565b91611d26565b5f915b838310611d5b5750505050565b611d71611d6b60019284516116c5565b92611d29565b92019190611d4e565b9190611d8e905f6106008501940190611d2f565b565b34611dc057611da036600461059d565b611dbc611dab61428c565b611db36104e2565b91829182611d7a565b0390f35b6104e8565b34611df657611df2611de1611ddb366004610753565b906142a2565b611de96104e2565b918291826107e1565b0390f35b6104e8565b611e30611e3794611e26606094989795611e1c608086019a5f8701906107d4565b60208501906107d4565b60408301906107d4565b0190610546565b565b34611e6d57611e4936600461059d565b611e69611e546142d7565b90611e609492946104e2565b94859485611dfb565b0390f35b6104e8565b34611ea257611e9e611e8d611e883660046107b6565b61447c565b611e956104e2565b918291826107e1565b0390f35b6104e8565b34611ed757611eb736600461059d565b611ed3611ec2614491565b611eca6104e2565b918291826107e1565b0390f35b6104e8565b34611f0c57611f08611ef7611ef23660046107b6565b6144a5565b611eff6104e2565b918291826107e1565b0390f35b6104e8565b611f1a81610d88565b03611f2157565b5f80fd5b90503590611f3282611f11565b565b909160c082840312611f9357611f4c835f840161071e565b92611f5a8160208501610744565b92611f688260408301610744565b92611f90611f798460608501611f25565b93611f878160808601610c70565b9360a001610c70565b90565b6104ec565b34611fcd57611fb7611fab366004611f34565b9493909392919261452f565b611fbf6104e2565b80611fc9816108ac565b0390f35b6104e8565b60e08183031261203d57611fe8825f830161071e565b92611ff6836020840161071e565b926120048160408501610744565b926120128260608301610744565b9261203a6120238460808501611f25565b936120318160a08601610c70565b9360c001610c70565b90565b6104ec565b3461207757612061612055366004611fd2565b95949094939193614683565b6120696104e2565b80612073816108ac565b0390f35b6104e8565b346120ab5761209561208f366004610d27565b906147a1565b61209d6104e2565b806120a7816108ac565b0390f35b6104e8565b91906040838203126120d857806120cc6120d5925f860161071e565b9360200161071e565b90565b6104ec565b3461210e5761210a6120f96120f33660046120b0565b906147c3565b6121016104e2565b918291826107e1565b0390f35b6104e8565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b61213f612113565b90565b346121725761215236600461059d565b61216e61215d612137565b6121656104e2565b91829182610caa565b0390f35b6104e8565b7f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a90565b6121a3612177565b90565b346121d6576121b636600461059d565b6121d26121c161219b565b6121c96104e2565b91829182610caa565b0390f35b6104e8565b6121e481611493565b036121eb57565b5f80fd5b905035906121fc826121db565b565b9190604083820312612226578061221a612223925f860161071e565b936020016121ef565b90565b6104ec565b612234906118a3565b9052565b60018060d01b031690565b61224c90612238565b9052565b90602080612272936122685f8201515f86019061222b565b0151910190612243565b565b9190612287905f60408501940190612250565b565b346122ba576122b66122a561229f3660046121fe565b90614831565b6122ad6104e2565b91829182612274565b0390f35b6104e8565b6122cb60425f90610e63565b90565b346122fe576122de36600461059d565b6122fa6122e96122bf565b6122f16104e2565b918291826107e1565b0390f35b6104e8565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b61232f612303565b90565b346123625761234236600461059d565b61235e61234d612327565b6123556104e2565b91829182610caa565b0390f35b6104e8565b5f80fd5b5f90565b634e487b7160e01b5f52601160045260245ffd5b61238f61239591612238565b91612238565b019060018060d01b0382116123a657565b61236f565b906123be916123b861236b565b50612383565b90565b6123cd6123d391612238565b91612238565b90039060018060d01b0382116123e557565b61236f565b906123fd916123f761236b565b506123c1565b90565b5f90565b61240c612400565b5080612427612421637965db0b60e01b6104f4565b916104f4565b14908115612434575b5090565b61243e9150614847565b5f612430565b606090565b60209181520190565b5f5260205f2090565b905f929180549061247561246e83610ab1565b8094612449565b916001811690815f146124cc5750600114612490575b505050565b61249d9192939450612452565b915f925b8184106124b457505001905f808061248b565b600181602092959395548486015201910192906124a1565b92949550505060ff19168252151560200201905f808061248b565b906124f19161245b565b90565b9061251461250d926125046104e2565b938480926124e7565b0383610b9a565b565b61251f906124f4565b90565b61252a612444565b506125356003612516565b90565b5f90565b606090565b61254d61255291611058565b611b9a565b90565b61255f9054612541565b90565b61256b90610bc3565b90565b612576612538565b5061257f61253c565b5061258a6043612555565b906125956044612562565b90565b6125b5916125a4612400565b506125ad61486d565b91909161487a565b600190565b5f90565b5f6125d66125dc926125ce6125ba565b50600c611042565b01611071565b90565b906125f9916125f46125ef612303565b61488a565b612859565b565b5090565b601f602091010490565b1b90565b919060086126289102916126225f1984612609565b92612609565b9181191691161790565b61264661264161264b9261072d565b61100b565b61072d565b90565b90565b919061266761266261266f93612632565b61264e565b90835461260d565b9055565b6126859161267f6125ba565b91612651565b565b5b818110612693575050565b806126a05f600193612673565b01612688565b9190601f81116126b6575b505050565b6126c26126e793610ae4565b9060206126ce846125ff565b830193106126ef575b6126e0906125ff565b0190612687565b5f80806126b1565b91506126e0819290506126d7565b9061270d905f199060080261094d565b191690565b8161271c916126fd565b906002021790565b9161272f90826125fb565b9067ffffffffffffffff82116127ee576127538261274d8554610ab1565b856126a6565b5f90601f831160011461278657918091612775935f9261277a575b5050612712565b90555b565b90915001355f8061276e565b601f1983169161279585610ae4565b925f5b8181106127d6575091600293918560019694106127bc575b50505002019055612778565b6127cc910135601f8416906126fd565b90555f80806127b0565b91936020600181928787013581550195019201612798565b610b86565b906127fe9291612724565b565b90825f939282370152565b91906128258161281e8161282a95610674565b8095612800565b6105c4565b0190565b91612848612856949260408501908582035f87015261067d565b92602081850391015261280b565b90565b906128646044612562565b61287183839060446127f3565b9190916128aa7fb9a2088426f03b30a81c06428094fbfa9e2692739b3241af6b9ab1da4b5546be936128a16104e2565b9384938461282e565b0390a1565b906128b9916125df565b565b6128c36125ba565b506128ce6002611071565b90565b6128e16128dc612113565b61488a565b6128e96129aa565b565b6128ff6128fa61290492611b2a565b61100b565b61072d565b90565b61291b61291661292092611b2a565b61100b565b61064c565b90565b61292c90612907565b90565b9061293b60ff91611b2d565b9181191691161790565b61294e90610541565b90565b90565b9061296961296461297092612945565b612951565b825461292f565b9055565b906129805f1991611b2d565b9181191691161790565b9061299f61299a6129a692612632565b61264e565b8254612974565b9055565b6129b46040611071565b6129c66129c05f6128eb565b9161072d565b03612a63576129d56043612555565b6129ef6129e96129e45f612923565b610657565b91610657565b14612a4757612a006001603f612954565b612a0b42604061298a565b42612a427f1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a322034116091612a396104e2565b918291826107e1565b0390a1565b5f633b0a48bd60e11b815280612a5f600482016108ac565b0390fd5b5f6338e93dbd60e11b815280612a7b600482016108ac565b0390fd5b612a876128d1565b565b91612ab392612a96612400565b50612aab612aa261486d565b829084916148de565b91909161496a565b600190565b612ac19061102a565b90565b5f80fd5b60e01b90565b90505190612adb82610730565b565b90602082820312612af657612af3915f01612ace565b90565b6104ec565b612b036104e2565b3d5f823e3d90fd5b612b1a612b209193929361072d565b9261072d565b8203918211612b2b57565b61236f565b90565b612b47612b42612b4c92612b30565b61100b565b61072d565b90565b612b5e612b649193929361072d565b9261072d565b91612b7083820261072d565b928184041490151715612b7f57565b61236f565b634e487b7160e01b5f52601260045260245ffd5b612ba4612baa9161072d565b9161072d565b908115612bb5570490565b612b84565b612bc26125ba565b91612bcb6125ba565b91612be25f612bdc600c8490611042565b01611071565b90612bfa6002612bf4600c8490611042565b01611071565b91612c336020612c0930612ab8565b63651fd26890612c288692612c1c6104e2565b95869485938493612ac8565b8352600483016111fe565b03915afa908115612d8c57612c7e916020915f91612d5f575b5093612c5730612ab8565b612c7363998955d3612c676104e2565b95869485938493612ac8565b8352600483016111fe565b03915afa908115612d5a575f91612d2c575b509181612ca5612c9f5f6128eb565b9161072d565b11612cfb575b505081612cc0612cba5f6128eb565b9161072d565b11612cca575b5050565b612cf3929350612cdd612cee9183612b0b565b612ce8612710612b33565b90612b4f565b612b98565b905f80612cc6565b612d24929650612d0e612d1f9183612b0b565b612d19612710612b33565b90612b4f565b612b98565b935f80612cab565b612d4d915060203d8111612d53575b612d458183610b9a565b810190612add565b5f612c90565b503d612d3b565b612afb565b612d7f9150823d8111612d85575b612d778183610b9a565b810190612add565b5f612c4c565b503d612d6d565b612afb565b5f90565b612d9e90610c59565b90565b90612dab90612d95565b5f5260205260405f2090565b90565b612dc6612dcb91611058565b612db7565b90565b612dd89054612dba565b90565b6001612df4612dfa92612dec612d91565b506005612da1565b01612dce565b90565b612e05614a07565b612e0d612f63565b565b612e1b612e2091611058565b610951565b90565b612e2d9054612e0f565b90565b6001612e3c910161072d565b90565b612e4e612e549193929361072d565b9261072d565b8201809211612e5f57565b61236f565b612e6d9061102a565b90565b612e799061100e565b90565b612e8590612e70565b90565b612e919061102a565b90565b5f910312612e9e57565b6104ec565b905f9291805490612ebd612eb683610ab1565b8094610674565b916001811690815f14612f145750600114612ed8575b505050565b612ee59192939450610ae4565b915f925b818410612efc57505001905f8080612ed3565b60018160209295939554848601520191019290612ee9565b92949550505060ff19168252151560200201905f8080612ed3565b612f53612f60949293612f4960608401955f850190610663565b60208301906107d4565b6040818403910152612ea3565b90565b612f76612f70603f612e23565b15610541565b61329657612f82614033565b61327a57612fab612f9d42612f976040611071565b90612b0b565b612fa5611c96565b90612b98565b80612fc7612fc1612fbc6041611071565b61072d565b9161072d565b111561325e57612fe190612fdb6041611071565b90612b0b565b908161300f613009613004612ff4611304565b612ffe6041611071565b90612b0b565b61072d565b9161072d565b1161323b575b61301e5f6128eb565b906130285f6128eb565b915b8261303d6130378661072d565b9161072d565b10156130845761307861307e9161307261306c600f61306661305f6041611071565b8990612e3f565b90610e20565b90610e63565b90612e3f565b92612e30565b9161302a565b91509161309b6130946042611071565b8390612e3f565b6130b46130ae6130a96113d8565b61072d565b9161072d565b1161321f576130cf6130d6916130ca6041611071565b612e3f565b604161298a565b6130f36130ec826130e76042611071565b612e3f565b604261298a565b6131066130ff30612e64565b8290614a31565b61312361311230612e64565b61311c6043612555565b839161487a565b61313d6131386131336043612555565b612e7c565b612e88565b6318b68b8c61314b30612e64565b8392604492813b1561321a575f6131759161318082966131696104e2565b98899788968795612ac8565b855260048501612f2f565b03925af18015613215576131e9575b5061319a6041611071565b906131a45f612923565b906131cf7f34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb92611036565b926131e46131db6104e2565b92839283610a31565b0390a2565b613208905f3d811161320e575b6132008183610b9a565b810190612e94565b5f61318f565b503d6131f6565b612afb565b612ac4565b5f6323064ebd60e01b815280613237600482016108ac565b0390fd5b9050613258613248611304565b6132526041611071565b90612b0b565b90613015565b5f63e085d22b60e01b815280613276600482016108ac565b0390fd5b5f631155624b60e21b815280613292600482016108ac565b0390fd5b5f6319afc99d60e21b8152806132ae600482016108ac565b0390fd5b6132ba612dfd565b565b906132d7916132d26132cd82612ddb565b61488a565b6132d9565b565b906132e391614a8f565b50565b906132f0916132bc565b565b5f90565b90565b61330d613308613312926132f6565b61100b565b610d88565b90565b61331d6132f2565b5061332860126132f9565b90565b61333b613336612113565b61488a565b613343613345565b565b61334f6040611071565b61336161335b5f6128eb565b9161072d565b146133aa576133726001603f612954565b7f4a792a0be42b5672faa40129fc6469072490775ca8d3c34e852d4d55d3a735a961339b6104e2565b806133a5816108ac565b0390a1565b5f638f98404160e01b8152806133c2600482016108ac565b0390fd5b6133ce61332b565b565b6133d8612d91565b506133e1614b3b565b90565b90806133ff6133f96133f461486d565b610657565b91610657565b036134105761340d91614bf5565b50565b5f63334bd91960e11b815280613428600482016108ac565b0390fd5b9061343690611036565b5f5260205260405f2090565b90565b61345961345461345e92612238565b61100b565b61072d565b90565b6134989161348d6134876134826134939461347a6125ba565b50600a61342c565b613442565b91614cd6565b90614dcc565b613445565b90565b6134ab6134a6611b4e565b61488a565b6134b36134b5565b565b6134bd614f53565b565b6134c761349b565b565b90816134e56134df6134da5f612923565b610657565b91610657565b146135e457806134fd6134f75f6128eb565b9161072d565b146135c85761351f613519613514600d339061142f565b612e23565b15610541565b6135ac5761352c33614f60565b613543600161353d600c3390611042565b01611071565b61355561354f8361072d565b9161072d565b106135905761358e91613589826135836001613573600c3390611042565b019161357e83611071565b612b0b565b9061298a565b614a31565b565b5f631c959ed960e21b8152806135a8600482016108ac565b0390fd5b5f634417760960e11b8152806135c4600482016108ac565b0390fd5b5f631f2a200560e01b8152806135e0600482016108ac565b0390fd5b5f63d92e233d60e01b8152806135fc600482016108ac565b0390fd5b6136086125ba565b506136246136146113d8565b61361e6042611071565b90612b0b565b90565b9061363a6136336104e2565b9283610b9a565b565b67ffffffffffffffff811161365a576136566020916105c4565b0190565b610b86565b9061367161366c8361363c565b613627565b918252565b5f7f6d6f64653d626c6f636b6e756d6265722666726f6d3d64656661756c74000000910152565b6136a7601d61365f565b906136b460208301613676565b565b6136be61369d565b90565b6136c9612444565b506136d2613bc1565b6136eb6136e56136e06150fb565b6118a3565b916118a3565b036136fb576136f86136b6565b90565b5f6301bfc1c560e61b815280613713600482016108ac565b0390fd5b9061372190611036565b5f5260205260405f2090565b6137446137499161373c612538565b506009613717565b612555565b90565b613754612400565b5061375f6040611071565b61377161376b5f6128eb565b9161072d565b1190565b6137869061378161486d565b615110565b565b613790612400565b5061379b600e612e23565b90565b6137f5906137aa6125ba565b506137c260016137bc600c8490611042565b01611071565b906137ef60046137e96137e15f6137db600c8790611042565b01611071565b93600c611042565b01611071565b9161519b565b90565b613808613803612177565b61488a565b613810613812565b565b61381d5f603f612954565b7f73a5fc60aafeec8f139af22d98e62140e2ce914d1f155c692b427757c3e4014c6138466104e2565b80613850816108ac565b0390a1565b61385d6137f8565b565b5f90565b6138759061386f61385f565b50615247565b90565b9061388290611036565b5f5260205260405f2090565b6138a46138a99161389d6125ba565b505f613878565b611071565b90565b6138c36138c8916138bb612400565b50600d61142f565b612e23565b90565b906138d4612400565b506138dd6125ba565b506138e66125ba565b506138ef6125ba565b506138f86125ba565b5061390d613908600d849061142f565b612e23565b916139245f61391e600c8490611042565b01611071565b9161393c6002613936600c8590611042565b01611071565b90613975602061394b30612ab8565b63651fd2689061396a879261395e6104e2565b95869485938493612ac8565b8352600483016111fe565b03915afa908115613a36576139c0916020915f91613a09575b509461399930612ab8565b6139b563998955d36139a96104e2565b95869485938493612ac8565b8352600483016111fe565b03915afa908115613a04575f916139d6575b5090565b6139f7915060203d81116139fd575b6139ef8183610b9a565b810190612add565b5f6139d2565b503d6139e5565b612afb565b613a299150823d8111613a2f575b613a218183610b9a565b810190612add565b5f61398e565b503d613a17565b612afb565b613a4d90613a476125ba565b50615276565b90565b613a60613a5b612177565b61488a565b613a68613a6a565b565b613a726152ec565b565b613a7c613a50565b565b5f90565b606090565b613a909061102a565b90565b67ffffffffffffffff8111613aab5760208091020190565b610b86565b90613ac2613abd83613a93565b613627565b918252565b369037565b90613af1613ad983613ab0565b92602080613ae78693613a93565b9201910390613ac7565b565b600f60f81b90565b613b03613a7e565b50613b0c612444565b50613b15612444565b50613b1e6125ba565b50613b27612538565b50613b30612d91565b50613b39613a82565b50613b426152f9565b90613b4b615339565b904690613b5730613a87565b90613b615f611b32565b90613b73613b6e5f6128eb565b613acc565b90613b7c613af3565b96959493929190565b613b8d6125ba565b50613b85565b613bba915f613baf613bb593613ba7612400565b506005612da1565b0161142f565b612e23565b90565b5f90565b613bc9613bbd565b50613bd26150fb565b90565b613bdd612444565b50613be86004612516565b90565b613c4390613bf76125ba565b50613c0f6003613c09600c8490611042565b01611071565b90613c3d6004613c37613c2f6002613c29600c8790611042565b01611071565b93600c611042565b01611071565b9161519b565b90565b613c6d613c68613c63613c7293613c5b6125ba565b50600a61342c565b613442565b615379565b613445565b90565b9081613c91613c8b613c865f612923565b610657565b91610657565b14613d905780613ca9613ca35f6128eb565b9161072d565b14613d7457613ccb613cc5613cc0600d339061142f565b612e23565b15610541565b613d5857613cd833614f60565b613cef6003613ce9600c3390611042565b01611071565b613d01613cfb8361072d565b9161072d565b10613d3c57613d3a91613d3582613d2f6003613d1f600c3390611042565b0191613d2a83611071565b612b0b565b9061298a565b6153ee565b565b5f631c959ed960e21b815280613d54600482016108ac565b0390fd5b5f634417760960e11b815280613d70600482016108ac565b0390fd5b5f631f2a200560e01b815280613d8c600482016108ac565b0390fd5b5f63d92e233d60e01b815280613da8600482016108ac565b0390fd5b90613dc79291613dc2613dbd612303565b61488a565b613dc9565b565b80613de4613dde613dd95f612923565b610657565b91610657565b1461400a57613e06613e00613dfb600d849061142f565b612e23565b15610541565b80613fcf575b613f73575b81613e24613e1e5f6128eb565b9161072d565b1480613f59575b80613f3f575b613ee4575b613e3f81614f60565b613e56825f613e50600c8590611042565b0161298a565b613e6e836002613e68600c8590611042565b0161298a565b613e86826001613e80600c8590611042565b0161298a565b613e9e836003613e98600c8590611042565b0161298a565b9091613eca7faa807d0abf30d91968c7478c66b6d82521a106af13eda036e2036da9af16895892611036565b92613edf613ed66104e2565b92839283610a31565b0390a2565b613ef95f613ef4600d849061142f565b612954565b80613f247f02c2f0ba15b03f88b18f4832609a18cf35fc6b3f4546a9992076d7453d1334a891611036565b90613f2d6104e2565b80613f37816108ac565b0390a2613e36565b50613f54613f4f600d839061142f565b612e23565b613e31565b5082613f6d613f675f6128eb565b9161072d565b14613e2b565b613f896001613f84600d849061142f565b612954565b80613fb47f6cf28439a2daab1b265097227212a5b71e0a76f9ed85e3f815b5a6c3e218eb7f91611036565b90613fbd6104e2565b80613fc7816108ac565b0390a2613e11565b5081613fe3613fdd5f6128eb565b9161072d565b118015613ff0575b613e0c565b5082614004613ffe5f6128eb565b9161072d565b11613feb565b5f63d92e233d60e01b815280614022600482016108ac565b0390fd5b906140319291613dac565b565b61403b612400565b506140466041611071565b61405f614059614054611304565b61072d565b9161072d565b101590565b61407d90614078614073612303565b61488a565b6140bd565b565b9061409060018060a01b0391611b2d565b9181191691161790565b90565b906140b26140ad6140b992611036565b61409a565b825461407f565b9055565b806140d86140d26140cd5f612923565b610657565b91610657565b1461413e576140e76043612555565b6140f282604361409d565b906141266141207f07015b6a9f05913148fd5faddf2acc9708f305937f3072ca2b4b46faa5d0898b93611036565b91611036565b9161412f6104e2565b80614139816108ac565b0390a3565b5f63d92e233d60e01b815280614156600482016108ac565b0390fd5b61416390614064565b565b61418291614171612400565b5061417a61486d565b91909161496a565b600190565b67ffffffffffffffff811161419c5760200290565b610b86565b6141ad6141b291614187565b613627565b90565b906141d36141c2836141a1565b926141cd8491614187565b90613ac7565b565b6141df60306141b5565b90565b905090565b6141f1905461105d565b90565b60010190565b61421661421061420983610e17565b80946141e2565b91610e1d565b5f915b8383106142265750505050565b61424361423d600192614238856141e7565b6116c5565b926141f4565b92019190614219565b9061425a81610600936141fa565b0190565b9061427e6142779261426e6104e2565b9384809261424c565b0383610b9a565b565b6142899061425e565b90565b6142946141d5565b5061429f600f614280565b90565b906142b5916142af6125ba565b50613461565b90565b90565b6142cf6142ca6142d4926142b8565b61100b565b61072d565b90565b6142df6125ba565b506142e86125ba565b506142f16125ba565b506142fa612400565b506143056040611071565b6143176143115f6128eb565b9161072d565b14614456576143416143334261432d6040611071565b90612b0b565b61433b611c96565b90612b98565b9061438361434f6040611071565b61437d61436f61435f6041611071565b61436960016142bb565b90612e3f565b614377611c96565b90612b4f565b90612e3f565b61438d6041611071565b6143a66143a061439b611304565b61072d565b9161072d565b105f14614448576143cb6143c5600f6143bf6041611071565b90610e20565b90610e63565b5b926143d7603f612e23565b9081614424575b50806143fa575b916143f06041611071565b9193929193929190565b506144056041611071565b61441e614418614413611304565b61072d565b9161072d565b106143e5565b905061444161443b6144366041611071565b61072d565b9161072d565b115f6143de565b6144515f6128eb565b6143cc565b5f905f915f9161447861447261446c5f946128eb565b956128eb565b936128eb565b9190565b61448e906144886125ba565b50613c46565b90565b6144996125ba565b506144a26128bb565b90565b60026144be6144c4926144b66125ba565b50600c611042565b01611071565b90565b7fe48329057bfd03d55e49b547132e39cffd9c1820ad7b9d4c5307691425d15adf90565b6145206145279461451660609498979561450c608086019a5f870190610c9d565b6020850190610663565b60408301906107d4565b01906107d4565b565b60200190565b93959490929195426145496145438961072d565b9161072d565b116145c257916145b4916145bb936145ab6145c0989961459361456a6144c7565b6145848b938b6145786104e2565b958694602086016144eb565b60208201810382520382610b9a565b6145a561459f82610670565b91614529565b2061544d565b9290919261546a565b91826154b4565b615110565b565b6145dd875f918291632341d78760e11b8352600483016107e1565b0390fd5b7f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c990565b919461464d6146579298979561464360a09661463961465e9a61462f60c08a019e5f8b0190610c9d565b6020890190610663565b6040870190610663565b60608501906107d4565b60808301906107d4565b01906107d4565b565b91602061468192949361467a60408201965f830190610663565b0190610663565b565b96959193929490944261469e6146988361072d565b9161072d565b1161475857906147076147109493926146ef6146b86145e1565b6146e08c80948c916146ca8d916154f7565b91926146d46104e2565b97889660208801614605565b60208201810382520382610b9a565b6147016146fb82610670565b91614529565b2061544d565b9290919261546a565b8061472361471d87610657565b91610657565b036147385750614736929391909161487a565b565b84906147545f9283926325c0072360e11b845260048401614660565b0390fd5b614773905f91829163313c898160e11b8352600483016107e1565b0390fd5b906147929161478d61478882612ddb565b61488a565b614794565b565b9061479e91614bf5565b50565b906147ab91614777565b565b906147b790611036565b5f5260205260405f2090565b6147e8916147de6147e3926147d66125ba565b5060016147ad565b613878565b611071565b90565b6147f56040613627565b90565b5f90565b5f90565b6148086147eb565b90602080836148156147f8565b8152016148206147fc565b81525050565b61482e614800565b90565b906148449161483e614826565b5061552a565b90565b61484f612400565b506148696148636301ffc9a760e01b6104f4565b916104f4565b1490565b614875612538565b503390565b916148889291600192615552565b565b61489c9061489661486d565b90615684565b565b6040906148c76148ce94969593966148bd60608401985f850190610663565b60208301906107d4565b01906107d4565b565b906148db910361072d565b90565b9291926148ec8183906147c3565b90816149016148fb5f1961072d565b9161072d565b1061490e575b5050509050565b8161492161491b8761072d565b9161072d565b106149475761493e93946149369193926148d0565b905f92615552565b805f8080614907565b50614966849291925f938493637dc7a0d960e11b85526004850161489e565b0390fd5b918261498661498061497b5f612923565b610657565b91610657565b146149e057816149a66149a061499b5f612923565b610657565b91610657565b146149b9576149b7929190916156bf565b565b6149dc6149c55f612923565b5f91829163ec442f0560e01b8352600483016111fe565b0390fd5b614a036149ec5f612923565b5f918291634b637e8f60e11b8352600483016111fe565b0390fd5b614a0f613788565b614a1557565b5f63d93c066560e01b815280614a2d600482016108ac565b0390fd5b80614a4c614a46614a415f612923565b610657565b91610657565b14614a6857614a6691614a5e5f612923565b9190916156bf565b565b614a8b614a745f612923565b5f91829163ec442f0560e01b8352600483016111fe565b0390fd5b614a97612400565b50614aac614aa6828490613b93565b15610541565b5f14614b3557614ad46001614acf5f614ac760058690612da1565b01859061142f565b612954565b90614add61486d565b90614b1a614b14614b0e7f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d95612d95565b92611036565b92611036565b92614b236104e2565b80614b2d816108ac565b0390a4600190565b50505f90565b614b43612d91565b50614b4d30613a87565b614b7f614b797f0000000000000000000000000000000000000000000000000000000000000000610657565b91610657565b1480614bbb575b5f14614bb0577f000000000000000000000000000000000000000000000000000000000000000090565b614bb861573f565b90565b5046614bef614be97f000000000000000000000000000000000000000000000000000000000000000061072d565b9161072d565b14614b86565b614bfd612400565b50614c09818390613b93565b5f14614c9157614c305f614c2b5f614c2360058690612da1565b01859061142f565b612954565b90614c3961486d565b90614c76614c70614c6a7ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b95612d95565b92611036565b92611036565b92614c7f6104e2565b80614c89816108ac565b0390a4600190565b50505f90565b614cab614ca6614cb0926118a3565b61100b565b61072d565b90565b916020614cd4929493614ccd60408201965f8301906107d4565b01906118ae565b565b614cde613bbd565b50614ce7613bc1565b81614cfa614cf483614c97565b9161072d565b1015614d0d5750614d0a90615845565b90565b90614d285f928392637669fc0f60e11b845260048401614cb3565b0390fd5b5490565b90565b614d47614d42614d4c92614d30565b61100b565b61072d565b90565b90565b65ffffffffffff1690565b614d69614d6e91611058565b614d52565b90565b614d7b9054614d5d565b90565b60301c90565b60018060d01b031690565b614d9b614da091614d7e565b614d84565b90565b614dad9054614d8f565b90565b614dc4614dbf614dc992611b2a565b61100b565b612238565b90565b90614e2090614dd961236b565b50614de55f8401614d2c565b614dee5f6128eb565b908080614e04614dfe6005614d33565b9161072d565b11614e81575b5090614e1b5f860193919293614d4f565b615e80565b80614e33614e2d5f6128eb565b9161072d565b145f14614e49575050614e455f614db0565b5b90565b614e765f91614e71614e6b84614e7c960192614e6560016142bb565b90612b0b565b91614d4f565b615e76565b01614da3565b614e46565b80614e8f614e959291615b0b565b90612b0b565b9083614ec7614ec1614ebc5f614eb6818c01614eb18991614d4f565b615e76565b01614d71565b6118a3565b916118a3565b105f14614ed85750905b905f614e0a565b9150614eee90614ee860016142bb565b90612e3f565b614ed1565b614efb615f0f565b614f03614f05565b565b614f105f600e612954565b614f1861486d565b614f4e7f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa91614f456104e2565b918291826111fe565b0390a1565b614f5b614ef3565b565b90565b614f6e614f7391600c611042565b614f5d565b614f7f60048201611071565b614f91614f8b5f6128eb565b9161072d565b146150eb5761500d90614fb042614faa60048401611071565b90612b0b565b80614fca614fc4614fbf611959565b61072d565b9161072d565b10155f1461500f5750614fea614fe15f8301611071565b6001830161298a565b615002614ff960028301611071565b6003830161298a565b5b600442910161298a565b565b8061502261501c5f6128eb565b9161072d565b1161502e575b50615003565b6150dc6150ca6150e5926150b96150b061509f61508d61507f61506d61505f6150585f8d01611071565b8890612b4f565b615067611959565b90612b98565b9561507a60028c01611071565b612b4f565b615087611959565b90612b98565b9361509a60018a01611071565b612e3f565b6150aa5f8901611071565b90615f42565b6001870161298a565b6150c560038601611071565b612e3f565b6150d660028501611071565b90615f42565b6003830161298a565b5f615028565b6150f990600442910161298a565b565b615103613bbd565b5061510d43615845565b90565b90615199916151936151218261372d565b6151368461513160098690613717565b61409d565b8281859061517661517061516a7f3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f95611036565b92611036565b92611036565b9261517f6104e2565b80615189816108ac565b0390a49291615f72565b91615f8a565b565b90916151a56125ba565b50806151b96151b35f6128eb565b9161072d565b14615238576151c89042612b0b565b90816151e36151dd6151d8611959565b61072d565b9161072d565b1015615233576152076151f961520d9385612b4f565b615201611959565b90612b98565b90612e3f565b8061522061521a8461072d565b9161072d565b115f1461522c57505b90565b9050615229565b505090565b5050506152445f6128eb565b90565b61526e6152696152646152739361525c61385f565b50600a61342c565b613442565b616138565b6161b7565b90565b615288906152826125ba565b50616208565b90565b615293614a07565b61529b61529d565b565b6152a96001600e612954565b6152b161486d565b6152e77f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258916152de6104e2565b918291826111fe565b0390a1565b6152f461528b565b565b90565b615301612444565b506153367f000000000000000000000000000000000000000000000000000000000000000061533060066152f6565b90616323565b90565b615341612444565b506153767f000000000000000000000000000000000000000000000000000000000000000061537060076152f6565b90616323565b90565b61538161236b565b5061538d5f8201614d2c565b806153a061539a5f6128eb565b9161072d565b145f146153b65750506153b25f614db0565b5b90565b6153e35f916153de6153d8846153e99601926153d260016142bb565b90612b0b565b91614d4f565b615e76565b01614da3565b6153b3565b908161540a6154046153ff5f612923565b610657565b91610657565b1461542657615424919061541d5f612923565b90916156bf565b565b6154496154325f612923565b5f918291634b637e8f60e11b8352600483016111fe565b0390fd5b61546790615459612d91565b50615462614b3b565b616371565b90565b926154859261548e9461547b612538565b5092909192616427565b90929192616552565b90565b9160206154b29294936154ab60408201965f830190610663565b01906107d4565b565b6154bd816154f7565b916154d06154ca8461072d565b9161072d565b036154d9575050565b6154f35f9283926301d4b62360e61b845260048401615491565b0390fd5b61550b906155036125ba565b506008613878565b61552761551782611071565b9161552183612e30565b9061298a565b90565b9061554a61554561554f9361553d614826565b50600a61342c565b613442565b6166b4565b90565b90928161556f6155696155645f612923565b610657565b91610657565b1461563a578361558f6155896155845f612923565b610657565b91610657565b14615613576155b3836155ae6155a7600186906147ad565b8790613878565b61298a565b6155bd575b505050565b9190916156086155f66155f07f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92593611036565b93611036565b936155ff6104e2565b918291826107e1565b0390a35f80806155b8565b61563661561f5f612923565b5f918291634a1406b160e11b8352600483016111fe565b0390fd5b61565d6156465f612923565b5f91829163e602df0560e01b8352600483016111fe565b0390fd5b91602061568292949361567b60408201965f830190610663565b0190610c9d565b565b90615699615693838390613b93565b15610541565b6156a1575050565b6156bb5f92839263e2517d3f60e01b845260048401615661565b0390fd5b916156cc929190916166d5565b565b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b9095949261573d9461572c6157369261572260809661571860a088019c5f890190610c9d565b6020870190610c9d565b6040850190610c9d565b60608301906107d4565b0190610663565b565b615747612d91565b506157506156ce565b6157c77f0000000000000000000000000000000000000000000000000000000000000000916157b87f0000000000000000000000000000000000000000000000000000000000000000466157a330613a87565b916157ac6104e2565b968795602087016156f2565b60208201810382520382610b9a565b6157d96157d382610670565b91614529565b2090565b6157f16157ec6157f6926112e5565b61100b565b610d88565b90565b615802906157dd565b9052565b91602061582792949361582060408201965f8301906157f9565b01906107d4565b565b61583d6158386158429261072d565b61100b565b6118a3565b90565b61584d613bbd565b508061586761586165ffffffffffff614c97565b9161072d565b116158785761587590615829565b90565b60306158945f9283926306dfcc6560e41b845260048401615806565b0390fd5b90565b6158af6158aa6158b492615898565b61100b565b61072d565b90565b90565b6158ce6158c96158d3926158b7565b61100b565b610d88565b90565b6158f5906158ef6158e96158fa94610d88565b9161072d565b9061094d565b61072d565b90565b90565b61591461590f615919926158fd565b61100b565b610d88565b90565b61593b9061593561592f61594094610d88565b9161072d565b90612609565b61072d565b90565b90565b61595a61595561595f92615943565b61100b565b61072d565b90565b90565b61597961597461597e92615962565b61100b565b610d88565b90565b90565b61599861599361599d92615981565b61100b565b61072d565b90565b90565b6159b76159b26159bc926159a0565b61100b565b610d88565b90565b90565b6159d66159d16159db926159bf565b61100b565b61072d565b90565b90565b6159f56159f06159fa926159de565b61100b565b610d88565b90565b90565b615a14615a0f615a19926159fd565b61100b565b61072d565b90565b90565b615a33615a2e615a3892615a1c565b61100b565b610d88565b90565b615a4f615a4a615a54926159a0565b61100b565b61072d565b90565b90565b615a6e615a69615a7392615a57565b61100b565b610d88565b90565b615a8a615a85615a8f92615a1c565b61100b565b61072d565b90565b615aa6615aa1615aab926142b8565b61100b565b610d88565b90565b90565b615ac5615ac0615aca92615aae565b61100b565b61072d565b90565b90615ad8910261072d565b90565b615ae7615aed9161072d565b9161072d565b908115615af8570490565b612b84565b90615b08910161072d565b90565b615b136125ba565b5080615b28615b2260016142bb565b9161072d565b1115615e735780615d3d615d1a615d0a615cfa615cea615cda615cca615cba615caa615c9a615c8a8b615c84615c7d615d439f615c5d615c4d615c6d92615b6f60016142bb565b9080615b87615b81600160801b61589b565b9161072d565b1015615e45575b80615baa615ba468010000000000000000615946565b9161072d565b1015615e17575b80615bc9615bc3640100000000615984565b9161072d565b1015615de9575b80615be6615be0620100006159c2565b9161072d565b1015615dbb575b80615c02615bfc610100615a00565b9161072d565b1015615d8d575b80615c1d615c176010615a3b565b9161072d565b1015615d5f575b615c37615c316004615a76565b9161072d565b1015615d46575b615c486003615ab1565b615acd565b615c576001615a92565b906158d6565b615c678186615adb565b90615afd565b615c776001615a92565b906158d6565b8092615adb565b90615afd565b615c946001615a92565b906158d6565b615ca4818c615adb565b90615afd565b615cb46001615a92565b906158d6565b615cc4818a615adb565b90615afd565b615cd46001615a92565b906158d6565b615ce48188615adb565b90615afd565b615cf46001615a92565b906158d6565b615d048186615adb565b90615afd565b615d146001615a92565b906158d6565b91615d37615d31615d2c858094615adb565b61072d565b9161072d565b11616765565b906148d0565b90565b615d5a90615d546001615a92565b9061591c565b615c3e565b615d76615d8791615d706004615a1f565b906158d6565b91615d816002615a5a565b9061591c565b90615c24565b615da4615db591615d9e60086159e1565b906158d6565b91615daf6004615a1f565b9061591c565b90615c09565b615dd2615de391615dcc60106159a3565b906158d6565b91615ddd60086159e1565b9061591c565b90615bed565b615e00615e1191615dfa6020615965565b906158d6565b91615e0b60106159a3565b9061591c565b90615bd0565b615e2e615e3f91615e286040615900565b906158d6565b91615e396020615965565b9061591c565b90615bb1565b615e5c615e6d91615e5660806158ba565b906158d6565b91615e676040615900565b9061591c565b90615b8e565b90565b5f5260205f200190565b93919092615e8c6125ba565b505b81615ea1615e9b8361072d565b9161072d565b1015615f0757615eb282829061678f565b90615ec85f615ec2888590615e76565b01614d71565b615eda615ed4876118a3565b916118a3565b115f14615eea5750915b91615e8e565b929150615f0190615efb60016142bb565b90612e3f565b90615ee4565b925050915090565b615f20615f1a613788565b15610541565b615f2657565b5f638dfc202b60e01b815280615f3e600482016108ac565b0390fd5b90615f4b6125ba565b5081615f5f615f598361072d565b9161072d565b105f14615f6b57505b90565b9050615f68565b615f8490615f7e6125ba565b5061388e565b90565b90565b91909180615fa0615f9a85610657565b91610657565b14158061611e575b615fb2575b505050565b80615fcd615fc7615fc25f612923565b610657565b91610657565b0361608e575b5081615fef615fe9615fe45f612923565b610657565b91610657565b03615ffb575b80615fad565b61604261603561603c92616011600a869061342c565b9061602f616029616023600193616828565b93613442565b91615f87565b9061687b565b9290613445565b91613445565b91909161606f7fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492611036565b9261608461607b6104e2565b92839283610a31565b0390a25f80615ff5565b6160cd6160d36160c66160a3600a859061342c565b60026160c06160ba6160b489616828565b93613442565b91615f87565b9061687b565b9290613445565b91613445565b9190916161007fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492611036565b9261611561610c6104e2565b92839283610a31565b0390a25f615fd3565b508161613261612c5f6128eb565b9161072d565b11615fa8565b5f61614c916161456125ba565b5001614d2c565b90565b61616361615e61616892611493565b61100b565b61072d565b90565b61617490615965565b9052565b91602061619992949361619260408201965f83019061616b565b01906107d4565b565b6161af6161aa6161b49261072d565b61100b565b611493565b90565b6161bf61385f565b50806161d76161d163ffffffff61614f565b9161072d565b116161e8576161e59061619b565b90565b60206162045f9283926306dfcc6560e41b845260048401616178565b0390fd5b61621f616224916162176125ba565b506008613878565b611071565b90565b90565b61623e61623961624392616227565b611b2d565b610c59565b90565b61625060ff61622a565b90565b5f5260205f2090565b905f929180549061627661626f83610ab1565b8094612449565b916001811690815f146162cd5750600114616291575b505050565b61629e9192939450616253565b915f925b8184106162b557505001905f808061628c565b600181602092959395548486015201910192906162a2565b92949550505060ff19168252151560200201905f808061628c565b906162f29161625c565b90565b9061631561630e926163056104e2565b938480926162e8565b0383610b9a565b565b616320906162f5565b90565b9061632c612444565b5061633682612d95565b61634f616349616344616246565b610c59565b91610c59565b14155f14616364575061636190616905565b90565b61636e9150616317565b90565b60429161637c612d91565b50604051917f19010000000000000000000000000000000000000000000000000000000000008352600283015260228201522090565b5f90565b6163c26163c791611058565b612632565b90565b90565b6163e16163dc6163e6926163ca565b61100b565b61072d565b90565b61641e6164259461641460609498979561640a608086019a5f870190610c9d565b6020850190610d8e565b6040830190610c9d565b0190610c9d565b565b939293616432612538565b5061643b6163b2565b50616444612d91565b5061644e856163b6565b61648061647a7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a06163cd565b9161072d565b1161650d57906164a3602094955f9493929361649a6104e2565b948594856163e9565b838052039060015afa15616508576164bb5f51611b2d565b806164d66164d06164cb5f612923565b610657565b91610657565b146164ec575f916164e65f611b32565b91929190565b506164f65f612923565b6001916165025f611b32565b91929190565b612afb565b5050506165195f612923565b9060039291929190565b634e487b7160e01b5f52602160045260245ffd5b6004111561654157565b616523565b9061655082616537565b565b8061656561655f5f616546565b91616546565b145f14616570575050565b8061658461657e6001616546565b91616546565b145f146165a7575f63f645eedf60e01b8152806165a3600482016108ac565b0390fd5b806165bb6165b56002616546565b91616546565b145f146165e9576165e56165ce836163b6565b5f91829163fce698f760e01b8352600483016107e1565b0390fd5b6165fc6165f66003616546565b91616546565b146166045750565b61661f905f9182916335e2f38360e21b835260048301610caa565b0390fd5b5f5260205f2090565b61663581614d2c565b82101561664f57616647600191616623565b910201905f90565b610e03565b9061665e906118a3565b9052565b9061666c90612238565b9052565b906166a661669d5f6166806147eb565b9461669761668f838301614d71565b838801616654565b01614da3565b60208401616662565b565b6166b190616670565b90565b6166d2915f6166cc926166c5614826565b500161662c565b506166a8565b90565b92916166e384838391616935565b836166fe6166f86166f35f612923565b610657565b91610657565b14616713575b6167119293919091616abf565b565b61671b6128bb565b93616724616aa4565b94806167386167328861072d565b9161072d565b1161674557509350616704565b85906167615f928392630e58ae9360e11b845260048401610a31565b0390fd5b61676d6125ba565b50151590565b61678761678261678c92615a57565b61100b565b61072d565b90565b6167b46167ba9261679e6125ba565b5082811692186167ae6002616773565b90612b98565b90612e3f565b90565b90565b6167d46167cf6167d9926167bd565b61100b565b610d88565b90565b6167e5906167c0565b9052565b91602061680a92949361680360408201965f8301906167dc565b01906107d4565b565b61682061681b6168259261072d565b61100b565b612238565b90565b61683061236b565b508061684a61684460018060d01b03613445565b9161072d565b1161685b576168589061680c565b90565b60d06168775f9283926306dfcc6560e41b8452600484016167e9565b0390fd5b906168b16168b7939261688c61236b565b5061689561236b565b5080936168aa6168a3613bc1565b9492615379565b9091616f27565b91616b7e565b91909190565b6168d16168cc6168d692615962565b61100b565b61072d565b90565b369037565b906169036168eb8361365f565b926020806168f9869361363c565b92019103906168d9565b565b61690d612444565b5061691781616be8565b9061692a61692560206168bd565b6168de565b918252602082015290565b9190918061695361694d6169485f612923565b610657565b91610657565b145f14616a34576169776169708361696b6002611071565b612e3f565b600261298a565b5b8261699361698d6169885f612923565b610657565b91610657565b145f14616a08576169b76169b0836169ab6002611071565b6148d0565b600261298a565b5b919091616a036169f16169eb7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef93611036565b93611036565b936169fa6104e2565b918291826107e1565b0390a3565b616a2f82616a29616a1a5f8790613878565b91616a2483611071565b615afd565b9061298a565b6169b8565b616a47616a425f8390613878565b611071565b80616a5a616a548561072d565b9161072d565b10616a8257616a6d616a7d9184906148d0565b616a785f8490613878565b61298a565b616978565b90616aa09091925f93849363391434e360e21b85526004850161489e565b0390fd5b616aac6125ba565b50616abc60018060d01b03613445565b90565b91616b17616b11616b1e9480616ae5616adf616ada5f612923565b610657565b91610657565b14616b4f575b84616b06616b00616afb5f612923565b610657565b91610657565b14616b20575b61372d565b9261372d565b9091615f8a565b565b616b48600b6002616b42616b3c616b3689616828565b93613442565b91615f87565b9061687b565b5050616b0c565b616b77600b6001616b71616b6b616b6589616828565b93613442565b91615f87565b9061687b565b5050616aeb565b91616ba25f616ba794616b8f61236b565b50616b9861236b565b5001929192614d4f565b616dd9565b91909190565b616bc1616bbc616bc692616227565b61100b565b61072d565b90565b90565b616be0616bdb616be592616bc9565b61100b565b61072d565b90565b616bfd616c0291616bf76125ba565b50612d95565b6163b6565b616c0c60ff616bad565b1680616c21616c1b601f616bcc565b9161072d565b11616c295790565b5f632cd44ac360e21b815280616c41600482016108ac565b0390fd5b5490565b616c536040613627565b90565b5f5260205f2090565b616c6881616c45565b821015616c8257616c7a600191616c56565b910201905f90565b610e03565b616c9190516118a3565b90565b90616ca565ffffffffffff91611b2d565b9181191691161790565b616cc3616cbe616cc8926118a3565b61100b565b6118a3565b90565b90565b90616ce3616cde616cea92616caf565b616ccb565b8254616c94565b9055565b616cf89051612238565b90565b60301b90565b90616d1365ffffffffffff1991616cfb565b9181191691161790565b616d31616d2c616d3692612238565b61100b565b612238565b90565b90565b90616d51616d4c616d5892616d1d565b616d39565b8254616d01565b9055565b90616d8660205f616d8c94616d7e828201616d78848801616c87565b90616cce565b019201616cee565b90616d3c565b565b9190616d9f57616d9d91616d5c565b565b610a8a565b9081549168010000000000000000831015616dd45782616dcc916001616dd295018155616c5f565b90616d8e565b565b610b86565b90929192616de561236b565b50616dee61236b565b50616df882616c45565b80616e0b616e055f6128eb565b9161072d565b115f14616edb57616e3190616e2b8491616e2560016142bb565b90612b0b565b90615e76565b90616e3d5f8301614d71565b92616e495f8401614da3565b9380616e5d616e57856118a3565b916118a3565b11616ebf57616e74616e6e846118a3565b916118a3565b145f14616e8f575050616e8a905f859101616d3c565b5b9190565b616eba9250616eb586616eac616ea3616c49565b945f8601616654565b60208401616662565b616da4565b616e8b565b5f632520601d60e01b815280616ed7600482016108ac565b0390fd5b50616f0691616f0185616ef8616eef616c49565b945f8601616654565b60208401616662565b616da4565b616f0f5f614db0565b9190565b634e487b7160e01b5f52605160045260245ffd5b91909180600114616f4657600203616f1357616f42916123ea565b905b565b50616f50916123ab565b90616f4456
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x01``@R4a\0vWa\0\x1Ea\0\x15a\x01cV[\x92\x91\x90\x91a\x03]V[a\0&a\0{V[aoVa \x8D\x829`\x80Q\x81aK\x8E\x01R`\xA0Q\x81aK\xC5\x01R`\xC0Q\x81aKU\x01R`\xE0Q\x81aWU\x01Ra\x01\0Q\x81aWz\x01Ra\x01 Q\x81aS\x07\x01Ra\x01@Q\x81aSG\x01RaoV\x90\xF3[a\0\x81V[`@Q\x90V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\0\xAD\x90a\0\x85V[\x81\x01\x90\x81\x10`\x01\x80`@\x1B\x03\x82\x11\x17a\0\xC5W`@RV[a\0\x8FV[\x90a\0\xDDa\0\xD6a\0{V[\x92\x83a\0\xA3V[V[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\0\xF7\x90a\0\xE3V[\x90V[a\x01\x03\x81a\0\xEEV[\x03a\x01\nWV[_\x80\xFD[\x90PQ\x90a\x01\x1B\x82a\0\xFAV[V[`\x80\x81\x83\x03\x12a\x01^Wa\x013\x82_\x83\x01a\x01\x0EV[\x92a\x01[a\x01D\x84` \x85\x01a\x01\x0EV[\x93a\x01R\x81`@\x86\x01a\x01\x0EV[\x93``\x01a\x01\x0EV[\x90V[a\0\xDFV[a\x01\x81a\x8F\xE3\x808\x03\x80a\x01v\x81a\0\xCAV[\x92\x839\x81\x01\x90a\x01\x1DV[\x90\x91\x92\x93V[`\x01\x80`@\x1B\x03\x81\x11a\x01\xA3Wa\x01\x9F` \x91a\0\x85V[\x01\x90V[a\0\x8FV[\x90a\x01\xBAa\x01\xB5\x83a\x01\x87V[a\0\xCAV[\x91\x82RV[_\x7FSyndicate\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x01\xF0`\ta\x01\xA8V[\x90a\x01\xFD` \x83\x01a\x01\xBFV[V[a\x02\x07a\x01\xE6V[\x90V[_\x7FSYND\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x02;`\x04a\x01\xA8V[\x90a\x02H` \x83\x01a\x02\nV[V[a\x02Ra\x021V[\x90V[\x90V[\x90V[a\x02oa\x02ja\x02t\x92a\x02UV[a\x02XV[a\0\xE3V[\x90V[a\x02\x80\x90a\x02[V[\x90V[_\x01\x90V[\x90V[_\x1B\x90V[a\x02\xA4a\x02\x9Fa\x02\xA9\x92a\x02UV[a\x02\x8BV[a\x02\x88V[\x90V[a\x02\xB5_a\x02\x90V[\x90V[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*\x90V[\x90V[\x90V[a\x03>a\x039a\x03C\x92a\x03$V[a\x02XV[a\x03'V[\x90V[a\x03ZjJr=\xC6\xB4\x0B\x8A\x9A\0\0\0a\x03*V[\x90V[\x90\x91\x92a\x03ya\x03ka\x01\xFFV[a\x03sa\x02JV[\x90a\x05\x16V[\x81a\x03\x94a\x03\x8Ea\x03\x89_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x04\xB0W\x82a\x03\xB4a\x03\xAEa\x03\xA9_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x04\x94W\x83a\x03\xD4a\x03\xCEa\x03\xC9_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x04xW\x80a\x03\xF4a\x03\xEEa\x03\xE9_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x04\\Wa\x045a\x04C\x92a\x04'a\x04R\x96a\x04\x19a\x04\x12a\x02\xACV[\x84\x90a\t\xB9V[Pa\x04\"a\x02\xB8V[a\t\xB9V[Pa\x040a\x02\xDCV[a\t\xB9V[Pa\x04>a\x03\0V[a\t\xB9V[Pa\x04La\x03FV[\x90a\n\x87V[a\x04Za\r\x8FV[V[_c\xD9.#=`\xE0\x1B\x81R\x80a\x04t`\x04\x82\x01a\x02\x83V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x04\x90`\x04\x82\x01a\x02\x83V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x04\xAC`\x04\x82\x01a\x02\x83V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x04\xC8`\x04\x82\x01a\x02\x83V[\x03\x90\xFD[\x90a\x04\xD8`\xFF\x91a\x02\x8BV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x15\x15\x90V[a\x04\xF0\x90a\x04\xE2V[\x90V[\x90V[\x90a\x05\x0Ba\x05\x06a\x05\x12\x92a\x04\xE7V[a\x04\xF3V[\x82Ta\x04\xCCV[\x90UV[\x90a\x05 \x91a\x05-V[a\x05+_`\x0Ea\x04\xF6V[V[a\x059\x91\x81\x90\x91a\x05;V[V[\x90a\x05F\x92\x91a\x05HV[V[\x90a\x05S\x92\x91a\x05UV[V[\x90a\x05`\x92\x91a\x05bV[V[\x90a\x05m\x92\x91a\x05oV[V[\x90a\x05z\x92\x91a\x05|V[V[\x90a\x05\x87\x92\x91a\x05\xD4V[V[_\x7F1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x05\xBA`\x01a\x01\xA8V[\x90a\x05\xC7` \x83\x01a\x05\x89V[V[a\x05\xD1a\x05\xB0V[\x90V[\x90a\x05\xE8\x92\x91a\x05\xE2a\x05\xC9V[\x90a\x05\xEAV[V[\x90a\x05\xF6\x93\x92\x91a\x06<V[V[\x90V[\x90V[` \x01\x90V[Q\x90V[a\x06\x1Ca\x06\x17a\x06!\x92a\0\xE3V[a\x02XV[a\0\xE3V[\x90V[a\x06-\x90a\x06\x08V[\x90V[a\x069\x90a\x06$V[\x90V[a\x06Ma\x06\x9D\x94a\x06\x82\x93\x94a\x06\xD1V[a\x06a\x81a\x06[`\x06a\x05\xF8V[\x90a\x0F\xB9V[a\x01 Ra\x06y\x83a\x06s`\x07a\x05\xF8V[\x90a\x0F\xB9V[a\x01@Ra\x05\xFBV[a\x06\x94a\x06\x8E\x82a\x06\x04V[\x91a\x05\xFEV[ `\xE0Ra\x05\xFBV[a\x06\xAFa\x06\xA9\x82a\x06\x04V[\x91a\x05\xFEV[ a\x01\0RF`\xA0Ra\x06\xC0a\x10\xBEV[`\x80Ra\x06\xCC0a\x060V[`\xC0RV[\x90a\x06\xDB\x91a\x06\xDDV[V[\x90a\x06\xE7\x91a\x06\xE9V[V[\x90a\x06\xF3\x91a\tYV[V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[Q\x90V[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x07@W[` \x83\x10\x14a\x07;WV[a\x07\x0CV[\x91`\x7F\x16\x91a\x070V[_R` _ \x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a\x07|\x91\x02\x91a\x07v_\x19\x84a\x07]V[\x92a\x07]V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x07\x9Aa\x07\x95a\x07\x9F\x92a\x03'V[a\x02XV[a\x03'V[\x90V[\x90V[\x91\x90a\x07\xBBa\x07\xB6a\x07\xC3\x93a\x07\x86V[a\x07\xA2V[\x90\x83Ta\x07aV[\x90UV[_\x90V[a\x07\xDD\x91a\x07\xD7a\x07\xC7V[\x91a\x07\xA5V[V[[\x81\x81\x10a\x07\xEBWPPV[\x80a\x07\xF8_`\x01\x93a\x07\xCBV[\x01a\x07\xE0V[\x91\x90`\x1F\x81\x11a\x08\x0EW[PPPV[a\x08\x1Aa\x08?\x93a\x07JV[\x90` a\x08&\x84a\x07SV[\x83\x01\x93\x10a\x08GW[a\x088\x90a\x07SV[\x01\x90a\x07\xDFV[_\x80\x80a\x08\tV[\x91Pa\x088\x81\x92\x90Pa\x08/V[\x1C\x90V[\x90a\x08i\x90_\x19\x90`\x08\x02a\x08UV[\x19\x16\x90V[\x81a\x08x\x91a\x08YV[\x90`\x02\x02\x17\x90V[\x90a\x08\x8A\x81a\x07\x08V[\x90`\x01\x80`@\x1B\x03\x82\x11a\tHWa\x08\xAC\x82a\x08\xA6\x85Ta\x07 V[\x85a\x07\xFEV[` \x90`\x1F\x83\x11`\x01\x14a\x08\xE0W\x91\x80\x91a\x08\xCF\x93_\x92a\x08\xD4W[PPa\x08nV[\x90U[V[\x90\x91P\x01Q_\x80a\x08\xC8V[`\x1F\x19\x83\x16\x91a\x08\xEF\x85a\x07JV[\x92_[\x81\x81\x10a\t0WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\t\x16W[PPP\x02\x01\x90Ua\x08\xD2V[a\t&\x91\x01Q`\x1F\x84\x16\x90a\x08YV[\x90U_\x80\x80a\t\nV[\x91\x93` `\x01\x81\x92\x87\x87\x01Q\x81U\x01\x95\x01\x92\x01a\x08\xF2V[a\0\x8FV[\x90a\tW\x91a\x08\x80V[V[\x90a\tha\to\x92`\x03a\tMV[`\x04a\tMV[V[_\x90V[a\t~\x90a\x02\x88V[\x90V[\x90a\t\x8B\x90a\tuV[_R` R`@_ \x90V[a\t\xA0\x90a\x06$V[\x90V[\x90a\t\xAD\x90a\t\x97V[_R` R`@_ \x90V[a\t\xC1a\tqV[Pa\t\xD6a\t\xD0\x82\x84\x90a\x11[V[\x15a\x04\xE2V[_\x14a\n_Wa\t\xFE`\x01a\t\xF9_a\t\xF1`\x05\x86\x90a\t\x81V[\x01\x85\x90a\t\xA3V[a\x04\xF6V[\x90a\n\x07a\x11\x89V[\x90a\nDa\n>a\n8\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\tuV[\x92a\t\x97V[\x92a\t\x97V[\x92a\nMa\0{V[\x80a\nW\x81a\x02\x83V[\x03\x90\xA4`\x01\x90V[PP_\x90V[a\nn\x90a\0\xEEV[\x90RV[\x91\x90a\n\x85\x90_` \x85\x01\x94\x01\x90a\neV[V[\x80a\n\xA2a\n\x9Ca\n\x97_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\n\xBEWa\n\xBC\x91a\n\xB4_a\x02wV[\x91\x90\x91a\x11\x96V[V[a\n\xE1a\n\xCA_a\x02wV[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\nrV[\x03\x90\xFD[`\x01\x80`@\x1B\x03\x81\x11a\n\xF8W` \x02\x90V[a\0\x8FV[a\x0B\ta\x0B\x0E\x91a\n\xE5V[a\0\xCAV[\x90V[\x90V[a\x0B(a\x0B#a\x0B-\x92a\x0B\x11V[a\x02XV[a\x03'V[\x90V[\x90a\x0B:\x90a\x03'V[\x90RV[\x90V[a\x0BUa\x0BPa\x0BZ\x92a\x0B>V[a\x02XV[a\x03'V[\x90V[\x90V[a\x0Bta\x0Boa\x0By\x92a\x0B]V[a\x02XV[a\x03'V[\x90V[\x90V[a\x0B\x93a\x0B\x8Ea\x0B\x98\x92a\x0B|V[a\x02XV[a\x03'V[\x90V[\x90V[a\x0B\xB2a\x0B\xADa\x0B\xB7\x92a\x0B\x9BV[a\x02XV[a\x03'V[\x90V[\x90V[a\x0B\xD1a\x0B\xCCa\x0B\xD6\x92a\x0B\xBAV[a\x02XV[a\x03'V[\x90V[\x90V[a\x0B\xF0a\x0B\xEBa\x0B\xF5\x92a\x0B\xD9V[a\x02XV[a\x03'V[\x90V[\x90V[a\x0C\x0Fa\x0C\na\x0C\x14\x92a\x0B\xF8V[a\x02XV[a\x03'V[\x90V[a\x0C+a\x0C&a\x0C0\x92a\x02UV[a\x02XV[a\x03'V[\x90V[`\x01a\x0C?\x91\x01a\x03'V[\x90V[\x90V[a\x0CYa\x0CTa\x0C^\x92a\x0CBV[a\x02XV[a\x03'V[\x90V[\x90V[a\x0Cxa\x0Csa\x0C}\x92a\x0CaV[a\x02XV[a\x03'V[\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x0C\xA3a\x0C\xA9\x91\x93\x92\x93a\x03'V[\x92a\x03'V[\x91a\x0C\xB5\x83\x82\x02a\x03'V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a\x0C\xC4WV[a\x0C\x80V[a\x0C\xD8a\x0C\xDE\x91\x93\x92\x93a\x03'V[\x92a\x03'V[\x82\x01\x80\x92\x11a\x0C\xE9WV[a\x0C\x80V[\x90V[a\r\x05a\r\0a\r\n\x92a\x0C\xEEV[a\x02XV[a\x03'V[\x90V[a\r\x17`0a\x0C\xF1V[\x90V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[P`\x08\x90V[\x90a\r>\x82a\r.V[\x81\x10\x15a\rLW` \x02\x01\x90V[a\r\x1AV[a\r[\x90Qa\x03'V[\x90V[P`0\x90V[\x90V[a\rp\x81a\r^V[\x82\x10\x15a\r\x8AWa\r\x82`\x01\x91a\rdV[\x91\x02\x01\x90_\x90V[a\r\x1AV[a\r\x99`\x08a\n\xFDV[a\r\xB7a\r\xAFi\x8F\x95oiz\xA4\x92<\0\0a\x0B\x14V[_\x83\x01a\x0B0V[a\r\xD6a\r\xCDiV&v\x0C\x16b\xBE$\0\0a\x0BAV[` \x83\x01a\x0B0V[a\r\xF5a\r\xECi3\xB0\xB0\0\xFE\xC5\x93\x90\0\0a\x0B`V[`@\x83\x01a\x0B0V[a\x0E\x14a\x0E\x0Bi\x1F\x03\x9C\xCDe\xA9\xBE\xF0\0\0a\x0B\x7FV[``\x83\x01a\x0B0V[a\x0E3a\x0E*i\x12\x9B\xC4{<\xFFr\x90\0\0a\x0B\x9EV[`\x80\x83\x01a\x0B0V[a\x0ERa\x0EIi\x0B*H=m\xAD\xEE\x18\0\0a\x0B\xBDV[`\xA0\x83\x01a\x0B0V[a\x0Eqa\x0Ehi\x06\xB2\xEF\xD1:\x96*l\0\0a\x0B\xDCV[`\xC0\x83\x01a\x0B0V[a\x0E\x90a\x0E\x87i\x04\x04\xF6JVZ\x19t\0\0a\x0B\xFBV[`\xE0\x83\x01a\x0B0V[a\x0E\x99_a\x0C\x17V[\x91[\x82a\x0E\xAFa\x0E\xA9`\x08a\x0CEV[\x91a\x03'V[\x10\x15a\x0FeWa\x0E\xBE_a\x0C\x17V[[\x80a\x0E\xD3a\x0E\xCD`\x06a\x0CdV[\x91a\x03'V[\x10\x15a\x0FTWa\x0F!\x90a\x0E\xFBa\x0E\xF4\x86a\x0E\xEE`\x06a\x0CdV[\x90a\x0C\x94V[\x82\x90a\x0C\xC9V[\x80a\x0F\x15a\x0F\x0Fa\x0F\na\r\rV[a\x03'V[\x91a\x03'V[\x10a\x0F&W[Pa\x0C3V[a\x0E\xBFV[a\x0FN\x90a\x0FHa\x0F@a\x0F;\x88\x8A\x90a\r4V[a\rQV[\x91`\x0Fa\rgV[\x90a\x07\xA5V[_a\x0F\x1BV[P\x91a\x0F_\x90a\x0C3V[\x91a\x0E\x9BV[\x91PPV[_\x90V[\x90V[a\x0F\x85a\x0F\x80a\x0F\x8A\x92a\x0FnV[a\x02XV[a\x03'V[\x90V[\x90V[a\x0F\xA4a\x0F\x9Fa\x0F\xA9\x92a\x0F\x8DV[a\x02\x8BV[a\x02\x88V[\x90V[a\x0F\xB6`\xFFa\x0F\x90V[\x90V[\x90a\x0F\xC2a\x0FjV[Pa\x0F\xD4a\x0F\xCF\x83a\x05\xFBV[a\x06\x04V[a\x0F\xE7a\x0F\xE1` a\x0FqV[\x91a\x03'V[\x10_\x14a\x0F\xFBWPa\x0F\xF8\x90a\x12\x95V[\x90V[_a\x10\ta\x10\x0F\x93\x92a\x11\xA5V[\x01a\tMV[a\x10\x1Fa\x10\x1Aa\x0F\xACV[a\tuV[\x90V[_\x90V[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[a\x10T\x90Qa\x02\x88V[\x90V[a\x10`\x90a\x02\x88V[\x90RV[a\x10m\x90a\x03'V[\x90RV[\x90\x95\x94\x92a\x10\xBC\x94a\x10\xABa\x10\xB5\x92a\x10\xA1`\x80\x96a\x10\x97`\xA0\x88\x01\x9C_\x89\x01\x90a\x10WV[` \x87\x01\x90a\x10WV[`@\x85\x01\x90a\x10WV[``\x83\x01\x90a\x10dV[\x01\x90a\neV[V[a\x10\xC6a\x10\"V[Pa\x10\xCFa\x10&V[a\x11\x19a\x10\xDC`\xE0a\x10JV[\x91a\x11\na\x10\xEBa\x01\0a\x10JV[Fa\x10\xF50a\x060V[\x91a\x10\xFEa\0{V[\x96\x87\x95` \x87\x01a\x10qV[` \x82\x01\x81\x03\x82R\x03\x82a\0\xA3V[a\x11+a\x11%\x82a\x06\x04V[\x91a\x05\xFEV[ \x90V[_\x1C\x90V[`\xFF\x16\x90V[a\x11Fa\x11K\x91a\x11/V[a\x114V[\x90V[a\x11X\x90Ta\x11:V[\x90V[a\x11\x82\x91_a\x11wa\x11}\x93a\x11oa\tqV[P`\x05a\t\x81V[\x01a\t\xA3V[a\x11NV[\x90V[_\x90V[a\x11\x91a\x11\x85V[P3\x90V[\x91a\x11\xA3\x92\x91\x90\x91a\x13BV[V[\x90V[\x90V[a\x11\xBFa\x11\xBAa\x11\xC4\x92a\x11\xA8V[a\x02XV[a\x03'V[\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[a\x11\xFAa\x12\x03` \x93a\x12\x08\x93a\x11\xF1\x81a\x07\x08V[\x93\x84\x80\x93a\x11\xC7V[\x95\x86\x91\x01a\x11\xD0V[a\0\x85V[\x01\x90V[a\x12!\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x11\xDBV[\x90V[a\x12>a\x129a\x123\x83a\x06\x04V[\x92a\x05\xFEV[a\x10JV[\x90` \x81\x10a\x12LW[P\x90V[a\x12^\x90_\x19\x90` \x03`\x08\x02a\x07]V[\x16_a\x12HV[a\x12qa\x12v\x91a\x11/V[a\x07\x86V[\x90V[a\x12\x8Da\x12\x88a\x12\x92\x92a\x03'V[a\x02\x8BV[a\x02\x88V[\x90V[a\x12\x9Da\x0FjV[Pa\x12\xA7\x81a\x05\xFBV[\x90a\x12\xB1\x82a\x06\x04V[a\x12\xC4a\x12\xBE`\x1Fa\x11\xABV[\x91a\x03'V[\x11a\x12\xF9WPa\x12\xF1\x81a\x12\xEBa\x12\xE5a\x12\xE0a\x12\xF6\x95a\x12$V[a\x12eV[\x91a\x06\x04V[\x17a\x12yV[a\tuV[\x90V[a\x13\x1B\x90a\x13\x05a\0{V[\x91\x82\x91c0Z'\xA9`\xE0\x1B\x83R`\x04\x83\x01a\x12\x0CV[\x03\x90\xFD[\x91` a\x13@\x92\x94\x93a\x139`@\x82\x01\x96_\x83\x01\x90a\x10dV[\x01\x90a\x10dV[V[\x92\x91a\x13P\x84\x83\x83\x91a\x14\xA5V[\x83a\x13ka\x13ea\x13`_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x13\x80W[a\x13~\x92\x93\x91\x90\x91a\x16rV[V[a\x13\x88a\x16\x14V[\x93a\x13\x91a\x16QV[\x94\x80a\x13\xA5a\x13\x9F\x88a\x03'V[\x91a\x03'V[\x11a\x13\xB2WP\x93Pa\x13qV[\x85\x90a\x13\xCE_\x92\x83\x92c\x0EX\xAE\x93`\xE1\x1B\x84R`\x04\x84\x01a\x13\x1FV[\x03\x90\xFD[\x90a\x13\xDC\x90a\t\x97V[_R` R`@_ \x90V[\x90V[a\x13\xF7a\x13\xFC\x91a\x11/V[a\x13\xE8V[\x90V[a\x14\t\x90Ta\x13\xEBV[\x90V[`@\x90a\x145a\x14<\x94\x96\x95\x93\x96a\x14+``\x84\x01\x98_\x85\x01\x90a\neV[` \x83\x01\x90a\x10dV[\x01\x90a\x10dV[V[\x90a\x14I\x91\x03a\x03'V[\x90V[\x90a\x14X_\x19\x91a\x02\x8BV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x14wa\x14ra\x14~\x92a\x07\x86V[a\x07\xA2V[\x82Ta\x14LV[\x90UV[\x90a\x14\x8D\x91\x01a\x03'V[\x90V[\x91\x90a\x14\xA3\x90_` \x85\x01\x94\x01\x90a\x10dV[V[\x91\x90\x91\x80a\x14\xC3a\x14\xBDa\x14\xB8_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14_\x14a\x15\xA4Wa\x14\xE7a\x14\xE0\x83a\x14\xDB`\x02a\x13\xFFV[a\x0C\xC9V[`\x02a\x14bV[[\x82a\x15\x03a\x14\xFDa\x14\xF8_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14_\x14a\x15xWa\x15'a\x15 \x83a\x15\x1B`\x02a\x13\xFFV[a\x14>V[`\x02a\x14bV[[\x91\x90\x91a\x15sa\x15aa\x15[\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a\t\x97V[\x93a\t\x97V[\x93a\x15ja\0{V[\x91\x82\x91\x82a\x14\x90V[\x03\x90\xA3V[a\x15\x9F\x82a\x15\x99a\x15\x8A_\x87\x90a\x13\xD2V[\x91a\x15\x94\x83a\x13\xFFV[a\x14\x82V[\x90a\x14bV[a\x15(V[a\x15\xB7a\x15\xB2_\x83\x90a\x13\xD2V[a\x13\xFFV[\x80a\x15\xCAa\x15\xC4\x85a\x03'V[\x91a\x03'V[\x10a\x15\xF2Wa\x15\xDDa\x15\xED\x91\x84\x90a\x14>V[a\x15\xE8_\x84\x90a\x13\xD2V[a\x14bV[a\x14\xE8V[\x90a\x16\x10\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01a\x14\x0CV[\x03\x90\xFD[a\x16\x1Ca\x07\xC7V[Pa\x16'`\x02a\x13\xFFV[\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[a\x16Ia\x16Da\x16N\x92a\x16*V[a\x02XV[a\x03'V[\x90V[a\x16Ya\x07\xC7V[Pa\x16i`\x01\x80`\xD0\x1B\x03a\x165V[\x90V[\x90V[\x90V[\x91a\x16\xCAa\x16\xC4a\x16\xD1\x94\x80a\x16\x98a\x16\x92a\x16\x8D_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x17\x02W[\x84a\x16\xB9a\x16\xB3a\x16\xAE_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x16\xD3W[a\x18\xFAV[\x92a\x18\xFAV[\x90\x91a\x19/V[V[a\x16\xFB`\x0B`\x02a\x16\xF5a\x16\xEFa\x16\xE9\x89a\x17\xE4V[\x93a\x16lV[\x91a\x16oV[\x90a\x187V[PPa\x16\xBFV[a\x17*`\x0B`\x01a\x17$a\x17\x1Ea\x17\x18\x89a\x17\xE4V[\x93a\x16lV[\x91a\x16oV[\x90a\x187V[PPa\x16\x9EV[_\x90V[a\x17Aa\x17G\x91a\x16*V[\x91a\x16*V[\x01\x90`\x01\x80`\xD0\x1B\x03\x82\x11a\x17XWV[a\x0C\x80V[\x90a\x17p\x91a\x17ja\x171V[Pa\x175V[\x90V[\x90V[`\xFF\x16\x90V[a\x17\x90a\x17\x8Ba\x17\x95\x92a\x17sV[a\x02XV[a\x17vV[\x90V[a\x17\xA1\x90a\x17|V[\x90RV[\x91` a\x17\xC6\x92\x94\x93a\x17\xBF`@\x82\x01\x96_\x83\x01\x90a\x17\x98V[\x01\x90a\x10dV[V[a\x17\xDCa\x17\xD7a\x17\xE1\x92a\x03'V[a\x02XV[a\x16*V[\x90V[a\x17\xECa\x171V[P\x80a\x18\x06a\x18\0`\x01\x80`\xD0\x1B\x03a\x165V[\x91a\x03'V[\x11a\x18\x17Wa\x18\x14\x90a\x17\xC8V[\x90V[`\xD0a\x183_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01a\x17\xA5V[\x03\x90\xFD[\x90a\x18ma\x18s\x93\x92a\x18Ha\x171V[Pa\x18Qa\x171V[P\x80\x93a\x18fa\x18_a\x1A\xE1V[\x94\x92a\x1B\x8EV[\x90\x91a ]V[\x91a\x1C\x03V[\x91\x90\x91\x90V[a\x18\x85a\x18\x8B\x91a\x16*V[\x91a\x16*V[\x90\x03\x90`\x01\x80`\xD0\x1B\x03\x82\x11a\x18\x9DWV[a\x0C\x80V[\x90a\x18\xB5\x91a\x18\xAFa\x171V[Pa\x18yV[\x90V[\x90a\x18\xC2\x90a\t\x97V[_R` R`@_ \x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x18\xE5a\x18\xEA\x91a\x11/V[a\x18\xCEV[\x90V[a\x18\xF7\x90Ta\x18\xD9V[\x90V[a\x19\x11a\x19\x16\x91a\x19\ta\x11\x85V[P`\ta\x18\xB8V[a\x18\xEDV[\x90V[\x90a\x19#\x90a\t\x97V[_R` R`@_ \x90V[\x91\x90\x91\x80a\x19Ea\x19?\x85a\0\xEEV[\x91a\0\xEEV[\x14\x15\x80a\x1A\xC3W[a\x19WW[PPPV[\x80a\x19ra\x19la\x19g_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x03a\x1A3W[P\x81a\x19\x94a\x19\x8Ea\x19\x89_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x03a\x19\xA0W[\x80a\x19RV[a\x19\xE7a\x19\xDAa\x19\xE1\x92a\x19\xB6`\n\x86\x90a\x19\x19V[\x90a\x19\xD4a\x19\xCEa\x19\xC8`\x01\x93a\x17\xE4V[\x93a\x16lV[\x91a\x16oV[\x90a\x187V[\x92\x90a\x165V[\x91a\x165V[\x91\x90\x91a\x1A\x14\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\t\x97V[\x92a\x1A)a\x1A a\0{V[\x92\x83\x92\x83a\x13\x1FV[\x03\x90\xA2_\x80a\x19\x9AV[a\x1Ara\x1Axa\x1Aka\x1AH`\n\x85\x90a\x19\x19V[`\x02a\x1Aea\x1A_a\x1AY\x89a\x17\xE4V[\x93a\x16lV[\x91a\x16oV[\x90a\x187V[\x92\x90a\x165V[\x91a\x165V[\x91\x90\x91a\x1A\xA5\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\t\x97V[\x92a\x1A\xBAa\x1A\xB1a\0{V[\x92\x83\x92\x83a\x13\x1FV[\x03\x90\xA2_a\x19xV[P\x81a\x1A\xD7a\x1A\xD1_a\x0C\x17V[\x91a\x03'V[\x11a\x19MV[_\x90V[a\x1A\xE9a\x1A\xDDV[Pa\x1A\xF2a\x1C2V[\x90V[T\x90V[\x90V[a\x1B\x10a\x1B\x0Ba\x1B\x15\x92a\x1A\xF9V[a\x02XV[a\x03'V[\x90V[a\x1B'a\x1B-\x91\x93\x92\x93a\x03'V[\x92a\x03'V[\x82\x03\x91\x82\x11a\x1B8WV[a\x0C\x80V[\x90V[`0\x1C\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[a\x1B]a\x1Bb\x91a\x1B@V[a\x1BFV[\x90V[a\x1Bo\x90Ta\x1BQV[\x90V[a\x1B\x86a\x1B\x81a\x1B\x8B\x92a\x02UV[a\x02XV[a\x16*V[\x90V[a\x1B\x96a\x171V[Pa\x1B\xA2_\x82\x01a\x1A\xF5V[\x80a\x1B\xB5a\x1B\xAF_a\x0C\x17V[\x91a\x03'V[\x14_\x14a\x1B\xCBWPPa\x1B\xC7_a\x1BrV[[\x90V[a\x1B\xF8_\x91a\x1B\xF3a\x1B\xED\x84a\x1B\xFE\x96\x01\x92a\x1B\xE7`\x01a\x1A\xFCV[\x90a\x1B\x18V[\x91a\x1B=V[a\x1CGV[\x01a\x1BeV[a\x1B\xC8V[\x91a\x1C'_a\x1C,\x94a\x1C\x14a\x171V[Pa\x1C\x1Da\x171V[P\x01\x92\x91\x92a\x1B=V[a\x1E8V[\x91\x90\x91\x90V[a\x1C:a\x1A\xDDV[Pa\x1CDCa\x1F\xF6V[\x90V[_R` _ \x01\x90V[T\x90V[a\x1C_`@a\0\xCAV[\x90V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[\x90a\x1Cw\x90a\x1CbV[\x90RV[\x90a\x1C\x85\x90a\x16*V[\x90RV[_R` _ \x90V[a\x1C\x9B\x81a\x1CQV[\x82\x10\x15a\x1C\xB5Wa\x1C\xAD`\x01\x91a\x1C\x89V[\x91\x02\x01\x90_\x90V[a\r\x1AV[a\x1C\xC4\x90Qa\x1CbV[\x90V[\x90a\x1C\xD8e\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x02\x8BV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1C\xF6a\x1C\xF1a\x1C\xFB\x92a\x1CbV[a\x02XV[a\x1CbV[\x90V[\x90V[\x90a\x1D\x16a\x1D\x11a\x1D\x1D\x92a\x1C\xE2V[a\x1C\xFEV[\x82Ta\x1C\xC7V[\x90UV[a\x1D+\x90Qa\x16*V[\x90V[`0\x1B\x90V[\x90a\x1DFe\xFF\xFF\xFF\xFF\xFF\xFF\x19\x91a\x1D.V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1Dda\x1D_a\x1Di\x92a\x16*V[a\x02XV[a\x16*V[\x90V[\x90V[\x90a\x1D\x84a\x1D\x7Fa\x1D\x8B\x92a\x1DPV[a\x1DlV[\x82Ta\x1D4V[\x90UV[\x90a\x1D\xB9` _a\x1D\xBF\x94a\x1D\xB1\x82\x82\x01a\x1D\xAB\x84\x88\x01a\x1C\xBAV[\x90a\x1D\x01V[\x01\x92\x01a\x1D!V[\x90a\x1DoV[V[\x91\x90a\x1D\xD2Wa\x1D\xD0\x91a\x1D\x8FV[V[a\x06\xF5V[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a\x1E\x07W\x82a\x1D\xFF\x91`\x01a\x1E\x05\x95\x01\x81Ua\x1C\x92V[\x90a\x1D\xC1V[V[a\0\x8FV[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x1E#a\x1E(\x91a\x11/V[a\x1E\x0CV[\x90V[a\x1E5\x90Ta\x1E\x17V[\x90V[\x90\x92\x91\x92a\x1EDa\x171V[Pa\x1EMa\x171V[Pa\x1EW\x82a\x1CQV[\x80a\x1Eja\x1Ed_a\x0C\x17V[\x91a\x03'V[\x11_\x14a\x1F:Wa\x1E\x90\x90a\x1E\x8A\x84\x91a\x1E\x84`\x01a\x1A\xFCV[\x90a\x1B\x18V[\x90a\x1CGV[\x90a\x1E\x9C_\x83\x01a\x1E+V[\x92a\x1E\xA8_\x84\x01a\x1BeV[\x93\x80a\x1E\xBCa\x1E\xB6\x85a\x1CbV[\x91a\x1CbV[\x11a\x1F\x1EWa\x1E\xD3a\x1E\xCD\x84a\x1CbV[\x91a\x1CbV[\x14_\x14a\x1E\xEEWPPa\x1E\xE9\x90_\x85\x91\x01a\x1DoV[[\x91\x90V[a\x1F\x19\x92Pa\x1F\x14\x86a\x1F\x0Ba\x1F\x02a\x1CUV[\x94_\x86\x01a\x1CmV[` \x84\x01a\x1C{V[a\x1D\xD7V[a\x1E\xEAV[_c% `\x1D`\xE0\x1B\x81R\x80a\x1F6`\x04\x82\x01a\x02\x83V[\x03\x90\xFD[Pa\x1Fe\x91a\x1F`\x85a\x1FWa\x1FNa\x1CUV[\x94_\x86\x01a\x1CmV[` \x84\x01a\x1C{V[a\x1D\xD7V[a\x1Fn_a\x1BrV[\x91\x90V[a\x1F\x86a\x1F\x81a\x1F\x8B\x92a\x1CbV[a\x02XV[a\x03'V[\x90V[a\x1F\xA2a\x1F\x9Da\x1F\xA7\x92a\x0C\xEEV[a\x02XV[a\x17vV[\x90V[a\x1F\xB3\x90a\x1F\x8EV[\x90RV[\x91` a\x1F\xD8\x92\x94\x93a\x1F\xD1`@\x82\x01\x96_\x83\x01\x90a\x1F\xAAV[\x01\x90a\x10dV[V[a\x1F\xEEa\x1F\xE9a\x1F\xF3\x92a\x03'V[a\x02XV[a\x1CbV[\x90V[a\x1F\xFEa\x1A\xDDV[P\x80a \x18a \x12e\xFF\xFF\xFF\xFF\xFF\xFFa\x1FrV[\x91a\x03'V[\x11a )Wa &\x90a\x1F\xDAV[\x90V[`0a E_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01a\x1F\xB7V[\x03\x90\xFD[cNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[\x91\x90\x91\x80`\x01\x14a |W`\x02\x03a IWa x\x91a\x18\xA2V[\x90[V[Pa \x86\x91a\x17]V[\x90a zV\xFE`\x80`@R`\x046\x10\x15a\0\x13W[a#gV[a\0\x1D_5a\x04\xDCV[\x80c\x01\xFF\xC9\xA7\x14a\x04\xD7W\x80c\x06\xFD\xDE\x03\x14a\x04\xD2W\x80c\x07\xA1\xD5\xFA\x14a\x04\xCDW\x80c\t^\xA7\xB3\x14a\x04\xC8W\x80c\x0C\x05\xF8,\x14a\x04\xC3W\x80c\x13\xBE\xAA[\x14a\x04\xBEW\x80c\x18\x16\r\xDD\x14a\x04\xB9W\x80c\x1B\x02\xF8E\x14a\x04\xB4W\x80c\"\xA9}\x9C\x14a\x04\xAFW\x80c#\xB8r\xDD\x14a\x04\xAAW\x80c#\xE4`\xD2\x14a\x04\xA5W\x80c$\x81\xBB\\\x14a\x04\xA0W\x80c$\x8A\x9C\xA3\x14a\x04\x9BW\x80c(N\x133\x14a\x04\x96W\x80c//\xF1]\x14a\x04\x91W\x80c1<\xE5g\x14a\x04\x8CW\x80c3M\x0B\xBD\x14a\x04\x87W\x80c5\x9Bv\xFE\x14a\x04\x82W\x80c6D\xE5\x15\x14a\x04}W\x80c6V\x8A\xBE\x14a\x04xW\x80c:F\xB1\xA8\x14a\x04sW\x80c?K\xA8:\x14a\x04nW\x80c@\xC1\x0F\x19\x14a\x04iW\x80cD\xE1\x81\xAA\x14a\x04dW\x80cH\xB0\xDA\xA6\x14a\x04_W\x80cK\xDD6\xCE\x14a\x04ZW\x80cK\xF5\xD7\xE9\x14a\x04UW\x80cX|\xDE\x1E\x14a\x04PW\x80cZ\xDF\0!\x14a\x04KW\x80c\\\x19\xA9\\\x14a\x04FW\x80c\\\x97Z\xBB\x14a\x04AW\x80c_\x15\xC3\xC9\x14a\x04<W\x80ce\x1F\xD2h\x14a\x047W\x80cl3\xBC\xED\x14a\x042W\x80cl\xF0\x16%\x14a\x04-W\x80co\xC0c\xBE\x14a\x04(W\x80co\xCF\xFFE\x14a\x04#W\x80cp\xA0\x821\x14a\x04\x1EW\x80crf\0\xCE\x14a\x04\x19W\x80cvg\x18\x08\x14a\x04\x14W\x80c|y\x0C\xAB\x14a\x04\x0FW\x80c~\xCE\xBE\0\x14a\x04\nW\x80c\x84V\xCBY\x14a\x04\x05W\x80c\x84\xB0\x19n\x14a\x04\0W\x80c\x8ES\x9E\x8C\x14a\x03\xFBW\x80c\x90-U\xA5\x14a\x03\xF6W\x80c\x91\xD1HT\x14a\x03\xF1W\x80c\x91\xDD\xAD\xF4\x14a\x03\xECW\x80c\x95\xD8\x9BA\x14a\x03\xE7W\x80c\x99\x12}\x9B\x14a\x03\xE2W\x80c\x99\x89U\xD3\x14a\x03\xDDW\x80c\x9A\xB2N\xB0\x14a\x03\xD8W\x80c\x9B~\xF6K\x14a\x03\xD3W\x80c\x9D\xC2\x9F\xAC\x14a\x03\xCEW\x80c\xA0\x8DVT\x14a\x03\xC9W\x80c\xA2\x17\xFD\xDF\x14a\x03\xC4W\x80c\xA3\xD4H[\x14a\x03\xBFW\x80c\xA4\xD7\xE3\x1D\x14a\x03\xBAW\x80c\xA5q\xE1\x84\x14a\x03\xB5W\x80c\xA7\x0B\x9F\x0C\x14a\x03\xB0W\x80c\xA9\x05\x9C\xBB\x14a\x03\xABW\x80c\xAF*\xA6;\x14a\x03\xA6W\x80c\xB0\xCA%>\x14a\x03\xA1W\x80c\xBA\xBC9O\x14a\x03\x9CW\x80c\xBBMD6\x14a\x03\x97W\x80c\xC0*\xE7T\x14a\x03\x92W\x80c\xC1\xEBq7\x14a\x03\x8DW\x80c\xC3\xCD\xA5 \x14a\x03\x88W\x80c\xD5\x05\xAC\xCF\x14a\x03\x83W\x80c\xD5Gt\x1F\x14a\x03~W\x80c\xDDb\xED>\x14a\x03yW\x80c\xE3\xAB\xDF\xCB\x14a\x03tW\x80c\xE6:\xB1\xE9\x14a\x03oW\x80c\xF1\x12~\xD8\x14a\x03jW\x80c\xF5\x08\xE1\x9D\x14a\x03eWc\xF7^\x85\x12\x03a\0\x0EWa#2V[a\"\xCEV[a\"\x89V[a!\xA6V[a!BV[a \xDDV[a |V[a BV[a\x1F\x98V[a\x1E\xDCV[a\x1E\xA7V[a\x1ErV[a\x1E9V[a\x1D\xC5V[a\x1D\x90V[a\x1C\xE5V[a\x1C\xB0V[a\x1CDV[a\x1C\x0FV[a\x1B\xDAV[a\x1BeV[a\x1A\xF6V[a\x1A\x88V[a\x1ASV[a\x19\xDDV[a\x19\xA8V[a\x19sV[a\x19\x05V[a\x18\xD0V[a\x18mV[a\x188V[a\x17\xDDV[a\x17\xA1V[a\x16\\V[a\x16'V[a\x15\xEEV[a\x15lV[a\x15(V[a\x14\xF3V[a\x14\xBEV[a\x14^V[a\x13\xFAV[a\x13\x86V[a\x13QV[a\x13\x1CV[a\x12\xB0V[a\x12}V[a\x12HV[a\x12\x13V[a\x11\xC9V[a\x11\x94V[a\x11_V[a\x11\x17V[a\x0F\xD7V[a\x0F\xA4V[a\x0FnV[a\x0F:V[a\x0F\x05V[a\x0E\xD2V[a\x0E\x9DV[a\r\xB0V[a\rTV[a\x0C\xF4V[a\x0C\xBFV[a\x0C$V[a\nTV[a\t\xFBV[a\t\x8CV[a\t\x1AV[a\x08\xE5V[a\x08\xB1V[a\x07\xF6V[a\x07\x80V[a\x06\xD4V[a\x06\x17V[a\x05hV[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x05\t\x81a\x04\xF4V[\x03a\x05\x10WV[_\x80\xFD[\x90P5\x90a\x05!\x82a\x05\0V[V[\x90` \x82\x82\x03\x12a\x05<Wa\x059\x91_\x01a\x05\x14V[\x90V[a\x04\xECV[\x15\x15\x90V[a\x05O\x90a\x05AV[\x90RV[\x91\x90a\x05f\x90_` \x85\x01\x94\x01\x90a\x05FV[V[4a\x05\x98Wa\x05\x94a\x05\x83a\x05~6`\x04a\x05#V[a$\x04V[a\x05\x8Ba\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[_\x91\x03\x12a\x05\xA7WV[a\x04\xECV[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x05\xEDa\x05\xF6` \x93a\x05\xFB\x93a\x05\xE4\x81a\x05\xACV[\x93\x84\x80\x93a\x05\xB0V[\x95\x86\x91\x01a\x05\xB9V[a\x05\xC4V[\x01\x90V[a\x06\x14\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x05\xCEV[\x90V[4a\x06GWa\x06'6`\x04a\x05\x9DV[a\x06Ca\x062a%\"V[a\x06:a\x04\xE2V[\x91\x82\x91\x82a\x05\xFFV[\x03\x90\xF3[a\x04\xE8V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x06`\x90a\x06LV[\x90V[a\x06l\x90a\x06WV[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[a\x06\x9Ca\x06\xA5` \x93a\x06\xAA\x93a\x06\x93\x81a\x06pV[\x93\x84\x80\x93a\x06tV[\x95\x86\x91\x01a\x05\xB9V[a\x05\xC4V[\x01\x90V[\x91a\x06\xD1\x92a\x06\xC4`@\x82\x01\x93_\x83\x01\x90a\x06cV[` \x81\x84\x03\x91\x01Ra\x06}V[\x90V[4a\x07\x05Wa\x06\xE46`\x04a\x05\x9DV[a\x06\xECa%nV[\x90a\x07\x01a\x06\xF8a\x04\xE2V[\x92\x83\x92\x83a\x06\xAEV[\x03\x90\xF3[a\x04\xE8V[a\x07\x13\x81a\x06WV[\x03a\x07\x1AWV[_\x80\xFD[\x90P5\x90a\x07+\x82a\x07\nV[V[\x90V[a\x079\x81a\x07-V[\x03a\x07@WV[_\x80\xFD[\x90P5\x90a\x07Q\x82a\x070V[V[\x91\x90`@\x83\x82\x03\x12a\x07{W\x80a\x07oa\x07x\x92_\x86\x01a\x07\x1EV[\x93` \x01a\x07DV[\x90V[a\x04\xECV[4a\x07\xB1Wa\x07\xADa\x07\x9Ca\x07\x966`\x04a\x07SV[\x90a%\x98V[a\x07\xA4a\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[\x90` \x82\x82\x03\x12a\x07\xCFWa\x07\xCC\x91_\x01a\x07\x1EV[\x90V[a\x04\xECV[a\x07\xDD\x90a\x07-V[\x90RV[\x91\x90a\x07\xF4\x90_` \x85\x01\x94\x01\x90a\x07\xD4V[V[4a\x08&Wa\x08\"a\x08\x11a\x08\x0C6`\x04a\x07\xB6V[a%\xBEV[a\x08\x19a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x08qW\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x08lW` \x01\x92`\x01\x83\x02\x84\x01\x11a\x08gWV[a\x083V[a\x08/V[a\x08+V[\x90` \x82\x82\x03\x12a\x08\xA7W_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x08\xA2Wa\x08\x9E\x92\x01a\x087V[\x90\x91V[a\x04\xF0V[a\x04\xECV[_\x01\x90V[4a\x08\xE0Wa\x08\xCAa\x08\xC46`\x04a\x08vV[\x90a(\xAFV[a\x08\xD2a\x04\xE2V[\x80a\x08\xDC\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a\t\x15Wa\x08\xF56`\x04a\x05\x9DV[a\t\x11a\t\0a(\xBBV[a\t\x08a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\tHWa\t*6`\x04a\x05\x9DV[a\t2a*\x7FV[a\t:a\x04\xE2V[\x80a\tD\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x1C\x90V[`\xFF\x16\x90V[a\tg\x90`\x08a\tl\x93\x02a\tMV[a\tQV[\x90V[\x90a\tz\x91Ta\tWV[\x90V[a\t\x89`?_\x90a\toV[\x90V[4a\t\xBCWa\t\x9C6`\x04a\x05\x9DV[a\t\xB8a\t\xA7a\t}V[a\t\xAFa\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[\x90\x91``\x82\x84\x03\x12a\t\xF6Wa\t\xF3a\t\xDC\x84_\x85\x01a\x07\x1EV[\x93a\t\xEA\x81` \x86\x01a\x07\x1EV[\x93`@\x01a\x07DV[\x90V[a\x04\xECV[4a\n,Wa\n(a\n\x17a\n\x116`\x04a\t\xC1V[\x91a*\x89V[a\n\x1Fa\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[\x91` a\nR\x92\x94\x93a\nK`@\x82\x01\x96_\x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[4a\n\x85Wa\nla\ng6`\x04a\x07\xB6V[a+\xBAV[\x90a\n\x81a\nxa\x04\xE2V[\x92\x83\x92\x83a\n1V[\x03\x90\xF3[a\x04\xE8V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\n\xD1W[` \x83\x10\x14a\n\xCCWV[a\n\x9DV[\x91`\x7F\x16\x91a\n\xC1V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x0B\x07a\x0B\0\x83a\n\xB1V[\x80\x94a\n\xDBV[\x91`\x01\x81\x16\x90\x81_\x14a\x0B^WP`\x01\x14a\x0B\"W[PPPV[a\x0B/\x91\x92\x93\x94Pa\n\xE4V[\x91_\x92[\x81\x84\x10a\x0BFWPP\x01\x90_\x80\x80a\x0B\x1DV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x0B3V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x0B\x1DV[\x90a\x0B\x83\x91a\n\xEDV[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x0B\xA4\x90a\x05\xC4V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x0B\xBEW`@RV[a\x0B\x86V[\x90a\x0B\xE3a\x0B\xDC\x92a\x0B\xD3a\x04\xE2V[\x93\x84\x80\x92a\x0ByV[\x03\x83a\x0B\x9AV[V[\x90_\x10a\x0B\xF8Wa\x0B\xF5\x90a\x0B\xC3V[\x90V[a\n\x8AV[a\x0C\t`D_\x90a\x0B\xE5V[\x90V[a\x0C!\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x06}V[\x90V[4a\x0CTWa\x0C46`\x04a\x05\x9DV[a\x0CPa\x0C?a\x0B\xFDV[a\x0CGa\x04\xE2V[\x91\x82\x91\x82a\x0C\x0CV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x0Ce\x81a\x0CYV[\x03a\x0ClWV[_\x80\xFD[\x90P5\x90a\x0C}\x82a\x0C\\V[V[\x90` \x82\x82\x03\x12a\x0C\x98Wa\x0C\x95\x91_\x01a\x0CpV[\x90V[a\x04\xECV[a\x0C\xA6\x90a\x0CYV[\x90RV[\x91\x90a\x0C\xBD\x90_` \x85\x01\x94\x01\x90a\x0C\x9DV[V[4a\x0C\xEFWa\x0C\xEBa\x0C\xDAa\x0C\xD56`\x04a\x0C\x7FV[a-\xDBV[a\x0C\xE2a\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[4a\r\"Wa\r\x046`\x04a\x05\x9DV[a\r\x0Ca2\xB2V[a\r\x14a\x04\xE2V[\x80a\r\x1E\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x91\x90`@\x83\x82\x03\x12a\rOW\x80a\rCa\rL\x92_\x86\x01a\x0CpV[\x93` \x01a\x07\x1EV[\x90V[a\x04\xECV[4a\r\x83Wa\rma\rg6`\x04a\r'V[\x90a2\xE6V[a\rua\x04\xE2V[\x80a\r\x7F\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[`\xFF\x16\x90V[a\r\x97\x90a\r\x88V[\x90RV[\x91\x90a\r\xAE\x90_` \x85\x01\x94\x01\x90a\r\x8EV[V[4a\r\xE0Wa\r\xC06`\x04a\x05\x9DV[a\r\xDCa\r\xCBa3\x15V[a\r\xD3a\x04\xE2V[\x91\x82\x91\x82a\r\x9BV[\x03\x90\xF3[a\x04\xE8V[\x90` \x82\x82\x03\x12a\r\xFEWa\r\xFB\x91_\x01a\x07DV[\x90V[a\x04\xECV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[P`0\x90V[\x90V[a\x0E)\x81a\x0E\x17V[\x82\x10\x15a\x0ECWa\x0E;`\x01\x91a\x0E\x1DV[\x91\x02\x01\x90_\x90V[a\x0E\x03V[\x90V[a\x0E[\x90`\x08a\x0E`\x93\x02a\tMV[a\x0EHV[\x90V[\x90a\x0En\x91Ta\x0EKV[\x90V[`\x0Fa\x0E|\x81a\x0E\x17V[\x82\x10\x15a\x0E\x99Wa\x0E\x96\x91a\x0E\x90\x91a\x0E V[\x90a\x0EcV[\x90V[_\x80\xFD[4a\x0E\xCDWa\x0E\xC9a\x0E\xB8a\x0E\xB36`\x04a\r\xE5V[a\x0EqV[a\x0E\xC0a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x0F\0Wa\x0E\xE26`\x04a\x05\x9DV[a\x0E\xEAa3\xC6V[a\x0E\xF2a\x04\xE2V[\x80a\x0E\xFC\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a\x0F5Wa\x0F\x156`\x04a\x05\x9DV[a\x0F1a\x0F a3\xD0V[a\x0F(a\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[4a\x0FiWa\x0FSa\x0FM6`\x04a\r'V[\x90a3\xE4V[a\x0F[a\x04\xE2V[\x80a\x0Fe\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a\x0F\x9FWa\x0F\x9Ba\x0F\x8Aa\x0F\x846`\x04a\x07SV[\x90a4aV[a\x0F\x92a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x0F\xD2Wa\x0F\xB46`\x04a\x05\x9DV[a\x0F\xBCa4\xBFV[a\x0F\xC4a\x04\xE2V[\x80a\x0F\xCE\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a\x10\x06Wa\x0F\xF0a\x0F\xEA6`\x04a\x07SV[\x90a4\xC9V[a\x0F\xF8a\x04\xE2V[\x80a\x10\x02\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x10\"a\x10\x1Da\x10'\x92a\x06LV[a\x10\x0BV[a\x06LV[\x90V[a\x103\x90a\x10\x0EV[\x90V[a\x10?\x90a\x10*V[\x90V[\x90a\x10L\x90a\x106V[_R` R`@_ \x90V[_\x1C\x90V[a\x10ia\x10n\x91a\x10XV[a\x0EHV[\x90V[a\x10{\x90Ta\x10]V[\x90V[a\x10\x89\x90`\x0Ca\x10BV[a\x10\x94_\x82\x01a\x10qV[\x91a\x10\xA1`\x01\x83\x01a\x10qV[\x91a\x10\xAE`\x02\x82\x01a\x10qV[\x91a\x10\xC7`\x04a\x10\xC0`\x03\x85\x01a\x10qV[\x93\x01a\x10qV[\x90V[\x90\x95\x94\x92a\x11\x15\x94a\x11\x04a\x11\x0E\x92a\x10\xFA`\x80\x96a\x10\xF0`\xA0\x88\x01\x9C_\x89\x01\x90a\x07\xD4V[` \x87\x01\x90a\x07\xD4V[`@\x85\x01\x90a\x07\xD4V[``\x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[4a\x11KWa\x11Ga\x112a\x11-6`\x04a\x07\xB6V[a\x10~V[\x91a\x11>\x95\x93\x95a\x04\xE2V[\x95\x86\x95\x86a\x10\xCAV[\x03\x90\xF3[a\x04\xE8V[a\x11\\`@_\x90a\x0EcV[\x90V[4a\x11\x8FWa\x11o6`\x04a\x05\x9DV[a\x11\x8Ba\x11za\x11PV[a\x11\x82a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x11\xC4Wa\x11\xA46`\x04a\x05\x9DV[a\x11\xC0a\x11\xAFa6\0V[a\x11\xB7a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x11\xF9Wa\x11\xD96`\x04a\x05\x9DV[a\x11\xF5a\x11\xE4a6\xC1V[a\x11\xECa\x04\xE2V[\x91\x82\x91\x82a\x05\xFFV[\x03\x90\xF3[a\x04\xE8V[\x91\x90a\x12\x11\x90_` \x85\x01\x94\x01\x90a\x06cV[V[4a\x12CWa\x12?a\x12.a\x12)6`\x04a\x07\xB6V[a7-V[a\x126a\x04\xE2V[\x91\x82\x91\x82a\x11\xFEV[\x03\x90\xF3[a\x04\xE8V[4a\x12xWa\x12X6`\x04a\x05\x9DV[a\x12ta\x12ca7LV[a\x12ka\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[4a\x12\xABWa\x12\x95a\x12\x906`\x04a\x07\xB6V[a7uV[a\x12\x9Da\x04\xE2V[\x80a\x12\xA7\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a\x12\xE0Wa\x12\xC06`\x04a\x05\x9DV[a\x12\xDCa\x12\xCBa7\x88V[a\x12\xD3a\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x12\xFCa\x12\xF7a\x13\x01\x92a\x12\xE5V[a\x10\x0BV[a\x07-V[\x90V[a\x13\x0E`0a\x12\xE8V[\x90V[a\x13\x19a\x13\x04V[\x90V[4a\x13LWa\x13,6`\x04a\x05\x9DV[a\x13Ha\x137a\x13\x11V[a\x13?a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x13\x81Wa\x13}a\x13la\x13g6`\x04a\x07\xB6V[a7\x9EV[a\x13ta\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x13\xB4Wa\x13\x966`\x04a\x05\x9DV[a\x13\x9Ea8UV[a\x13\xA6a\x04\xE2V[\x80a\x13\xB0\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x13\xD0a\x13\xCBa\x13\xD5\x92a\x13\xB9V[a\x10\x0BV[a\x07-V[\x90V[a\x13\xECj\x08E\x95\x16\x14\x01HJ\0\0\0a\x13\xBCV[\x90V[a\x13\xF7a\x13\xD8V[\x90V[4a\x14*Wa\x14\n6`\x04a\x05\x9DV[a\x14&a\x14\x15a\x13\xEFV[a\x14\x1Da\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x90a\x149\x90a\x106V[_R` R`@_ \x90V[a\x14[\x90a\x14V`\r\x91_\x92a\x14/V[a\toV[\x90V[4a\x14\x8EWa\x14\x8Aa\x14ya\x14t6`\x04a\x07\xB6V[a\x14EV[a\x14\x81a\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[c\xFF\xFF\xFF\xFF\x16\x90V[a\x14\xA5\x90a\x14\x93V[\x90RV[\x91\x90a\x14\xBC\x90_` \x85\x01\x94\x01\x90a\x14\x9CV[V[4a\x14\xEEWa\x14\xEAa\x14\xD9a\x14\xD46`\x04a\x07\xB6V[a8cV[a\x14\xE1a\x04\xE2V[\x91\x82\x91\x82a\x14\xA9V[\x03\x90\xF3[a\x04\xE8V[4a\x15#Wa\x15\x1Fa\x15\x0Ea\x15\t6`\x04a\x07\xB6V[a8\x8EV[a\x15\x16a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x15XWa\x15Ta\x15Ca\x15>6`\x04a\x07\xB6V[a8\xACV[a\x15Ka\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[a\x15i`A_\x90a\x0EcV[\x90V[4a\x15\x9CWa\x15|6`\x04a\x05\x9DV[a\x15\x98a\x15\x87a\x15]V[a\x15\x8Fa\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x90\x95\x94\x92a\x15\xEC\x94a\x15\xDBa\x15\xE5\x92a\x15\xD1`\x80\x96a\x15\xC7`\xA0\x88\x01\x9C_\x89\x01\x90a\x05FV[` \x87\x01\x90a\x07\xD4V[`@\x85\x01\x90a\x07\xD4V[``\x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[4a\x16\"Wa\x16\x1Ea\x16\ta\x16\x046`\x04a\x07\xB6V[a8\xCBV[\x91a\x16\x15\x95\x93\x95a\x04\xE2V[\x95\x86\x95\x86a\x15\xA1V[\x03\x90\xF3[a\x04\xE8V[4a\x16WWa\x16Sa\x16Ba\x16=6`\x04a\x07\xB6V[a:;V[a\x16Ja\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x16\x8AWa\x16l6`\x04a\x05\x9DV[a\x16ta:tV[a\x16|a\x04\xE2V[\x80a\x16\x86\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[`\xFF`\xF8\x1B\x16\x90V[a\x16\xA1\x90a\x16\x8FV[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\x16\xC1\x90a\x07-V[\x90RV[\x90a\x16\xD2\x81` \x93a\x16\xB8V[\x01\x90V[` \x01\x90V[\x90a\x16\xF9a\x16\xF3a\x16\xEC\x84a\x16\xA5V[\x80\x93a\x16\xA9V[\x92a\x16\xB2V[\x90_[\x81\x81\x10a\x17\tWPPP\x90V[\x90\x91\x92a\x17\"a\x17\x1C`\x01\x92\x86Qa\x16\xC5V[\x94a\x16\xD6V[\x91\x01\x91\x90\x91a\x16\xFCV[\x93\x95\x91\x94a\x17}a\x17ra\x17\x91\x95a\x17da\x17\x87\x95a\x17\x9E\x9C\x9Aa\x17W`\xE0\x8C\x01\x92_\x8D\x01\x90a\x16\x98V[\x8A\x82\x03` \x8C\x01Ra\x05\xCEV[\x90\x88\x82\x03`@\x8A\x01Ra\x05\xCEV[\x97``\x87\x01\x90a\x07\xD4V[`\x80\x85\x01\x90a\x06cV[`\xA0\x83\x01\x90a\x0C\x9DV[`\xC0\x81\x84\x03\x91\x01Ra\x16\xDCV[\x90V[4a\x17\xD8Wa\x17\xB16`\x04a\x05\x9DV[a\x17\xD4a\x17\xBCa:\xFBV[\x93a\x17\xCB\x97\x95\x97\x93\x91\x93a\x04\xE2V[\x97\x88\x97\x88a\x17,V[\x03\x90\xF3[a\x04\xE8V[4a\x17\xF2Wa\x17\xED6`\x04a\r\xE5V[a;\x85V[a\x04\xE8V[\x90V[a\x18\x0Ea\x18\ta\x18\x13\x92a\x17\xF7V[a\x10\x0BV[a\x07-V[\x90V[a\x18*jR\xB7\xD2\xDC\xC8\x0C\xD2\xE4\0\0\0a\x17\xFAV[\x90V[a\x185a\x18\x16V[\x90V[4a\x18hWa\x18H6`\x04a\x05\x9DV[a\x18da\x18Sa\x18-V[a\x18[a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x18\x9EWa\x18\x9Aa\x18\x89a\x18\x836`\x04a\r'V[\x90a;\x93V[a\x18\x91a\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x18\xB7\x90a\x18\xA3V[\x90RV[\x91\x90a\x18\xCE\x90_` \x85\x01\x94\x01\x90a\x18\xAEV[V[4a\x19\0Wa\x18\xE06`\x04a\x05\x9DV[a\x18\xFCa\x18\xEBa;\xC1V[a\x18\xF3a\x04\xE2V[\x91\x82\x91\x82a\x18\xBBV[\x03\x90\xF3[a\x04\xE8V[4a\x195Wa\x19\x156`\x04a\x05\x9DV[a\x191a\x19 a;\xD5V[a\x19(a\x04\xE2V[\x91\x82\x91\x82a\x05\xFFV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x19Qa\x19La\x19V\x92a\x19:V[a\x10\x0BV[a\x07-V[\x90V[a\x19eb\x01Q\x80a\x19=V[\x90V[a\x19pa\x19YV[\x90V[4a\x19\xA3Wa\x19\x836`\x04a\x05\x9DV[a\x19\x9Fa\x19\x8Ea\x19hV[a\x19\x96a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x19\xD8Wa\x19\xD4a\x19\xC3a\x19\xBE6`\x04a\x07\xB6V[a;\xEBV[a\x19\xCBa\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x1A\rWa\x1A\ta\x19\xF8a\x19\xF36`\x04a\x07\xB6V[a<FV[a\x1A\0a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x1A)a\x1A$a\x1A.\x92a\x1A\x12V[a\x10\x0BV[a\x07-V[\x90V[a\x1AEjJr=\xC6\xB4\x0B\x8A\x9A\0\0\0a\x1A\x15V[\x90V[a\x1APa\x1A1V[\x90V[4a\x1A\x83Wa\x1Ac6`\x04a\x05\x9DV[a\x1A\x7Fa\x1Ana\x1AHV[a\x1Ava\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x1A\xB7Wa\x1A\xA1a\x1A\x9B6`\x04a\x07SV[\x90a<uV[a\x1A\xA9a\x04\xE2V[\x80a\x1A\xB3\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x90\x91``\x82\x84\x03\x12a\x1A\xF1Wa\x1A\xEEa\x1A\xD7\x84_\x85\x01a\x07\x1EV[\x93a\x1A\xE5\x81` \x86\x01a\x07DV[\x93`@\x01a\x07DV[\x90V[a\x04\xECV[4a\x1B%Wa\x1B\x0Fa\x1B\t6`\x04a\x1A\xBCV[\x91a@&V[a\x1B\x17a\x04\xE2V[\x80a\x1B!\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x90V[_\x1B\x90V[a\x1BFa\x1BAa\x1BK\x92a\x1B*V[a\x1B-V[a\x0CYV[\x90V[a\x1BW_a\x1B2V[\x90V[a\x1Bba\x1BNV[\x90V[4a\x1B\x95Wa\x1Bu6`\x04a\x05\x9DV[a\x1B\x91a\x1B\x80a\x1BZV[a\x1B\x88a\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x1B\xB5\x90`\x08a\x1B\xBA\x93\x02a\tMV[a\x1B\x9AV[\x90V[\x90a\x1B\xC8\x91Ta\x1B\xA5V[\x90V[a\x1B\xD7`C_\x90a\x1B\xBDV[\x90V[4a\x1C\nWa\x1B\xEA6`\x04a\x05\x9DV[a\x1C\x06a\x1B\xF5a\x1B\xCBV[a\x1B\xFDa\x04\xE2V[\x91\x82\x91\x82a\x11\xFEV[\x03\x90\xF3[a\x04\xE8V[4a\x1C?Wa\x1C\x1F6`\x04a\x05\x9DV[a\x1C;a\x1C*a@3V[a\x1C2a\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[4a\x1CrWa\x1C\\a\x1CW6`\x04a\x07\xB6V[aAZV[a\x1Cda\x04\xE2V[\x80a\x1Cn\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x1C\x8Ea\x1C\x89a\x1C\x93\x92a\x1CwV[a\x10\x0BV[a\x07-V[\x90V[a\x1C\xA2b'\x8D\0a\x1CzV[\x90V[a\x1C\xADa\x1C\x96V[\x90V[4a\x1C\xE0Wa\x1C\xC06`\x04a\x05\x9DV[a\x1C\xDCa\x1C\xCBa\x1C\xA5V[a\x1C\xD3a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x1D\x16Wa\x1D\x12a\x1D\x01a\x1C\xFB6`\x04a\x07SV[\x90aAeV[a\x1D\ta\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[P`0\x90V[\x90P\x90V[\x90V[` \x01\x90V[a\x1DKa\x1DEa\x1D>\x83a\x1D\x1BV[\x80\x94a\x1D!V[\x91a\x1D&V[_\x91[\x83\x83\x10a\x1D[WPPPPV[a\x1Dqa\x1Dk`\x01\x92\x84Qa\x16\xC5V[\x92a\x1D)V[\x92\x01\x91\x90a\x1DNV[\x91\x90a\x1D\x8E\x90_a\x06\0\x85\x01\x94\x01\x90a\x1D/V[V[4a\x1D\xC0Wa\x1D\xA06`\x04a\x05\x9DV[a\x1D\xBCa\x1D\xABaB\x8CV[a\x1D\xB3a\x04\xE2V[\x91\x82\x91\x82a\x1DzV[\x03\x90\xF3[a\x04\xE8V[4a\x1D\xF6Wa\x1D\xF2a\x1D\xE1a\x1D\xDB6`\x04a\x07SV[\x90aB\xA2V[a\x1D\xE9a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[a\x1E0a\x1E7\x94a\x1E&``\x94\x98\x97\x95a\x1E\x1C`\x80\x86\x01\x9A_\x87\x01\x90a\x07\xD4V[` \x85\x01\x90a\x07\xD4V[`@\x83\x01\x90a\x07\xD4V[\x01\x90a\x05FV[V[4a\x1EmWa\x1EI6`\x04a\x05\x9DV[a\x1Eia\x1ETaB\xD7V[\x90a\x1E`\x94\x92\x94a\x04\xE2V[\x94\x85\x94\x85a\x1D\xFBV[\x03\x90\xF3[a\x04\xE8V[4a\x1E\xA2Wa\x1E\x9Ea\x1E\x8Da\x1E\x886`\x04a\x07\xB6V[aD|V[a\x1E\x95a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x1E\xD7Wa\x1E\xB76`\x04a\x05\x9DV[a\x1E\xD3a\x1E\xC2aD\x91V[a\x1E\xCAa\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x1F\x0CWa\x1F\x08a\x1E\xF7a\x1E\xF26`\x04a\x07\xB6V[aD\xA5V[a\x1E\xFFa\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[a\x1F\x1A\x81a\r\x88V[\x03a\x1F!WV[_\x80\xFD[\x90P5\x90a\x1F2\x82a\x1F\x11V[V[\x90\x91`\xC0\x82\x84\x03\x12a\x1F\x93Wa\x1FL\x83_\x84\x01a\x07\x1EV[\x92a\x1FZ\x81` \x85\x01a\x07DV[\x92a\x1Fh\x82`@\x83\x01a\x07DV[\x92a\x1F\x90a\x1Fy\x84``\x85\x01a\x1F%V[\x93a\x1F\x87\x81`\x80\x86\x01a\x0CpV[\x93`\xA0\x01a\x0CpV[\x90V[a\x04\xECV[4a\x1F\xCDWa\x1F\xB7a\x1F\xAB6`\x04a\x1F4V[\x94\x93\x90\x93\x92\x91\x92aE/V[a\x1F\xBFa\x04\xE2V[\x80a\x1F\xC9\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[`\xE0\x81\x83\x03\x12a =Wa\x1F\xE8\x82_\x83\x01a\x07\x1EV[\x92a\x1F\xF6\x83` \x84\x01a\x07\x1EV[\x92a \x04\x81`@\x85\x01a\x07DV[\x92a \x12\x82``\x83\x01a\x07DV[\x92a :a #\x84`\x80\x85\x01a\x1F%V[\x93a 1\x81`\xA0\x86\x01a\x0CpV[\x93`\xC0\x01a\x0CpV[\x90V[a\x04\xECV[4a wWa aa U6`\x04a\x1F\xD2V[\x95\x94\x90\x94\x93\x91\x93aF\x83V[a ia\x04\xE2V[\x80a s\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a \xABWa \x95a \x8F6`\x04a\r'V[\x90aG\xA1V[a \x9Da\x04\xE2V[\x80a \xA7\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x91\x90`@\x83\x82\x03\x12a \xD8W\x80a \xCCa \xD5\x92_\x86\x01a\x07\x1EV[\x93` \x01a\x07\x1EV[\x90V[a\x04\xECV[4a!\x0EWa!\na \xF9a \xF36`\x04a \xB0V[\x90aG\xC3V[a!\x01a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[a!?a!\x13V[\x90V[4a!rWa!R6`\x04a\x05\x9DV[a!na!]a!7V[a!ea\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*\x90V[a!\xA3a!wV[\x90V[4a!\xD6Wa!\xB66`\x04a\x05\x9DV[a!\xD2a!\xC1a!\x9BV[a!\xC9a\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[a!\xE4\x81a\x14\x93V[\x03a!\xEBWV[_\x80\xFD[\x90P5\x90a!\xFC\x82a!\xDBV[V[\x91\x90`@\x83\x82\x03\x12a\"&W\x80a\"\x1Aa\"#\x92_\x86\x01a\x07\x1EV[\x93` \x01a!\xEFV[\x90V[a\x04\xECV[a\"4\x90a\x18\xA3V[\x90RV[`\x01\x80`\xD0\x1B\x03\x16\x90V[a\"L\x90a\"8V[\x90RV[\x90` \x80a\"r\x93a\"h_\x82\x01Q_\x86\x01\x90a\"+V[\x01Q\x91\x01\x90a\"CV[V[\x91\x90a\"\x87\x90_`@\x85\x01\x94\x01\x90a\"PV[V[4a\"\xBAWa\"\xB6a\"\xA5a\"\x9F6`\x04a!\xFEV[\x90aH1V[a\"\xADa\x04\xE2V[\x91\x82\x91\x82a\"tV[\x03\x90\xF3[a\x04\xE8V[a\"\xCB`B_\x90a\x0EcV[\x90V[4a\"\xFEWa\"\xDE6`\x04a\x05\x9DV[a\"\xFAa\"\xE9a\"\xBFV[a\"\xF1a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[a#/a#\x03V[\x90V[4a#bWa#B6`\x04a\x05\x9DV[a#^a#Ma#'V[a#Ua\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[_\x80\xFD[_\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a#\x8Fa#\x95\x91a\"8V[\x91a\"8V[\x01\x90`\x01\x80`\xD0\x1B\x03\x82\x11a#\xA6WV[a#oV[\x90a#\xBE\x91a#\xB8a#kV[Pa#\x83V[\x90V[a#\xCDa#\xD3\x91a\"8V[\x91a\"8V[\x90\x03\x90`\x01\x80`\xD0\x1B\x03\x82\x11a#\xE5WV[a#oV[\x90a#\xFD\x91a#\xF7a#kV[Pa#\xC1V[\x90V[_\x90V[a$\x0Ca$\0V[P\x80a$'a$!cye\xDB\x0B`\xE0\x1Ba\x04\xF4V[\x91a\x04\xF4V[\x14\x90\x81\x15a$4W[P\x90V[a$>\x91PaHGV[_a$0V[``\x90V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a$ua$n\x83a\n\xB1V[\x80\x94a$IV[\x91`\x01\x81\x16\x90\x81_\x14a$\xCCWP`\x01\x14a$\x90W[PPPV[a$\x9D\x91\x92\x93\x94Pa$RV[\x91_\x92[\x81\x84\x10a$\xB4WPP\x01\x90_\x80\x80a$\x8BV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a$\xA1V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a$\x8BV[\x90a$\xF1\x91a$[V[\x90V[\x90a%\x14a%\r\x92a%\x04a\x04\xE2V[\x93\x84\x80\x92a$\xE7V[\x03\x83a\x0B\x9AV[V[a%\x1F\x90a$\xF4V[\x90V[a%*a$DV[Pa%5`\x03a%\x16V[\x90V[_\x90V[``\x90V[a%Ma%R\x91a\x10XV[a\x1B\x9AV[\x90V[a%_\x90Ta%AV[\x90V[a%k\x90a\x0B\xC3V[\x90V[a%va%8V[Pa%\x7Fa%<V[Pa%\x8A`Ca%UV[\x90a%\x95`Da%bV[\x90V[a%\xB5\x91a%\xA4a$\0V[Pa%\xADaHmV[\x91\x90\x91aHzV[`\x01\x90V[_\x90V[_a%\xD6a%\xDC\x92a%\xCEa%\xBAV[P`\x0Ca\x10BV[\x01a\x10qV[\x90V[\x90a%\xF9\x91a%\xF4a%\xEFa#\x03V[aH\x8AV[a(YV[V[P\x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a&(\x91\x02\x91a&\"_\x19\x84a&\tV[\x92a&\tV[\x91\x81\x19\x16\x91\x16\x17\x90V[a&Fa&Aa&K\x92a\x07-V[a\x10\x0BV[a\x07-V[\x90V[\x90V[\x91\x90a&ga&ba&o\x93a&2V[a&NV[\x90\x83Ta&\rV[\x90UV[a&\x85\x91a&\x7Fa%\xBAV[\x91a&QV[V[[\x81\x81\x10a&\x93WPPV[\x80a&\xA0_`\x01\x93a&sV[\x01a&\x88V[\x91\x90`\x1F\x81\x11a&\xB6W[PPPV[a&\xC2a&\xE7\x93a\n\xE4V[\x90` a&\xCE\x84a%\xFFV[\x83\x01\x93\x10a&\xEFW[a&\xE0\x90a%\xFFV[\x01\x90a&\x87V[_\x80\x80a&\xB1V[\x91Pa&\xE0\x81\x92\x90Pa&\xD7V[\x90a'\r\x90_\x19\x90`\x08\x02a\tMV[\x19\x16\x90V[\x81a'\x1C\x91a&\xFDV[\x90`\x02\x02\x17\x90V[\x91a'/\x90\x82a%\xFBV[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a'\xEEWa'S\x82a'M\x85Ta\n\xB1V[\x85a&\xA6V[_\x90`\x1F\x83\x11`\x01\x14a'\x86W\x91\x80\x91a'u\x93_\x92a'zW[PPa'\x12V[\x90U[V[\x90\x91P\x015_\x80a'nV[`\x1F\x19\x83\x16\x91a'\x95\x85a\n\xE4V[\x92_[\x81\x81\x10a'\xD6WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a'\xBCW[PPP\x02\x01\x90Ua'xV[a'\xCC\x91\x015`\x1F\x84\x16\x90a&\xFDV[\x90U_\x80\x80a'\xB0V[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a'\x98V[a\x0B\x86V[\x90a'\xFE\x92\x91a'$V[V[\x90\x82_\x93\x92\x827\x01RV[\x91\x90a(%\x81a(\x1E\x81a(*\x95a\x06tV[\x80\x95a(\0V[a\x05\xC4V[\x01\x90V[\x91a(Ha(V\x94\x92`@\x85\x01\x90\x85\x82\x03_\x87\x01Ra\x06}V[\x92` \x81\x85\x03\x91\x01Ra(\x0BV[\x90V[\x90a(d`Da%bV[a(q\x83\x83\x90`Da'\xF3V[\x91\x90\x91a(\xAA\x7F\xB9\xA2\x08\x84&\xF0;0\xA8\x1C\x06B\x80\x94\xFB\xFA\x9E&\x92s\x9B2A\xAFk\x9A\xB1\xDAKUF\xBE\x93a(\xA1a\x04\xE2V[\x93\x84\x93\x84a(.V[\x03\x90\xA1V[\x90a(\xB9\x91a%\xDFV[V[a(\xC3a%\xBAV[Pa(\xCE`\x02a\x10qV[\x90V[a(\xE1a(\xDCa!\x13V[aH\x8AV[a(\xE9a)\xAAV[V[a(\xFFa(\xFAa)\x04\x92a\x1B*V[a\x10\x0BV[a\x07-V[\x90V[a)\x1Ba)\x16a) \x92a\x1B*V[a\x10\x0BV[a\x06LV[\x90V[a),\x90a)\x07V[\x90V[\x90a);`\xFF\x91a\x1B-V[\x91\x81\x19\x16\x91\x16\x17\x90V[a)N\x90a\x05AV[\x90V[\x90V[\x90a)ia)da)p\x92a)EV[a)QV[\x82Ta)/V[\x90UV[\x90a)\x80_\x19\x91a\x1B-V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a)\x9Fa)\x9Aa)\xA6\x92a&2V[a&NV[\x82Ta)tV[\x90UV[a)\xB4`@a\x10qV[a)\xC6a)\xC0_a(\xEBV[\x91a\x07-V[\x03a*cWa)\xD5`Ca%UV[a)\xEFa)\xE9a)\xE4_a)#V[a\x06WV[\x91a\x06WV[\x14a*GWa*\0`\x01`?a)TV[a*\x0BB`@a)\x8AV[Ba*B\x7F\x11\x94\xB04\xCF\xA9\xABX\x07IJ\x1D\\f}\x8B\x0En\x97\xF3\x88\x88t*\xA3\x87\x1A2 4\x11`\x91a*9a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xA1V[_c;\nH\xBD`\xE1\x1B\x81R\x80a*_`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c8\xE9=\xBD`\xE1\x1B\x81R\x80a*{`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[a*\x87a(\xD1V[V[\x91a*\xB3\x92a*\x96a$\0V[Pa*\xABa*\xA2aHmV[\x82\x90\x84\x91aH\xDEV[\x91\x90\x91aIjV[`\x01\x90V[a*\xC1\x90a\x10*V[\x90V[_\x80\xFD[`\xE0\x1B\x90V[\x90PQ\x90a*\xDB\x82a\x070V[V[\x90` \x82\x82\x03\x12a*\xF6Wa*\xF3\x91_\x01a*\xCEV[\x90V[a\x04\xECV[a+\x03a\x04\xE2V[=_\x82>=\x90\xFD[a+\x1Aa+ \x91\x93\x92\x93a\x07-V[\x92a\x07-V[\x82\x03\x91\x82\x11a++WV[a#oV[\x90V[a+Ga+Ba+L\x92a+0V[a\x10\x0BV[a\x07-V[\x90V[a+^a+d\x91\x93\x92\x93a\x07-V[\x92a\x07-V[\x91a+p\x83\x82\x02a\x07-V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a+\x7FWV[a#oV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a+\xA4a+\xAA\x91a\x07-V[\x91a\x07-V[\x90\x81\x15a+\xB5W\x04\x90V[a+\x84V[a+\xC2a%\xBAV[\x91a+\xCBa%\xBAV[\x91a+\xE2_a+\xDC`\x0C\x84\x90a\x10BV[\x01a\x10qV[\x90a+\xFA`\x02a+\xF4`\x0C\x84\x90a\x10BV[\x01a\x10qV[\x91a,3` a,\t0a*\xB8V[ce\x1F\xD2h\x90a,(\x86\x92a,\x1Ca\x04\xE2V[\x95\x86\x94\x85\x93\x84\x93a*\xC8V[\x83R`\x04\x83\x01a\x11\xFEV[\x03\x91Z\xFA\x90\x81\x15a-\x8CWa,~\x91` \x91_\x91a-_W[P\x93a,W0a*\xB8V[a,sc\x99\x89U\xD3a,ga\x04\xE2V[\x95\x86\x94\x85\x93\x84\x93a*\xC8V[\x83R`\x04\x83\x01a\x11\xFEV[\x03\x91Z\xFA\x90\x81\x15a-ZW_\x91a-,W[P\x91\x81a,\xA5a,\x9F_a(\xEBV[\x91a\x07-V[\x11a,\xFBW[PP\x81a,\xC0a,\xBA_a(\xEBV[\x91a\x07-V[\x11a,\xCAW[PPV[a,\xF3\x92\x93Pa,\xDDa,\xEE\x91\x83a+\x0BV[a,\xE8a'\x10a+3V[\x90a+OV[a+\x98V[\x90_\x80a,\xC6V[a-$\x92\x96Pa-\x0Ea-\x1F\x91\x83a+\x0BV[a-\x19a'\x10a+3V[\x90a+OV[a+\x98V[\x93_\x80a,\xABV[a-M\x91P` =\x81\x11a-SW[a-E\x81\x83a\x0B\x9AV[\x81\x01\x90a*\xDDV[_a,\x90V[P=a-;V[a*\xFBV[a-\x7F\x91P\x82=\x81\x11a-\x85W[a-w\x81\x83a\x0B\x9AV[\x81\x01\x90a*\xDDV[_a,LV[P=a-mV[a*\xFBV[_\x90V[a-\x9E\x90a\x0CYV[\x90V[\x90a-\xAB\x90a-\x95V[_R` R`@_ \x90V[\x90V[a-\xC6a-\xCB\x91a\x10XV[a-\xB7V[\x90V[a-\xD8\x90Ta-\xBAV[\x90V[`\x01a-\xF4a-\xFA\x92a-\xECa-\x91V[P`\x05a-\xA1V[\x01a-\xCEV[\x90V[a.\x05aJ\x07V[a.\ra/cV[V[a.\x1Ba. \x91a\x10XV[a\tQV[\x90V[a.-\x90Ta.\x0FV[\x90V[`\x01a.<\x91\x01a\x07-V[\x90V[a.Na.T\x91\x93\x92\x93a\x07-V[\x92a\x07-V[\x82\x01\x80\x92\x11a._WV[a#oV[a.m\x90a\x10*V[\x90V[a.y\x90a\x10\x0EV[\x90V[a.\x85\x90a.pV[\x90V[a.\x91\x90a\x10*V[\x90V[_\x91\x03\x12a.\x9EWV[a\x04\xECV[\x90_\x92\x91\x80T\x90a.\xBDa.\xB6\x83a\n\xB1V[\x80\x94a\x06tV[\x91`\x01\x81\x16\x90\x81_\x14a/\x14WP`\x01\x14a.\xD8W[PPPV[a.\xE5\x91\x92\x93\x94Pa\n\xE4V[\x91_\x92[\x81\x84\x10a.\xFCWPP\x01\x90_\x80\x80a.\xD3V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a.\xE9V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a.\xD3V[a/Sa/`\x94\x92\x93a/I``\x84\x01\x95_\x85\x01\x90a\x06cV[` \x83\x01\x90a\x07\xD4V[`@\x81\x84\x03\x91\x01Ra.\xA3V[\x90V[a/va/p`?a.#V[\x15a\x05AV[a2\x96Wa/\x82a@3V[a2zWa/\xABa/\x9DBa/\x97`@a\x10qV[\x90a+\x0BV[a/\xA5a\x1C\x96V[\x90a+\x98V[\x80a/\xC7a/\xC1a/\xBC`Aa\x10qV[a\x07-V[\x91a\x07-V[\x11\x15a2^Wa/\xE1\x90a/\xDB`Aa\x10qV[\x90a+\x0BV[\x90\x81a0\x0Fa0\ta0\x04a/\xF4a\x13\x04V[a/\xFE`Aa\x10qV[\x90a+\x0BV[a\x07-V[\x91a\x07-V[\x11a2;W[a0\x1E_a(\xEBV[\x90a0(_a(\xEBV[\x91[\x82a0=a07\x86a\x07-V[\x91a\x07-V[\x10\x15a0\x84Wa0xa0~\x91a0ra0l`\x0Fa0fa0_`Aa\x10qV[\x89\x90a.?V[\x90a\x0E V[\x90a\x0EcV[\x90a.?V[\x92a.0V[\x91a0*V[\x91P\x91a0\x9Ba0\x94`Ba\x10qV[\x83\x90a.?V[a0\xB4a0\xAEa0\xA9a\x13\xD8V[a\x07-V[\x91a\x07-V[\x11a2\x1FWa0\xCFa0\xD6\x91a0\xCA`Aa\x10qV[a.?V[`Aa)\x8AV[a0\xF3a0\xEC\x82a0\xE7`Ba\x10qV[a.?V[`Ba)\x8AV[a1\x06a0\xFF0a.dV[\x82\x90aJ1V[a1#a1\x120a.dV[a1\x1C`Ca%UV[\x83\x91aHzV[a1=a18a13`Ca%UV[a.|V[a.\x88V[c\x18\xB6\x8B\x8Ca1K0a.dV[\x83\x92`D\x92\x81;\x15a2\x1AW_a1u\x91a1\x80\x82\x96a1ia\x04\xE2V[\x98\x89\x97\x88\x96\x87\x95a*\xC8V[\x85R`\x04\x85\x01a//V[\x03\x92Z\xF1\x80\x15a2\x15Wa1\xE9W[Pa1\x9A`Aa\x10qV[\x90a1\xA4_a)#V[\x90a1\xCF\x7F4\xB7=\x0C\x96\xE9\xFFMS\x11CH\x17\xC8\xEC\xC90\xE7\xD2x,[\xDE.y\xDCD\xB0YgU\xBB\x92a\x106V[\x92a1\xE4a1\xDBa\x04\xE2V[\x92\x83\x92\x83a\n1V[\x03\x90\xA2V[a2\x08\x90_=\x81\x11a2\x0EW[a2\0\x81\x83a\x0B\x9AV[\x81\x01\x90a.\x94V[_a1\x8FV[P=a1\xF6V[a*\xFBV[a*\xC4V[_c#\x06N\xBD`\xE0\x1B\x81R\x80a27`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90Pa2Xa2Ha\x13\x04V[a2R`Aa\x10qV[\x90a+\x0BV[\x90a0\x15V[_c\xE0\x85\xD2+`\xE0\x1B\x81R\x80a2v`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\x11UbK`\xE2\x1B\x81R\x80a2\x92`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\x19\xAF\xC9\x9D`\xE2\x1B\x81R\x80a2\xAE`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[a2\xBAa-\xFDV[V[\x90a2\xD7\x91a2\xD2a2\xCD\x82a-\xDBV[aH\x8AV[a2\xD9V[V[\x90a2\xE3\x91aJ\x8FV[PV[\x90a2\xF0\x91a2\xBCV[V[_\x90V[\x90V[a3\ra3\x08a3\x12\x92a2\xF6V[a\x10\x0BV[a\r\x88V[\x90V[a3\x1Da2\xF2V[Pa3(`\x12a2\xF9V[\x90V[a3;a36a!\x13V[aH\x8AV[a3Ca3EV[V[a3O`@a\x10qV[a3aa3[_a(\xEBV[\x91a\x07-V[\x14a3\xAAWa3r`\x01`?a)TV[\x7FJy*\x0B\xE4+Vr\xFA\xA4\x01)\xFCdi\x07$\x90w\\\xA8\xD3\xC3N\x85-MU\xD3\xA75\xA9a3\x9Ba\x04\xE2V[\x80a3\xA5\x81a\x08\xACV[\x03\x90\xA1V[_c\x8F\x98@A`\xE0\x1B\x81R\x80a3\xC2`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[a3\xCEa3+V[V[a3\xD8a-\x91V[Pa3\xE1aK;V[\x90V[\x90\x80a3\xFFa3\xF9a3\xF4aHmV[a\x06WV[\x91a\x06WV[\x03a4\x10Wa4\r\x91aK\xF5V[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a4(`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90a46\x90a\x106V[_R` R`@_ \x90V[\x90V[a4Ya4Ta4^\x92a\"8V[a\x10\x0BV[a\x07-V[\x90V[a4\x98\x91a4\x8Da4\x87a4\x82a4\x93\x94a4za%\xBAV[P`\na4,V[a4BV[\x91aL\xD6V[\x90aM\xCCV[a4EV[\x90V[a4\xABa4\xA6a\x1BNV[aH\x8AV[a4\xB3a4\xB5V[V[a4\xBDaOSV[V[a4\xC7a4\x9BV[V[\x90\x81a4\xE5a4\xDFa4\xDA_a)#V[a\x06WV[\x91a\x06WV[\x14a5\xE4W\x80a4\xFDa4\xF7_a(\xEBV[\x91a\x07-V[\x14a5\xC8Wa5\x1Fa5\x19a5\x14`\r3\x90a\x14/V[a.#V[\x15a\x05AV[a5\xACWa5,3aO`V[a5C`\x01a5=`\x0C3\x90a\x10BV[\x01a\x10qV[a5Ua5O\x83a\x07-V[\x91a\x07-V[\x10a5\x90Wa5\x8E\x91a5\x89\x82a5\x83`\x01a5s`\x0C3\x90a\x10BV[\x01\x91a5~\x83a\x10qV[a+\x0BV[\x90a)\x8AV[aJ1V[V[_c\x1C\x95\x9E\xD9`\xE2\x1B\x81R\x80a5\xA8`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_cD\x17v\t`\xE1\x1B\x81R\x80a5\xC4`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a5\xE0`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a5\xFC`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[a6\x08a%\xBAV[Pa6$a6\x14a\x13\xD8V[a6\x1E`Ba\x10qV[\x90a+\x0BV[\x90V[\x90a6:a63a\x04\xE2V[\x92\x83a\x0B\x9AV[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a6ZWa6V` \x91a\x05\xC4V[\x01\x90V[a\x0B\x86V[\x90a6qa6l\x83a6<V[a6'V[\x91\x82RV[_\x7Fmode=blocknumber&from=default\0\0\0\x91\x01RV[a6\xA7`\x1Da6_V[\x90a6\xB4` \x83\x01a6vV[V[a6\xBEa6\x9DV[\x90V[a6\xC9a$DV[Pa6\xD2a;\xC1V[a6\xEBa6\xE5a6\xE0aP\xFBV[a\x18\xA3V[\x91a\x18\xA3V[\x03a6\xFBWa6\xF8a6\xB6V[\x90V[_c\x01\xBF\xC1\xC5`\xE6\x1B\x81R\x80a7\x13`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90a7!\x90a\x106V[_R` R`@_ \x90V[a7Da7I\x91a7<a%8V[P`\ta7\x17V[a%UV[\x90V[a7Ta$\0V[Pa7_`@a\x10qV[a7qa7k_a(\xEBV[\x91a\x07-V[\x11\x90V[a7\x86\x90a7\x81aHmV[aQ\x10V[V[a7\x90a$\0V[Pa7\x9B`\x0Ea.#V[\x90V[a7\xF5\x90a7\xAAa%\xBAV[Pa7\xC2`\x01a7\xBC`\x0C\x84\x90a\x10BV[\x01a\x10qV[\x90a7\xEF`\x04a7\xE9a7\xE1_a7\xDB`\x0C\x87\x90a\x10BV[\x01a\x10qV[\x93`\x0Ca\x10BV[\x01a\x10qV[\x91aQ\x9BV[\x90V[a8\x08a8\x03a!wV[aH\x8AV[a8\x10a8\x12V[V[a8\x1D_`?a)TV[\x7Fs\xA5\xFC`\xAA\xFE\xEC\x8F\x13\x9A\xF2-\x98\xE6!@\xE2\xCE\x91M\x1F\x15\\i+BwW\xC3\xE4\x01La8Fa\x04\xE2V[\x80a8P\x81a\x08\xACV[\x03\x90\xA1V[a8]a7\xF8V[V[_\x90V[a8u\x90a8oa8_V[PaRGV[\x90V[\x90a8\x82\x90a\x106V[_R` R`@_ \x90V[a8\xA4a8\xA9\x91a8\x9Da%\xBAV[P_a8xV[a\x10qV[\x90V[a8\xC3a8\xC8\x91a8\xBBa$\0V[P`\ra\x14/V[a.#V[\x90V[\x90a8\xD4a$\0V[Pa8\xDDa%\xBAV[Pa8\xE6a%\xBAV[Pa8\xEFa%\xBAV[Pa8\xF8a%\xBAV[Pa9\ra9\x08`\r\x84\x90a\x14/V[a.#V[\x91a9$_a9\x1E`\x0C\x84\x90a\x10BV[\x01a\x10qV[\x91a9<`\x02a96`\x0C\x85\x90a\x10BV[\x01a\x10qV[\x90a9u` a9K0a*\xB8V[ce\x1F\xD2h\x90a9j\x87\x92a9^a\x04\xE2V[\x95\x86\x94\x85\x93\x84\x93a*\xC8V[\x83R`\x04\x83\x01a\x11\xFEV[\x03\x91Z\xFA\x90\x81\x15a:6Wa9\xC0\x91` \x91_\x91a:\tW[P\x94a9\x990a*\xB8V[a9\xB5c\x99\x89U\xD3a9\xA9a\x04\xE2V[\x95\x86\x94\x85\x93\x84\x93a*\xC8V[\x83R`\x04\x83\x01a\x11\xFEV[\x03\x91Z\xFA\x90\x81\x15a:\x04W_\x91a9\xD6W[P\x90V[a9\xF7\x91P` =\x81\x11a9\xFDW[a9\xEF\x81\x83a\x0B\x9AV[\x81\x01\x90a*\xDDV[_a9\xD2V[P=a9\xE5V[a*\xFBV[a:)\x91P\x82=\x81\x11a:/W[a:!\x81\x83a\x0B\x9AV[\x81\x01\x90a*\xDDV[_a9\x8EV[P=a:\x17V[a*\xFBV[a:M\x90a:Ga%\xBAV[PaRvV[\x90V[a:`a:[a!wV[aH\x8AV[a:ha:jV[V[a:raR\xECV[V[a:|a:PV[V[_\x90V[``\x90V[a:\x90\x90a\x10*V[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a:\xABW` \x80\x91\x02\x01\x90V[a\x0B\x86V[\x90a:\xC2a:\xBD\x83a:\x93V[a6'V[\x91\x82RV[6\x907V[\x90a:\xF1a:\xD9\x83a:\xB0V[\x92` \x80a:\xE7\x86\x93a:\x93V[\x92\x01\x91\x03\x90a:\xC7V[V[`\x0F`\xF8\x1B\x90V[a;\x03a:~V[Pa;\x0Ca$DV[Pa;\x15a$DV[Pa;\x1Ea%\xBAV[Pa;'a%8V[Pa;0a-\x91V[Pa;9a:\x82V[Pa;BaR\xF9V[\x90a;KaS9V[\x90F\x90a;W0a:\x87V[\x90a;a_a\x1B2V[\x90a;sa;n_a(\xEBV[a:\xCCV[\x90a;|a:\xF3V[\x96\x95\x94\x93\x92\x91\x90V[a;\x8Da%\xBAV[Pa;\x85V[a;\xBA\x91_a;\xAFa;\xB5\x93a;\xA7a$\0V[P`\x05a-\xA1V[\x01a\x14/V[a.#V[\x90V[_\x90V[a;\xC9a;\xBDV[Pa;\xD2aP\xFBV[\x90V[a;\xDDa$DV[Pa;\xE8`\x04a%\x16V[\x90V[a<C\x90a;\xF7a%\xBAV[Pa<\x0F`\x03a<\t`\x0C\x84\x90a\x10BV[\x01a\x10qV[\x90a<=`\x04a<7a</`\x02a<)`\x0C\x87\x90a\x10BV[\x01a\x10qV[\x93`\x0Ca\x10BV[\x01a\x10qV[\x91aQ\x9BV[\x90V[a<ma<ha<ca<r\x93a<[a%\xBAV[P`\na4,V[a4BV[aSyV[a4EV[\x90V[\x90\x81a<\x91a<\x8Ba<\x86_a)#V[a\x06WV[\x91a\x06WV[\x14a=\x90W\x80a<\xA9a<\xA3_a(\xEBV[\x91a\x07-V[\x14a=tWa<\xCBa<\xC5a<\xC0`\r3\x90a\x14/V[a.#V[\x15a\x05AV[a=XWa<\xD83aO`V[a<\xEF`\x03a<\xE9`\x0C3\x90a\x10BV[\x01a\x10qV[a=\x01a<\xFB\x83a\x07-V[\x91a\x07-V[\x10a=<Wa=:\x91a=5\x82a=/`\x03a=\x1F`\x0C3\x90a\x10BV[\x01\x91a=*\x83a\x10qV[a+\x0BV[\x90a)\x8AV[aS\xEEV[V[_c\x1C\x95\x9E\xD9`\xE2\x1B\x81R\x80a=T`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_cD\x17v\t`\xE1\x1B\x81R\x80a=p`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a=\x8C`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a=\xA8`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90a=\xC7\x92\x91a=\xC2a=\xBDa#\x03V[aH\x8AV[a=\xC9V[V[\x80a=\xE4a=\xDEa=\xD9_a)#V[a\x06WV[\x91a\x06WV[\x14a@\nWa>\x06a>\0a=\xFB`\r\x84\x90a\x14/V[a.#V[\x15a\x05AV[\x80a?\xCFW[a?sW[\x81a>$a>\x1E_a(\xEBV[\x91a\x07-V[\x14\x80a?YW[\x80a??W[a>\xE4W[a>?\x81aO`V[a>V\x82_a>P`\x0C\x85\x90a\x10BV[\x01a)\x8AV[a>n\x83`\x02a>h`\x0C\x85\x90a\x10BV[\x01a)\x8AV[a>\x86\x82`\x01a>\x80`\x0C\x85\x90a\x10BV[\x01a)\x8AV[a>\x9E\x83`\x03a>\x98`\x0C\x85\x90a\x10BV[\x01a)\x8AV[\x90\x91a>\xCA\x7F\xAA\x80}\n\xBF0\xD9\x19h\xC7G\x8Cf\xB6\xD8%!\xA1\x06\xAF\x13\xED\xA06\xE2\x03m\xA9\xAF\x16\x89X\x92a\x106V[\x92a>\xDFa>\xD6a\x04\xE2V[\x92\x83\x92\x83a\n1V[\x03\x90\xA2V[a>\xF9_a>\xF4`\r\x84\x90a\x14/V[a)TV[\x80a?$\x7F\x02\xC2\xF0\xBA\x15\xB0?\x88\xB1\x8FH2`\x9A\x18\xCF5\xFCk?EF\xA9\x99 v\xD7E=\x134\xA8\x91a\x106V[\x90a?-a\x04\xE2V[\x80a?7\x81a\x08\xACV[\x03\x90\xA2a>6V[Pa?Ta?O`\r\x83\x90a\x14/V[a.#V[a>1V[P\x82a?ma?g_a(\xEBV[\x91a\x07-V[\x14a>+V[a?\x89`\x01a?\x84`\r\x84\x90a\x14/V[a)TV[\x80a?\xB4\x7Fl\xF2\x849\xA2\xDA\xAB\x1B&P\x97\"r\x12\xA5\xB7\x1E\nv\xF9\xED\x85\xE3\xF8\x15\xB5\xA6\xC3\xE2\x18\xEB\x7F\x91a\x106V[\x90a?\xBDa\x04\xE2V[\x80a?\xC7\x81a\x08\xACV[\x03\x90\xA2a>\x11V[P\x81a?\xE3a?\xDD_a(\xEBV[\x91a\x07-V[\x11\x80\x15a?\xF0W[a>\x0CV[P\x82a@\x04a?\xFE_a(\xEBV[\x91a\x07-V[\x11a?\xEBV[_c\xD9.#=`\xE0\x1B\x81R\x80a@\"`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90a@1\x92\x91a=\xACV[V[a@;a$\0V[Pa@F`Aa\x10qV[a@_a@Ya@Ta\x13\x04V[a\x07-V[\x91a\x07-V[\x10\x15\x90V[a@}\x90a@xa@sa#\x03V[aH\x8AV[a@\xBDV[V[\x90a@\x90`\x01\x80`\xA0\x1B\x03\x91a\x1B-V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x90a@\xB2a@\xADa@\xB9\x92a\x106V[a@\x9AV[\x82Ta@\x7FV[\x90UV[\x80a@\xD8a@\xD2a@\xCD_a)#V[a\x06WV[\x91a\x06WV[\x14aA>Wa@\xE7`Ca%UV[a@\xF2\x82`Ca@\x9DV[\x90aA&aA \x7F\x07\x01[j\x9F\x05\x911H\xFD_\xAD\xDF*\xCC\x97\x08\xF3\x05\x93\x7F0r\xCA+KF\xFA\xA5\xD0\x89\x8B\x93a\x106V[\x91a\x106V[\x91aA/a\x04\xE2V[\x80aA9\x81a\x08\xACV[\x03\x90\xA3V[_c\xD9.#=`\xE0\x1B\x81R\x80aAV`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[aAc\x90a@dV[V[aA\x82\x91aAqa$\0V[PaAzaHmV[\x91\x90\x91aIjV[`\x01\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11aA\x9CW` \x02\x90V[a\x0B\x86V[aA\xADaA\xB2\x91aA\x87V[a6'V[\x90V[\x90aA\xD3aA\xC2\x83aA\xA1V[\x92aA\xCD\x84\x91aA\x87V[\x90a:\xC7V[V[aA\xDF`0aA\xB5V[\x90V[\x90P\x90V[aA\xF1\x90Ta\x10]V[\x90V[`\x01\x01\x90V[aB\x16aB\x10aB\t\x83a\x0E\x17V[\x80\x94aA\xE2V[\x91a\x0E\x1DV[_\x91[\x83\x83\x10aB&WPPPPV[aBCaB=`\x01\x92aB8\x85aA\xE7V[a\x16\xC5V[\x92aA\xF4V[\x92\x01\x91\x90aB\x19V[\x90aBZ\x81a\x06\0\x93aA\xFAV[\x01\x90V[\x90aB~aBw\x92aBna\x04\xE2V[\x93\x84\x80\x92aBLV[\x03\x83a\x0B\x9AV[V[aB\x89\x90aB^V[\x90V[aB\x94aA\xD5V[PaB\x9F`\x0FaB\x80V[\x90V[\x90aB\xB5\x91aB\xAFa%\xBAV[Pa4aV[\x90V[\x90V[aB\xCFaB\xCAaB\xD4\x92aB\xB8V[a\x10\x0BV[a\x07-V[\x90V[aB\xDFa%\xBAV[PaB\xE8a%\xBAV[PaB\xF1a%\xBAV[PaB\xFAa$\0V[PaC\x05`@a\x10qV[aC\x17aC\x11_a(\xEBV[\x91a\x07-V[\x14aDVWaCAaC3BaC-`@a\x10qV[\x90a+\x0BV[aC;a\x1C\x96V[\x90a+\x98V[\x90aC\x83aCO`@a\x10qV[aC}aCoaC_`Aa\x10qV[aCi`\x01aB\xBBV[\x90a.?V[aCwa\x1C\x96V[\x90a+OV[\x90a.?V[aC\x8D`Aa\x10qV[aC\xA6aC\xA0aC\x9Ba\x13\x04V[a\x07-V[\x91a\x07-V[\x10_\x14aDHWaC\xCBaC\xC5`\x0FaC\xBF`Aa\x10qV[\x90a\x0E V[\x90a\x0EcV[[\x92aC\xD7`?a.#V[\x90\x81aD$W[P\x80aC\xFAW[\x91aC\xF0`Aa\x10qV[\x91\x93\x92\x91\x93\x92\x91\x90V[PaD\x05`Aa\x10qV[aD\x1EaD\x18aD\x13a\x13\x04V[a\x07-V[\x91a\x07-V[\x10aC\xE5V[\x90PaDAaD;aD6`Aa\x10qV[a\x07-V[\x91a\x07-V[\x11_aC\xDEV[aDQ_a(\xEBV[aC\xCCV[_\x90_\x91_\x91aDxaDraDl_\x94a(\xEBV[\x95a(\xEBV[\x93a(\xEBV[\x91\x90V[aD\x8E\x90aD\x88a%\xBAV[Pa<FV[\x90V[aD\x99a%\xBAV[PaD\xA2a(\xBBV[\x90V[`\x02aD\xBEaD\xC4\x92aD\xB6a%\xBAV[P`\x0Ca\x10BV[\x01a\x10qV[\x90V[\x7F\xE4\x83)\x05{\xFD\x03\xD5^I\xB5G\x13.9\xCF\xFD\x9C\x18 \xAD{\x9DLS\x07i\x14%\xD1Z\xDF\x90V[aE aE'\x94aE\x16``\x94\x98\x97\x95aE\x0C`\x80\x86\x01\x9A_\x87\x01\x90a\x0C\x9DV[` \x85\x01\x90a\x06cV[`@\x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[` \x01\x90V[\x93\x95\x94\x90\x92\x91\x95BaEIaEC\x89a\x07-V[\x91a\x07-V[\x11aE\xC2W\x91aE\xB4\x91aE\xBB\x93aE\xABaE\xC0\x98\x99aE\x93aEjaD\xC7V[aE\x84\x8B\x93\x8BaExa\x04\xE2V[\x95\x86\x94` \x86\x01aD\xEBV[` \x82\x01\x81\x03\x82R\x03\x82a\x0B\x9AV[aE\xA5aE\x9F\x82a\x06pV[\x91aE)V[ aTMV[\x92\x90\x91\x92aTjV[\x91\x82aT\xB4V[aQ\x10V[V[aE\xDD\x87_\x91\x82\x91c#A\xD7\x87`\xE1\x1B\x83R`\x04\x83\x01a\x07\xE1V[\x03\x90\xFD[\x7Fnq\xED\xAE\x12\xB1\xB9\x7FM\x1F`7\x0F\xEF\x10\x10_\xA2\xFA\xAE\x01&\x11J\x16\x9Cd\x84]a&\xC9\x90V[\x91\x94aFMaFW\x92\x98\x97\x95aFC`\xA0\x96aF9aF^\x9AaF/`\xC0\x8A\x01\x9E_\x8B\x01\x90a\x0C\x9DV[` \x89\x01\x90a\x06cV[`@\x87\x01\x90a\x06cV[``\x85\x01\x90a\x07\xD4V[`\x80\x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[\x91` aF\x81\x92\x94\x93aFz`@\x82\x01\x96_\x83\x01\x90a\x06cV[\x01\x90a\x06cV[V[\x96\x95\x91\x93\x92\x94\x90\x94BaF\x9EaF\x98\x83a\x07-V[\x91a\x07-V[\x11aGXW\x90aG\x07aG\x10\x94\x93\x92aF\xEFaF\xB8aE\xE1V[aF\xE0\x8C\x80\x94\x8C\x91aF\xCA\x8D\x91aT\xF7V[\x91\x92aF\xD4a\x04\xE2V[\x97\x88\x96` \x88\x01aF\x05V[` \x82\x01\x81\x03\x82R\x03\x82a\x0B\x9AV[aG\x01aF\xFB\x82a\x06pV[\x91aE)V[ aTMV[\x92\x90\x91\x92aTjV[\x80aG#aG\x1D\x87a\x06WV[\x91a\x06WV[\x03aG8WPaG6\x92\x93\x91\x90\x91aHzV[V[\x84\x90aGT_\x92\x83\x92c%\xC0\x07#`\xE1\x1B\x84R`\x04\x84\x01aF`V[\x03\x90\xFD[aGs\x90_\x91\x82\x91c1<\x89\x81`\xE1\x1B\x83R`\x04\x83\x01a\x07\xE1V[\x03\x90\xFD[\x90aG\x92\x91aG\x8DaG\x88\x82a-\xDBV[aH\x8AV[aG\x94V[V[\x90aG\x9E\x91aK\xF5V[PV[\x90aG\xAB\x91aGwV[V[\x90aG\xB7\x90a\x106V[_R` R`@_ \x90V[aG\xE8\x91aG\xDEaG\xE3\x92aG\xD6a%\xBAV[P`\x01aG\xADV[a8xV[a\x10qV[\x90V[aG\xF5`@a6'V[\x90V[_\x90V[_\x90V[aH\x08aG\xEBV[\x90` \x80\x83aH\x15aG\xF8V[\x81R\x01aH aG\xFCV[\x81RPPV[aH.aH\0V[\x90V[\x90aHD\x91aH>aH&V[PaU*V[\x90V[aHOa$\0V[PaHiaHcc\x01\xFF\xC9\xA7`\xE0\x1Ba\x04\xF4V[\x91a\x04\xF4V[\x14\x90V[aHua%8V[P3\x90V[\x91aH\x88\x92\x91`\x01\x92aURV[V[aH\x9C\x90aH\x96aHmV[\x90aV\x84V[V[`@\x90aH\xC7aH\xCE\x94\x96\x95\x93\x96aH\xBD``\x84\x01\x98_\x85\x01\x90a\x06cV[` \x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[\x90aH\xDB\x91\x03a\x07-V[\x90V[\x92\x91\x92aH\xEC\x81\x83\x90aG\xC3V[\x90\x81aI\x01aH\xFB_\x19a\x07-V[\x91a\x07-V[\x10aI\x0EW[PPP\x90PV[\x81aI!aI\x1B\x87a\x07-V[\x91a\x07-V[\x10aIGWaI>\x93\x94aI6\x91\x93\x92aH\xD0V[\x90_\x92aURV[\x80_\x80\x80aI\x07V[PaIf\x84\x92\x91\x92_\x93\x84\x93c}\xC7\xA0\xD9`\xE1\x1B\x85R`\x04\x85\x01aH\x9EV[\x03\x90\xFD[\x91\x82aI\x86aI\x80aI{_a)#V[a\x06WV[\x91a\x06WV[\x14aI\xE0W\x81aI\xA6aI\xA0aI\x9B_a)#V[a\x06WV[\x91a\x06WV[\x14aI\xB9WaI\xB7\x92\x91\x90\x91aV\xBFV[V[aI\xDCaI\xC5_a)#V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[aJ\x03aI\xEC_a)#V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[aJ\x0Fa7\x88V[aJ\x15WV[_c\xD9<\x06e`\xE0\x1B\x81R\x80aJ-`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x80aJLaJFaJA_a)#V[a\x06WV[\x91a\x06WV[\x14aJhWaJf\x91aJ^_a)#V[\x91\x90\x91aV\xBFV[V[aJ\x8BaJt_a)#V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[aJ\x97a$\0V[PaJ\xACaJ\xA6\x82\x84\x90a;\x93V[\x15a\x05AV[_\x14aK5WaJ\xD4`\x01aJ\xCF_aJ\xC7`\x05\x86\x90a-\xA1V[\x01\x85\x90a\x14/V[a)TV[\x90aJ\xDDaHmV[\x90aK\x1AaK\x14aK\x0E\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a-\x95V[\x92a\x106V[\x92a\x106V[\x92aK#a\x04\xE2V[\x80aK-\x81a\x08\xACV[\x03\x90\xA4`\x01\x90V[PP_\x90V[aKCa-\x91V[PaKM0a:\x87V[aK\x7FaKy\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x06WV[\x91a\x06WV[\x14\x80aK\xBBW[_\x14aK\xB0W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[aK\xB8aW?V[\x90V[PFaK\xEFaK\xE9\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x07-V[\x91a\x07-V[\x14aK\x86V[aK\xFDa$\0V[PaL\t\x81\x83\x90a;\x93V[_\x14aL\x91WaL0_aL+_aL#`\x05\x86\x90a-\xA1V[\x01\x85\x90a\x14/V[a)TV[\x90aL9aHmV[\x90aLvaLpaLj\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a-\x95V[\x92a\x106V[\x92a\x106V[\x92aL\x7Fa\x04\xE2V[\x80aL\x89\x81a\x08\xACV[\x03\x90\xA4`\x01\x90V[PP_\x90V[aL\xABaL\xA6aL\xB0\x92a\x18\xA3V[a\x10\x0BV[a\x07-V[\x90V[\x91` aL\xD4\x92\x94\x93aL\xCD`@\x82\x01\x96_\x83\x01\x90a\x07\xD4V[\x01\x90a\x18\xAEV[V[aL\xDEa;\xBDV[PaL\xE7a;\xC1V[\x81aL\xFAaL\xF4\x83aL\x97V[\x91a\x07-V[\x10\x15aM\rWPaM\n\x90aXEV[\x90V[\x90aM(_\x92\x83\x92cvi\xFC\x0F`\xE1\x1B\x84R`\x04\x84\x01aL\xB3V[\x03\x90\xFD[T\x90V[\x90V[aMGaMBaML\x92aM0V[a\x10\x0BV[a\x07-V[\x90V[\x90V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[aMiaMn\x91a\x10XV[aMRV[\x90V[aM{\x90TaM]V[\x90V[`0\x1C\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[aM\x9BaM\xA0\x91aM~V[aM\x84V[\x90V[aM\xAD\x90TaM\x8FV[\x90V[aM\xC4aM\xBFaM\xC9\x92a\x1B*V[a\x10\x0BV[a\"8V[\x90V[\x90aN \x90aM\xD9a#kV[PaM\xE5_\x84\x01aM,V[aM\xEE_a(\xEBV[\x90\x80\x80aN\x04aM\xFE`\x05aM3V[\x91a\x07-V[\x11aN\x81W[P\x90aN\x1B_\x86\x01\x93\x91\x92\x93aMOV[a^\x80V[\x80aN3aN-_a(\xEBV[\x91a\x07-V[\x14_\x14aNIWPPaNE_aM\xB0V[[\x90V[aNv_\x91aNqaNk\x84aN|\x96\x01\x92aNe`\x01aB\xBBV[\x90a+\x0BV[\x91aMOV[a^vV[\x01aM\xA3V[aNFV[\x80aN\x8FaN\x95\x92\x91a[\x0BV[\x90a+\x0BV[\x90\x83aN\xC7aN\xC1aN\xBC_aN\xB6\x81\x8C\x01aN\xB1\x89\x91aMOV[a^vV[\x01aMqV[a\x18\xA3V[\x91a\x18\xA3V[\x10_\x14aN\xD8WP\x90[\x90_aN\nV[\x91PaN\xEE\x90aN\xE8`\x01aB\xBBV[\x90a.?V[aN\xD1V[aN\xFBa_\x0FV[aO\x03aO\x05V[V[aO\x10_`\x0Ea)TV[aO\x18aHmV[aON\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA\x91aOEa\x04\xE2V[\x91\x82\x91\x82a\x11\xFEV[\x03\x90\xA1V[aO[aN\xF3V[V[\x90V[aOnaOs\x91`\x0Ca\x10BV[aO]V[aO\x7F`\x04\x82\x01a\x10qV[aO\x91aO\x8B_a(\xEBV[\x91a\x07-V[\x14aP\xEBWaP\r\x90aO\xB0BaO\xAA`\x04\x84\x01a\x10qV[\x90a+\x0BV[\x80aO\xCAaO\xC4aO\xBFa\x19YV[a\x07-V[\x91a\x07-V[\x10\x15_\x14aP\x0FWPaO\xEAaO\xE1_\x83\x01a\x10qV[`\x01\x83\x01a)\x8AV[aP\x02aO\xF9`\x02\x83\x01a\x10qV[`\x03\x83\x01a)\x8AV[[`\x04B\x91\x01a)\x8AV[V[\x80aP\"aP\x1C_a(\xEBV[\x91a\x07-V[\x11aP.W[PaP\x03V[aP\xDCaP\xCAaP\xE5\x92aP\xB9aP\xB0aP\x9FaP\x8DaP\x7FaPmaP_aPX_\x8D\x01a\x10qV[\x88\x90a+OV[aPga\x19YV[\x90a+\x98V[\x95aPz`\x02\x8C\x01a\x10qV[a+OV[aP\x87a\x19YV[\x90a+\x98V[\x93aP\x9A`\x01\x8A\x01a\x10qV[a.?V[aP\xAA_\x89\x01a\x10qV[\x90a_BV[`\x01\x87\x01a)\x8AV[aP\xC5`\x03\x86\x01a\x10qV[a.?V[aP\xD6`\x02\x85\x01a\x10qV[\x90a_BV[`\x03\x83\x01a)\x8AV[_aP(V[aP\xF9\x90`\x04B\x91\x01a)\x8AV[V[aQ\x03a;\xBDV[PaQ\rCaXEV[\x90V[\x90aQ\x99\x91aQ\x93aQ!\x82a7-V[aQ6\x84aQ1`\t\x86\x90a7\x17V[a@\x9DV[\x82\x81\x85\x90aQvaQpaQj\x7F14\xE8\xA2\xE6\xD9~\x92\x9A~T\x01\x1E\xA5H]}\x19m\xD5\xF0\xBAMN\xF9X\x03\xE8\xE3\xFC%\x7F\x95a\x106V[\x92a\x106V[\x92a\x106V[\x92aQ\x7Fa\x04\xE2V[\x80aQ\x89\x81a\x08\xACV[\x03\x90\xA4\x92\x91a_rV[\x91a_\x8AV[V[\x90\x91aQ\xA5a%\xBAV[P\x80aQ\xB9aQ\xB3_a(\xEBV[\x91a\x07-V[\x14aR8WaQ\xC8\x90Ba+\x0BV[\x90\x81aQ\xE3aQ\xDDaQ\xD8a\x19YV[a\x07-V[\x91a\x07-V[\x10\x15aR3WaR\x07aQ\xF9aR\r\x93\x85a+OV[aR\x01a\x19YV[\x90a+\x98V[\x90a.?V[\x80aR aR\x1A\x84a\x07-V[\x91a\x07-V[\x11_\x14aR,WP[\x90V[\x90PaR)V[PP\x90V[PPPaRD_a(\xEBV[\x90V[aRnaRiaRdaRs\x93aR\\a8_V[P`\na4,V[a4BV[aa8V[aa\xB7V[\x90V[aR\x88\x90aR\x82a%\xBAV[Pab\x08V[\x90V[aR\x93aJ\x07V[aR\x9BaR\x9DV[V[aR\xA9`\x01`\x0Ea)TV[aR\xB1aHmV[aR\xE7\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X\x91aR\xDEa\x04\xE2V[\x91\x82\x91\x82a\x11\xFEV[\x03\x90\xA1V[aR\xF4aR\x8BV[V[\x90V[aS\x01a$DV[PaS6\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aS0`\x06aR\xF6V[\x90ac#V[\x90V[aSAa$DV[PaSv\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aSp`\x07aR\xF6V[\x90ac#V[\x90V[aS\x81a#kV[PaS\x8D_\x82\x01aM,V[\x80aS\xA0aS\x9A_a(\xEBV[\x91a\x07-V[\x14_\x14aS\xB6WPPaS\xB2_aM\xB0V[[\x90V[aS\xE3_\x91aS\xDEaS\xD8\x84aS\xE9\x96\x01\x92aS\xD2`\x01aB\xBBV[\x90a+\x0BV[\x91aMOV[a^vV[\x01aM\xA3V[aS\xB3V[\x90\x81aT\naT\x04aS\xFF_a)#V[a\x06WV[\x91a\x06WV[\x14aT&WaT$\x91\x90aT\x1D_a)#V[\x90\x91aV\xBFV[V[aTIaT2_a)#V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[aTg\x90aTYa-\x91V[PaTbaK;V[acqV[\x90V[\x92aT\x85\x92aT\x8E\x94aT{a%8V[P\x92\x90\x91\x92ad'V[\x90\x92\x91\x92aeRV[\x90V[\x91` aT\xB2\x92\x94\x93aT\xAB`@\x82\x01\x96_\x83\x01\x90a\x06cV[\x01\x90a\x07\xD4V[V[aT\xBD\x81aT\xF7V[\x91aT\xD0aT\xCA\x84a\x07-V[\x91a\x07-V[\x03aT\xD9WPPV[aT\xF3_\x92\x83\x92c\x01\xD4\xB6#`\xE6\x1B\x84R`\x04\x84\x01aT\x91V[\x03\x90\xFD[aU\x0B\x90aU\x03a%\xBAV[P`\x08a8xV[aU'aU\x17\x82a\x10qV[\x91aU!\x83a.0V[\x90a)\x8AV[\x90V[\x90aUJaUEaUO\x93aU=aH&V[P`\na4,V[a4BV[af\xB4V[\x90V[\x90\x92\x81aUoaUiaUd_a)#V[a\x06WV[\x91a\x06WV[\x14aV:W\x83aU\x8FaU\x89aU\x84_a)#V[a\x06WV[\x91a\x06WV[\x14aV\x13WaU\xB3\x83aU\xAEaU\xA7`\x01\x86\x90aG\xADV[\x87\x90a8xV[a)\x8AV[aU\xBDW[PPPV[\x91\x90\x91aV\x08aU\xF6aU\xF0\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%\x93a\x106V[\x93a\x106V[\x93aU\xFFa\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xA3_\x80\x80aU\xB8V[aV6aV\x1F_a)#V[_\x91\x82\x91cJ\x14\x06\xB1`\xE1\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[aV]aVF_a)#V[_\x91\x82\x91c\xE6\x02\xDF\x05`\xE0\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[\x91` aV\x82\x92\x94\x93aV{`@\x82\x01\x96_\x83\x01\x90a\x06cV[\x01\x90a\x0C\x9DV[V[\x90aV\x99aV\x93\x83\x83\x90a;\x93V[\x15a\x05AV[aV\xA1WPPV[aV\xBB_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01aVaV[\x03\x90\xFD[\x91aV\xCC\x92\x91\x90\x91af\xD5V[V[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[\x90\x95\x94\x92aW=\x94aW,aW6\x92aW\"`\x80\x96aW\x18`\xA0\x88\x01\x9C_\x89\x01\x90a\x0C\x9DV[` \x87\x01\x90a\x0C\x9DV[`@\x85\x01\x90a\x0C\x9DV[``\x83\x01\x90a\x07\xD4V[\x01\x90a\x06cV[V[aWGa-\x91V[PaWPaV\xCEV[aW\xC7\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91aW\xB8\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0FaW\xA30a:\x87V[\x91aW\xACa\x04\xE2V[\x96\x87\x95` \x87\x01aV\xF2V[` \x82\x01\x81\x03\x82R\x03\x82a\x0B\x9AV[aW\xD9aW\xD3\x82a\x06pV[\x91aE)V[ \x90V[aW\xF1aW\xECaW\xF6\x92a\x12\xE5V[a\x10\x0BV[a\r\x88V[\x90V[aX\x02\x90aW\xDDV[\x90RV[\x91` aX'\x92\x94\x93aX `@\x82\x01\x96_\x83\x01\x90aW\xF9V[\x01\x90a\x07\xD4V[V[aX=aX8aXB\x92a\x07-V[a\x10\x0BV[a\x18\xA3V[\x90V[aXMa;\xBDV[P\x80aXgaXae\xFF\xFF\xFF\xFF\xFF\xFFaL\x97V[\x91a\x07-V[\x11aXxWaXu\x90aX)V[\x90V[`0aX\x94_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01aX\x06V[\x03\x90\xFD[\x90V[aX\xAFaX\xAAaX\xB4\x92aX\x98V[a\x10\x0BV[a\x07-V[\x90V[\x90V[aX\xCEaX\xC9aX\xD3\x92aX\xB7V[a\x10\x0BV[a\r\x88V[\x90V[aX\xF5\x90aX\xEFaX\xE9aX\xFA\x94a\r\x88V[\x91a\x07-V[\x90a\tMV[a\x07-V[\x90V[\x90V[aY\x14aY\x0FaY\x19\x92aX\xFDV[a\x10\x0BV[a\r\x88V[\x90V[aY;\x90aY5aY/aY@\x94a\r\x88V[\x91a\x07-V[\x90a&\tV[a\x07-V[\x90V[\x90V[aYZaYUaY_\x92aYCV[a\x10\x0BV[a\x07-V[\x90V[\x90V[aYyaYtaY~\x92aYbV[a\x10\x0BV[a\r\x88V[\x90V[\x90V[aY\x98aY\x93aY\x9D\x92aY\x81V[a\x10\x0BV[a\x07-V[\x90V[\x90V[aY\xB7aY\xB2aY\xBC\x92aY\xA0V[a\x10\x0BV[a\r\x88V[\x90V[\x90V[aY\xD6aY\xD1aY\xDB\x92aY\xBFV[a\x10\x0BV[a\x07-V[\x90V[\x90V[aY\xF5aY\xF0aY\xFA\x92aY\xDEV[a\x10\x0BV[a\r\x88V[\x90V[\x90V[aZ\x14aZ\x0FaZ\x19\x92aY\xFDV[a\x10\x0BV[a\x07-V[\x90V[\x90V[aZ3aZ.aZ8\x92aZ\x1CV[a\x10\x0BV[a\r\x88V[\x90V[aZOaZJaZT\x92aY\xA0V[a\x10\x0BV[a\x07-V[\x90V[\x90V[aZnaZiaZs\x92aZWV[a\x10\x0BV[a\r\x88V[\x90V[aZ\x8AaZ\x85aZ\x8F\x92aZ\x1CV[a\x10\x0BV[a\x07-V[\x90V[aZ\xA6aZ\xA1aZ\xAB\x92aB\xB8V[a\x10\x0BV[a\r\x88V[\x90V[\x90V[aZ\xC5aZ\xC0aZ\xCA\x92aZ\xAEV[a\x10\x0BV[a\x07-V[\x90V[\x90aZ\xD8\x91\x02a\x07-V[\x90V[aZ\xE7aZ\xED\x91a\x07-V[\x91a\x07-V[\x90\x81\x15aZ\xF8W\x04\x90V[a+\x84V[\x90a[\x08\x91\x01a\x07-V[\x90V[a[\x13a%\xBAV[P\x80a[(a[\"`\x01aB\xBBV[\x91a\x07-V[\x11\x15a^sW\x80a]=a]\x1Aa]\na\\\xFAa\\\xEAa\\\xDAa\\\xCAa\\\xBAa\\\xAAa\\\x9Aa\\\x8A\x8Ba\\\x84a\\}a]C\x9Fa\\]a\\Ma\\m\x92a[o`\x01aB\xBBV[\x90\x80a[\x87a[\x81`\x01`\x80\x1BaX\x9BV[\x91a\x07-V[\x10\x15a^EW[\x80a[\xAAa[\xA4h\x01\0\0\0\0\0\0\0\0aYFV[\x91a\x07-V[\x10\x15a^\x17W[\x80a[\xC9a[\xC3d\x01\0\0\0\0aY\x84V[\x91a\x07-V[\x10\x15a]\xE9W[\x80a[\xE6a[\xE0b\x01\0\0aY\xC2V[\x91a\x07-V[\x10\x15a]\xBBW[\x80a\\\x02a[\xFCa\x01\0aZ\0V[\x91a\x07-V[\x10\x15a]\x8DW[\x80a\\\x1Da\\\x17`\x10aZ;V[\x91a\x07-V[\x10\x15a]_W[a\\7a\\1`\x04aZvV[\x91a\x07-V[\x10\x15a]FW[a\\H`\x03aZ\xB1V[aZ\xCDV[a\\W`\x01aZ\x92V[\x90aX\xD6V[a\\g\x81\x86aZ\xDBV[\x90aZ\xFDV[a\\w`\x01aZ\x92V[\x90aX\xD6V[\x80\x92aZ\xDBV[\x90aZ\xFDV[a\\\x94`\x01aZ\x92V[\x90aX\xD6V[a\\\xA4\x81\x8CaZ\xDBV[\x90aZ\xFDV[a\\\xB4`\x01aZ\x92V[\x90aX\xD6V[a\\\xC4\x81\x8AaZ\xDBV[\x90aZ\xFDV[a\\\xD4`\x01aZ\x92V[\x90aX\xD6V[a\\\xE4\x81\x88aZ\xDBV[\x90aZ\xFDV[a\\\xF4`\x01aZ\x92V[\x90aX\xD6V[a]\x04\x81\x86aZ\xDBV[\x90aZ\xFDV[a]\x14`\x01aZ\x92V[\x90aX\xD6V[\x91a]7a]1a],\x85\x80\x94aZ\xDBV[a\x07-V[\x91a\x07-V[\x11ageV[\x90aH\xD0V[\x90V[a]Z\x90a]T`\x01aZ\x92V[\x90aY\x1CV[a\\>V[a]va]\x87\x91a]p`\x04aZ\x1FV[\x90aX\xD6V[\x91a]\x81`\x02aZZV[\x90aY\x1CV[\x90a\\$V[a]\xA4a]\xB5\x91a]\x9E`\x08aY\xE1V[\x90aX\xD6V[\x91a]\xAF`\x04aZ\x1FV[\x90aY\x1CV[\x90a\\\tV[a]\xD2a]\xE3\x91a]\xCC`\x10aY\xA3V[\x90aX\xD6V[\x91a]\xDD`\x08aY\xE1V[\x90aY\x1CV[\x90a[\xEDV[a^\0a^\x11\x91a]\xFA` aYeV[\x90aX\xD6V[\x91a^\x0B`\x10aY\xA3V[\x90aY\x1CV[\x90a[\xD0V[a^.a^?\x91a^(`@aY\0V[\x90aX\xD6V[\x91a^9` aYeV[\x90aY\x1CV[\x90a[\xB1V[a^\\a^m\x91a^V`\x80aX\xBAV[\x90aX\xD6V[\x91a^g`@aY\0V[\x90aY\x1CV[\x90a[\x8EV[\x90V[_R` _ \x01\x90V[\x93\x91\x90\x92a^\x8Ca%\xBAV[P[\x81a^\xA1a^\x9B\x83a\x07-V[\x91a\x07-V[\x10\x15a_\x07Wa^\xB2\x82\x82\x90ag\x8FV[\x90a^\xC8_a^\xC2\x88\x85\x90a^vV[\x01aMqV[a^\xDAa^\xD4\x87a\x18\xA3V[\x91a\x18\xA3V[\x11_\x14a^\xEAWP\x91[\x91a^\x8EV[\x92\x91Pa_\x01\x90a^\xFB`\x01aB\xBBV[\x90a.?V[\x90a^\xE4V[\x92PP\x91P\x90V[a_ a_\x1Aa7\x88V[\x15a\x05AV[a_&WV[_c\x8D\xFC +`\xE0\x1B\x81R\x80a_>`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90a_Ka%\xBAV[P\x81a__a_Y\x83a\x07-V[\x91a\x07-V[\x10_\x14a_kWP[\x90V[\x90Pa_hV[a_\x84\x90a_~a%\xBAV[Pa8\x8EV[\x90V[\x90V[\x91\x90\x91\x80a_\xA0a_\x9A\x85a\x06WV[\x91a\x06WV[\x14\x15\x80aa\x1EW[a_\xB2W[PPPV[\x80a_\xCDa_\xC7a_\xC2_a)#V[a\x06WV[\x91a\x06WV[\x03a`\x8EW[P\x81a_\xEFa_\xE9a_\xE4_a)#V[a\x06WV[\x91a\x06WV[\x03a_\xFBW[\x80a_\xADV[a`Ba`5a`<\x92a`\x11`\n\x86\x90a4,V[\x90a`/a`)a`#`\x01\x93ah(V[\x93a4BV[\x91a_\x87V[\x90ah{V[\x92\x90a4EV[\x91a4EV[\x91\x90\x91a`o\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\x106V[\x92a`\x84a`{a\x04\xE2V[\x92\x83\x92\x83a\n1V[\x03\x90\xA2_\x80a_\xF5V[a`\xCDa`\xD3a`\xC6a`\xA3`\n\x85\x90a4,V[`\x02a`\xC0a`\xBAa`\xB4\x89ah(V[\x93a4BV[\x91a_\x87V[\x90ah{V[\x92\x90a4EV[\x91a4EV[\x91\x90\x91aa\0\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\x106V[\x92aa\x15aa\x0Ca\x04\xE2V[\x92\x83\x92\x83a\n1V[\x03\x90\xA2_a_\xD3V[P\x81aa2aa,_a(\xEBV[\x91a\x07-V[\x11a_\xA8V[_aaL\x91aaEa%\xBAV[P\x01aM,V[\x90V[aacaa^aah\x92a\x14\x93V[a\x10\x0BV[a\x07-V[\x90V[aat\x90aYeV[\x90RV[\x91` aa\x99\x92\x94\x93aa\x92`@\x82\x01\x96_\x83\x01\x90aakV[\x01\x90a\x07\xD4V[V[aa\xAFaa\xAAaa\xB4\x92a\x07-V[a\x10\x0BV[a\x14\x93V[\x90V[aa\xBFa8_V[P\x80aa\xD7aa\xD1c\xFF\xFF\xFF\xFFaaOV[\x91a\x07-V[\x11aa\xE8Waa\xE5\x90aa\x9BV[\x90V[` ab\x04_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01aaxV[\x03\x90\xFD[ab\x1Fab$\x91ab\x17a%\xBAV[P`\x08a8xV[a\x10qV[\x90V[\x90V[ab>ab9abC\x92ab'V[a\x1B-V[a\x0CYV[\x90V[abP`\xFFab*V[\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90abvabo\x83a\n\xB1V[\x80\x94a$IV[\x91`\x01\x81\x16\x90\x81_\x14ab\xCDWP`\x01\x14ab\x91W[PPPV[ab\x9E\x91\x92\x93\x94PabSV[\x91_\x92[\x81\x84\x10ab\xB5WPP\x01\x90_\x80\x80ab\x8CV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90ab\xA2V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80ab\x8CV[\x90ab\xF2\x91ab\\V[\x90V[\x90ac\x15ac\x0E\x92ac\x05a\x04\xE2V[\x93\x84\x80\x92ab\xE8V[\x03\x83a\x0B\x9AV[V[ac \x90ab\xF5V[\x90V[\x90ac,a$DV[Pac6\x82a-\x95V[acOacIacDabFV[a\x0CYV[\x91a\x0CYV[\x14\x15_\x14acdWPaca\x90ai\x05V[\x90V[acn\x91Pac\x17V[\x90V[`B\x91ac|a-\x91V[P`@Q\x91\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R`\x02\x83\x01R`\"\x82\x01R \x90V[_\x90V[ac\xC2ac\xC7\x91a\x10XV[a&2V[\x90V[\x90V[ac\xE1ac\xDCac\xE6\x92ac\xCAV[a\x10\x0BV[a\x07-V[\x90V[ad\x1Ead%\x94ad\x14``\x94\x98\x97\x95ad\n`\x80\x86\x01\x9A_\x87\x01\x90a\x0C\x9DV[` \x85\x01\x90a\r\x8EV[`@\x83\x01\x90a\x0C\x9DV[\x01\x90a\x0C\x9DV[V[\x93\x92\x93ad2a%8V[Pad;ac\xB2V[PadDa-\x91V[PadN\x85ac\xB6V[ad\x80adz\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0ac\xCDV[\x91a\x07-V[\x11ae\rW\x90ad\xA3` \x94\x95_\x94\x93\x92\x93ad\x9Aa\x04\xE2V[\x94\x85\x94\x85ac\xE9V[\x83\x80R\x03\x90`\x01Z\xFA\x15ae\x08Wad\xBB_Qa\x1B-V[\x80ad\xD6ad\xD0ad\xCB_a)#V[a\x06WV[\x91a\x06WV[\x14ad\xECW_\x91ad\xE6_a\x1B2V[\x91\x92\x91\x90V[Pad\xF6_a)#V[`\x01\x91ae\x02_a\x1B2V[\x91\x92\x91\x90V[a*\xFBV[PPPae\x19_a)#V[\x90`\x03\x92\x91\x92\x91\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x04\x11\x15aeAWV[ae#V[\x90aeP\x82ae7V[V[\x80aeeae__aeFV[\x91aeFV[\x14_\x14aepWPPV[\x80ae\x84ae~`\x01aeFV[\x91aeFV[\x14_\x14ae\xA7W_c\xF6E\xEE\xDF`\xE0\x1B\x81R\x80ae\xA3`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x80ae\xBBae\xB5`\x02aeFV[\x91aeFV[\x14_\x14ae\xE9Wae\xE5ae\xCE\x83ac\xB6V[_\x91\x82\x91c\xFC\xE6\x98\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x07\xE1V[\x03\x90\xFD[ae\xFCae\xF6`\x03aeFV[\x91aeFV[\x14af\x04WPV[af\x1F\x90_\x91\x82\x91c5\xE2\xF3\x83`\xE2\x1B\x83R`\x04\x83\x01a\x0C\xAAV[\x03\x90\xFD[_R` _ \x90V[af5\x81aM,V[\x82\x10\x15afOWafG`\x01\x91af#V[\x91\x02\x01\x90_\x90V[a\x0E\x03V[\x90af^\x90a\x18\xA3V[\x90RV[\x90afl\x90a\"8V[\x90RV[\x90af\xA6af\x9D_af\x80aG\xEBV[\x94af\x97af\x8F\x83\x83\x01aMqV[\x83\x88\x01afTV[\x01aM\xA3V[` \x84\x01afbV[V[af\xB1\x90afpV[\x90V[af\xD2\x91_af\xCC\x92af\xC5aH&V[P\x01af,V[Paf\xA8V[\x90V[\x92\x91af\xE3\x84\x83\x83\x91ai5V[\x83af\xFEaf\xF8af\xF3_a)#V[a\x06WV[\x91a\x06WV[\x14ag\x13W[ag\x11\x92\x93\x91\x90\x91aj\xBFV[V[ag\x1Ba(\xBBV[\x93ag$aj\xA4V[\x94\x80ag8ag2\x88a\x07-V[\x91a\x07-V[\x11agEWP\x93Pag\x04V[\x85\x90aga_\x92\x83\x92c\x0EX\xAE\x93`\xE1\x1B\x84R`\x04\x84\x01a\n1V[\x03\x90\xFD[agma%\xBAV[P\x15\x15\x90V[ag\x87ag\x82ag\x8C\x92aZWV[a\x10\x0BV[a\x07-V[\x90V[ag\xB4ag\xBA\x92ag\x9Ea%\xBAV[P\x82\x81\x16\x92\x18ag\xAE`\x02agsV[\x90a+\x98V[\x90a.?V[\x90V[\x90V[ag\xD4ag\xCFag\xD9\x92ag\xBDV[a\x10\x0BV[a\r\x88V[\x90V[ag\xE5\x90ag\xC0V[\x90RV[\x91` ah\n\x92\x94\x93ah\x03`@\x82\x01\x96_\x83\x01\x90ag\xDCV[\x01\x90a\x07\xD4V[V[ah ah\x1Bah%\x92a\x07-V[a\x10\x0BV[a\"8V[\x90V[ah0a#kV[P\x80ahJahD`\x01\x80`\xD0\x1B\x03a4EV[\x91a\x07-V[\x11ah[WahX\x90ah\x0CV[\x90V[`\xD0ahw_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01ag\xE9V[\x03\x90\xFD[\x90ah\xB1ah\xB7\x93\x92ah\x8Ca#kV[Pah\x95a#kV[P\x80\x93ah\xAAah\xA3a;\xC1V[\x94\x92aSyV[\x90\x91ao'V[\x91ak~V[\x91\x90\x91\x90V[ah\xD1ah\xCCah\xD6\x92aYbV[a\x10\x0BV[a\x07-V[\x90V[6\x907V[\x90ai\x03ah\xEB\x83a6_V[\x92` \x80ah\xF9\x86\x93a6<V[\x92\x01\x91\x03\x90ah\xD9V[V[ai\ra$DV[Pai\x17\x81ak\xE8V[\x90ai*ai%` ah\xBDV[ah\xDEV[\x91\x82R` \x82\x01R\x90V[\x91\x90\x91\x80aiSaiMaiH_a)#V[a\x06WV[\x91a\x06WV[\x14_\x14aj4Waiwaip\x83aik`\x02a\x10qV[a.?V[`\x02a)\x8AV[[\x82ai\x93ai\x8Dai\x88_a)#V[a\x06WV[\x91a\x06WV[\x14_\x14aj\x08Wai\xB7ai\xB0\x83ai\xAB`\x02a\x10qV[aH\xD0V[`\x02a)\x8AV[[\x91\x90\x91aj\x03ai\xF1ai\xEB\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a\x106V[\x93a\x106V[\x93ai\xFAa\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xA3V[aj/\x82aj)aj\x1A_\x87\x90a8xV[\x91aj$\x83a\x10qV[aZ\xFDV[\x90a)\x8AV[ai\xB8V[ajGajB_\x83\x90a8xV[a\x10qV[\x80ajZajT\x85a\x07-V[\x91a\x07-V[\x10aj\x82Wajmaj}\x91\x84\x90aH\xD0V[ajx_\x84\x90a8xV[a)\x8AV[aixV[\x90aj\xA0\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01aH\x9EV[\x03\x90\xFD[aj\xACa%\xBAV[Paj\xBC`\x01\x80`\xD0\x1B\x03a4EV[\x90V[\x91ak\x17ak\x11ak\x1E\x94\x80aj\xE5aj\xDFaj\xDA_a)#V[a\x06WV[\x91a\x06WV[\x14akOW[\x84ak\x06ak\0aj\xFB_a)#V[a\x06WV[\x91a\x06WV[\x14ak W[a7-V[\x92a7-V[\x90\x91a_\x8AV[V[akH`\x0B`\x02akBak<ak6\x89ah(V[\x93a4BV[\x91a_\x87V[\x90ah{V[PPak\x0CV[akw`\x0B`\x01akqakkake\x89ah(V[\x93a4BV[\x91a_\x87V[\x90ah{V[PPaj\xEBV[\x91ak\xA2_ak\xA7\x94ak\x8Fa#kV[Pak\x98a#kV[P\x01\x92\x91\x92aMOV[am\xD9V[\x91\x90\x91\x90V[ak\xC1ak\xBCak\xC6\x92ab'V[a\x10\x0BV[a\x07-V[\x90V[\x90V[ak\xE0ak\xDBak\xE5\x92ak\xC9V[a\x10\x0BV[a\x07-V[\x90V[ak\xFDal\x02\x91ak\xF7a%\xBAV[Pa-\x95V[ac\xB6V[al\x0C`\xFFak\xADV[\x16\x80al!al\x1B`\x1Fak\xCCV[\x91a\x07-V[\x11al)W\x90V[_c,\xD4J\xC3`\xE2\x1B\x81R\x80alA`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[T\x90V[alS`@a6'V[\x90V[_R` _ \x90V[alh\x81alEV[\x82\x10\x15al\x82Walz`\x01\x91alVV[\x91\x02\x01\x90_\x90V[a\x0E\x03V[al\x91\x90Qa\x18\xA3V[\x90V[\x90al\xA5e\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x1B-V[\x91\x81\x19\x16\x91\x16\x17\x90V[al\xC3al\xBEal\xC8\x92a\x18\xA3V[a\x10\x0BV[a\x18\xA3V[\x90V[\x90V[\x90al\xE3al\xDEal\xEA\x92al\xAFV[al\xCBV[\x82Tal\x94V[\x90UV[al\xF8\x90Qa\"8V[\x90V[`0\x1B\x90V[\x90am\x13e\xFF\xFF\xFF\xFF\xFF\xFF\x19\x91al\xFBV[\x91\x81\x19\x16\x91\x16\x17\x90V[am1am,am6\x92a\"8V[a\x10\x0BV[a\"8V[\x90V[\x90V[\x90amQamLamX\x92am\x1DV[am9V[\x82Tam\x01V[\x90UV[\x90am\x86` _am\x8C\x94am~\x82\x82\x01amx\x84\x88\x01al\x87V[\x90al\xCEV[\x01\x92\x01al\xEEV[\x90am<V[V[\x91\x90am\x9FWam\x9D\x91am\\V[V[a\n\x8AV[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15am\xD4W\x82am\xCC\x91`\x01am\xD2\x95\x01\x81Ual_V[\x90am\x8EV[V[a\x0B\x86V[\x90\x92\x91\x92am\xE5a#kV[Pam\xEEa#kV[Pam\xF8\x82alEV[\x80an\x0Ban\x05_a(\xEBV[\x91a\x07-V[\x11_\x14an\xDBWan1\x90an+\x84\x91an%`\x01aB\xBBV[\x90a+\x0BV[\x90a^vV[\x90an=_\x83\x01aMqV[\x92anI_\x84\x01aM\xA3V[\x93\x80an]anW\x85a\x18\xA3V[\x91a\x18\xA3V[\x11an\xBFWantann\x84a\x18\xA3V[\x91a\x18\xA3V[\x14_\x14an\x8FWPPan\x8A\x90_\x85\x91\x01am<V[[\x91\x90V[an\xBA\x92Pan\xB5\x86an\xACan\xA3alIV[\x94_\x86\x01afTV[` \x84\x01afbV[am\xA4V[an\x8BV[_c% `\x1D`\xE0\x1B\x81R\x80an\xD7`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[Pao\x06\x91ao\x01\x85an\xF8an\xEFalIV[\x94_\x86\x01afTV[` \x84\x01afbV[am\xA4V[ao\x0F_aM\xB0V[\x91\x90V[cNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[\x91\x90\x91\x80`\x01\x14aoFW`\x02\x03ao\x13WaoB\x91a#\xEAV[\x90[V[PaoP\x91a#\xABV[\x90aoDV",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610013575b612367565b61001d5f356104dc565b806301ffc9a7146104d757806306fdde03146104d257806307a1d5fa146104cd578063095ea7b3146104c85780630c05f82c146104c357806313beaa5b146104be57806318160ddd146104b95780631b02f845146104b457806322a97d9c146104af57806323b872dd146104aa57806323e460d2146104a55780632481bb5c146104a0578063248a9ca31461049b578063284e1333146104965780632f2ff15d14610491578063313ce5671461048c578063334d0bbd14610487578063359b76fe146104825780633644e5151461047d57806336568abe146104785780633a46b1a8146104735780633f4ba83a1461046e57806340c10f191461046957806344e181aa1461046457806348b0daa61461045f5780634bdd36ce1461045a5780634bf5d7e914610455578063587cde1e146104505780635adf00211461044b5780635c19a95c146104465780635c975abb146104415780635f15c3c91461043c578063651fd268146104375780636c33bced146104325780636cf016251461042d5780636fc063be146104285780636fcfff451461042357806370a082311461041e578063726600ce1461041957806376671808146104145780637c790cab1461040f5780637ecebe001461040a5780638456cb591461040557806384b0196e146104005780638e539e8c146103fb578063902d55a5146103f657806391d14854146103f157806391ddadf4146103ec57806395d89b41146103e757806399127d9b146103e2578063998955d3146103dd5780639ab24eb0146103d85780639b7ef64b146103d35780639dc29fac146103ce578063a08d5654146103c9578063a217fddf146103c4578063a3d4485b146103bf578063a4d7e31d146103ba578063a571e184146103b5578063a70b9f0c146103b0578063a9059cbb146103ab578063af2aa63b146103a6578063b0ca253e146103a1578063babc394f1461039c578063bb4d443614610397578063c02ae75414610392578063c1eb71371461038d578063c3cda52014610388578063d505accf14610383578063d547741f1461037e578063dd62ed3e14610379578063e3abdfcb14610374578063e63ab1e91461036f578063f1127ed81461036a578063f508e19d146103655763f75e85120361000e57612332565b6122ce565b612289565b6121a6565b612142565b6120dd565b61207c565b612042565b611f98565b611edc565b611ea7565b611e72565b611e39565b611dc5565b611d90565b611ce5565b611cb0565b611c44565b611c0f565b611bda565b611b65565b611af6565b611a88565b611a53565b6119dd565b6119a8565b611973565b611905565b6118d0565b61186d565b611838565b6117dd565b6117a1565b61165c565b611627565b6115ee565b61156c565b611528565b6114f3565b6114be565b61145e565b6113fa565b611386565b611351565b61131c565b6112b0565b61127d565b611248565b611213565b6111c9565b611194565b61115f565b611117565b610fd7565b610fa4565b610f6e565b610f3a565b610f05565b610ed2565b610e9d565b610db0565b610d54565b610cf4565b610cbf565b610c24565b610a54565b6109fb565b61098c565b61091a565b6108e5565b6108b1565b6107f6565b610780565b6106d4565b610617565b610568565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b610509816104f4565b0361051057565b5f80fd5b9050359061052182610500565b565b9060208282031261053c57610539915f01610514565b90565b6104ec565b151590565b61054f90610541565b9052565b9190610566905f60208501940190610546565b565b346105985761059461058361057e366004610523565b612404565b61058b6104e2565b91829182610553565b0390f35b6104e8565b5f9103126105a757565b6104ec565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b6105ed6105f66020936105fb936105e4816105ac565b938480936105b0565b958691016105b9565b6105c4565b0190565b6106149160208201915f8184039101526105ce565b90565b346106475761062736600461059d565b610643610632612522565b61063a6104e2565b918291826105ff565b0390f35b6104e8565b60018060a01b031690565b6106609061064c565b90565b61066c90610657565b9052565b5190565b60209181520190565b61069c6106a56020936106aa9361069381610670565b93848093610674565b958691016105b9565b6105c4565b0190565b916106d1926106c460408201935f830190610663565b602081840391015261067d565b90565b34610705576106e436600461059d565b6106ec61256e565b906107016106f86104e2565b928392836106ae565b0390f35b6104e8565b61071381610657565b0361071a57565b5f80fd5b9050359061072b8261070a565b565b90565b6107398161072d565b0361074057565b5f80fd5b9050359061075182610730565b565b919060408382031261077b578061076f610778925f860161071e565b93602001610744565b90565b6104ec565b346107b1576107ad61079c610796366004610753565b90612598565b6107a46104e2565b91829182610553565b0390f35b6104e8565b906020828203126107cf576107cc915f0161071e565b90565b6104ec565b6107dd9061072d565b9052565b91906107f4905f602085019401906107d4565b565b346108265761082261081161080c3660046107b6565b6125be565b6108196104e2565b918291826107e1565b0390f35b6104e8565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156108715781359167ffffffffffffffff831161086c57602001926001830284011161086757565b610833565b61082f565b61082b565b906020828203126108a7575f82013567ffffffffffffffff81116108a25761089e9201610837565b9091565b6104f0565b6104ec565b5f0190565b346108e0576108ca6108c4366004610876565b906128af565b6108d26104e2565b806108dc816108ac565b0390f35b6104e8565b34610915576108f536600461059d565b6109116109006128bb565b6109086104e2565b918291826107e1565b0390f35b6104e8565b346109485761092a36600461059d565b610932612a7f565b61093a6104e2565b80610944816108ac565b0390f35b6104e8565b1c90565b60ff1690565b61096790600861096c930261094d565b610951565b90565b9061097a9154610957565b90565b610989603f5f9061096f565b90565b346109bc5761099c36600461059d565b6109b86109a761097d565b6109af6104e2565b91829182610553565b0390f35b6104e8565b90916060828403126109f6576109f36109dc845f850161071e565b936109ea816020860161071e565b93604001610744565b90565b6104ec565b34610a2c57610a28610a17610a113660046109c1565b91612a89565b610a1f6104e2565b91829182610553565b0390f35b6104e8565b916020610a52929493610a4b60408201965f8301906107d4565b01906107d4565b565b34610a8557610a6c610a673660046107b6565b612bba565b90610a81610a786104e2565b92839283610a31565b0390f35b6104e8565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610ad1575b6020831014610acc57565b610a9d565b91607f1691610ac1565b60209181520190565b5f5260205f2090565b905f9291805490610b07610b0083610ab1565b8094610adb565b916001811690815f14610b5e5750600114610b22575b505050565b610b2f9192939450610ae4565b915f925b818410610b4657505001905f8080610b1d565b60018160209295939554848601520191019290610b33565b92949550505060ff19168252151560200201905f8080610b1d565b90610b8391610aed565b90565b634e487b7160e01b5f52604160045260245ffd5b90610ba4906105c4565b810190811067ffffffffffffffff821117610bbe57604052565b610b86565b90610be3610bdc92610bd36104e2565b93848092610b79565b0383610b9a565b565b905f10610bf857610bf590610bc3565b90565b610a8a565b610c0960445f90610be5565b90565b610c219160208201915f81840391015261067d565b90565b34610c5457610c3436600461059d565b610c50610c3f610bfd565b610c476104e2565b91829182610c0c565b0390f35b6104e8565b90565b610c6581610c59565b03610c6c57565b5f80fd5b90503590610c7d82610c5c565b565b90602082820312610c9857610c95915f01610c70565b90565b6104ec565b610ca690610c59565b9052565b9190610cbd905f60208501940190610c9d565b565b34610cef57610ceb610cda610cd5366004610c7f565b612ddb565b610ce26104e2565b91829182610caa565b0390f35b6104e8565b34610d2257610d0436600461059d565b610d0c6132b2565b610d146104e2565b80610d1e816108ac565b0390f35b6104e8565b9190604083820312610d4f5780610d43610d4c925f8601610c70565b9360200161071e565b90565b6104ec565b34610d8357610d6d610d67366004610d27565b906132e6565b610d756104e2565b80610d7f816108ac565b0390f35b6104e8565b60ff1690565b610d9790610d88565b9052565b9190610dae905f60208501940190610d8e565b565b34610de057610dc036600461059d565b610ddc610dcb613315565b610dd36104e2565b91829182610d9b565b0390f35b6104e8565b90602082820312610dfe57610dfb915f01610744565b90565b6104ec565b634e487b7160e01b5f52603260045260245ffd5b50603090565b90565b610e2981610e17565b821015610e4357610e3b600191610e1d565b910201905f90565b610e03565b90565b610e5b906008610e60930261094d565b610e48565b90565b90610e6e9154610e4b565b90565b600f610e7c81610e17565b821015610e9957610e9691610e9091610e20565b90610e63565b90565b5f80fd5b34610ecd57610ec9610eb8610eb3366004610de5565b610e71565b610ec06104e2565b918291826107e1565b0390f35b6104e8565b34610f0057610ee236600461059d565b610eea6133c6565b610ef26104e2565b80610efc816108ac565b0390f35b6104e8565b34610f3557610f1536600461059d565b610f31610f206133d0565b610f286104e2565b91829182610caa565b0390f35b6104e8565b34610f6957610f53610f4d366004610d27565b906133e4565b610f5b6104e2565b80610f65816108ac565b0390f35b6104e8565b34610f9f57610f9b610f8a610f84366004610753565b90613461565b610f926104e2565b918291826107e1565b0390f35b6104e8565b34610fd257610fb436600461059d565b610fbc6134bf565b610fc46104e2565b80610fce816108ac565b0390f35b6104e8565b3461100657610ff0610fea366004610753565b906134c9565b610ff86104e2565b80611002816108ac565b0390f35b6104e8565b90565b61102261101d6110279261064c565b61100b565b61064c565b90565b6110339061100e565b90565b61103f9061102a565b90565b9061104c90611036565b5f5260205260405f2090565b5f1c90565b61106961106e91611058565b610e48565b90565b61107b905461105d565b90565b61108990600c611042565b6110945f8201611071565b916110a160018301611071565b916110ae60028201611071565b916110c760046110c060038501611071565b9301611071565b90565b909594926111159461110461110e926110fa6080966110f060a088019c5f8901906107d4565b60208701906107d4565b60408501906107d4565b60608301906107d4565b01906107d4565b565b3461114b5761114761113261112d3660046107b6565b61107e565b9161113e9593956104e2565b958695866110ca565b0390f35b6104e8565b61115c60405f90610e63565b90565b3461118f5761116f36600461059d565b61118b61117a611150565b6111826104e2565b918291826107e1565b0390f35b6104e8565b346111c4576111a436600461059d565b6111c06111af613600565b6111b76104e2565b918291826107e1565b0390f35b6104e8565b346111f9576111d936600461059d565b6111f56111e46136c1565b6111ec6104e2565b918291826105ff565b0390f35b6104e8565b9190611211905f60208501940190610663565b565b346112435761123f61122e6112293660046107b6565b61372d565b6112366104e2565b918291826111fe565b0390f35b6104e8565b346112785761125836600461059d565b61127461126361374c565b61126b6104e2565b91829182610553565b0390f35b6104e8565b346112ab576112956112903660046107b6565b613775565b61129d6104e2565b806112a7816108ac565b0390f35b6104e8565b346112e0576112c036600461059d565b6112dc6112cb613788565b6112d36104e2565b91829182610553565b0390f35b6104e8565b90565b6112fc6112f7611301926112e5565b61100b565b61072d565b90565b61130e60306112e8565b90565b611319611304565b90565b3461134c5761132c36600461059d565b611348611337611311565b61133f6104e2565b918291826107e1565b0390f35b6104e8565b346113815761137d61136c6113673660046107b6565b61379e565b6113746104e2565b918291826107e1565b0390f35b6104e8565b346113b45761139636600461059d565b61139e613855565b6113a66104e2565b806113b0816108ac565b0390f35b6104e8565b90565b6113d06113cb6113d5926113b9565b61100b565b61072d565b90565b6113ec6a084595161401484a0000006113bc565b90565b6113f76113d8565b90565b3461142a5761140a36600461059d565b6114266114156113ef565b61141d6104e2565b918291826107e1565b0390f35b6104e8565b9061143990611036565b5f5260205260405f2090565b61145b90611456600d915f9261142f565b61096f565b90565b3461148e5761148a6114796114743660046107b6565b611445565b6114816104e2565b91829182610553565b0390f35b6104e8565b63ffffffff1690565b6114a590611493565b9052565b91906114bc905f6020850194019061149c565b565b346114ee576114ea6114d96114d43660046107b6565b613863565b6114e16104e2565b918291826114a9565b0390f35b6104e8565b346115235761151f61150e6115093660046107b6565b61388e565b6115166104e2565b918291826107e1565b0390f35b6104e8565b346115585761155461154361153e3660046107b6565b6138ac565b61154b6104e2565b91829182610553565b0390f35b6104e8565b61156960415f90610e63565b90565b3461159c5761157c36600461059d565b61159861158761155d565b61158f6104e2565b918291826107e1565b0390f35b6104e8565b909594926115ec946115db6115e5926115d16080966115c760a088019c5f890190610546565b60208701906107d4565b60408501906107d4565b60608301906107d4565b01906107d4565b565b346116225761161e6116096116043660046107b6565b6138cb565b916116159593956104e2565b958695866115a1565b0390f35b6104e8565b346116575761165361164261163d3660046107b6565b613a3b565b61164a6104e2565b918291826107e1565b0390f35b6104e8565b3461168a5761166c36600461059d565b611674613a74565b61167c6104e2565b80611686816108ac565b0390f35b6104e8565b60ff60f81b1690565b6116a19061168f565b9052565b5190565b60209181520190565b60200190565b6116c19061072d565b9052565b906116d2816020936116b8565b0190565b60200190565b906116f96116f36116ec846116a5565b80936116a9565b926116b2565b905f5b8181106117095750505090565b90919261172261171c60019286516116c5565b946116d6565b91019190916116fc565b9395919461177d611772611791956117646117879561179e9c9a61175760e08c01925f8d0190611698565b8a820360208c01526105ce565b9088820360408a01526105ce565b9760608701906107d4565b6080850190610663565b60a0830190610c9d565b60c08184039101526116dc565b90565b346117d8576117b136600461059d565b6117d46117bc613afb565b936117cb9795979391936104e2565b9788978861172c565b0390f35b6104e8565b346117f2576117ed366004610de5565b613b85565b6104e8565b90565b61180e611809611813926117f7565b61100b565b61072d565b90565b61182a6a52b7d2dcc80cd2e40000006117fa565b90565b611835611816565b90565b346118685761184836600461059d565b61186461185361182d565b61185b6104e2565b918291826107e1565b0390f35b6104e8565b3461189e5761189a611889611883366004610d27565b90613b93565b6118916104e2565b91829182610553565b0390f35b6104e8565b65ffffffffffff1690565b6118b7906118a3565b9052565b91906118ce905f602085019401906118ae565b565b34611900576118e036600461059d565b6118fc6118eb613bc1565b6118f36104e2565b918291826118bb565b0390f35b6104e8565b346119355761191536600461059d565b611931611920613bd5565b6119286104e2565b918291826105ff565b0390f35b6104e8565b90565b61195161194c6119569261193a565b61100b565b61072d565b90565b6119656201518061193d565b90565b611970611959565b90565b346119a35761198336600461059d565b61199f61198e611968565b6119966104e2565b918291826107e1565b0390f35b6104e8565b346119d8576119d46119c36119be3660046107b6565b613beb565b6119cb6104e2565b918291826107e1565b0390f35b6104e8565b34611a0d57611a096119f86119f33660046107b6565b613c46565b611a006104e2565b918291826107e1565b0390f35b6104e8565b90565b611a29611a24611a2e92611a12565b61100b565b61072d565b90565b611a456a4a723dc6b40b8a9a000000611a15565b90565b611a50611a31565b90565b34611a8357611a6336600461059d565b611a7f611a6e611a48565b611a766104e2565b918291826107e1565b0390f35b6104e8565b34611ab757611aa1611a9b366004610753565b90613c75565b611aa96104e2565b80611ab3816108ac565b0390f35b6104e8565b9091606082840312611af157611aee611ad7845f850161071e565b93611ae58160208601610744565b93604001610744565b90565b6104ec565b34611b2557611b0f611b09366004611abc565b91614026565b611b176104e2565b80611b21816108ac565b0390f35b6104e8565b90565b5f1b90565b611b46611b41611b4b92611b2a565b611b2d565b610c59565b90565b611b575f611b32565b90565b611b62611b4e565b90565b34611b9557611b7536600461059d565b611b91611b80611b5a565b611b886104e2565b91829182610caa565b0390f35b6104e8565b60018060a01b031690565b611bb5906008611bba930261094d565b611b9a565b90565b90611bc89154611ba5565b90565b611bd760435f90611bbd565b90565b34611c0a57611bea36600461059d565b611c06611bf5611bcb565b611bfd6104e2565b918291826111fe565b0390f35b6104e8565b34611c3f57611c1f36600461059d565b611c3b611c2a614033565b611c326104e2565b91829182610553565b0390f35b6104e8565b34611c7257611c5c611c573660046107b6565b61415a565b611c646104e2565b80611c6e816108ac565b0390f35b6104e8565b90565b611c8e611c89611c9392611c77565b61100b565b61072d565b90565b611ca262278d00611c7a565b90565b611cad611c96565b90565b34611ce057611cc036600461059d565b611cdc611ccb611ca5565b611cd36104e2565b918291826107e1565b0390f35b6104e8565b34611d1657611d12611d01611cfb366004610753565b90614165565b611d096104e2565b91829182610553565b0390f35b6104e8565b50603090565b905090565b90565b60200190565b611d4b611d45611d3e83611d1b565b8094611d21565b91611d26565b5f915b838310611d5b5750505050565b611d71611d6b60019284516116c5565b92611d29565b92019190611d4e565b9190611d8e905f6106008501940190611d2f565b565b34611dc057611da036600461059d565b611dbc611dab61428c565b611db36104e2565b91829182611d7a565b0390f35b6104e8565b34611df657611df2611de1611ddb366004610753565b906142a2565b611de96104e2565b918291826107e1565b0390f35b6104e8565b611e30611e3794611e26606094989795611e1c608086019a5f8701906107d4565b60208501906107d4565b60408301906107d4565b0190610546565b565b34611e6d57611e4936600461059d565b611e69611e546142d7565b90611e609492946104e2565b94859485611dfb565b0390f35b6104e8565b34611ea257611e9e611e8d611e883660046107b6565b61447c565b611e956104e2565b918291826107e1565b0390f35b6104e8565b34611ed757611eb736600461059d565b611ed3611ec2614491565b611eca6104e2565b918291826107e1565b0390f35b6104e8565b34611f0c57611f08611ef7611ef23660046107b6565b6144a5565b611eff6104e2565b918291826107e1565b0390f35b6104e8565b611f1a81610d88565b03611f2157565b5f80fd5b90503590611f3282611f11565b565b909160c082840312611f9357611f4c835f840161071e565b92611f5a8160208501610744565b92611f688260408301610744565b92611f90611f798460608501611f25565b93611f878160808601610c70565b9360a001610c70565b90565b6104ec565b34611fcd57611fb7611fab366004611f34565b9493909392919261452f565b611fbf6104e2565b80611fc9816108ac565b0390f35b6104e8565b60e08183031261203d57611fe8825f830161071e565b92611ff6836020840161071e565b926120048160408501610744565b926120128260608301610744565b9261203a6120238460808501611f25565b936120318160a08601610c70565b9360c001610c70565b90565b6104ec565b3461207757612061612055366004611fd2565b95949094939193614683565b6120696104e2565b80612073816108ac565b0390f35b6104e8565b346120ab5761209561208f366004610d27565b906147a1565b61209d6104e2565b806120a7816108ac565b0390f35b6104e8565b91906040838203126120d857806120cc6120d5925f860161071e565b9360200161071e565b90565b6104ec565b3461210e5761210a6120f96120f33660046120b0565b906147c3565b6121016104e2565b918291826107e1565b0390f35b6104e8565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b61213f612113565b90565b346121725761215236600461059d565b61216e61215d612137565b6121656104e2565b91829182610caa565b0390f35b6104e8565b7f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a90565b6121a3612177565b90565b346121d6576121b636600461059d565b6121d26121c161219b565b6121c96104e2565b91829182610caa565b0390f35b6104e8565b6121e481611493565b036121eb57565b5f80fd5b905035906121fc826121db565b565b9190604083820312612226578061221a612223925f860161071e565b936020016121ef565b90565b6104ec565b612234906118a3565b9052565b60018060d01b031690565b61224c90612238565b9052565b90602080612272936122685f8201515f86019061222b565b0151910190612243565b565b9190612287905f60408501940190612250565b565b346122ba576122b66122a561229f3660046121fe565b90614831565b6122ad6104e2565b91829182612274565b0390f35b6104e8565b6122cb60425f90610e63565b90565b346122fe576122de36600461059d565b6122fa6122e96122bf565b6122f16104e2565b918291826107e1565b0390f35b6104e8565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b61232f612303565b90565b346123625761234236600461059d565b61235e61234d612327565b6123556104e2565b91829182610caa565b0390f35b6104e8565b5f80fd5b5f90565b634e487b7160e01b5f52601160045260245ffd5b61238f61239591612238565b91612238565b019060018060d01b0382116123a657565b61236f565b906123be916123b861236b565b50612383565b90565b6123cd6123d391612238565b91612238565b90039060018060d01b0382116123e557565b61236f565b906123fd916123f761236b565b506123c1565b90565b5f90565b61240c612400565b5080612427612421637965db0b60e01b6104f4565b916104f4565b14908115612434575b5090565b61243e9150614847565b5f612430565b606090565b60209181520190565b5f5260205f2090565b905f929180549061247561246e83610ab1565b8094612449565b916001811690815f146124cc5750600114612490575b505050565b61249d9192939450612452565b915f925b8184106124b457505001905f808061248b565b600181602092959395548486015201910192906124a1565b92949550505060ff19168252151560200201905f808061248b565b906124f19161245b565b90565b9061251461250d926125046104e2565b938480926124e7565b0383610b9a565b565b61251f906124f4565b90565b61252a612444565b506125356003612516565b90565b5f90565b606090565b61254d61255291611058565b611b9a565b90565b61255f9054612541565b90565b61256b90610bc3565b90565b612576612538565b5061257f61253c565b5061258a6043612555565b906125956044612562565b90565b6125b5916125a4612400565b506125ad61486d565b91909161487a565b600190565b5f90565b5f6125d66125dc926125ce6125ba565b50600c611042565b01611071565b90565b906125f9916125f46125ef612303565b61488a565b612859565b565b5090565b601f602091010490565b1b90565b919060086126289102916126225f1984612609565b92612609565b9181191691161790565b61264661264161264b9261072d565b61100b565b61072d565b90565b90565b919061266761266261266f93612632565b61264e565b90835461260d565b9055565b6126859161267f6125ba565b91612651565b565b5b818110612693575050565b806126a05f600193612673565b01612688565b9190601f81116126b6575b505050565b6126c26126e793610ae4565b9060206126ce846125ff565b830193106126ef575b6126e0906125ff565b0190612687565b5f80806126b1565b91506126e0819290506126d7565b9061270d905f199060080261094d565b191690565b8161271c916126fd565b906002021790565b9161272f90826125fb565b9067ffffffffffffffff82116127ee576127538261274d8554610ab1565b856126a6565b5f90601f831160011461278657918091612775935f9261277a575b5050612712565b90555b565b90915001355f8061276e565b601f1983169161279585610ae4565b925f5b8181106127d6575091600293918560019694106127bc575b50505002019055612778565b6127cc910135601f8416906126fd565b90555f80806127b0565b91936020600181928787013581550195019201612798565b610b86565b906127fe9291612724565b565b90825f939282370152565b91906128258161281e8161282a95610674565b8095612800565b6105c4565b0190565b91612848612856949260408501908582035f87015261067d565b92602081850391015261280b565b90565b906128646044612562565b61287183839060446127f3565b9190916128aa7fb9a2088426f03b30a81c06428094fbfa9e2692739b3241af6b9ab1da4b5546be936128a16104e2565b9384938461282e565b0390a1565b906128b9916125df565b565b6128c36125ba565b506128ce6002611071565b90565b6128e16128dc612113565b61488a565b6128e96129aa565b565b6128ff6128fa61290492611b2a565b61100b565b61072d565b90565b61291b61291661292092611b2a565b61100b565b61064c565b90565b61292c90612907565b90565b9061293b60ff91611b2d565b9181191691161790565b61294e90610541565b90565b90565b9061296961296461297092612945565b612951565b825461292f565b9055565b906129805f1991611b2d565b9181191691161790565b9061299f61299a6129a692612632565b61264e565b8254612974565b9055565b6129b46040611071565b6129c66129c05f6128eb565b9161072d565b03612a63576129d56043612555565b6129ef6129e96129e45f612923565b610657565b91610657565b14612a4757612a006001603f612954565b612a0b42604061298a565b42612a427f1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a322034116091612a396104e2565b918291826107e1565b0390a1565b5f633b0a48bd60e11b815280612a5f600482016108ac565b0390fd5b5f6338e93dbd60e11b815280612a7b600482016108ac565b0390fd5b612a876128d1565b565b91612ab392612a96612400565b50612aab612aa261486d565b829084916148de565b91909161496a565b600190565b612ac19061102a565b90565b5f80fd5b60e01b90565b90505190612adb82610730565b565b90602082820312612af657612af3915f01612ace565b90565b6104ec565b612b036104e2565b3d5f823e3d90fd5b612b1a612b209193929361072d565b9261072d565b8203918211612b2b57565b61236f565b90565b612b47612b42612b4c92612b30565b61100b565b61072d565b90565b612b5e612b649193929361072d565b9261072d565b91612b7083820261072d565b928184041490151715612b7f57565b61236f565b634e487b7160e01b5f52601260045260245ffd5b612ba4612baa9161072d565b9161072d565b908115612bb5570490565b612b84565b612bc26125ba565b91612bcb6125ba565b91612be25f612bdc600c8490611042565b01611071565b90612bfa6002612bf4600c8490611042565b01611071565b91612c336020612c0930612ab8565b63651fd26890612c288692612c1c6104e2565b95869485938493612ac8565b8352600483016111fe565b03915afa908115612d8c57612c7e916020915f91612d5f575b5093612c5730612ab8565b612c7363998955d3612c676104e2565b95869485938493612ac8565b8352600483016111fe565b03915afa908115612d5a575f91612d2c575b509181612ca5612c9f5f6128eb565b9161072d565b11612cfb575b505081612cc0612cba5f6128eb565b9161072d565b11612cca575b5050565b612cf3929350612cdd612cee9183612b0b565b612ce8612710612b33565b90612b4f565b612b98565b905f80612cc6565b612d24929650612d0e612d1f9183612b0b565b612d19612710612b33565b90612b4f565b612b98565b935f80612cab565b612d4d915060203d8111612d53575b612d458183610b9a565b810190612add565b5f612c90565b503d612d3b565b612afb565b612d7f9150823d8111612d85575b612d778183610b9a565b810190612add565b5f612c4c565b503d612d6d565b612afb565b5f90565b612d9e90610c59565b90565b90612dab90612d95565b5f5260205260405f2090565b90565b612dc6612dcb91611058565b612db7565b90565b612dd89054612dba565b90565b6001612df4612dfa92612dec612d91565b506005612da1565b01612dce565b90565b612e05614a07565b612e0d612f63565b565b612e1b612e2091611058565b610951565b90565b612e2d9054612e0f565b90565b6001612e3c910161072d565b90565b612e4e612e549193929361072d565b9261072d565b8201809211612e5f57565b61236f565b612e6d9061102a565b90565b612e799061100e565b90565b612e8590612e70565b90565b612e919061102a565b90565b5f910312612e9e57565b6104ec565b905f9291805490612ebd612eb683610ab1565b8094610674565b916001811690815f14612f145750600114612ed8575b505050565b612ee59192939450610ae4565b915f925b818410612efc57505001905f8080612ed3565b60018160209295939554848601520191019290612ee9565b92949550505060ff19168252151560200201905f8080612ed3565b612f53612f60949293612f4960608401955f850190610663565b60208301906107d4565b6040818403910152612ea3565b90565b612f76612f70603f612e23565b15610541565b61329657612f82614033565b61327a57612fab612f9d42612f976040611071565b90612b0b565b612fa5611c96565b90612b98565b80612fc7612fc1612fbc6041611071565b61072d565b9161072d565b111561325e57612fe190612fdb6041611071565b90612b0b565b908161300f613009613004612ff4611304565b612ffe6041611071565b90612b0b565b61072d565b9161072d565b1161323b575b61301e5f6128eb565b906130285f6128eb565b915b8261303d6130378661072d565b9161072d565b10156130845761307861307e9161307261306c600f61306661305f6041611071565b8990612e3f565b90610e20565b90610e63565b90612e3f565b92612e30565b9161302a565b91509161309b6130946042611071565b8390612e3f565b6130b46130ae6130a96113d8565b61072d565b9161072d565b1161321f576130cf6130d6916130ca6041611071565b612e3f565b604161298a565b6130f36130ec826130e76042611071565b612e3f565b604261298a565b6131066130ff30612e64565b8290614a31565b61312361311230612e64565b61311c6043612555565b839161487a565b61313d6131386131336043612555565b612e7c565b612e88565b6318b68b8c61314b30612e64565b8392604492813b1561321a575f6131759161318082966131696104e2565b98899788968795612ac8565b855260048501612f2f565b03925af18015613215576131e9575b5061319a6041611071565b906131a45f612923565b906131cf7f34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb92611036565b926131e46131db6104e2565b92839283610a31565b0390a2565b613208905f3d811161320e575b6132008183610b9a565b810190612e94565b5f61318f565b503d6131f6565b612afb565b612ac4565b5f6323064ebd60e01b815280613237600482016108ac565b0390fd5b9050613258613248611304565b6132526041611071565b90612b0b565b90613015565b5f63e085d22b60e01b815280613276600482016108ac565b0390fd5b5f631155624b60e21b815280613292600482016108ac565b0390fd5b5f6319afc99d60e21b8152806132ae600482016108ac565b0390fd5b6132ba612dfd565b565b906132d7916132d26132cd82612ddb565b61488a565b6132d9565b565b906132e391614a8f565b50565b906132f0916132bc565b565b5f90565b90565b61330d613308613312926132f6565b61100b565b610d88565b90565b61331d6132f2565b5061332860126132f9565b90565b61333b613336612113565b61488a565b613343613345565b565b61334f6040611071565b61336161335b5f6128eb565b9161072d565b146133aa576133726001603f612954565b7f4a792a0be42b5672faa40129fc6469072490775ca8d3c34e852d4d55d3a735a961339b6104e2565b806133a5816108ac565b0390a1565b5f638f98404160e01b8152806133c2600482016108ac565b0390fd5b6133ce61332b565b565b6133d8612d91565b506133e1614b3b565b90565b90806133ff6133f96133f461486d565b610657565b91610657565b036134105761340d91614bf5565b50565b5f63334bd91960e11b815280613428600482016108ac565b0390fd5b9061343690611036565b5f5260205260405f2090565b90565b61345961345461345e92612238565b61100b565b61072d565b90565b6134989161348d6134876134826134939461347a6125ba565b50600a61342c565b613442565b91614cd6565b90614dcc565b613445565b90565b6134ab6134a6611b4e565b61488a565b6134b36134b5565b565b6134bd614f53565b565b6134c761349b565b565b90816134e56134df6134da5f612923565b610657565b91610657565b146135e457806134fd6134f75f6128eb565b9161072d565b146135c85761351f613519613514600d339061142f565b612e23565b15610541565b6135ac5761352c33614f60565b613543600161353d600c3390611042565b01611071565b61355561354f8361072d565b9161072d565b106135905761358e91613589826135836001613573600c3390611042565b019161357e83611071565b612b0b565b9061298a565b614a31565b565b5f631c959ed960e21b8152806135a8600482016108ac565b0390fd5b5f634417760960e11b8152806135c4600482016108ac565b0390fd5b5f631f2a200560e01b8152806135e0600482016108ac565b0390fd5b5f63d92e233d60e01b8152806135fc600482016108ac565b0390fd5b6136086125ba565b506136246136146113d8565b61361e6042611071565b90612b0b565b90565b9061363a6136336104e2565b9283610b9a565b565b67ffffffffffffffff811161365a576136566020916105c4565b0190565b610b86565b9061367161366c8361363c565b613627565b918252565b5f7f6d6f64653d626c6f636b6e756d6265722666726f6d3d64656661756c74000000910152565b6136a7601d61365f565b906136b460208301613676565b565b6136be61369d565b90565b6136c9612444565b506136d2613bc1565b6136eb6136e56136e06150fb565b6118a3565b916118a3565b036136fb576136f86136b6565b90565b5f6301bfc1c560e61b815280613713600482016108ac565b0390fd5b9061372190611036565b5f5260205260405f2090565b6137446137499161373c612538565b506009613717565b612555565b90565b613754612400565b5061375f6040611071565b61377161376b5f6128eb565b9161072d565b1190565b6137869061378161486d565b615110565b565b613790612400565b5061379b600e612e23565b90565b6137f5906137aa6125ba565b506137c260016137bc600c8490611042565b01611071565b906137ef60046137e96137e15f6137db600c8790611042565b01611071565b93600c611042565b01611071565b9161519b565b90565b613808613803612177565b61488a565b613810613812565b565b61381d5f603f612954565b7f73a5fc60aafeec8f139af22d98e62140e2ce914d1f155c692b427757c3e4014c6138466104e2565b80613850816108ac565b0390a1565b61385d6137f8565b565b5f90565b6138759061386f61385f565b50615247565b90565b9061388290611036565b5f5260205260405f2090565b6138a46138a99161389d6125ba565b505f613878565b611071565b90565b6138c36138c8916138bb612400565b50600d61142f565b612e23565b90565b906138d4612400565b506138dd6125ba565b506138e66125ba565b506138ef6125ba565b506138f86125ba565b5061390d613908600d849061142f565b612e23565b916139245f61391e600c8490611042565b01611071565b9161393c6002613936600c8590611042565b01611071565b90613975602061394b30612ab8565b63651fd2689061396a879261395e6104e2565b95869485938493612ac8565b8352600483016111fe565b03915afa908115613a36576139c0916020915f91613a09575b509461399930612ab8565b6139b563998955d36139a96104e2565b95869485938493612ac8565b8352600483016111fe565b03915afa908115613a04575f916139d6575b5090565b6139f7915060203d81116139fd575b6139ef8183610b9a565b810190612add565b5f6139d2565b503d6139e5565b612afb565b613a299150823d8111613a2f575b613a218183610b9a565b810190612add565b5f61398e565b503d613a17565b612afb565b613a4d90613a476125ba565b50615276565b90565b613a60613a5b612177565b61488a565b613a68613a6a565b565b613a726152ec565b565b613a7c613a50565b565b5f90565b606090565b613a909061102a565b90565b67ffffffffffffffff8111613aab5760208091020190565b610b86565b90613ac2613abd83613a93565b613627565b918252565b369037565b90613af1613ad983613ab0565b92602080613ae78693613a93565b9201910390613ac7565b565b600f60f81b90565b613b03613a7e565b50613b0c612444565b50613b15612444565b50613b1e6125ba565b50613b27612538565b50613b30612d91565b50613b39613a82565b50613b426152f9565b90613b4b615339565b904690613b5730613a87565b90613b615f611b32565b90613b73613b6e5f6128eb565b613acc565b90613b7c613af3565b96959493929190565b613b8d6125ba565b50613b85565b613bba915f613baf613bb593613ba7612400565b506005612da1565b0161142f565b612e23565b90565b5f90565b613bc9613bbd565b50613bd26150fb565b90565b613bdd612444565b50613be86004612516565b90565b613c4390613bf76125ba565b50613c0f6003613c09600c8490611042565b01611071565b90613c3d6004613c37613c2f6002613c29600c8790611042565b01611071565b93600c611042565b01611071565b9161519b565b90565b613c6d613c68613c63613c7293613c5b6125ba565b50600a61342c565b613442565b615379565b613445565b90565b9081613c91613c8b613c865f612923565b610657565b91610657565b14613d905780613ca9613ca35f6128eb565b9161072d565b14613d7457613ccb613cc5613cc0600d339061142f565b612e23565b15610541565b613d5857613cd833614f60565b613cef6003613ce9600c3390611042565b01611071565b613d01613cfb8361072d565b9161072d565b10613d3c57613d3a91613d3582613d2f6003613d1f600c3390611042565b0191613d2a83611071565b612b0b565b9061298a565b6153ee565b565b5f631c959ed960e21b815280613d54600482016108ac565b0390fd5b5f634417760960e11b815280613d70600482016108ac565b0390fd5b5f631f2a200560e01b815280613d8c600482016108ac565b0390fd5b5f63d92e233d60e01b815280613da8600482016108ac565b0390fd5b90613dc79291613dc2613dbd612303565b61488a565b613dc9565b565b80613de4613dde613dd95f612923565b610657565b91610657565b1461400a57613e06613e00613dfb600d849061142f565b612e23565b15610541565b80613fcf575b613f73575b81613e24613e1e5f6128eb565b9161072d565b1480613f59575b80613f3f575b613ee4575b613e3f81614f60565b613e56825f613e50600c8590611042565b0161298a565b613e6e836002613e68600c8590611042565b0161298a565b613e86826001613e80600c8590611042565b0161298a565b613e9e836003613e98600c8590611042565b0161298a565b9091613eca7faa807d0abf30d91968c7478c66b6d82521a106af13eda036e2036da9af16895892611036565b92613edf613ed66104e2565b92839283610a31565b0390a2565b613ef95f613ef4600d849061142f565b612954565b80613f247f02c2f0ba15b03f88b18f4832609a18cf35fc6b3f4546a9992076d7453d1334a891611036565b90613f2d6104e2565b80613f37816108ac565b0390a2613e36565b50613f54613f4f600d839061142f565b612e23565b613e31565b5082613f6d613f675f6128eb565b9161072d565b14613e2b565b613f896001613f84600d849061142f565b612954565b80613fb47f6cf28439a2daab1b265097227212a5b71e0a76f9ed85e3f815b5a6c3e218eb7f91611036565b90613fbd6104e2565b80613fc7816108ac565b0390a2613e11565b5081613fe3613fdd5f6128eb565b9161072d565b118015613ff0575b613e0c565b5082614004613ffe5f6128eb565b9161072d565b11613feb565b5f63d92e233d60e01b815280614022600482016108ac565b0390fd5b906140319291613dac565b565b61403b612400565b506140466041611071565b61405f614059614054611304565b61072d565b9161072d565b101590565b61407d90614078614073612303565b61488a565b6140bd565b565b9061409060018060a01b0391611b2d565b9181191691161790565b90565b906140b26140ad6140b992611036565b61409a565b825461407f565b9055565b806140d86140d26140cd5f612923565b610657565b91610657565b1461413e576140e76043612555565b6140f282604361409d565b906141266141207f07015b6a9f05913148fd5faddf2acc9708f305937f3072ca2b4b46faa5d0898b93611036565b91611036565b9161412f6104e2565b80614139816108ac565b0390a3565b5f63d92e233d60e01b815280614156600482016108ac565b0390fd5b61416390614064565b565b61418291614171612400565b5061417a61486d565b91909161496a565b600190565b67ffffffffffffffff811161419c5760200290565b610b86565b6141ad6141b291614187565b613627565b90565b906141d36141c2836141a1565b926141cd8491614187565b90613ac7565b565b6141df60306141b5565b90565b905090565b6141f1905461105d565b90565b60010190565b61421661421061420983610e17565b80946141e2565b91610e1d565b5f915b8383106142265750505050565b61424361423d600192614238856141e7565b6116c5565b926141f4565b92019190614219565b9061425a81610600936141fa565b0190565b9061427e6142779261426e6104e2565b9384809261424c565b0383610b9a565b565b6142899061425e565b90565b6142946141d5565b5061429f600f614280565b90565b906142b5916142af6125ba565b50613461565b90565b90565b6142cf6142ca6142d4926142b8565b61100b565b61072d565b90565b6142df6125ba565b506142e86125ba565b506142f16125ba565b506142fa612400565b506143056040611071565b6143176143115f6128eb565b9161072d565b14614456576143416143334261432d6040611071565b90612b0b565b61433b611c96565b90612b98565b9061438361434f6040611071565b61437d61436f61435f6041611071565b61436960016142bb565b90612e3f565b614377611c96565b90612b4f565b90612e3f565b61438d6041611071565b6143a66143a061439b611304565b61072d565b9161072d565b105f14614448576143cb6143c5600f6143bf6041611071565b90610e20565b90610e63565b5b926143d7603f612e23565b9081614424575b50806143fa575b916143f06041611071565b9193929193929190565b506144056041611071565b61441e614418614413611304565b61072d565b9161072d565b106143e5565b905061444161443b6144366041611071565b61072d565b9161072d565b115f6143de565b6144515f6128eb565b6143cc565b5f905f915f9161447861447261446c5f946128eb565b956128eb565b936128eb565b9190565b61448e906144886125ba565b50613c46565b90565b6144996125ba565b506144a26128bb565b90565b60026144be6144c4926144b66125ba565b50600c611042565b01611071565b90565b7fe48329057bfd03d55e49b547132e39cffd9c1820ad7b9d4c5307691425d15adf90565b6145206145279461451660609498979561450c608086019a5f870190610c9d565b6020850190610663565b60408301906107d4565b01906107d4565b565b60200190565b93959490929195426145496145438961072d565b9161072d565b116145c257916145b4916145bb936145ab6145c0989961459361456a6144c7565b6145848b938b6145786104e2565b958694602086016144eb565b60208201810382520382610b9a565b6145a561459f82610670565b91614529565b2061544d565b9290919261546a565b91826154b4565b615110565b565b6145dd875f918291632341d78760e11b8352600483016107e1565b0390fd5b7f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c990565b919461464d6146579298979561464360a09661463961465e9a61462f60c08a019e5f8b0190610c9d565b6020890190610663565b6040870190610663565b60608501906107d4565b60808301906107d4565b01906107d4565b565b91602061468192949361467a60408201965f830190610663565b0190610663565b565b96959193929490944261469e6146988361072d565b9161072d565b1161475857906147076147109493926146ef6146b86145e1565b6146e08c80948c916146ca8d916154f7565b91926146d46104e2565b97889660208801614605565b60208201810382520382610b9a565b6147016146fb82610670565b91614529565b2061544d565b9290919261546a565b8061472361471d87610657565b91610657565b036147385750614736929391909161487a565b565b84906147545f9283926325c0072360e11b845260048401614660565b0390fd5b614773905f91829163313c898160e11b8352600483016107e1565b0390fd5b906147929161478d61478882612ddb565b61488a565b614794565b565b9061479e91614bf5565b50565b906147ab91614777565b565b906147b790611036565b5f5260205260405f2090565b6147e8916147de6147e3926147d66125ba565b5060016147ad565b613878565b611071565b90565b6147f56040613627565b90565b5f90565b5f90565b6148086147eb565b90602080836148156147f8565b8152016148206147fc565b81525050565b61482e614800565b90565b906148449161483e614826565b5061552a565b90565b61484f612400565b506148696148636301ffc9a760e01b6104f4565b916104f4565b1490565b614875612538565b503390565b916148889291600192615552565b565b61489c9061489661486d565b90615684565b565b6040906148c76148ce94969593966148bd60608401985f850190610663565b60208301906107d4565b01906107d4565b565b906148db910361072d565b90565b9291926148ec8183906147c3565b90816149016148fb5f1961072d565b9161072d565b1061490e575b5050509050565b8161492161491b8761072d565b9161072d565b106149475761493e93946149369193926148d0565b905f92615552565b805f8080614907565b50614966849291925f938493637dc7a0d960e11b85526004850161489e565b0390fd5b918261498661498061497b5f612923565b610657565b91610657565b146149e057816149a66149a061499b5f612923565b610657565b91610657565b146149b9576149b7929190916156bf565b565b6149dc6149c55f612923565b5f91829163ec442f0560e01b8352600483016111fe565b0390fd5b614a036149ec5f612923565b5f918291634b637e8f60e11b8352600483016111fe565b0390fd5b614a0f613788565b614a1557565b5f63d93c066560e01b815280614a2d600482016108ac565b0390fd5b80614a4c614a46614a415f612923565b610657565b91610657565b14614a6857614a6691614a5e5f612923565b9190916156bf565b565b614a8b614a745f612923565b5f91829163ec442f0560e01b8352600483016111fe565b0390fd5b614a97612400565b50614aac614aa6828490613b93565b15610541565b5f14614b3557614ad46001614acf5f614ac760058690612da1565b01859061142f565b612954565b90614add61486d565b90614b1a614b14614b0e7f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d95612d95565b92611036565b92611036565b92614b236104e2565b80614b2d816108ac565b0390a4600190565b50505f90565b614b43612d91565b50614b4d30613a87565b614b7f614b797f0000000000000000000000000000000000000000000000000000000000000000610657565b91610657565b1480614bbb575b5f14614bb0577f000000000000000000000000000000000000000000000000000000000000000090565b614bb861573f565b90565b5046614bef614be97f000000000000000000000000000000000000000000000000000000000000000061072d565b9161072d565b14614b86565b614bfd612400565b50614c09818390613b93565b5f14614c9157614c305f614c2b5f614c2360058690612da1565b01859061142f565b612954565b90614c3961486d565b90614c76614c70614c6a7ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b95612d95565b92611036565b92611036565b92614c7f6104e2565b80614c89816108ac565b0390a4600190565b50505f90565b614cab614ca6614cb0926118a3565b61100b565b61072d565b90565b916020614cd4929493614ccd60408201965f8301906107d4565b01906118ae565b565b614cde613bbd565b50614ce7613bc1565b81614cfa614cf483614c97565b9161072d565b1015614d0d5750614d0a90615845565b90565b90614d285f928392637669fc0f60e11b845260048401614cb3565b0390fd5b5490565b90565b614d47614d42614d4c92614d30565b61100b565b61072d565b90565b90565b65ffffffffffff1690565b614d69614d6e91611058565b614d52565b90565b614d7b9054614d5d565b90565b60301c90565b60018060d01b031690565b614d9b614da091614d7e565b614d84565b90565b614dad9054614d8f565b90565b614dc4614dbf614dc992611b2a565b61100b565b612238565b90565b90614e2090614dd961236b565b50614de55f8401614d2c565b614dee5f6128eb565b908080614e04614dfe6005614d33565b9161072d565b11614e81575b5090614e1b5f860193919293614d4f565b615e80565b80614e33614e2d5f6128eb565b9161072d565b145f14614e49575050614e455f614db0565b5b90565b614e765f91614e71614e6b84614e7c960192614e6560016142bb565b90612b0b565b91614d4f565b615e76565b01614da3565b614e46565b80614e8f614e959291615b0b565b90612b0b565b9083614ec7614ec1614ebc5f614eb6818c01614eb18991614d4f565b615e76565b01614d71565b6118a3565b916118a3565b105f14614ed85750905b905f614e0a565b9150614eee90614ee860016142bb565b90612e3f565b614ed1565b614efb615f0f565b614f03614f05565b565b614f105f600e612954565b614f1861486d565b614f4e7f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa91614f456104e2565b918291826111fe565b0390a1565b614f5b614ef3565b565b90565b614f6e614f7391600c611042565b614f5d565b614f7f60048201611071565b614f91614f8b5f6128eb565b9161072d565b146150eb5761500d90614fb042614faa60048401611071565b90612b0b565b80614fca614fc4614fbf611959565b61072d565b9161072d565b10155f1461500f5750614fea614fe15f8301611071565b6001830161298a565b615002614ff960028301611071565b6003830161298a565b5b600442910161298a565b565b8061502261501c5f6128eb565b9161072d565b1161502e575b50615003565b6150dc6150ca6150e5926150b96150b061509f61508d61507f61506d61505f6150585f8d01611071565b8890612b4f565b615067611959565b90612b98565b9561507a60028c01611071565b612b4f565b615087611959565b90612b98565b9361509a60018a01611071565b612e3f565b6150aa5f8901611071565b90615f42565b6001870161298a565b6150c560038601611071565b612e3f565b6150d660028501611071565b90615f42565b6003830161298a565b5f615028565b6150f990600442910161298a565b565b615103613bbd565b5061510d43615845565b90565b90615199916151936151218261372d565b6151368461513160098690613717565b61409d565b8281859061517661517061516a7f3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f95611036565b92611036565b92611036565b9261517f6104e2565b80615189816108ac565b0390a49291615f72565b91615f8a565b565b90916151a56125ba565b50806151b96151b35f6128eb565b9161072d565b14615238576151c89042612b0b565b90816151e36151dd6151d8611959565b61072d565b9161072d565b1015615233576152076151f961520d9385612b4f565b615201611959565b90612b98565b90612e3f565b8061522061521a8461072d565b9161072d565b115f1461522c57505b90565b9050615229565b505090565b5050506152445f6128eb565b90565b61526e6152696152646152739361525c61385f565b50600a61342c565b613442565b616138565b6161b7565b90565b615288906152826125ba565b50616208565b90565b615293614a07565b61529b61529d565b565b6152a96001600e612954565b6152b161486d565b6152e77f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258916152de6104e2565b918291826111fe565b0390a1565b6152f461528b565b565b90565b615301612444565b506153367f000000000000000000000000000000000000000000000000000000000000000061533060066152f6565b90616323565b90565b615341612444565b506153767f000000000000000000000000000000000000000000000000000000000000000061537060076152f6565b90616323565b90565b61538161236b565b5061538d5f8201614d2c565b806153a061539a5f6128eb565b9161072d565b145f146153b65750506153b25f614db0565b5b90565b6153e35f916153de6153d8846153e99601926153d260016142bb565b90612b0b565b91614d4f565b615e76565b01614da3565b6153b3565b908161540a6154046153ff5f612923565b610657565b91610657565b1461542657615424919061541d5f612923565b90916156bf565b565b6154496154325f612923565b5f918291634b637e8f60e11b8352600483016111fe565b0390fd5b61546790615459612d91565b50615462614b3b565b616371565b90565b926154859261548e9461547b612538565b5092909192616427565b90929192616552565b90565b9160206154b29294936154ab60408201965f830190610663565b01906107d4565b565b6154bd816154f7565b916154d06154ca8461072d565b9161072d565b036154d9575050565b6154f35f9283926301d4b62360e61b845260048401615491565b0390fd5b61550b906155036125ba565b506008613878565b61552761551782611071565b9161552183612e30565b9061298a565b90565b9061554a61554561554f9361553d614826565b50600a61342c565b613442565b6166b4565b90565b90928161556f6155696155645f612923565b610657565b91610657565b1461563a578361558f6155896155845f612923565b610657565b91610657565b14615613576155b3836155ae6155a7600186906147ad565b8790613878565b61298a565b6155bd575b505050565b9190916156086155f66155f07f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92593611036565b93611036565b936155ff6104e2565b918291826107e1565b0390a35f80806155b8565b61563661561f5f612923565b5f918291634a1406b160e11b8352600483016111fe565b0390fd5b61565d6156465f612923565b5f91829163e602df0560e01b8352600483016111fe565b0390fd5b91602061568292949361567b60408201965f830190610663565b0190610c9d565b565b90615699615693838390613b93565b15610541565b6156a1575050565b6156bb5f92839263e2517d3f60e01b845260048401615661565b0390fd5b916156cc929190916166d5565b565b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b9095949261573d9461572c6157369261572260809661571860a088019c5f890190610c9d565b6020870190610c9d565b6040850190610c9d565b60608301906107d4565b0190610663565b565b615747612d91565b506157506156ce565b6157c77f0000000000000000000000000000000000000000000000000000000000000000916157b87f0000000000000000000000000000000000000000000000000000000000000000466157a330613a87565b916157ac6104e2565b968795602087016156f2565b60208201810382520382610b9a565b6157d96157d382610670565b91614529565b2090565b6157f16157ec6157f6926112e5565b61100b565b610d88565b90565b615802906157dd565b9052565b91602061582792949361582060408201965f8301906157f9565b01906107d4565b565b61583d6158386158429261072d565b61100b565b6118a3565b90565b61584d613bbd565b508061586761586165ffffffffffff614c97565b9161072d565b116158785761587590615829565b90565b60306158945f9283926306dfcc6560e41b845260048401615806565b0390fd5b90565b6158af6158aa6158b492615898565b61100b565b61072d565b90565b90565b6158ce6158c96158d3926158b7565b61100b565b610d88565b90565b6158f5906158ef6158e96158fa94610d88565b9161072d565b9061094d565b61072d565b90565b90565b61591461590f615919926158fd565b61100b565b610d88565b90565b61593b9061593561592f61594094610d88565b9161072d565b90612609565b61072d565b90565b90565b61595a61595561595f92615943565b61100b565b61072d565b90565b90565b61597961597461597e92615962565b61100b565b610d88565b90565b90565b61599861599361599d92615981565b61100b565b61072d565b90565b90565b6159b76159b26159bc926159a0565b61100b565b610d88565b90565b90565b6159d66159d16159db926159bf565b61100b565b61072d565b90565b90565b6159f56159f06159fa926159de565b61100b565b610d88565b90565b90565b615a14615a0f615a19926159fd565b61100b565b61072d565b90565b90565b615a33615a2e615a3892615a1c565b61100b565b610d88565b90565b615a4f615a4a615a54926159a0565b61100b565b61072d565b90565b90565b615a6e615a69615a7392615a57565b61100b565b610d88565b90565b615a8a615a85615a8f92615a1c565b61100b565b61072d565b90565b615aa6615aa1615aab926142b8565b61100b565b610d88565b90565b90565b615ac5615ac0615aca92615aae565b61100b565b61072d565b90565b90615ad8910261072d565b90565b615ae7615aed9161072d565b9161072d565b908115615af8570490565b612b84565b90615b08910161072d565b90565b615b136125ba565b5080615b28615b2260016142bb565b9161072d565b1115615e735780615d3d615d1a615d0a615cfa615cea615cda615cca615cba615caa615c9a615c8a8b615c84615c7d615d439f615c5d615c4d615c6d92615b6f60016142bb565b9080615b87615b81600160801b61589b565b9161072d565b1015615e45575b80615baa615ba468010000000000000000615946565b9161072d565b1015615e17575b80615bc9615bc3640100000000615984565b9161072d565b1015615de9575b80615be6615be0620100006159c2565b9161072d565b1015615dbb575b80615c02615bfc610100615a00565b9161072d565b1015615d8d575b80615c1d615c176010615a3b565b9161072d565b1015615d5f575b615c37615c316004615a76565b9161072d565b1015615d46575b615c486003615ab1565b615acd565b615c576001615a92565b906158d6565b615c678186615adb565b90615afd565b615c776001615a92565b906158d6565b8092615adb565b90615afd565b615c946001615a92565b906158d6565b615ca4818c615adb565b90615afd565b615cb46001615a92565b906158d6565b615cc4818a615adb565b90615afd565b615cd46001615a92565b906158d6565b615ce48188615adb565b90615afd565b615cf46001615a92565b906158d6565b615d048186615adb565b90615afd565b615d146001615a92565b906158d6565b91615d37615d31615d2c858094615adb565b61072d565b9161072d565b11616765565b906148d0565b90565b615d5a90615d546001615a92565b9061591c565b615c3e565b615d76615d8791615d706004615a1f565b906158d6565b91615d816002615a5a565b9061591c565b90615c24565b615da4615db591615d9e60086159e1565b906158d6565b91615daf6004615a1f565b9061591c565b90615c09565b615dd2615de391615dcc60106159a3565b906158d6565b91615ddd60086159e1565b9061591c565b90615bed565b615e00615e1191615dfa6020615965565b906158d6565b91615e0b60106159a3565b9061591c565b90615bd0565b615e2e615e3f91615e286040615900565b906158d6565b91615e396020615965565b9061591c565b90615bb1565b615e5c615e6d91615e5660806158ba565b906158d6565b91615e676040615900565b9061591c565b90615b8e565b90565b5f5260205f200190565b93919092615e8c6125ba565b505b81615ea1615e9b8361072d565b9161072d565b1015615f0757615eb282829061678f565b90615ec85f615ec2888590615e76565b01614d71565b615eda615ed4876118a3565b916118a3565b115f14615eea5750915b91615e8e565b929150615f0190615efb60016142bb565b90612e3f565b90615ee4565b925050915090565b615f20615f1a613788565b15610541565b615f2657565b5f638dfc202b60e01b815280615f3e600482016108ac565b0390fd5b90615f4b6125ba565b5081615f5f615f598361072d565b9161072d565b105f14615f6b57505b90565b9050615f68565b615f8490615f7e6125ba565b5061388e565b90565b90565b91909180615fa0615f9a85610657565b91610657565b14158061611e575b615fb2575b505050565b80615fcd615fc7615fc25f612923565b610657565b91610657565b0361608e575b5081615fef615fe9615fe45f612923565b610657565b91610657565b03615ffb575b80615fad565b61604261603561603c92616011600a869061342c565b9061602f616029616023600193616828565b93613442565b91615f87565b9061687b565b9290613445565b91613445565b91909161606f7fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492611036565b9261608461607b6104e2565b92839283610a31565b0390a25f80615ff5565b6160cd6160d36160c66160a3600a859061342c565b60026160c06160ba6160b489616828565b93613442565b91615f87565b9061687b565b9290613445565b91613445565b9190916161007fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492611036565b9261611561610c6104e2565b92839283610a31565b0390a25f615fd3565b508161613261612c5f6128eb565b9161072d565b11615fa8565b5f61614c916161456125ba565b5001614d2c565b90565b61616361615e61616892611493565b61100b565b61072d565b90565b61617490615965565b9052565b91602061619992949361619260408201965f83019061616b565b01906107d4565b565b6161af6161aa6161b49261072d565b61100b565b611493565b90565b6161bf61385f565b50806161d76161d163ffffffff61614f565b9161072d565b116161e8576161e59061619b565b90565b60206162045f9283926306dfcc6560e41b845260048401616178565b0390fd5b61621f616224916162176125ba565b506008613878565b611071565b90565b90565b61623e61623961624392616227565b611b2d565b610c59565b90565b61625060ff61622a565b90565b5f5260205f2090565b905f929180549061627661626f83610ab1565b8094612449565b916001811690815f146162cd5750600114616291575b505050565b61629e9192939450616253565b915f925b8184106162b557505001905f808061628c565b600181602092959395548486015201910192906162a2565b92949550505060ff19168252151560200201905f808061628c565b906162f29161625c565b90565b9061631561630e926163056104e2565b938480926162e8565b0383610b9a565b565b616320906162f5565b90565b9061632c612444565b5061633682612d95565b61634f616349616344616246565b610c59565b91610c59565b14155f14616364575061636190616905565b90565b61636e9150616317565b90565b60429161637c612d91565b50604051917f19010000000000000000000000000000000000000000000000000000000000008352600283015260228201522090565b5f90565b6163c26163c791611058565b612632565b90565b90565b6163e16163dc6163e6926163ca565b61100b565b61072d565b90565b61641e6164259461641460609498979561640a608086019a5f870190610c9d565b6020850190610d8e565b6040830190610c9d565b0190610c9d565b565b939293616432612538565b5061643b6163b2565b50616444612d91565b5061644e856163b6565b61648061647a7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a06163cd565b9161072d565b1161650d57906164a3602094955f9493929361649a6104e2565b948594856163e9565b838052039060015afa15616508576164bb5f51611b2d565b806164d66164d06164cb5f612923565b610657565b91610657565b146164ec575f916164e65f611b32565b91929190565b506164f65f612923565b6001916165025f611b32565b91929190565b612afb565b5050506165195f612923565b9060039291929190565b634e487b7160e01b5f52602160045260245ffd5b6004111561654157565b616523565b9061655082616537565b565b8061656561655f5f616546565b91616546565b145f14616570575050565b8061658461657e6001616546565b91616546565b145f146165a7575f63f645eedf60e01b8152806165a3600482016108ac565b0390fd5b806165bb6165b56002616546565b91616546565b145f146165e9576165e56165ce836163b6565b5f91829163fce698f760e01b8352600483016107e1565b0390fd5b6165fc6165f66003616546565b91616546565b146166045750565b61661f905f9182916335e2f38360e21b835260048301610caa565b0390fd5b5f5260205f2090565b61663581614d2c565b82101561664f57616647600191616623565b910201905f90565b610e03565b9061665e906118a3565b9052565b9061666c90612238565b9052565b906166a661669d5f6166806147eb565b9461669761668f838301614d71565b838801616654565b01614da3565b60208401616662565b565b6166b190616670565b90565b6166d2915f6166cc926166c5614826565b500161662c565b506166a8565b90565b92916166e384838391616935565b836166fe6166f86166f35f612923565b610657565b91610657565b14616713575b6167119293919091616abf565b565b61671b6128bb565b93616724616aa4565b94806167386167328861072d565b9161072d565b1161674557509350616704565b85906167615f928392630e58ae9360e11b845260048401610a31565b0390fd5b61676d6125ba565b50151590565b61678761678261678c92615a57565b61100b565b61072d565b90565b6167b46167ba9261679e6125ba565b5082811692186167ae6002616773565b90612b98565b90612e3f565b90565b90565b6167d46167cf6167d9926167bd565b61100b565b610d88565b90565b6167e5906167c0565b9052565b91602061680a92949361680360408201965f8301906167dc565b01906107d4565b565b61682061681b6168259261072d565b61100b565b612238565b90565b61683061236b565b508061684a61684460018060d01b03613445565b9161072d565b1161685b576168589061680c565b90565b60d06168775f9283926306dfcc6560e41b8452600484016167e9565b0390fd5b906168b16168b7939261688c61236b565b5061689561236b565b5080936168aa6168a3613bc1565b9492615379565b9091616f27565b91616b7e565b91909190565b6168d16168cc6168d692615962565b61100b565b61072d565b90565b369037565b906169036168eb8361365f565b926020806168f9869361363c565b92019103906168d9565b565b61690d612444565b5061691781616be8565b9061692a61692560206168bd565b6168de565b918252602082015290565b9190918061695361694d6169485f612923565b610657565b91610657565b145f14616a34576169776169708361696b6002611071565b612e3f565b600261298a565b5b8261699361698d6169885f612923565b610657565b91610657565b145f14616a08576169b76169b0836169ab6002611071565b6148d0565b600261298a565b5b919091616a036169f16169eb7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef93611036565b93611036565b936169fa6104e2565b918291826107e1565b0390a3565b616a2f82616a29616a1a5f8790613878565b91616a2483611071565b615afd565b9061298a565b6169b8565b616a47616a425f8390613878565b611071565b80616a5a616a548561072d565b9161072d565b10616a8257616a6d616a7d9184906148d0565b616a785f8490613878565b61298a565b616978565b90616aa09091925f93849363391434e360e21b85526004850161489e565b0390fd5b616aac6125ba565b50616abc60018060d01b03613445565b90565b91616b17616b11616b1e9480616ae5616adf616ada5f612923565b610657565b91610657565b14616b4f575b84616b06616b00616afb5f612923565b610657565b91610657565b14616b20575b61372d565b9261372d565b9091615f8a565b565b616b48600b6002616b42616b3c616b3689616828565b93613442565b91615f87565b9061687b565b5050616b0c565b616b77600b6001616b71616b6b616b6589616828565b93613442565b91615f87565b9061687b565b5050616aeb565b91616ba25f616ba794616b8f61236b565b50616b9861236b565b5001929192614d4f565b616dd9565b91909190565b616bc1616bbc616bc692616227565b61100b565b61072d565b90565b90565b616be0616bdb616be592616bc9565b61100b565b61072d565b90565b616bfd616c0291616bf76125ba565b50612d95565b6163b6565b616c0c60ff616bad565b1680616c21616c1b601f616bcc565b9161072d565b11616c295790565b5f632cd44ac360e21b815280616c41600482016108ac565b0390fd5b5490565b616c536040613627565b90565b5f5260205f2090565b616c6881616c45565b821015616c8257616c7a600191616c56565b910201905f90565b610e03565b616c9190516118a3565b90565b90616ca565ffffffffffff91611b2d565b9181191691161790565b616cc3616cbe616cc8926118a3565b61100b565b6118a3565b90565b90565b90616ce3616cde616cea92616caf565b616ccb565b8254616c94565b9055565b616cf89051612238565b90565b60301b90565b90616d1365ffffffffffff1991616cfb565b9181191691161790565b616d31616d2c616d3692612238565b61100b565b612238565b90565b90565b90616d51616d4c616d5892616d1d565b616d39565b8254616d01565b9055565b90616d8660205f616d8c94616d7e828201616d78848801616c87565b90616cce565b019201616cee565b90616d3c565b565b9190616d9f57616d9d91616d5c565b565b610a8a565b9081549168010000000000000000831015616dd45782616dcc916001616dd295018155616c5f565b90616d8e565b565b610b86565b90929192616de561236b565b50616dee61236b565b50616df882616c45565b80616e0b616e055f6128eb565b9161072d565b115f14616edb57616e3190616e2b8491616e2560016142bb565b90612b0b565b90615e76565b90616e3d5f8301614d71565b92616e495f8401614da3565b9380616e5d616e57856118a3565b916118a3565b11616ebf57616e74616e6e846118a3565b916118a3565b145f14616e8f575050616e8a905f859101616d3c565b5b9190565b616eba9250616eb586616eac616ea3616c49565b945f8601616654565b60208401616662565b616da4565b616e8b565b5f632520601d60e01b815280616ed7600482016108ac565b0390fd5b50616f0691616f0185616ef8616eef616c49565b945f8601616654565b60208401616662565b616da4565b616f0f5f614db0565b9190565b634e487b7160e01b5f52605160045260245ffd5b91909180600114616f4657600203616f1357616f42916123ea565b905b565b50616f50916123ab565b90616f4456
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x13W[a#gV[a\0\x1D_5a\x04\xDCV[\x80c\x01\xFF\xC9\xA7\x14a\x04\xD7W\x80c\x06\xFD\xDE\x03\x14a\x04\xD2W\x80c\x07\xA1\xD5\xFA\x14a\x04\xCDW\x80c\t^\xA7\xB3\x14a\x04\xC8W\x80c\x0C\x05\xF8,\x14a\x04\xC3W\x80c\x13\xBE\xAA[\x14a\x04\xBEW\x80c\x18\x16\r\xDD\x14a\x04\xB9W\x80c\x1B\x02\xF8E\x14a\x04\xB4W\x80c\"\xA9}\x9C\x14a\x04\xAFW\x80c#\xB8r\xDD\x14a\x04\xAAW\x80c#\xE4`\xD2\x14a\x04\xA5W\x80c$\x81\xBB\\\x14a\x04\xA0W\x80c$\x8A\x9C\xA3\x14a\x04\x9BW\x80c(N\x133\x14a\x04\x96W\x80c//\xF1]\x14a\x04\x91W\x80c1<\xE5g\x14a\x04\x8CW\x80c3M\x0B\xBD\x14a\x04\x87W\x80c5\x9Bv\xFE\x14a\x04\x82W\x80c6D\xE5\x15\x14a\x04}W\x80c6V\x8A\xBE\x14a\x04xW\x80c:F\xB1\xA8\x14a\x04sW\x80c?K\xA8:\x14a\x04nW\x80c@\xC1\x0F\x19\x14a\x04iW\x80cD\xE1\x81\xAA\x14a\x04dW\x80cH\xB0\xDA\xA6\x14a\x04_W\x80cK\xDD6\xCE\x14a\x04ZW\x80cK\xF5\xD7\xE9\x14a\x04UW\x80cX|\xDE\x1E\x14a\x04PW\x80cZ\xDF\0!\x14a\x04KW\x80c\\\x19\xA9\\\x14a\x04FW\x80c\\\x97Z\xBB\x14a\x04AW\x80c_\x15\xC3\xC9\x14a\x04<W\x80ce\x1F\xD2h\x14a\x047W\x80cl3\xBC\xED\x14a\x042W\x80cl\xF0\x16%\x14a\x04-W\x80co\xC0c\xBE\x14a\x04(W\x80co\xCF\xFFE\x14a\x04#W\x80cp\xA0\x821\x14a\x04\x1EW\x80crf\0\xCE\x14a\x04\x19W\x80cvg\x18\x08\x14a\x04\x14W\x80c|y\x0C\xAB\x14a\x04\x0FW\x80c~\xCE\xBE\0\x14a\x04\nW\x80c\x84V\xCBY\x14a\x04\x05W\x80c\x84\xB0\x19n\x14a\x04\0W\x80c\x8ES\x9E\x8C\x14a\x03\xFBW\x80c\x90-U\xA5\x14a\x03\xF6W\x80c\x91\xD1HT\x14a\x03\xF1W\x80c\x91\xDD\xAD\xF4\x14a\x03\xECW\x80c\x95\xD8\x9BA\x14a\x03\xE7W\x80c\x99\x12}\x9B\x14a\x03\xE2W\x80c\x99\x89U\xD3\x14a\x03\xDDW\x80c\x9A\xB2N\xB0\x14a\x03\xD8W\x80c\x9B~\xF6K\x14a\x03\xD3W\x80c\x9D\xC2\x9F\xAC\x14a\x03\xCEW\x80c\xA0\x8DVT\x14a\x03\xC9W\x80c\xA2\x17\xFD\xDF\x14a\x03\xC4W\x80c\xA3\xD4H[\x14a\x03\xBFW\x80c\xA4\xD7\xE3\x1D\x14a\x03\xBAW\x80c\xA5q\xE1\x84\x14a\x03\xB5W\x80c\xA7\x0B\x9F\x0C\x14a\x03\xB0W\x80c\xA9\x05\x9C\xBB\x14a\x03\xABW\x80c\xAF*\xA6;\x14a\x03\xA6W\x80c\xB0\xCA%>\x14a\x03\xA1W\x80c\xBA\xBC9O\x14a\x03\x9CW\x80c\xBBMD6\x14a\x03\x97W\x80c\xC0*\xE7T\x14a\x03\x92W\x80c\xC1\xEBq7\x14a\x03\x8DW\x80c\xC3\xCD\xA5 \x14a\x03\x88W\x80c\xD5\x05\xAC\xCF\x14a\x03\x83W\x80c\xD5Gt\x1F\x14a\x03~W\x80c\xDDb\xED>\x14a\x03yW\x80c\xE3\xAB\xDF\xCB\x14a\x03tW\x80c\xE6:\xB1\xE9\x14a\x03oW\x80c\xF1\x12~\xD8\x14a\x03jW\x80c\xF5\x08\xE1\x9D\x14a\x03eWc\xF7^\x85\x12\x03a\0\x0EWa#2V[a\"\xCEV[a\"\x89V[a!\xA6V[a!BV[a \xDDV[a |V[a BV[a\x1F\x98V[a\x1E\xDCV[a\x1E\xA7V[a\x1ErV[a\x1E9V[a\x1D\xC5V[a\x1D\x90V[a\x1C\xE5V[a\x1C\xB0V[a\x1CDV[a\x1C\x0FV[a\x1B\xDAV[a\x1BeV[a\x1A\xF6V[a\x1A\x88V[a\x1ASV[a\x19\xDDV[a\x19\xA8V[a\x19sV[a\x19\x05V[a\x18\xD0V[a\x18mV[a\x188V[a\x17\xDDV[a\x17\xA1V[a\x16\\V[a\x16'V[a\x15\xEEV[a\x15lV[a\x15(V[a\x14\xF3V[a\x14\xBEV[a\x14^V[a\x13\xFAV[a\x13\x86V[a\x13QV[a\x13\x1CV[a\x12\xB0V[a\x12}V[a\x12HV[a\x12\x13V[a\x11\xC9V[a\x11\x94V[a\x11_V[a\x11\x17V[a\x0F\xD7V[a\x0F\xA4V[a\x0FnV[a\x0F:V[a\x0F\x05V[a\x0E\xD2V[a\x0E\x9DV[a\r\xB0V[a\rTV[a\x0C\xF4V[a\x0C\xBFV[a\x0C$V[a\nTV[a\t\xFBV[a\t\x8CV[a\t\x1AV[a\x08\xE5V[a\x08\xB1V[a\x07\xF6V[a\x07\x80V[a\x06\xD4V[a\x06\x17V[a\x05hV[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x05\t\x81a\x04\xF4V[\x03a\x05\x10WV[_\x80\xFD[\x90P5\x90a\x05!\x82a\x05\0V[V[\x90` \x82\x82\x03\x12a\x05<Wa\x059\x91_\x01a\x05\x14V[\x90V[a\x04\xECV[\x15\x15\x90V[a\x05O\x90a\x05AV[\x90RV[\x91\x90a\x05f\x90_` \x85\x01\x94\x01\x90a\x05FV[V[4a\x05\x98Wa\x05\x94a\x05\x83a\x05~6`\x04a\x05#V[a$\x04V[a\x05\x8Ba\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[_\x91\x03\x12a\x05\xA7WV[a\x04\xECV[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x05\xEDa\x05\xF6` \x93a\x05\xFB\x93a\x05\xE4\x81a\x05\xACV[\x93\x84\x80\x93a\x05\xB0V[\x95\x86\x91\x01a\x05\xB9V[a\x05\xC4V[\x01\x90V[a\x06\x14\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x05\xCEV[\x90V[4a\x06GWa\x06'6`\x04a\x05\x9DV[a\x06Ca\x062a%\"V[a\x06:a\x04\xE2V[\x91\x82\x91\x82a\x05\xFFV[\x03\x90\xF3[a\x04\xE8V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x06`\x90a\x06LV[\x90V[a\x06l\x90a\x06WV[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[a\x06\x9Ca\x06\xA5` \x93a\x06\xAA\x93a\x06\x93\x81a\x06pV[\x93\x84\x80\x93a\x06tV[\x95\x86\x91\x01a\x05\xB9V[a\x05\xC4V[\x01\x90V[\x91a\x06\xD1\x92a\x06\xC4`@\x82\x01\x93_\x83\x01\x90a\x06cV[` \x81\x84\x03\x91\x01Ra\x06}V[\x90V[4a\x07\x05Wa\x06\xE46`\x04a\x05\x9DV[a\x06\xECa%nV[\x90a\x07\x01a\x06\xF8a\x04\xE2V[\x92\x83\x92\x83a\x06\xAEV[\x03\x90\xF3[a\x04\xE8V[a\x07\x13\x81a\x06WV[\x03a\x07\x1AWV[_\x80\xFD[\x90P5\x90a\x07+\x82a\x07\nV[V[\x90V[a\x079\x81a\x07-V[\x03a\x07@WV[_\x80\xFD[\x90P5\x90a\x07Q\x82a\x070V[V[\x91\x90`@\x83\x82\x03\x12a\x07{W\x80a\x07oa\x07x\x92_\x86\x01a\x07\x1EV[\x93` \x01a\x07DV[\x90V[a\x04\xECV[4a\x07\xB1Wa\x07\xADa\x07\x9Ca\x07\x966`\x04a\x07SV[\x90a%\x98V[a\x07\xA4a\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[\x90` \x82\x82\x03\x12a\x07\xCFWa\x07\xCC\x91_\x01a\x07\x1EV[\x90V[a\x04\xECV[a\x07\xDD\x90a\x07-V[\x90RV[\x91\x90a\x07\xF4\x90_` \x85\x01\x94\x01\x90a\x07\xD4V[V[4a\x08&Wa\x08\"a\x08\x11a\x08\x0C6`\x04a\x07\xB6V[a%\xBEV[a\x08\x19a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x08qW\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x08lW` \x01\x92`\x01\x83\x02\x84\x01\x11a\x08gWV[a\x083V[a\x08/V[a\x08+V[\x90` \x82\x82\x03\x12a\x08\xA7W_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x08\xA2Wa\x08\x9E\x92\x01a\x087V[\x90\x91V[a\x04\xF0V[a\x04\xECV[_\x01\x90V[4a\x08\xE0Wa\x08\xCAa\x08\xC46`\x04a\x08vV[\x90a(\xAFV[a\x08\xD2a\x04\xE2V[\x80a\x08\xDC\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a\t\x15Wa\x08\xF56`\x04a\x05\x9DV[a\t\x11a\t\0a(\xBBV[a\t\x08a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\tHWa\t*6`\x04a\x05\x9DV[a\t2a*\x7FV[a\t:a\x04\xE2V[\x80a\tD\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x1C\x90V[`\xFF\x16\x90V[a\tg\x90`\x08a\tl\x93\x02a\tMV[a\tQV[\x90V[\x90a\tz\x91Ta\tWV[\x90V[a\t\x89`?_\x90a\toV[\x90V[4a\t\xBCWa\t\x9C6`\x04a\x05\x9DV[a\t\xB8a\t\xA7a\t}V[a\t\xAFa\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[\x90\x91``\x82\x84\x03\x12a\t\xF6Wa\t\xF3a\t\xDC\x84_\x85\x01a\x07\x1EV[\x93a\t\xEA\x81` \x86\x01a\x07\x1EV[\x93`@\x01a\x07DV[\x90V[a\x04\xECV[4a\n,Wa\n(a\n\x17a\n\x116`\x04a\t\xC1V[\x91a*\x89V[a\n\x1Fa\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[\x91` a\nR\x92\x94\x93a\nK`@\x82\x01\x96_\x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[4a\n\x85Wa\nla\ng6`\x04a\x07\xB6V[a+\xBAV[\x90a\n\x81a\nxa\x04\xE2V[\x92\x83\x92\x83a\n1V[\x03\x90\xF3[a\x04\xE8V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\n\xD1W[` \x83\x10\x14a\n\xCCWV[a\n\x9DV[\x91`\x7F\x16\x91a\n\xC1V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x0B\x07a\x0B\0\x83a\n\xB1V[\x80\x94a\n\xDBV[\x91`\x01\x81\x16\x90\x81_\x14a\x0B^WP`\x01\x14a\x0B\"W[PPPV[a\x0B/\x91\x92\x93\x94Pa\n\xE4V[\x91_\x92[\x81\x84\x10a\x0BFWPP\x01\x90_\x80\x80a\x0B\x1DV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x0B3V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x0B\x1DV[\x90a\x0B\x83\x91a\n\xEDV[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x0B\xA4\x90a\x05\xC4V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x0B\xBEW`@RV[a\x0B\x86V[\x90a\x0B\xE3a\x0B\xDC\x92a\x0B\xD3a\x04\xE2V[\x93\x84\x80\x92a\x0ByV[\x03\x83a\x0B\x9AV[V[\x90_\x10a\x0B\xF8Wa\x0B\xF5\x90a\x0B\xC3V[\x90V[a\n\x8AV[a\x0C\t`D_\x90a\x0B\xE5V[\x90V[a\x0C!\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x06}V[\x90V[4a\x0CTWa\x0C46`\x04a\x05\x9DV[a\x0CPa\x0C?a\x0B\xFDV[a\x0CGa\x04\xE2V[\x91\x82\x91\x82a\x0C\x0CV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x0Ce\x81a\x0CYV[\x03a\x0ClWV[_\x80\xFD[\x90P5\x90a\x0C}\x82a\x0C\\V[V[\x90` \x82\x82\x03\x12a\x0C\x98Wa\x0C\x95\x91_\x01a\x0CpV[\x90V[a\x04\xECV[a\x0C\xA6\x90a\x0CYV[\x90RV[\x91\x90a\x0C\xBD\x90_` \x85\x01\x94\x01\x90a\x0C\x9DV[V[4a\x0C\xEFWa\x0C\xEBa\x0C\xDAa\x0C\xD56`\x04a\x0C\x7FV[a-\xDBV[a\x0C\xE2a\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[4a\r\"Wa\r\x046`\x04a\x05\x9DV[a\r\x0Ca2\xB2V[a\r\x14a\x04\xE2V[\x80a\r\x1E\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x91\x90`@\x83\x82\x03\x12a\rOW\x80a\rCa\rL\x92_\x86\x01a\x0CpV[\x93` \x01a\x07\x1EV[\x90V[a\x04\xECV[4a\r\x83Wa\rma\rg6`\x04a\r'V[\x90a2\xE6V[a\rua\x04\xE2V[\x80a\r\x7F\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[`\xFF\x16\x90V[a\r\x97\x90a\r\x88V[\x90RV[\x91\x90a\r\xAE\x90_` \x85\x01\x94\x01\x90a\r\x8EV[V[4a\r\xE0Wa\r\xC06`\x04a\x05\x9DV[a\r\xDCa\r\xCBa3\x15V[a\r\xD3a\x04\xE2V[\x91\x82\x91\x82a\r\x9BV[\x03\x90\xF3[a\x04\xE8V[\x90` \x82\x82\x03\x12a\r\xFEWa\r\xFB\x91_\x01a\x07DV[\x90V[a\x04\xECV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[P`0\x90V[\x90V[a\x0E)\x81a\x0E\x17V[\x82\x10\x15a\x0ECWa\x0E;`\x01\x91a\x0E\x1DV[\x91\x02\x01\x90_\x90V[a\x0E\x03V[\x90V[a\x0E[\x90`\x08a\x0E`\x93\x02a\tMV[a\x0EHV[\x90V[\x90a\x0En\x91Ta\x0EKV[\x90V[`\x0Fa\x0E|\x81a\x0E\x17V[\x82\x10\x15a\x0E\x99Wa\x0E\x96\x91a\x0E\x90\x91a\x0E V[\x90a\x0EcV[\x90V[_\x80\xFD[4a\x0E\xCDWa\x0E\xC9a\x0E\xB8a\x0E\xB36`\x04a\r\xE5V[a\x0EqV[a\x0E\xC0a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x0F\0Wa\x0E\xE26`\x04a\x05\x9DV[a\x0E\xEAa3\xC6V[a\x0E\xF2a\x04\xE2V[\x80a\x0E\xFC\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a\x0F5Wa\x0F\x156`\x04a\x05\x9DV[a\x0F1a\x0F a3\xD0V[a\x0F(a\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[4a\x0FiWa\x0FSa\x0FM6`\x04a\r'V[\x90a3\xE4V[a\x0F[a\x04\xE2V[\x80a\x0Fe\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a\x0F\x9FWa\x0F\x9Ba\x0F\x8Aa\x0F\x846`\x04a\x07SV[\x90a4aV[a\x0F\x92a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x0F\xD2Wa\x0F\xB46`\x04a\x05\x9DV[a\x0F\xBCa4\xBFV[a\x0F\xC4a\x04\xE2V[\x80a\x0F\xCE\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a\x10\x06Wa\x0F\xF0a\x0F\xEA6`\x04a\x07SV[\x90a4\xC9V[a\x0F\xF8a\x04\xE2V[\x80a\x10\x02\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x10\"a\x10\x1Da\x10'\x92a\x06LV[a\x10\x0BV[a\x06LV[\x90V[a\x103\x90a\x10\x0EV[\x90V[a\x10?\x90a\x10*V[\x90V[\x90a\x10L\x90a\x106V[_R` R`@_ \x90V[_\x1C\x90V[a\x10ia\x10n\x91a\x10XV[a\x0EHV[\x90V[a\x10{\x90Ta\x10]V[\x90V[a\x10\x89\x90`\x0Ca\x10BV[a\x10\x94_\x82\x01a\x10qV[\x91a\x10\xA1`\x01\x83\x01a\x10qV[\x91a\x10\xAE`\x02\x82\x01a\x10qV[\x91a\x10\xC7`\x04a\x10\xC0`\x03\x85\x01a\x10qV[\x93\x01a\x10qV[\x90V[\x90\x95\x94\x92a\x11\x15\x94a\x11\x04a\x11\x0E\x92a\x10\xFA`\x80\x96a\x10\xF0`\xA0\x88\x01\x9C_\x89\x01\x90a\x07\xD4V[` \x87\x01\x90a\x07\xD4V[`@\x85\x01\x90a\x07\xD4V[``\x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[4a\x11KWa\x11Ga\x112a\x11-6`\x04a\x07\xB6V[a\x10~V[\x91a\x11>\x95\x93\x95a\x04\xE2V[\x95\x86\x95\x86a\x10\xCAV[\x03\x90\xF3[a\x04\xE8V[a\x11\\`@_\x90a\x0EcV[\x90V[4a\x11\x8FWa\x11o6`\x04a\x05\x9DV[a\x11\x8Ba\x11za\x11PV[a\x11\x82a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x11\xC4Wa\x11\xA46`\x04a\x05\x9DV[a\x11\xC0a\x11\xAFa6\0V[a\x11\xB7a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x11\xF9Wa\x11\xD96`\x04a\x05\x9DV[a\x11\xF5a\x11\xE4a6\xC1V[a\x11\xECa\x04\xE2V[\x91\x82\x91\x82a\x05\xFFV[\x03\x90\xF3[a\x04\xE8V[\x91\x90a\x12\x11\x90_` \x85\x01\x94\x01\x90a\x06cV[V[4a\x12CWa\x12?a\x12.a\x12)6`\x04a\x07\xB6V[a7-V[a\x126a\x04\xE2V[\x91\x82\x91\x82a\x11\xFEV[\x03\x90\xF3[a\x04\xE8V[4a\x12xWa\x12X6`\x04a\x05\x9DV[a\x12ta\x12ca7LV[a\x12ka\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[4a\x12\xABWa\x12\x95a\x12\x906`\x04a\x07\xB6V[a7uV[a\x12\x9Da\x04\xE2V[\x80a\x12\xA7\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a\x12\xE0Wa\x12\xC06`\x04a\x05\x9DV[a\x12\xDCa\x12\xCBa7\x88V[a\x12\xD3a\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x12\xFCa\x12\xF7a\x13\x01\x92a\x12\xE5V[a\x10\x0BV[a\x07-V[\x90V[a\x13\x0E`0a\x12\xE8V[\x90V[a\x13\x19a\x13\x04V[\x90V[4a\x13LWa\x13,6`\x04a\x05\x9DV[a\x13Ha\x137a\x13\x11V[a\x13?a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x13\x81Wa\x13}a\x13la\x13g6`\x04a\x07\xB6V[a7\x9EV[a\x13ta\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x13\xB4Wa\x13\x966`\x04a\x05\x9DV[a\x13\x9Ea8UV[a\x13\xA6a\x04\xE2V[\x80a\x13\xB0\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x13\xD0a\x13\xCBa\x13\xD5\x92a\x13\xB9V[a\x10\x0BV[a\x07-V[\x90V[a\x13\xECj\x08E\x95\x16\x14\x01HJ\0\0\0a\x13\xBCV[\x90V[a\x13\xF7a\x13\xD8V[\x90V[4a\x14*Wa\x14\n6`\x04a\x05\x9DV[a\x14&a\x14\x15a\x13\xEFV[a\x14\x1Da\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x90a\x149\x90a\x106V[_R` R`@_ \x90V[a\x14[\x90a\x14V`\r\x91_\x92a\x14/V[a\toV[\x90V[4a\x14\x8EWa\x14\x8Aa\x14ya\x14t6`\x04a\x07\xB6V[a\x14EV[a\x14\x81a\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[c\xFF\xFF\xFF\xFF\x16\x90V[a\x14\xA5\x90a\x14\x93V[\x90RV[\x91\x90a\x14\xBC\x90_` \x85\x01\x94\x01\x90a\x14\x9CV[V[4a\x14\xEEWa\x14\xEAa\x14\xD9a\x14\xD46`\x04a\x07\xB6V[a8cV[a\x14\xE1a\x04\xE2V[\x91\x82\x91\x82a\x14\xA9V[\x03\x90\xF3[a\x04\xE8V[4a\x15#Wa\x15\x1Fa\x15\x0Ea\x15\t6`\x04a\x07\xB6V[a8\x8EV[a\x15\x16a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x15XWa\x15Ta\x15Ca\x15>6`\x04a\x07\xB6V[a8\xACV[a\x15Ka\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[a\x15i`A_\x90a\x0EcV[\x90V[4a\x15\x9CWa\x15|6`\x04a\x05\x9DV[a\x15\x98a\x15\x87a\x15]V[a\x15\x8Fa\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x90\x95\x94\x92a\x15\xEC\x94a\x15\xDBa\x15\xE5\x92a\x15\xD1`\x80\x96a\x15\xC7`\xA0\x88\x01\x9C_\x89\x01\x90a\x05FV[` \x87\x01\x90a\x07\xD4V[`@\x85\x01\x90a\x07\xD4V[``\x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[4a\x16\"Wa\x16\x1Ea\x16\ta\x16\x046`\x04a\x07\xB6V[a8\xCBV[\x91a\x16\x15\x95\x93\x95a\x04\xE2V[\x95\x86\x95\x86a\x15\xA1V[\x03\x90\xF3[a\x04\xE8V[4a\x16WWa\x16Sa\x16Ba\x16=6`\x04a\x07\xB6V[a:;V[a\x16Ja\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x16\x8AWa\x16l6`\x04a\x05\x9DV[a\x16ta:tV[a\x16|a\x04\xE2V[\x80a\x16\x86\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[`\xFF`\xF8\x1B\x16\x90V[a\x16\xA1\x90a\x16\x8FV[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\x16\xC1\x90a\x07-V[\x90RV[\x90a\x16\xD2\x81` \x93a\x16\xB8V[\x01\x90V[` \x01\x90V[\x90a\x16\xF9a\x16\xF3a\x16\xEC\x84a\x16\xA5V[\x80\x93a\x16\xA9V[\x92a\x16\xB2V[\x90_[\x81\x81\x10a\x17\tWPPP\x90V[\x90\x91\x92a\x17\"a\x17\x1C`\x01\x92\x86Qa\x16\xC5V[\x94a\x16\xD6V[\x91\x01\x91\x90\x91a\x16\xFCV[\x93\x95\x91\x94a\x17}a\x17ra\x17\x91\x95a\x17da\x17\x87\x95a\x17\x9E\x9C\x9Aa\x17W`\xE0\x8C\x01\x92_\x8D\x01\x90a\x16\x98V[\x8A\x82\x03` \x8C\x01Ra\x05\xCEV[\x90\x88\x82\x03`@\x8A\x01Ra\x05\xCEV[\x97``\x87\x01\x90a\x07\xD4V[`\x80\x85\x01\x90a\x06cV[`\xA0\x83\x01\x90a\x0C\x9DV[`\xC0\x81\x84\x03\x91\x01Ra\x16\xDCV[\x90V[4a\x17\xD8Wa\x17\xB16`\x04a\x05\x9DV[a\x17\xD4a\x17\xBCa:\xFBV[\x93a\x17\xCB\x97\x95\x97\x93\x91\x93a\x04\xE2V[\x97\x88\x97\x88a\x17,V[\x03\x90\xF3[a\x04\xE8V[4a\x17\xF2Wa\x17\xED6`\x04a\r\xE5V[a;\x85V[a\x04\xE8V[\x90V[a\x18\x0Ea\x18\ta\x18\x13\x92a\x17\xF7V[a\x10\x0BV[a\x07-V[\x90V[a\x18*jR\xB7\xD2\xDC\xC8\x0C\xD2\xE4\0\0\0a\x17\xFAV[\x90V[a\x185a\x18\x16V[\x90V[4a\x18hWa\x18H6`\x04a\x05\x9DV[a\x18da\x18Sa\x18-V[a\x18[a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x18\x9EWa\x18\x9Aa\x18\x89a\x18\x836`\x04a\r'V[\x90a;\x93V[a\x18\x91a\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x18\xB7\x90a\x18\xA3V[\x90RV[\x91\x90a\x18\xCE\x90_` \x85\x01\x94\x01\x90a\x18\xAEV[V[4a\x19\0Wa\x18\xE06`\x04a\x05\x9DV[a\x18\xFCa\x18\xEBa;\xC1V[a\x18\xF3a\x04\xE2V[\x91\x82\x91\x82a\x18\xBBV[\x03\x90\xF3[a\x04\xE8V[4a\x195Wa\x19\x156`\x04a\x05\x9DV[a\x191a\x19 a;\xD5V[a\x19(a\x04\xE2V[\x91\x82\x91\x82a\x05\xFFV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x19Qa\x19La\x19V\x92a\x19:V[a\x10\x0BV[a\x07-V[\x90V[a\x19eb\x01Q\x80a\x19=V[\x90V[a\x19pa\x19YV[\x90V[4a\x19\xA3Wa\x19\x836`\x04a\x05\x9DV[a\x19\x9Fa\x19\x8Ea\x19hV[a\x19\x96a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x19\xD8Wa\x19\xD4a\x19\xC3a\x19\xBE6`\x04a\x07\xB6V[a;\xEBV[a\x19\xCBa\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x1A\rWa\x1A\ta\x19\xF8a\x19\xF36`\x04a\x07\xB6V[a<FV[a\x1A\0a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x1A)a\x1A$a\x1A.\x92a\x1A\x12V[a\x10\x0BV[a\x07-V[\x90V[a\x1AEjJr=\xC6\xB4\x0B\x8A\x9A\0\0\0a\x1A\x15V[\x90V[a\x1APa\x1A1V[\x90V[4a\x1A\x83Wa\x1Ac6`\x04a\x05\x9DV[a\x1A\x7Fa\x1Ana\x1AHV[a\x1Ava\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x1A\xB7Wa\x1A\xA1a\x1A\x9B6`\x04a\x07SV[\x90a<uV[a\x1A\xA9a\x04\xE2V[\x80a\x1A\xB3\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x90\x91``\x82\x84\x03\x12a\x1A\xF1Wa\x1A\xEEa\x1A\xD7\x84_\x85\x01a\x07\x1EV[\x93a\x1A\xE5\x81` \x86\x01a\x07DV[\x93`@\x01a\x07DV[\x90V[a\x04\xECV[4a\x1B%Wa\x1B\x0Fa\x1B\t6`\x04a\x1A\xBCV[\x91a@&V[a\x1B\x17a\x04\xE2V[\x80a\x1B!\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x90V[_\x1B\x90V[a\x1BFa\x1BAa\x1BK\x92a\x1B*V[a\x1B-V[a\x0CYV[\x90V[a\x1BW_a\x1B2V[\x90V[a\x1Bba\x1BNV[\x90V[4a\x1B\x95Wa\x1Bu6`\x04a\x05\x9DV[a\x1B\x91a\x1B\x80a\x1BZV[a\x1B\x88a\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x1B\xB5\x90`\x08a\x1B\xBA\x93\x02a\tMV[a\x1B\x9AV[\x90V[\x90a\x1B\xC8\x91Ta\x1B\xA5V[\x90V[a\x1B\xD7`C_\x90a\x1B\xBDV[\x90V[4a\x1C\nWa\x1B\xEA6`\x04a\x05\x9DV[a\x1C\x06a\x1B\xF5a\x1B\xCBV[a\x1B\xFDa\x04\xE2V[\x91\x82\x91\x82a\x11\xFEV[\x03\x90\xF3[a\x04\xE8V[4a\x1C?Wa\x1C\x1F6`\x04a\x05\x9DV[a\x1C;a\x1C*a@3V[a\x1C2a\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[4a\x1CrWa\x1C\\a\x1CW6`\x04a\x07\xB6V[aAZV[a\x1Cda\x04\xE2V[\x80a\x1Cn\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x1C\x8Ea\x1C\x89a\x1C\x93\x92a\x1CwV[a\x10\x0BV[a\x07-V[\x90V[a\x1C\xA2b'\x8D\0a\x1CzV[\x90V[a\x1C\xADa\x1C\x96V[\x90V[4a\x1C\xE0Wa\x1C\xC06`\x04a\x05\x9DV[a\x1C\xDCa\x1C\xCBa\x1C\xA5V[a\x1C\xD3a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x1D\x16Wa\x1D\x12a\x1D\x01a\x1C\xFB6`\x04a\x07SV[\x90aAeV[a\x1D\ta\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[P`0\x90V[\x90P\x90V[\x90V[` \x01\x90V[a\x1DKa\x1DEa\x1D>\x83a\x1D\x1BV[\x80\x94a\x1D!V[\x91a\x1D&V[_\x91[\x83\x83\x10a\x1D[WPPPPV[a\x1Dqa\x1Dk`\x01\x92\x84Qa\x16\xC5V[\x92a\x1D)V[\x92\x01\x91\x90a\x1DNV[\x91\x90a\x1D\x8E\x90_a\x06\0\x85\x01\x94\x01\x90a\x1D/V[V[4a\x1D\xC0Wa\x1D\xA06`\x04a\x05\x9DV[a\x1D\xBCa\x1D\xABaB\x8CV[a\x1D\xB3a\x04\xE2V[\x91\x82\x91\x82a\x1DzV[\x03\x90\xF3[a\x04\xE8V[4a\x1D\xF6Wa\x1D\xF2a\x1D\xE1a\x1D\xDB6`\x04a\x07SV[\x90aB\xA2V[a\x1D\xE9a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[a\x1E0a\x1E7\x94a\x1E&``\x94\x98\x97\x95a\x1E\x1C`\x80\x86\x01\x9A_\x87\x01\x90a\x07\xD4V[` \x85\x01\x90a\x07\xD4V[`@\x83\x01\x90a\x07\xD4V[\x01\x90a\x05FV[V[4a\x1EmWa\x1EI6`\x04a\x05\x9DV[a\x1Eia\x1ETaB\xD7V[\x90a\x1E`\x94\x92\x94a\x04\xE2V[\x94\x85\x94\x85a\x1D\xFBV[\x03\x90\xF3[a\x04\xE8V[4a\x1E\xA2Wa\x1E\x9Ea\x1E\x8Da\x1E\x886`\x04a\x07\xB6V[aD|V[a\x1E\x95a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x1E\xD7Wa\x1E\xB76`\x04a\x05\x9DV[a\x1E\xD3a\x1E\xC2aD\x91V[a\x1E\xCAa\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x1F\x0CWa\x1F\x08a\x1E\xF7a\x1E\xF26`\x04a\x07\xB6V[aD\xA5V[a\x1E\xFFa\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[a\x1F\x1A\x81a\r\x88V[\x03a\x1F!WV[_\x80\xFD[\x90P5\x90a\x1F2\x82a\x1F\x11V[V[\x90\x91`\xC0\x82\x84\x03\x12a\x1F\x93Wa\x1FL\x83_\x84\x01a\x07\x1EV[\x92a\x1FZ\x81` \x85\x01a\x07DV[\x92a\x1Fh\x82`@\x83\x01a\x07DV[\x92a\x1F\x90a\x1Fy\x84``\x85\x01a\x1F%V[\x93a\x1F\x87\x81`\x80\x86\x01a\x0CpV[\x93`\xA0\x01a\x0CpV[\x90V[a\x04\xECV[4a\x1F\xCDWa\x1F\xB7a\x1F\xAB6`\x04a\x1F4V[\x94\x93\x90\x93\x92\x91\x92aE/V[a\x1F\xBFa\x04\xE2V[\x80a\x1F\xC9\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[`\xE0\x81\x83\x03\x12a =Wa\x1F\xE8\x82_\x83\x01a\x07\x1EV[\x92a\x1F\xF6\x83` \x84\x01a\x07\x1EV[\x92a \x04\x81`@\x85\x01a\x07DV[\x92a \x12\x82``\x83\x01a\x07DV[\x92a :a #\x84`\x80\x85\x01a\x1F%V[\x93a 1\x81`\xA0\x86\x01a\x0CpV[\x93`\xC0\x01a\x0CpV[\x90V[a\x04\xECV[4a wWa aa U6`\x04a\x1F\xD2V[\x95\x94\x90\x94\x93\x91\x93aF\x83V[a ia\x04\xE2V[\x80a s\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a \xABWa \x95a \x8F6`\x04a\r'V[\x90aG\xA1V[a \x9Da\x04\xE2V[\x80a \xA7\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x91\x90`@\x83\x82\x03\x12a \xD8W\x80a \xCCa \xD5\x92_\x86\x01a\x07\x1EV[\x93` \x01a\x07\x1EV[\x90V[a\x04\xECV[4a!\x0EWa!\na \xF9a \xF36`\x04a \xB0V[\x90aG\xC3V[a!\x01a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[a!?a!\x13V[\x90V[4a!rWa!R6`\x04a\x05\x9DV[a!na!]a!7V[a!ea\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*\x90V[a!\xA3a!wV[\x90V[4a!\xD6Wa!\xB66`\x04a\x05\x9DV[a!\xD2a!\xC1a!\x9BV[a!\xC9a\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[a!\xE4\x81a\x14\x93V[\x03a!\xEBWV[_\x80\xFD[\x90P5\x90a!\xFC\x82a!\xDBV[V[\x91\x90`@\x83\x82\x03\x12a\"&W\x80a\"\x1Aa\"#\x92_\x86\x01a\x07\x1EV[\x93` \x01a!\xEFV[\x90V[a\x04\xECV[a\"4\x90a\x18\xA3V[\x90RV[`\x01\x80`\xD0\x1B\x03\x16\x90V[a\"L\x90a\"8V[\x90RV[\x90` \x80a\"r\x93a\"h_\x82\x01Q_\x86\x01\x90a\"+V[\x01Q\x91\x01\x90a\"CV[V[\x91\x90a\"\x87\x90_`@\x85\x01\x94\x01\x90a\"PV[V[4a\"\xBAWa\"\xB6a\"\xA5a\"\x9F6`\x04a!\xFEV[\x90aH1V[a\"\xADa\x04\xE2V[\x91\x82\x91\x82a\"tV[\x03\x90\xF3[a\x04\xE8V[a\"\xCB`B_\x90a\x0EcV[\x90V[4a\"\xFEWa\"\xDE6`\x04a\x05\x9DV[a\"\xFAa\"\xE9a\"\xBFV[a\"\xF1a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[a#/a#\x03V[\x90V[4a#bWa#B6`\x04a\x05\x9DV[a#^a#Ma#'V[a#Ua\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[_\x80\xFD[_\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a#\x8Fa#\x95\x91a\"8V[\x91a\"8V[\x01\x90`\x01\x80`\xD0\x1B\x03\x82\x11a#\xA6WV[a#oV[\x90a#\xBE\x91a#\xB8a#kV[Pa#\x83V[\x90V[a#\xCDa#\xD3\x91a\"8V[\x91a\"8V[\x90\x03\x90`\x01\x80`\xD0\x1B\x03\x82\x11a#\xE5WV[a#oV[\x90a#\xFD\x91a#\xF7a#kV[Pa#\xC1V[\x90V[_\x90V[a$\x0Ca$\0V[P\x80a$'a$!cye\xDB\x0B`\xE0\x1Ba\x04\xF4V[\x91a\x04\xF4V[\x14\x90\x81\x15a$4W[P\x90V[a$>\x91PaHGV[_a$0V[``\x90V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a$ua$n\x83a\n\xB1V[\x80\x94a$IV[\x91`\x01\x81\x16\x90\x81_\x14a$\xCCWP`\x01\x14a$\x90W[PPPV[a$\x9D\x91\x92\x93\x94Pa$RV[\x91_\x92[\x81\x84\x10a$\xB4WPP\x01\x90_\x80\x80a$\x8BV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a$\xA1V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a$\x8BV[\x90a$\xF1\x91a$[V[\x90V[\x90a%\x14a%\r\x92a%\x04a\x04\xE2V[\x93\x84\x80\x92a$\xE7V[\x03\x83a\x0B\x9AV[V[a%\x1F\x90a$\xF4V[\x90V[a%*a$DV[Pa%5`\x03a%\x16V[\x90V[_\x90V[``\x90V[a%Ma%R\x91a\x10XV[a\x1B\x9AV[\x90V[a%_\x90Ta%AV[\x90V[a%k\x90a\x0B\xC3V[\x90V[a%va%8V[Pa%\x7Fa%<V[Pa%\x8A`Ca%UV[\x90a%\x95`Da%bV[\x90V[a%\xB5\x91a%\xA4a$\0V[Pa%\xADaHmV[\x91\x90\x91aHzV[`\x01\x90V[_\x90V[_a%\xD6a%\xDC\x92a%\xCEa%\xBAV[P`\x0Ca\x10BV[\x01a\x10qV[\x90V[\x90a%\xF9\x91a%\xF4a%\xEFa#\x03V[aH\x8AV[a(YV[V[P\x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a&(\x91\x02\x91a&\"_\x19\x84a&\tV[\x92a&\tV[\x91\x81\x19\x16\x91\x16\x17\x90V[a&Fa&Aa&K\x92a\x07-V[a\x10\x0BV[a\x07-V[\x90V[\x90V[\x91\x90a&ga&ba&o\x93a&2V[a&NV[\x90\x83Ta&\rV[\x90UV[a&\x85\x91a&\x7Fa%\xBAV[\x91a&QV[V[[\x81\x81\x10a&\x93WPPV[\x80a&\xA0_`\x01\x93a&sV[\x01a&\x88V[\x91\x90`\x1F\x81\x11a&\xB6W[PPPV[a&\xC2a&\xE7\x93a\n\xE4V[\x90` a&\xCE\x84a%\xFFV[\x83\x01\x93\x10a&\xEFW[a&\xE0\x90a%\xFFV[\x01\x90a&\x87V[_\x80\x80a&\xB1V[\x91Pa&\xE0\x81\x92\x90Pa&\xD7V[\x90a'\r\x90_\x19\x90`\x08\x02a\tMV[\x19\x16\x90V[\x81a'\x1C\x91a&\xFDV[\x90`\x02\x02\x17\x90V[\x91a'/\x90\x82a%\xFBV[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a'\xEEWa'S\x82a'M\x85Ta\n\xB1V[\x85a&\xA6V[_\x90`\x1F\x83\x11`\x01\x14a'\x86W\x91\x80\x91a'u\x93_\x92a'zW[PPa'\x12V[\x90U[V[\x90\x91P\x015_\x80a'nV[`\x1F\x19\x83\x16\x91a'\x95\x85a\n\xE4V[\x92_[\x81\x81\x10a'\xD6WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a'\xBCW[PPP\x02\x01\x90Ua'xV[a'\xCC\x91\x015`\x1F\x84\x16\x90a&\xFDV[\x90U_\x80\x80a'\xB0V[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a'\x98V[a\x0B\x86V[\x90a'\xFE\x92\x91a'$V[V[\x90\x82_\x93\x92\x827\x01RV[\x91\x90a(%\x81a(\x1E\x81a(*\x95a\x06tV[\x80\x95a(\0V[a\x05\xC4V[\x01\x90V[\x91a(Ha(V\x94\x92`@\x85\x01\x90\x85\x82\x03_\x87\x01Ra\x06}V[\x92` \x81\x85\x03\x91\x01Ra(\x0BV[\x90V[\x90a(d`Da%bV[a(q\x83\x83\x90`Da'\xF3V[\x91\x90\x91a(\xAA\x7F\xB9\xA2\x08\x84&\xF0;0\xA8\x1C\x06B\x80\x94\xFB\xFA\x9E&\x92s\x9B2A\xAFk\x9A\xB1\xDAKUF\xBE\x93a(\xA1a\x04\xE2V[\x93\x84\x93\x84a(.V[\x03\x90\xA1V[\x90a(\xB9\x91a%\xDFV[V[a(\xC3a%\xBAV[Pa(\xCE`\x02a\x10qV[\x90V[a(\xE1a(\xDCa!\x13V[aH\x8AV[a(\xE9a)\xAAV[V[a(\xFFa(\xFAa)\x04\x92a\x1B*V[a\x10\x0BV[a\x07-V[\x90V[a)\x1Ba)\x16a) \x92a\x1B*V[a\x10\x0BV[a\x06LV[\x90V[a),\x90a)\x07V[\x90V[\x90a);`\xFF\x91a\x1B-V[\x91\x81\x19\x16\x91\x16\x17\x90V[a)N\x90a\x05AV[\x90V[\x90V[\x90a)ia)da)p\x92a)EV[a)QV[\x82Ta)/V[\x90UV[\x90a)\x80_\x19\x91a\x1B-V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a)\x9Fa)\x9Aa)\xA6\x92a&2V[a&NV[\x82Ta)tV[\x90UV[a)\xB4`@a\x10qV[a)\xC6a)\xC0_a(\xEBV[\x91a\x07-V[\x03a*cWa)\xD5`Ca%UV[a)\xEFa)\xE9a)\xE4_a)#V[a\x06WV[\x91a\x06WV[\x14a*GWa*\0`\x01`?a)TV[a*\x0BB`@a)\x8AV[Ba*B\x7F\x11\x94\xB04\xCF\xA9\xABX\x07IJ\x1D\\f}\x8B\x0En\x97\xF3\x88\x88t*\xA3\x87\x1A2 4\x11`\x91a*9a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xA1V[_c;\nH\xBD`\xE1\x1B\x81R\x80a*_`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c8\xE9=\xBD`\xE1\x1B\x81R\x80a*{`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[a*\x87a(\xD1V[V[\x91a*\xB3\x92a*\x96a$\0V[Pa*\xABa*\xA2aHmV[\x82\x90\x84\x91aH\xDEV[\x91\x90\x91aIjV[`\x01\x90V[a*\xC1\x90a\x10*V[\x90V[_\x80\xFD[`\xE0\x1B\x90V[\x90PQ\x90a*\xDB\x82a\x070V[V[\x90` \x82\x82\x03\x12a*\xF6Wa*\xF3\x91_\x01a*\xCEV[\x90V[a\x04\xECV[a+\x03a\x04\xE2V[=_\x82>=\x90\xFD[a+\x1Aa+ \x91\x93\x92\x93a\x07-V[\x92a\x07-V[\x82\x03\x91\x82\x11a++WV[a#oV[\x90V[a+Ga+Ba+L\x92a+0V[a\x10\x0BV[a\x07-V[\x90V[a+^a+d\x91\x93\x92\x93a\x07-V[\x92a\x07-V[\x91a+p\x83\x82\x02a\x07-V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a+\x7FWV[a#oV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a+\xA4a+\xAA\x91a\x07-V[\x91a\x07-V[\x90\x81\x15a+\xB5W\x04\x90V[a+\x84V[a+\xC2a%\xBAV[\x91a+\xCBa%\xBAV[\x91a+\xE2_a+\xDC`\x0C\x84\x90a\x10BV[\x01a\x10qV[\x90a+\xFA`\x02a+\xF4`\x0C\x84\x90a\x10BV[\x01a\x10qV[\x91a,3` a,\t0a*\xB8V[ce\x1F\xD2h\x90a,(\x86\x92a,\x1Ca\x04\xE2V[\x95\x86\x94\x85\x93\x84\x93a*\xC8V[\x83R`\x04\x83\x01a\x11\xFEV[\x03\x91Z\xFA\x90\x81\x15a-\x8CWa,~\x91` \x91_\x91a-_W[P\x93a,W0a*\xB8V[a,sc\x99\x89U\xD3a,ga\x04\xE2V[\x95\x86\x94\x85\x93\x84\x93a*\xC8V[\x83R`\x04\x83\x01a\x11\xFEV[\x03\x91Z\xFA\x90\x81\x15a-ZW_\x91a-,W[P\x91\x81a,\xA5a,\x9F_a(\xEBV[\x91a\x07-V[\x11a,\xFBW[PP\x81a,\xC0a,\xBA_a(\xEBV[\x91a\x07-V[\x11a,\xCAW[PPV[a,\xF3\x92\x93Pa,\xDDa,\xEE\x91\x83a+\x0BV[a,\xE8a'\x10a+3V[\x90a+OV[a+\x98V[\x90_\x80a,\xC6V[a-$\x92\x96Pa-\x0Ea-\x1F\x91\x83a+\x0BV[a-\x19a'\x10a+3V[\x90a+OV[a+\x98V[\x93_\x80a,\xABV[a-M\x91P` =\x81\x11a-SW[a-E\x81\x83a\x0B\x9AV[\x81\x01\x90a*\xDDV[_a,\x90V[P=a-;V[a*\xFBV[a-\x7F\x91P\x82=\x81\x11a-\x85W[a-w\x81\x83a\x0B\x9AV[\x81\x01\x90a*\xDDV[_a,LV[P=a-mV[a*\xFBV[_\x90V[a-\x9E\x90a\x0CYV[\x90V[\x90a-\xAB\x90a-\x95V[_R` R`@_ \x90V[\x90V[a-\xC6a-\xCB\x91a\x10XV[a-\xB7V[\x90V[a-\xD8\x90Ta-\xBAV[\x90V[`\x01a-\xF4a-\xFA\x92a-\xECa-\x91V[P`\x05a-\xA1V[\x01a-\xCEV[\x90V[a.\x05aJ\x07V[a.\ra/cV[V[a.\x1Ba. \x91a\x10XV[a\tQV[\x90V[a.-\x90Ta.\x0FV[\x90V[`\x01a.<\x91\x01a\x07-V[\x90V[a.Na.T\x91\x93\x92\x93a\x07-V[\x92a\x07-V[\x82\x01\x80\x92\x11a._WV[a#oV[a.m\x90a\x10*V[\x90V[a.y\x90a\x10\x0EV[\x90V[a.\x85\x90a.pV[\x90V[a.\x91\x90a\x10*V[\x90V[_\x91\x03\x12a.\x9EWV[a\x04\xECV[\x90_\x92\x91\x80T\x90a.\xBDa.\xB6\x83a\n\xB1V[\x80\x94a\x06tV[\x91`\x01\x81\x16\x90\x81_\x14a/\x14WP`\x01\x14a.\xD8W[PPPV[a.\xE5\x91\x92\x93\x94Pa\n\xE4V[\x91_\x92[\x81\x84\x10a.\xFCWPP\x01\x90_\x80\x80a.\xD3V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a.\xE9V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a.\xD3V[a/Sa/`\x94\x92\x93a/I``\x84\x01\x95_\x85\x01\x90a\x06cV[` \x83\x01\x90a\x07\xD4V[`@\x81\x84\x03\x91\x01Ra.\xA3V[\x90V[a/va/p`?a.#V[\x15a\x05AV[a2\x96Wa/\x82a@3V[a2zWa/\xABa/\x9DBa/\x97`@a\x10qV[\x90a+\x0BV[a/\xA5a\x1C\x96V[\x90a+\x98V[\x80a/\xC7a/\xC1a/\xBC`Aa\x10qV[a\x07-V[\x91a\x07-V[\x11\x15a2^Wa/\xE1\x90a/\xDB`Aa\x10qV[\x90a+\x0BV[\x90\x81a0\x0Fa0\ta0\x04a/\xF4a\x13\x04V[a/\xFE`Aa\x10qV[\x90a+\x0BV[a\x07-V[\x91a\x07-V[\x11a2;W[a0\x1E_a(\xEBV[\x90a0(_a(\xEBV[\x91[\x82a0=a07\x86a\x07-V[\x91a\x07-V[\x10\x15a0\x84Wa0xa0~\x91a0ra0l`\x0Fa0fa0_`Aa\x10qV[\x89\x90a.?V[\x90a\x0E V[\x90a\x0EcV[\x90a.?V[\x92a.0V[\x91a0*V[\x91P\x91a0\x9Ba0\x94`Ba\x10qV[\x83\x90a.?V[a0\xB4a0\xAEa0\xA9a\x13\xD8V[a\x07-V[\x91a\x07-V[\x11a2\x1FWa0\xCFa0\xD6\x91a0\xCA`Aa\x10qV[a.?V[`Aa)\x8AV[a0\xF3a0\xEC\x82a0\xE7`Ba\x10qV[a.?V[`Ba)\x8AV[a1\x06a0\xFF0a.dV[\x82\x90aJ1V[a1#a1\x120a.dV[a1\x1C`Ca%UV[\x83\x91aHzV[a1=a18a13`Ca%UV[a.|V[a.\x88V[c\x18\xB6\x8B\x8Ca1K0a.dV[\x83\x92`D\x92\x81;\x15a2\x1AW_a1u\x91a1\x80\x82\x96a1ia\x04\xE2V[\x98\x89\x97\x88\x96\x87\x95a*\xC8V[\x85R`\x04\x85\x01a//V[\x03\x92Z\xF1\x80\x15a2\x15Wa1\xE9W[Pa1\x9A`Aa\x10qV[\x90a1\xA4_a)#V[\x90a1\xCF\x7F4\xB7=\x0C\x96\xE9\xFFMS\x11CH\x17\xC8\xEC\xC90\xE7\xD2x,[\xDE.y\xDCD\xB0YgU\xBB\x92a\x106V[\x92a1\xE4a1\xDBa\x04\xE2V[\x92\x83\x92\x83a\n1V[\x03\x90\xA2V[a2\x08\x90_=\x81\x11a2\x0EW[a2\0\x81\x83a\x0B\x9AV[\x81\x01\x90a.\x94V[_a1\x8FV[P=a1\xF6V[a*\xFBV[a*\xC4V[_c#\x06N\xBD`\xE0\x1B\x81R\x80a27`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90Pa2Xa2Ha\x13\x04V[a2R`Aa\x10qV[\x90a+\x0BV[\x90a0\x15V[_c\xE0\x85\xD2+`\xE0\x1B\x81R\x80a2v`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\x11UbK`\xE2\x1B\x81R\x80a2\x92`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\x19\xAF\xC9\x9D`\xE2\x1B\x81R\x80a2\xAE`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[a2\xBAa-\xFDV[V[\x90a2\xD7\x91a2\xD2a2\xCD\x82a-\xDBV[aH\x8AV[a2\xD9V[V[\x90a2\xE3\x91aJ\x8FV[PV[\x90a2\xF0\x91a2\xBCV[V[_\x90V[\x90V[a3\ra3\x08a3\x12\x92a2\xF6V[a\x10\x0BV[a\r\x88V[\x90V[a3\x1Da2\xF2V[Pa3(`\x12a2\xF9V[\x90V[a3;a36a!\x13V[aH\x8AV[a3Ca3EV[V[a3O`@a\x10qV[a3aa3[_a(\xEBV[\x91a\x07-V[\x14a3\xAAWa3r`\x01`?a)TV[\x7FJy*\x0B\xE4+Vr\xFA\xA4\x01)\xFCdi\x07$\x90w\\\xA8\xD3\xC3N\x85-MU\xD3\xA75\xA9a3\x9Ba\x04\xE2V[\x80a3\xA5\x81a\x08\xACV[\x03\x90\xA1V[_c\x8F\x98@A`\xE0\x1B\x81R\x80a3\xC2`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[a3\xCEa3+V[V[a3\xD8a-\x91V[Pa3\xE1aK;V[\x90V[\x90\x80a3\xFFa3\xF9a3\xF4aHmV[a\x06WV[\x91a\x06WV[\x03a4\x10Wa4\r\x91aK\xF5V[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a4(`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90a46\x90a\x106V[_R` R`@_ \x90V[\x90V[a4Ya4Ta4^\x92a\"8V[a\x10\x0BV[a\x07-V[\x90V[a4\x98\x91a4\x8Da4\x87a4\x82a4\x93\x94a4za%\xBAV[P`\na4,V[a4BV[\x91aL\xD6V[\x90aM\xCCV[a4EV[\x90V[a4\xABa4\xA6a\x1BNV[aH\x8AV[a4\xB3a4\xB5V[V[a4\xBDaOSV[V[a4\xC7a4\x9BV[V[\x90\x81a4\xE5a4\xDFa4\xDA_a)#V[a\x06WV[\x91a\x06WV[\x14a5\xE4W\x80a4\xFDa4\xF7_a(\xEBV[\x91a\x07-V[\x14a5\xC8Wa5\x1Fa5\x19a5\x14`\r3\x90a\x14/V[a.#V[\x15a\x05AV[a5\xACWa5,3aO`V[a5C`\x01a5=`\x0C3\x90a\x10BV[\x01a\x10qV[a5Ua5O\x83a\x07-V[\x91a\x07-V[\x10a5\x90Wa5\x8E\x91a5\x89\x82a5\x83`\x01a5s`\x0C3\x90a\x10BV[\x01\x91a5~\x83a\x10qV[a+\x0BV[\x90a)\x8AV[aJ1V[V[_c\x1C\x95\x9E\xD9`\xE2\x1B\x81R\x80a5\xA8`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_cD\x17v\t`\xE1\x1B\x81R\x80a5\xC4`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a5\xE0`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a5\xFC`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[a6\x08a%\xBAV[Pa6$a6\x14a\x13\xD8V[a6\x1E`Ba\x10qV[\x90a+\x0BV[\x90V[\x90a6:a63a\x04\xE2V[\x92\x83a\x0B\x9AV[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a6ZWa6V` \x91a\x05\xC4V[\x01\x90V[a\x0B\x86V[\x90a6qa6l\x83a6<V[a6'V[\x91\x82RV[_\x7Fmode=blocknumber&from=default\0\0\0\x91\x01RV[a6\xA7`\x1Da6_V[\x90a6\xB4` \x83\x01a6vV[V[a6\xBEa6\x9DV[\x90V[a6\xC9a$DV[Pa6\xD2a;\xC1V[a6\xEBa6\xE5a6\xE0aP\xFBV[a\x18\xA3V[\x91a\x18\xA3V[\x03a6\xFBWa6\xF8a6\xB6V[\x90V[_c\x01\xBF\xC1\xC5`\xE6\x1B\x81R\x80a7\x13`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90a7!\x90a\x106V[_R` R`@_ \x90V[a7Da7I\x91a7<a%8V[P`\ta7\x17V[a%UV[\x90V[a7Ta$\0V[Pa7_`@a\x10qV[a7qa7k_a(\xEBV[\x91a\x07-V[\x11\x90V[a7\x86\x90a7\x81aHmV[aQ\x10V[V[a7\x90a$\0V[Pa7\x9B`\x0Ea.#V[\x90V[a7\xF5\x90a7\xAAa%\xBAV[Pa7\xC2`\x01a7\xBC`\x0C\x84\x90a\x10BV[\x01a\x10qV[\x90a7\xEF`\x04a7\xE9a7\xE1_a7\xDB`\x0C\x87\x90a\x10BV[\x01a\x10qV[\x93`\x0Ca\x10BV[\x01a\x10qV[\x91aQ\x9BV[\x90V[a8\x08a8\x03a!wV[aH\x8AV[a8\x10a8\x12V[V[a8\x1D_`?a)TV[\x7Fs\xA5\xFC`\xAA\xFE\xEC\x8F\x13\x9A\xF2-\x98\xE6!@\xE2\xCE\x91M\x1F\x15\\i+BwW\xC3\xE4\x01La8Fa\x04\xE2V[\x80a8P\x81a\x08\xACV[\x03\x90\xA1V[a8]a7\xF8V[V[_\x90V[a8u\x90a8oa8_V[PaRGV[\x90V[\x90a8\x82\x90a\x106V[_R` R`@_ \x90V[a8\xA4a8\xA9\x91a8\x9Da%\xBAV[P_a8xV[a\x10qV[\x90V[a8\xC3a8\xC8\x91a8\xBBa$\0V[P`\ra\x14/V[a.#V[\x90V[\x90a8\xD4a$\0V[Pa8\xDDa%\xBAV[Pa8\xE6a%\xBAV[Pa8\xEFa%\xBAV[Pa8\xF8a%\xBAV[Pa9\ra9\x08`\r\x84\x90a\x14/V[a.#V[\x91a9$_a9\x1E`\x0C\x84\x90a\x10BV[\x01a\x10qV[\x91a9<`\x02a96`\x0C\x85\x90a\x10BV[\x01a\x10qV[\x90a9u` a9K0a*\xB8V[ce\x1F\xD2h\x90a9j\x87\x92a9^a\x04\xE2V[\x95\x86\x94\x85\x93\x84\x93a*\xC8V[\x83R`\x04\x83\x01a\x11\xFEV[\x03\x91Z\xFA\x90\x81\x15a:6Wa9\xC0\x91` \x91_\x91a:\tW[P\x94a9\x990a*\xB8V[a9\xB5c\x99\x89U\xD3a9\xA9a\x04\xE2V[\x95\x86\x94\x85\x93\x84\x93a*\xC8V[\x83R`\x04\x83\x01a\x11\xFEV[\x03\x91Z\xFA\x90\x81\x15a:\x04W_\x91a9\xD6W[P\x90V[a9\xF7\x91P` =\x81\x11a9\xFDW[a9\xEF\x81\x83a\x0B\x9AV[\x81\x01\x90a*\xDDV[_a9\xD2V[P=a9\xE5V[a*\xFBV[a:)\x91P\x82=\x81\x11a:/W[a:!\x81\x83a\x0B\x9AV[\x81\x01\x90a*\xDDV[_a9\x8EV[P=a:\x17V[a*\xFBV[a:M\x90a:Ga%\xBAV[PaRvV[\x90V[a:`a:[a!wV[aH\x8AV[a:ha:jV[V[a:raR\xECV[V[a:|a:PV[V[_\x90V[``\x90V[a:\x90\x90a\x10*V[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a:\xABW` \x80\x91\x02\x01\x90V[a\x0B\x86V[\x90a:\xC2a:\xBD\x83a:\x93V[a6'V[\x91\x82RV[6\x907V[\x90a:\xF1a:\xD9\x83a:\xB0V[\x92` \x80a:\xE7\x86\x93a:\x93V[\x92\x01\x91\x03\x90a:\xC7V[V[`\x0F`\xF8\x1B\x90V[a;\x03a:~V[Pa;\x0Ca$DV[Pa;\x15a$DV[Pa;\x1Ea%\xBAV[Pa;'a%8V[Pa;0a-\x91V[Pa;9a:\x82V[Pa;BaR\xF9V[\x90a;KaS9V[\x90F\x90a;W0a:\x87V[\x90a;a_a\x1B2V[\x90a;sa;n_a(\xEBV[a:\xCCV[\x90a;|a:\xF3V[\x96\x95\x94\x93\x92\x91\x90V[a;\x8Da%\xBAV[Pa;\x85V[a;\xBA\x91_a;\xAFa;\xB5\x93a;\xA7a$\0V[P`\x05a-\xA1V[\x01a\x14/V[a.#V[\x90V[_\x90V[a;\xC9a;\xBDV[Pa;\xD2aP\xFBV[\x90V[a;\xDDa$DV[Pa;\xE8`\x04a%\x16V[\x90V[a<C\x90a;\xF7a%\xBAV[Pa<\x0F`\x03a<\t`\x0C\x84\x90a\x10BV[\x01a\x10qV[\x90a<=`\x04a<7a</`\x02a<)`\x0C\x87\x90a\x10BV[\x01a\x10qV[\x93`\x0Ca\x10BV[\x01a\x10qV[\x91aQ\x9BV[\x90V[a<ma<ha<ca<r\x93a<[a%\xBAV[P`\na4,V[a4BV[aSyV[a4EV[\x90V[\x90\x81a<\x91a<\x8Ba<\x86_a)#V[a\x06WV[\x91a\x06WV[\x14a=\x90W\x80a<\xA9a<\xA3_a(\xEBV[\x91a\x07-V[\x14a=tWa<\xCBa<\xC5a<\xC0`\r3\x90a\x14/V[a.#V[\x15a\x05AV[a=XWa<\xD83aO`V[a<\xEF`\x03a<\xE9`\x0C3\x90a\x10BV[\x01a\x10qV[a=\x01a<\xFB\x83a\x07-V[\x91a\x07-V[\x10a=<Wa=:\x91a=5\x82a=/`\x03a=\x1F`\x0C3\x90a\x10BV[\x01\x91a=*\x83a\x10qV[a+\x0BV[\x90a)\x8AV[aS\xEEV[V[_c\x1C\x95\x9E\xD9`\xE2\x1B\x81R\x80a=T`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_cD\x17v\t`\xE1\x1B\x81R\x80a=p`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a=\x8C`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a=\xA8`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90a=\xC7\x92\x91a=\xC2a=\xBDa#\x03V[aH\x8AV[a=\xC9V[V[\x80a=\xE4a=\xDEa=\xD9_a)#V[a\x06WV[\x91a\x06WV[\x14a@\nWa>\x06a>\0a=\xFB`\r\x84\x90a\x14/V[a.#V[\x15a\x05AV[\x80a?\xCFW[a?sW[\x81a>$a>\x1E_a(\xEBV[\x91a\x07-V[\x14\x80a?YW[\x80a??W[a>\xE4W[a>?\x81aO`V[a>V\x82_a>P`\x0C\x85\x90a\x10BV[\x01a)\x8AV[a>n\x83`\x02a>h`\x0C\x85\x90a\x10BV[\x01a)\x8AV[a>\x86\x82`\x01a>\x80`\x0C\x85\x90a\x10BV[\x01a)\x8AV[a>\x9E\x83`\x03a>\x98`\x0C\x85\x90a\x10BV[\x01a)\x8AV[\x90\x91a>\xCA\x7F\xAA\x80}\n\xBF0\xD9\x19h\xC7G\x8Cf\xB6\xD8%!\xA1\x06\xAF\x13\xED\xA06\xE2\x03m\xA9\xAF\x16\x89X\x92a\x106V[\x92a>\xDFa>\xD6a\x04\xE2V[\x92\x83\x92\x83a\n1V[\x03\x90\xA2V[a>\xF9_a>\xF4`\r\x84\x90a\x14/V[a)TV[\x80a?$\x7F\x02\xC2\xF0\xBA\x15\xB0?\x88\xB1\x8FH2`\x9A\x18\xCF5\xFCk?EF\xA9\x99 v\xD7E=\x134\xA8\x91a\x106V[\x90a?-a\x04\xE2V[\x80a?7\x81a\x08\xACV[\x03\x90\xA2a>6V[Pa?Ta?O`\r\x83\x90a\x14/V[a.#V[a>1V[P\x82a?ma?g_a(\xEBV[\x91a\x07-V[\x14a>+V[a?\x89`\x01a?\x84`\r\x84\x90a\x14/V[a)TV[\x80a?\xB4\x7Fl\xF2\x849\xA2\xDA\xAB\x1B&P\x97\"r\x12\xA5\xB7\x1E\nv\xF9\xED\x85\xE3\xF8\x15\xB5\xA6\xC3\xE2\x18\xEB\x7F\x91a\x106V[\x90a?\xBDa\x04\xE2V[\x80a?\xC7\x81a\x08\xACV[\x03\x90\xA2a>\x11V[P\x81a?\xE3a?\xDD_a(\xEBV[\x91a\x07-V[\x11\x80\x15a?\xF0W[a>\x0CV[P\x82a@\x04a?\xFE_a(\xEBV[\x91a\x07-V[\x11a?\xEBV[_c\xD9.#=`\xE0\x1B\x81R\x80a@\"`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90a@1\x92\x91a=\xACV[V[a@;a$\0V[Pa@F`Aa\x10qV[a@_a@Ya@Ta\x13\x04V[a\x07-V[\x91a\x07-V[\x10\x15\x90V[a@}\x90a@xa@sa#\x03V[aH\x8AV[a@\xBDV[V[\x90a@\x90`\x01\x80`\xA0\x1B\x03\x91a\x1B-V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x90a@\xB2a@\xADa@\xB9\x92a\x106V[a@\x9AV[\x82Ta@\x7FV[\x90UV[\x80a@\xD8a@\xD2a@\xCD_a)#V[a\x06WV[\x91a\x06WV[\x14aA>Wa@\xE7`Ca%UV[a@\xF2\x82`Ca@\x9DV[\x90aA&aA \x7F\x07\x01[j\x9F\x05\x911H\xFD_\xAD\xDF*\xCC\x97\x08\xF3\x05\x93\x7F0r\xCA+KF\xFA\xA5\xD0\x89\x8B\x93a\x106V[\x91a\x106V[\x91aA/a\x04\xE2V[\x80aA9\x81a\x08\xACV[\x03\x90\xA3V[_c\xD9.#=`\xE0\x1B\x81R\x80aAV`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[aAc\x90a@dV[V[aA\x82\x91aAqa$\0V[PaAzaHmV[\x91\x90\x91aIjV[`\x01\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11aA\x9CW` \x02\x90V[a\x0B\x86V[aA\xADaA\xB2\x91aA\x87V[a6'V[\x90V[\x90aA\xD3aA\xC2\x83aA\xA1V[\x92aA\xCD\x84\x91aA\x87V[\x90a:\xC7V[V[aA\xDF`0aA\xB5V[\x90V[\x90P\x90V[aA\xF1\x90Ta\x10]V[\x90V[`\x01\x01\x90V[aB\x16aB\x10aB\t\x83a\x0E\x17V[\x80\x94aA\xE2V[\x91a\x0E\x1DV[_\x91[\x83\x83\x10aB&WPPPPV[aBCaB=`\x01\x92aB8\x85aA\xE7V[a\x16\xC5V[\x92aA\xF4V[\x92\x01\x91\x90aB\x19V[\x90aBZ\x81a\x06\0\x93aA\xFAV[\x01\x90V[\x90aB~aBw\x92aBna\x04\xE2V[\x93\x84\x80\x92aBLV[\x03\x83a\x0B\x9AV[V[aB\x89\x90aB^V[\x90V[aB\x94aA\xD5V[PaB\x9F`\x0FaB\x80V[\x90V[\x90aB\xB5\x91aB\xAFa%\xBAV[Pa4aV[\x90V[\x90V[aB\xCFaB\xCAaB\xD4\x92aB\xB8V[a\x10\x0BV[a\x07-V[\x90V[aB\xDFa%\xBAV[PaB\xE8a%\xBAV[PaB\xF1a%\xBAV[PaB\xFAa$\0V[PaC\x05`@a\x10qV[aC\x17aC\x11_a(\xEBV[\x91a\x07-V[\x14aDVWaCAaC3BaC-`@a\x10qV[\x90a+\x0BV[aC;a\x1C\x96V[\x90a+\x98V[\x90aC\x83aCO`@a\x10qV[aC}aCoaC_`Aa\x10qV[aCi`\x01aB\xBBV[\x90a.?V[aCwa\x1C\x96V[\x90a+OV[\x90a.?V[aC\x8D`Aa\x10qV[aC\xA6aC\xA0aC\x9Ba\x13\x04V[a\x07-V[\x91a\x07-V[\x10_\x14aDHWaC\xCBaC\xC5`\x0FaC\xBF`Aa\x10qV[\x90a\x0E V[\x90a\x0EcV[[\x92aC\xD7`?a.#V[\x90\x81aD$W[P\x80aC\xFAW[\x91aC\xF0`Aa\x10qV[\x91\x93\x92\x91\x93\x92\x91\x90V[PaD\x05`Aa\x10qV[aD\x1EaD\x18aD\x13a\x13\x04V[a\x07-V[\x91a\x07-V[\x10aC\xE5V[\x90PaDAaD;aD6`Aa\x10qV[a\x07-V[\x91a\x07-V[\x11_aC\xDEV[aDQ_a(\xEBV[aC\xCCV[_\x90_\x91_\x91aDxaDraDl_\x94a(\xEBV[\x95a(\xEBV[\x93a(\xEBV[\x91\x90V[aD\x8E\x90aD\x88a%\xBAV[Pa<FV[\x90V[aD\x99a%\xBAV[PaD\xA2a(\xBBV[\x90V[`\x02aD\xBEaD\xC4\x92aD\xB6a%\xBAV[P`\x0Ca\x10BV[\x01a\x10qV[\x90V[\x7F\xE4\x83)\x05{\xFD\x03\xD5^I\xB5G\x13.9\xCF\xFD\x9C\x18 \xAD{\x9DLS\x07i\x14%\xD1Z\xDF\x90V[aE aE'\x94aE\x16``\x94\x98\x97\x95aE\x0C`\x80\x86\x01\x9A_\x87\x01\x90a\x0C\x9DV[` \x85\x01\x90a\x06cV[`@\x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[` \x01\x90V[\x93\x95\x94\x90\x92\x91\x95BaEIaEC\x89a\x07-V[\x91a\x07-V[\x11aE\xC2W\x91aE\xB4\x91aE\xBB\x93aE\xABaE\xC0\x98\x99aE\x93aEjaD\xC7V[aE\x84\x8B\x93\x8BaExa\x04\xE2V[\x95\x86\x94` \x86\x01aD\xEBV[` \x82\x01\x81\x03\x82R\x03\x82a\x0B\x9AV[aE\xA5aE\x9F\x82a\x06pV[\x91aE)V[ aTMV[\x92\x90\x91\x92aTjV[\x91\x82aT\xB4V[aQ\x10V[V[aE\xDD\x87_\x91\x82\x91c#A\xD7\x87`\xE1\x1B\x83R`\x04\x83\x01a\x07\xE1V[\x03\x90\xFD[\x7Fnq\xED\xAE\x12\xB1\xB9\x7FM\x1F`7\x0F\xEF\x10\x10_\xA2\xFA\xAE\x01&\x11J\x16\x9Cd\x84]a&\xC9\x90V[\x91\x94aFMaFW\x92\x98\x97\x95aFC`\xA0\x96aF9aF^\x9AaF/`\xC0\x8A\x01\x9E_\x8B\x01\x90a\x0C\x9DV[` \x89\x01\x90a\x06cV[`@\x87\x01\x90a\x06cV[``\x85\x01\x90a\x07\xD4V[`\x80\x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[\x91` aF\x81\x92\x94\x93aFz`@\x82\x01\x96_\x83\x01\x90a\x06cV[\x01\x90a\x06cV[V[\x96\x95\x91\x93\x92\x94\x90\x94BaF\x9EaF\x98\x83a\x07-V[\x91a\x07-V[\x11aGXW\x90aG\x07aG\x10\x94\x93\x92aF\xEFaF\xB8aE\xE1V[aF\xE0\x8C\x80\x94\x8C\x91aF\xCA\x8D\x91aT\xF7V[\x91\x92aF\xD4a\x04\xE2V[\x97\x88\x96` \x88\x01aF\x05V[` \x82\x01\x81\x03\x82R\x03\x82a\x0B\x9AV[aG\x01aF\xFB\x82a\x06pV[\x91aE)V[ aTMV[\x92\x90\x91\x92aTjV[\x80aG#aG\x1D\x87a\x06WV[\x91a\x06WV[\x03aG8WPaG6\x92\x93\x91\x90\x91aHzV[V[\x84\x90aGT_\x92\x83\x92c%\xC0\x07#`\xE1\x1B\x84R`\x04\x84\x01aF`V[\x03\x90\xFD[aGs\x90_\x91\x82\x91c1<\x89\x81`\xE1\x1B\x83R`\x04\x83\x01a\x07\xE1V[\x03\x90\xFD[\x90aG\x92\x91aG\x8DaG\x88\x82a-\xDBV[aH\x8AV[aG\x94V[V[\x90aG\x9E\x91aK\xF5V[PV[\x90aG\xAB\x91aGwV[V[\x90aG\xB7\x90a\x106V[_R` R`@_ \x90V[aG\xE8\x91aG\xDEaG\xE3\x92aG\xD6a%\xBAV[P`\x01aG\xADV[a8xV[a\x10qV[\x90V[aG\xF5`@a6'V[\x90V[_\x90V[_\x90V[aH\x08aG\xEBV[\x90` \x80\x83aH\x15aG\xF8V[\x81R\x01aH aG\xFCV[\x81RPPV[aH.aH\0V[\x90V[\x90aHD\x91aH>aH&V[PaU*V[\x90V[aHOa$\0V[PaHiaHcc\x01\xFF\xC9\xA7`\xE0\x1Ba\x04\xF4V[\x91a\x04\xF4V[\x14\x90V[aHua%8V[P3\x90V[\x91aH\x88\x92\x91`\x01\x92aURV[V[aH\x9C\x90aH\x96aHmV[\x90aV\x84V[V[`@\x90aH\xC7aH\xCE\x94\x96\x95\x93\x96aH\xBD``\x84\x01\x98_\x85\x01\x90a\x06cV[` \x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[\x90aH\xDB\x91\x03a\x07-V[\x90V[\x92\x91\x92aH\xEC\x81\x83\x90aG\xC3V[\x90\x81aI\x01aH\xFB_\x19a\x07-V[\x91a\x07-V[\x10aI\x0EW[PPP\x90PV[\x81aI!aI\x1B\x87a\x07-V[\x91a\x07-V[\x10aIGWaI>\x93\x94aI6\x91\x93\x92aH\xD0V[\x90_\x92aURV[\x80_\x80\x80aI\x07V[PaIf\x84\x92\x91\x92_\x93\x84\x93c}\xC7\xA0\xD9`\xE1\x1B\x85R`\x04\x85\x01aH\x9EV[\x03\x90\xFD[\x91\x82aI\x86aI\x80aI{_a)#V[a\x06WV[\x91a\x06WV[\x14aI\xE0W\x81aI\xA6aI\xA0aI\x9B_a)#V[a\x06WV[\x91a\x06WV[\x14aI\xB9WaI\xB7\x92\x91\x90\x91aV\xBFV[V[aI\xDCaI\xC5_a)#V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[aJ\x03aI\xEC_a)#V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[aJ\x0Fa7\x88V[aJ\x15WV[_c\xD9<\x06e`\xE0\x1B\x81R\x80aJ-`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x80aJLaJFaJA_a)#V[a\x06WV[\x91a\x06WV[\x14aJhWaJf\x91aJ^_a)#V[\x91\x90\x91aV\xBFV[V[aJ\x8BaJt_a)#V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[aJ\x97a$\0V[PaJ\xACaJ\xA6\x82\x84\x90a;\x93V[\x15a\x05AV[_\x14aK5WaJ\xD4`\x01aJ\xCF_aJ\xC7`\x05\x86\x90a-\xA1V[\x01\x85\x90a\x14/V[a)TV[\x90aJ\xDDaHmV[\x90aK\x1AaK\x14aK\x0E\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a-\x95V[\x92a\x106V[\x92a\x106V[\x92aK#a\x04\xE2V[\x80aK-\x81a\x08\xACV[\x03\x90\xA4`\x01\x90V[PP_\x90V[aKCa-\x91V[PaKM0a:\x87V[aK\x7FaKy\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x06WV[\x91a\x06WV[\x14\x80aK\xBBW[_\x14aK\xB0W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[aK\xB8aW?V[\x90V[PFaK\xEFaK\xE9\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x07-V[\x91a\x07-V[\x14aK\x86V[aK\xFDa$\0V[PaL\t\x81\x83\x90a;\x93V[_\x14aL\x91WaL0_aL+_aL#`\x05\x86\x90a-\xA1V[\x01\x85\x90a\x14/V[a)TV[\x90aL9aHmV[\x90aLvaLpaLj\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a-\x95V[\x92a\x106V[\x92a\x106V[\x92aL\x7Fa\x04\xE2V[\x80aL\x89\x81a\x08\xACV[\x03\x90\xA4`\x01\x90V[PP_\x90V[aL\xABaL\xA6aL\xB0\x92a\x18\xA3V[a\x10\x0BV[a\x07-V[\x90V[\x91` aL\xD4\x92\x94\x93aL\xCD`@\x82\x01\x96_\x83\x01\x90a\x07\xD4V[\x01\x90a\x18\xAEV[V[aL\xDEa;\xBDV[PaL\xE7a;\xC1V[\x81aL\xFAaL\xF4\x83aL\x97V[\x91a\x07-V[\x10\x15aM\rWPaM\n\x90aXEV[\x90V[\x90aM(_\x92\x83\x92cvi\xFC\x0F`\xE1\x1B\x84R`\x04\x84\x01aL\xB3V[\x03\x90\xFD[T\x90V[\x90V[aMGaMBaML\x92aM0V[a\x10\x0BV[a\x07-V[\x90V[\x90V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[aMiaMn\x91a\x10XV[aMRV[\x90V[aM{\x90TaM]V[\x90V[`0\x1C\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[aM\x9BaM\xA0\x91aM~V[aM\x84V[\x90V[aM\xAD\x90TaM\x8FV[\x90V[aM\xC4aM\xBFaM\xC9\x92a\x1B*V[a\x10\x0BV[a\"8V[\x90V[\x90aN \x90aM\xD9a#kV[PaM\xE5_\x84\x01aM,V[aM\xEE_a(\xEBV[\x90\x80\x80aN\x04aM\xFE`\x05aM3V[\x91a\x07-V[\x11aN\x81W[P\x90aN\x1B_\x86\x01\x93\x91\x92\x93aMOV[a^\x80V[\x80aN3aN-_a(\xEBV[\x91a\x07-V[\x14_\x14aNIWPPaNE_aM\xB0V[[\x90V[aNv_\x91aNqaNk\x84aN|\x96\x01\x92aNe`\x01aB\xBBV[\x90a+\x0BV[\x91aMOV[a^vV[\x01aM\xA3V[aNFV[\x80aN\x8FaN\x95\x92\x91a[\x0BV[\x90a+\x0BV[\x90\x83aN\xC7aN\xC1aN\xBC_aN\xB6\x81\x8C\x01aN\xB1\x89\x91aMOV[a^vV[\x01aMqV[a\x18\xA3V[\x91a\x18\xA3V[\x10_\x14aN\xD8WP\x90[\x90_aN\nV[\x91PaN\xEE\x90aN\xE8`\x01aB\xBBV[\x90a.?V[aN\xD1V[aN\xFBa_\x0FV[aO\x03aO\x05V[V[aO\x10_`\x0Ea)TV[aO\x18aHmV[aON\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA\x91aOEa\x04\xE2V[\x91\x82\x91\x82a\x11\xFEV[\x03\x90\xA1V[aO[aN\xF3V[V[\x90V[aOnaOs\x91`\x0Ca\x10BV[aO]V[aO\x7F`\x04\x82\x01a\x10qV[aO\x91aO\x8B_a(\xEBV[\x91a\x07-V[\x14aP\xEBWaP\r\x90aO\xB0BaO\xAA`\x04\x84\x01a\x10qV[\x90a+\x0BV[\x80aO\xCAaO\xC4aO\xBFa\x19YV[a\x07-V[\x91a\x07-V[\x10\x15_\x14aP\x0FWPaO\xEAaO\xE1_\x83\x01a\x10qV[`\x01\x83\x01a)\x8AV[aP\x02aO\xF9`\x02\x83\x01a\x10qV[`\x03\x83\x01a)\x8AV[[`\x04B\x91\x01a)\x8AV[V[\x80aP\"aP\x1C_a(\xEBV[\x91a\x07-V[\x11aP.W[PaP\x03V[aP\xDCaP\xCAaP\xE5\x92aP\xB9aP\xB0aP\x9FaP\x8DaP\x7FaPmaP_aPX_\x8D\x01a\x10qV[\x88\x90a+OV[aPga\x19YV[\x90a+\x98V[\x95aPz`\x02\x8C\x01a\x10qV[a+OV[aP\x87a\x19YV[\x90a+\x98V[\x93aP\x9A`\x01\x8A\x01a\x10qV[a.?V[aP\xAA_\x89\x01a\x10qV[\x90a_BV[`\x01\x87\x01a)\x8AV[aP\xC5`\x03\x86\x01a\x10qV[a.?V[aP\xD6`\x02\x85\x01a\x10qV[\x90a_BV[`\x03\x83\x01a)\x8AV[_aP(V[aP\xF9\x90`\x04B\x91\x01a)\x8AV[V[aQ\x03a;\xBDV[PaQ\rCaXEV[\x90V[\x90aQ\x99\x91aQ\x93aQ!\x82a7-V[aQ6\x84aQ1`\t\x86\x90a7\x17V[a@\x9DV[\x82\x81\x85\x90aQvaQpaQj\x7F14\xE8\xA2\xE6\xD9~\x92\x9A~T\x01\x1E\xA5H]}\x19m\xD5\xF0\xBAMN\xF9X\x03\xE8\xE3\xFC%\x7F\x95a\x106V[\x92a\x106V[\x92a\x106V[\x92aQ\x7Fa\x04\xE2V[\x80aQ\x89\x81a\x08\xACV[\x03\x90\xA4\x92\x91a_rV[\x91a_\x8AV[V[\x90\x91aQ\xA5a%\xBAV[P\x80aQ\xB9aQ\xB3_a(\xEBV[\x91a\x07-V[\x14aR8WaQ\xC8\x90Ba+\x0BV[\x90\x81aQ\xE3aQ\xDDaQ\xD8a\x19YV[a\x07-V[\x91a\x07-V[\x10\x15aR3WaR\x07aQ\xF9aR\r\x93\x85a+OV[aR\x01a\x19YV[\x90a+\x98V[\x90a.?V[\x80aR aR\x1A\x84a\x07-V[\x91a\x07-V[\x11_\x14aR,WP[\x90V[\x90PaR)V[PP\x90V[PPPaRD_a(\xEBV[\x90V[aRnaRiaRdaRs\x93aR\\a8_V[P`\na4,V[a4BV[aa8V[aa\xB7V[\x90V[aR\x88\x90aR\x82a%\xBAV[Pab\x08V[\x90V[aR\x93aJ\x07V[aR\x9BaR\x9DV[V[aR\xA9`\x01`\x0Ea)TV[aR\xB1aHmV[aR\xE7\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X\x91aR\xDEa\x04\xE2V[\x91\x82\x91\x82a\x11\xFEV[\x03\x90\xA1V[aR\xF4aR\x8BV[V[\x90V[aS\x01a$DV[PaS6\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aS0`\x06aR\xF6V[\x90ac#V[\x90V[aSAa$DV[PaSv\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aSp`\x07aR\xF6V[\x90ac#V[\x90V[aS\x81a#kV[PaS\x8D_\x82\x01aM,V[\x80aS\xA0aS\x9A_a(\xEBV[\x91a\x07-V[\x14_\x14aS\xB6WPPaS\xB2_aM\xB0V[[\x90V[aS\xE3_\x91aS\xDEaS\xD8\x84aS\xE9\x96\x01\x92aS\xD2`\x01aB\xBBV[\x90a+\x0BV[\x91aMOV[a^vV[\x01aM\xA3V[aS\xB3V[\x90\x81aT\naT\x04aS\xFF_a)#V[a\x06WV[\x91a\x06WV[\x14aT&WaT$\x91\x90aT\x1D_a)#V[\x90\x91aV\xBFV[V[aTIaT2_a)#V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[aTg\x90aTYa-\x91V[PaTbaK;V[acqV[\x90V[\x92aT\x85\x92aT\x8E\x94aT{a%8V[P\x92\x90\x91\x92ad'V[\x90\x92\x91\x92aeRV[\x90V[\x91` aT\xB2\x92\x94\x93aT\xAB`@\x82\x01\x96_\x83\x01\x90a\x06cV[\x01\x90a\x07\xD4V[V[aT\xBD\x81aT\xF7V[\x91aT\xD0aT\xCA\x84a\x07-V[\x91a\x07-V[\x03aT\xD9WPPV[aT\xF3_\x92\x83\x92c\x01\xD4\xB6#`\xE6\x1B\x84R`\x04\x84\x01aT\x91V[\x03\x90\xFD[aU\x0B\x90aU\x03a%\xBAV[P`\x08a8xV[aU'aU\x17\x82a\x10qV[\x91aU!\x83a.0V[\x90a)\x8AV[\x90V[\x90aUJaUEaUO\x93aU=aH&V[P`\na4,V[a4BV[af\xB4V[\x90V[\x90\x92\x81aUoaUiaUd_a)#V[a\x06WV[\x91a\x06WV[\x14aV:W\x83aU\x8FaU\x89aU\x84_a)#V[a\x06WV[\x91a\x06WV[\x14aV\x13WaU\xB3\x83aU\xAEaU\xA7`\x01\x86\x90aG\xADV[\x87\x90a8xV[a)\x8AV[aU\xBDW[PPPV[\x91\x90\x91aV\x08aU\xF6aU\xF0\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%\x93a\x106V[\x93a\x106V[\x93aU\xFFa\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xA3_\x80\x80aU\xB8V[aV6aV\x1F_a)#V[_\x91\x82\x91cJ\x14\x06\xB1`\xE1\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[aV]aVF_a)#V[_\x91\x82\x91c\xE6\x02\xDF\x05`\xE0\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[\x91` aV\x82\x92\x94\x93aV{`@\x82\x01\x96_\x83\x01\x90a\x06cV[\x01\x90a\x0C\x9DV[V[\x90aV\x99aV\x93\x83\x83\x90a;\x93V[\x15a\x05AV[aV\xA1WPPV[aV\xBB_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01aVaV[\x03\x90\xFD[\x91aV\xCC\x92\x91\x90\x91af\xD5V[V[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[\x90\x95\x94\x92aW=\x94aW,aW6\x92aW\"`\x80\x96aW\x18`\xA0\x88\x01\x9C_\x89\x01\x90a\x0C\x9DV[` \x87\x01\x90a\x0C\x9DV[`@\x85\x01\x90a\x0C\x9DV[``\x83\x01\x90a\x07\xD4V[\x01\x90a\x06cV[V[aWGa-\x91V[PaWPaV\xCEV[aW\xC7\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91aW\xB8\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0FaW\xA30a:\x87V[\x91aW\xACa\x04\xE2V[\x96\x87\x95` \x87\x01aV\xF2V[` \x82\x01\x81\x03\x82R\x03\x82a\x0B\x9AV[aW\xD9aW\xD3\x82a\x06pV[\x91aE)V[ \x90V[aW\xF1aW\xECaW\xF6\x92a\x12\xE5V[a\x10\x0BV[a\r\x88V[\x90V[aX\x02\x90aW\xDDV[\x90RV[\x91` aX'\x92\x94\x93aX `@\x82\x01\x96_\x83\x01\x90aW\xF9V[\x01\x90a\x07\xD4V[V[aX=aX8aXB\x92a\x07-V[a\x10\x0BV[a\x18\xA3V[\x90V[aXMa;\xBDV[P\x80aXgaXae\xFF\xFF\xFF\xFF\xFF\xFFaL\x97V[\x91a\x07-V[\x11aXxWaXu\x90aX)V[\x90V[`0aX\x94_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01aX\x06V[\x03\x90\xFD[\x90V[aX\xAFaX\xAAaX\xB4\x92aX\x98V[a\x10\x0BV[a\x07-V[\x90V[\x90V[aX\xCEaX\xC9aX\xD3\x92aX\xB7V[a\x10\x0BV[a\r\x88V[\x90V[aX\xF5\x90aX\xEFaX\xE9aX\xFA\x94a\r\x88V[\x91a\x07-V[\x90a\tMV[a\x07-V[\x90V[\x90V[aY\x14aY\x0FaY\x19\x92aX\xFDV[a\x10\x0BV[a\r\x88V[\x90V[aY;\x90aY5aY/aY@\x94a\r\x88V[\x91a\x07-V[\x90a&\tV[a\x07-V[\x90V[\x90V[aYZaYUaY_\x92aYCV[a\x10\x0BV[a\x07-V[\x90V[\x90V[aYyaYtaY~\x92aYbV[a\x10\x0BV[a\r\x88V[\x90V[\x90V[aY\x98aY\x93aY\x9D\x92aY\x81V[a\x10\x0BV[a\x07-V[\x90V[\x90V[aY\xB7aY\xB2aY\xBC\x92aY\xA0V[a\x10\x0BV[a\r\x88V[\x90V[\x90V[aY\xD6aY\xD1aY\xDB\x92aY\xBFV[a\x10\x0BV[a\x07-V[\x90V[\x90V[aY\xF5aY\xF0aY\xFA\x92aY\xDEV[a\x10\x0BV[a\r\x88V[\x90V[\x90V[aZ\x14aZ\x0FaZ\x19\x92aY\xFDV[a\x10\x0BV[a\x07-V[\x90V[\x90V[aZ3aZ.aZ8\x92aZ\x1CV[a\x10\x0BV[a\r\x88V[\x90V[aZOaZJaZT\x92aY\xA0V[a\x10\x0BV[a\x07-V[\x90V[\x90V[aZnaZiaZs\x92aZWV[a\x10\x0BV[a\r\x88V[\x90V[aZ\x8AaZ\x85aZ\x8F\x92aZ\x1CV[a\x10\x0BV[a\x07-V[\x90V[aZ\xA6aZ\xA1aZ\xAB\x92aB\xB8V[a\x10\x0BV[a\r\x88V[\x90V[\x90V[aZ\xC5aZ\xC0aZ\xCA\x92aZ\xAEV[a\x10\x0BV[a\x07-V[\x90V[\x90aZ\xD8\x91\x02a\x07-V[\x90V[aZ\xE7aZ\xED\x91a\x07-V[\x91a\x07-V[\x90\x81\x15aZ\xF8W\x04\x90V[a+\x84V[\x90a[\x08\x91\x01a\x07-V[\x90V[a[\x13a%\xBAV[P\x80a[(a[\"`\x01aB\xBBV[\x91a\x07-V[\x11\x15a^sW\x80a]=a]\x1Aa]\na\\\xFAa\\\xEAa\\\xDAa\\\xCAa\\\xBAa\\\xAAa\\\x9Aa\\\x8A\x8Ba\\\x84a\\}a]C\x9Fa\\]a\\Ma\\m\x92a[o`\x01aB\xBBV[\x90\x80a[\x87a[\x81`\x01`\x80\x1BaX\x9BV[\x91a\x07-V[\x10\x15a^EW[\x80a[\xAAa[\xA4h\x01\0\0\0\0\0\0\0\0aYFV[\x91a\x07-V[\x10\x15a^\x17W[\x80a[\xC9a[\xC3d\x01\0\0\0\0aY\x84V[\x91a\x07-V[\x10\x15a]\xE9W[\x80a[\xE6a[\xE0b\x01\0\0aY\xC2V[\x91a\x07-V[\x10\x15a]\xBBW[\x80a\\\x02a[\xFCa\x01\0aZ\0V[\x91a\x07-V[\x10\x15a]\x8DW[\x80a\\\x1Da\\\x17`\x10aZ;V[\x91a\x07-V[\x10\x15a]_W[a\\7a\\1`\x04aZvV[\x91a\x07-V[\x10\x15a]FW[a\\H`\x03aZ\xB1V[aZ\xCDV[a\\W`\x01aZ\x92V[\x90aX\xD6V[a\\g\x81\x86aZ\xDBV[\x90aZ\xFDV[a\\w`\x01aZ\x92V[\x90aX\xD6V[\x80\x92aZ\xDBV[\x90aZ\xFDV[a\\\x94`\x01aZ\x92V[\x90aX\xD6V[a\\\xA4\x81\x8CaZ\xDBV[\x90aZ\xFDV[a\\\xB4`\x01aZ\x92V[\x90aX\xD6V[a\\\xC4\x81\x8AaZ\xDBV[\x90aZ\xFDV[a\\\xD4`\x01aZ\x92V[\x90aX\xD6V[a\\\xE4\x81\x88aZ\xDBV[\x90aZ\xFDV[a\\\xF4`\x01aZ\x92V[\x90aX\xD6V[a]\x04\x81\x86aZ\xDBV[\x90aZ\xFDV[a]\x14`\x01aZ\x92V[\x90aX\xD6V[\x91a]7a]1a],\x85\x80\x94aZ\xDBV[a\x07-V[\x91a\x07-V[\x11ageV[\x90aH\xD0V[\x90V[a]Z\x90a]T`\x01aZ\x92V[\x90aY\x1CV[a\\>V[a]va]\x87\x91a]p`\x04aZ\x1FV[\x90aX\xD6V[\x91a]\x81`\x02aZZV[\x90aY\x1CV[\x90a\\$V[a]\xA4a]\xB5\x91a]\x9E`\x08aY\xE1V[\x90aX\xD6V[\x91a]\xAF`\x04aZ\x1FV[\x90aY\x1CV[\x90a\\\tV[a]\xD2a]\xE3\x91a]\xCC`\x10aY\xA3V[\x90aX\xD6V[\x91a]\xDD`\x08aY\xE1V[\x90aY\x1CV[\x90a[\xEDV[a^\0a^\x11\x91a]\xFA` aYeV[\x90aX\xD6V[\x91a^\x0B`\x10aY\xA3V[\x90aY\x1CV[\x90a[\xD0V[a^.a^?\x91a^(`@aY\0V[\x90aX\xD6V[\x91a^9` aYeV[\x90aY\x1CV[\x90a[\xB1V[a^\\a^m\x91a^V`\x80aX\xBAV[\x90aX\xD6V[\x91a^g`@aY\0V[\x90aY\x1CV[\x90a[\x8EV[\x90V[_R` _ \x01\x90V[\x93\x91\x90\x92a^\x8Ca%\xBAV[P[\x81a^\xA1a^\x9B\x83a\x07-V[\x91a\x07-V[\x10\x15a_\x07Wa^\xB2\x82\x82\x90ag\x8FV[\x90a^\xC8_a^\xC2\x88\x85\x90a^vV[\x01aMqV[a^\xDAa^\xD4\x87a\x18\xA3V[\x91a\x18\xA3V[\x11_\x14a^\xEAWP\x91[\x91a^\x8EV[\x92\x91Pa_\x01\x90a^\xFB`\x01aB\xBBV[\x90a.?V[\x90a^\xE4V[\x92PP\x91P\x90V[a_ a_\x1Aa7\x88V[\x15a\x05AV[a_&WV[_c\x8D\xFC +`\xE0\x1B\x81R\x80a_>`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90a_Ka%\xBAV[P\x81a__a_Y\x83a\x07-V[\x91a\x07-V[\x10_\x14a_kWP[\x90V[\x90Pa_hV[a_\x84\x90a_~a%\xBAV[Pa8\x8EV[\x90V[\x90V[\x91\x90\x91\x80a_\xA0a_\x9A\x85a\x06WV[\x91a\x06WV[\x14\x15\x80aa\x1EW[a_\xB2W[PPPV[\x80a_\xCDa_\xC7a_\xC2_a)#V[a\x06WV[\x91a\x06WV[\x03a`\x8EW[P\x81a_\xEFa_\xE9a_\xE4_a)#V[a\x06WV[\x91a\x06WV[\x03a_\xFBW[\x80a_\xADV[a`Ba`5a`<\x92a`\x11`\n\x86\x90a4,V[\x90a`/a`)a`#`\x01\x93ah(V[\x93a4BV[\x91a_\x87V[\x90ah{V[\x92\x90a4EV[\x91a4EV[\x91\x90\x91a`o\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\x106V[\x92a`\x84a`{a\x04\xE2V[\x92\x83\x92\x83a\n1V[\x03\x90\xA2_\x80a_\xF5V[a`\xCDa`\xD3a`\xC6a`\xA3`\n\x85\x90a4,V[`\x02a`\xC0a`\xBAa`\xB4\x89ah(V[\x93a4BV[\x91a_\x87V[\x90ah{V[\x92\x90a4EV[\x91a4EV[\x91\x90\x91aa\0\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\x106V[\x92aa\x15aa\x0Ca\x04\xE2V[\x92\x83\x92\x83a\n1V[\x03\x90\xA2_a_\xD3V[P\x81aa2aa,_a(\xEBV[\x91a\x07-V[\x11a_\xA8V[_aaL\x91aaEa%\xBAV[P\x01aM,V[\x90V[aacaa^aah\x92a\x14\x93V[a\x10\x0BV[a\x07-V[\x90V[aat\x90aYeV[\x90RV[\x91` aa\x99\x92\x94\x93aa\x92`@\x82\x01\x96_\x83\x01\x90aakV[\x01\x90a\x07\xD4V[V[aa\xAFaa\xAAaa\xB4\x92a\x07-V[a\x10\x0BV[a\x14\x93V[\x90V[aa\xBFa8_V[P\x80aa\xD7aa\xD1c\xFF\xFF\xFF\xFFaaOV[\x91a\x07-V[\x11aa\xE8Waa\xE5\x90aa\x9BV[\x90V[` ab\x04_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01aaxV[\x03\x90\xFD[ab\x1Fab$\x91ab\x17a%\xBAV[P`\x08a8xV[a\x10qV[\x90V[\x90V[ab>ab9abC\x92ab'V[a\x1B-V[a\x0CYV[\x90V[abP`\xFFab*V[\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90abvabo\x83a\n\xB1V[\x80\x94a$IV[\x91`\x01\x81\x16\x90\x81_\x14ab\xCDWP`\x01\x14ab\x91W[PPPV[ab\x9E\x91\x92\x93\x94PabSV[\x91_\x92[\x81\x84\x10ab\xB5WPP\x01\x90_\x80\x80ab\x8CV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90ab\xA2V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80ab\x8CV[\x90ab\xF2\x91ab\\V[\x90V[\x90ac\x15ac\x0E\x92ac\x05a\x04\xE2V[\x93\x84\x80\x92ab\xE8V[\x03\x83a\x0B\x9AV[V[ac \x90ab\xF5V[\x90V[\x90ac,a$DV[Pac6\x82a-\x95V[acOacIacDabFV[a\x0CYV[\x91a\x0CYV[\x14\x15_\x14acdWPaca\x90ai\x05V[\x90V[acn\x91Pac\x17V[\x90V[`B\x91ac|a-\x91V[P`@Q\x91\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R`\x02\x83\x01R`\"\x82\x01R \x90V[_\x90V[ac\xC2ac\xC7\x91a\x10XV[a&2V[\x90V[\x90V[ac\xE1ac\xDCac\xE6\x92ac\xCAV[a\x10\x0BV[a\x07-V[\x90V[ad\x1Ead%\x94ad\x14``\x94\x98\x97\x95ad\n`\x80\x86\x01\x9A_\x87\x01\x90a\x0C\x9DV[` \x85\x01\x90a\r\x8EV[`@\x83\x01\x90a\x0C\x9DV[\x01\x90a\x0C\x9DV[V[\x93\x92\x93ad2a%8V[Pad;ac\xB2V[PadDa-\x91V[PadN\x85ac\xB6V[ad\x80adz\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0ac\xCDV[\x91a\x07-V[\x11ae\rW\x90ad\xA3` \x94\x95_\x94\x93\x92\x93ad\x9Aa\x04\xE2V[\x94\x85\x94\x85ac\xE9V[\x83\x80R\x03\x90`\x01Z\xFA\x15ae\x08Wad\xBB_Qa\x1B-V[\x80ad\xD6ad\xD0ad\xCB_a)#V[a\x06WV[\x91a\x06WV[\x14ad\xECW_\x91ad\xE6_a\x1B2V[\x91\x92\x91\x90V[Pad\xF6_a)#V[`\x01\x91ae\x02_a\x1B2V[\x91\x92\x91\x90V[a*\xFBV[PPPae\x19_a)#V[\x90`\x03\x92\x91\x92\x91\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x04\x11\x15aeAWV[ae#V[\x90aeP\x82ae7V[V[\x80aeeae__aeFV[\x91aeFV[\x14_\x14aepWPPV[\x80ae\x84ae~`\x01aeFV[\x91aeFV[\x14_\x14ae\xA7W_c\xF6E\xEE\xDF`\xE0\x1B\x81R\x80ae\xA3`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x80ae\xBBae\xB5`\x02aeFV[\x91aeFV[\x14_\x14ae\xE9Wae\xE5ae\xCE\x83ac\xB6V[_\x91\x82\x91c\xFC\xE6\x98\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x07\xE1V[\x03\x90\xFD[ae\xFCae\xF6`\x03aeFV[\x91aeFV[\x14af\x04WPV[af\x1F\x90_\x91\x82\x91c5\xE2\xF3\x83`\xE2\x1B\x83R`\x04\x83\x01a\x0C\xAAV[\x03\x90\xFD[_R` _ \x90V[af5\x81aM,V[\x82\x10\x15afOWafG`\x01\x91af#V[\x91\x02\x01\x90_\x90V[a\x0E\x03V[\x90af^\x90a\x18\xA3V[\x90RV[\x90afl\x90a\"8V[\x90RV[\x90af\xA6af\x9D_af\x80aG\xEBV[\x94af\x97af\x8F\x83\x83\x01aMqV[\x83\x88\x01afTV[\x01aM\xA3V[` \x84\x01afbV[V[af\xB1\x90afpV[\x90V[af\xD2\x91_af\xCC\x92af\xC5aH&V[P\x01af,V[Paf\xA8V[\x90V[\x92\x91af\xE3\x84\x83\x83\x91ai5V[\x83af\xFEaf\xF8af\xF3_a)#V[a\x06WV[\x91a\x06WV[\x14ag\x13W[ag\x11\x92\x93\x91\x90\x91aj\xBFV[V[ag\x1Ba(\xBBV[\x93ag$aj\xA4V[\x94\x80ag8ag2\x88a\x07-V[\x91a\x07-V[\x11agEWP\x93Pag\x04V[\x85\x90aga_\x92\x83\x92c\x0EX\xAE\x93`\xE1\x1B\x84R`\x04\x84\x01a\n1V[\x03\x90\xFD[agma%\xBAV[P\x15\x15\x90V[ag\x87ag\x82ag\x8C\x92aZWV[a\x10\x0BV[a\x07-V[\x90V[ag\xB4ag\xBA\x92ag\x9Ea%\xBAV[P\x82\x81\x16\x92\x18ag\xAE`\x02agsV[\x90a+\x98V[\x90a.?V[\x90V[\x90V[ag\xD4ag\xCFag\xD9\x92ag\xBDV[a\x10\x0BV[a\r\x88V[\x90V[ag\xE5\x90ag\xC0V[\x90RV[\x91` ah\n\x92\x94\x93ah\x03`@\x82\x01\x96_\x83\x01\x90ag\xDCV[\x01\x90a\x07\xD4V[V[ah ah\x1Bah%\x92a\x07-V[a\x10\x0BV[a\"8V[\x90V[ah0a#kV[P\x80ahJahD`\x01\x80`\xD0\x1B\x03a4EV[\x91a\x07-V[\x11ah[WahX\x90ah\x0CV[\x90V[`\xD0ahw_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01ag\xE9V[\x03\x90\xFD[\x90ah\xB1ah\xB7\x93\x92ah\x8Ca#kV[Pah\x95a#kV[P\x80\x93ah\xAAah\xA3a;\xC1V[\x94\x92aSyV[\x90\x91ao'V[\x91ak~V[\x91\x90\x91\x90V[ah\xD1ah\xCCah\xD6\x92aYbV[a\x10\x0BV[a\x07-V[\x90V[6\x907V[\x90ai\x03ah\xEB\x83a6_V[\x92` \x80ah\xF9\x86\x93a6<V[\x92\x01\x91\x03\x90ah\xD9V[V[ai\ra$DV[Pai\x17\x81ak\xE8V[\x90ai*ai%` ah\xBDV[ah\xDEV[\x91\x82R` \x82\x01R\x90V[\x91\x90\x91\x80aiSaiMaiH_a)#V[a\x06WV[\x91a\x06WV[\x14_\x14aj4Waiwaip\x83aik`\x02a\x10qV[a.?V[`\x02a)\x8AV[[\x82ai\x93ai\x8Dai\x88_a)#V[a\x06WV[\x91a\x06WV[\x14_\x14aj\x08Wai\xB7ai\xB0\x83ai\xAB`\x02a\x10qV[aH\xD0V[`\x02a)\x8AV[[\x91\x90\x91aj\x03ai\xF1ai\xEB\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a\x106V[\x93a\x106V[\x93ai\xFAa\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xA3V[aj/\x82aj)aj\x1A_\x87\x90a8xV[\x91aj$\x83a\x10qV[aZ\xFDV[\x90a)\x8AV[ai\xB8V[ajGajB_\x83\x90a8xV[a\x10qV[\x80ajZajT\x85a\x07-V[\x91a\x07-V[\x10aj\x82Wajmaj}\x91\x84\x90aH\xD0V[ajx_\x84\x90a8xV[a)\x8AV[aixV[\x90aj\xA0\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01aH\x9EV[\x03\x90\xFD[aj\xACa%\xBAV[Paj\xBC`\x01\x80`\xD0\x1B\x03a4EV[\x90V[\x91ak\x17ak\x11ak\x1E\x94\x80aj\xE5aj\xDFaj\xDA_a)#V[a\x06WV[\x91a\x06WV[\x14akOW[\x84ak\x06ak\0aj\xFB_a)#V[a\x06WV[\x91a\x06WV[\x14ak W[a7-V[\x92a7-V[\x90\x91a_\x8AV[V[akH`\x0B`\x02akBak<ak6\x89ah(V[\x93a4BV[\x91a_\x87V[\x90ah{V[PPak\x0CV[akw`\x0B`\x01akqakkake\x89ah(V[\x93a4BV[\x91a_\x87V[\x90ah{V[PPaj\xEBV[\x91ak\xA2_ak\xA7\x94ak\x8Fa#kV[Pak\x98a#kV[P\x01\x92\x91\x92aMOV[am\xD9V[\x91\x90\x91\x90V[ak\xC1ak\xBCak\xC6\x92ab'V[a\x10\x0BV[a\x07-V[\x90V[\x90V[ak\xE0ak\xDBak\xE5\x92ak\xC9V[a\x10\x0BV[a\x07-V[\x90V[ak\xFDal\x02\x91ak\xF7a%\xBAV[Pa-\x95V[ac\xB6V[al\x0C`\xFFak\xADV[\x16\x80al!al\x1B`\x1Fak\xCCV[\x91a\x07-V[\x11al)W\x90V[_c,\xD4J\xC3`\xE2\x1B\x81R\x80alA`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[T\x90V[alS`@a6'V[\x90V[_R` _ \x90V[alh\x81alEV[\x82\x10\x15al\x82Walz`\x01\x91alVV[\x91\x02\x01\x90_\x90V[a\x0E\x03V[al\x91\x90Qa\x18\xA3V[\x90V[\x90al\xA5e\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x1B-V[\x91\x81\x19\x16\x91\x16\x17\x90V[al\xC3al\xBEal\xC8\x92a\x18\xA3V[a\x10\x0BV[a\x18\xA3V[\x90V[\x90V[\x90al\xE3al\xDEal\xEA\x92al\xAFV[al\xCBV[\x82Tal\x94V[\x90UV[al\xF8\x90Qa\"8V[\x90V[`0\x1B\x90V[\x90am\x13e\xFF\xFF\xFF\xFF\xFF\xFF\x19\x91al\xFBV[\x91\x81\x19\x16\x91\x16\x17\x90V[am1am,am6\x92a\"8V[a\x10\x0BV[a\"8V[\x90V[\x90V[\x90amQamLamX\x92am\x1DV[am9V[\x82Tam\x01V[\x90UV[\x90am\x86` _am\x8C\x94am~\x82\x82\x01amx\x84\x88\x01al\x87V[\x90al\xCEV[\x01\x92\x01al\xEEV[\x90am<V[V[\x91\x90am\x9FWam\x9D\x91am\\V[V[a\n\x8AV[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15am\xD4W\x82am\xCC\x91`\x01am\xD2\x95\x01\x81Ual_V[\x90am\x8EV[V[a\x0B\x86V[\x90\x92\x91\x92am\xE5a#kV[Pam\xEEa#kV[Pam\xF8\x82alEV[\x80an\x0Ban\x05_a(\xEBV[\x91a\x07-V[\x11_\x14an\xDBWan1\x90an+\x84\x91an%`\x01aB\xBBV[\x90a+\x0BV[\x90a^vV[\x90an=_\x83\x01aMqV[\x92anI_\x84\x01aM\xA3V[\x93\x80an]anW\x85a\x18\xA3V[\x91a\x18\xA3V[\x11an\xBFWantann\x84a\x18\xA3V[\x91a\x18\xA3V[\x14_\x14an\x8FWPPan\x8A\x90_\x85\x91\x01am<V[[\x91\x90V[an\xBA\x92Pan\xB5\x86an\xACan\xA3alIV[\x94_\x86\x01afTV[` \x84\x01afbV[am\xA4V[an\x8BV[_c% `\x1D`\xE0\x1B\x81R\x80an\xD7`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[Pao\x06\x91ao\x01\x85an\xF8an\xEFalIV[\x94_\x86\x01afTV[` \x84\x01afbV[am\xA4V[ao\x0F_aM\xB0V[\x91\x90V[cNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[\x91\x90\x91\x80`\x01\x14aoFW`\x02\x03ao\x13WaoB\x91a#\xEAV[\x90[V[PaoP\x91a#\xABV[\x90aoDV",
    );
    /**Custom error with signature `AccessControlBadConfirmation()` and selector `0x6697b232`.
```solidity
error AccessControlBadConfirmation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlBadConfirmation {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlBadConfirmation>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlBadConfirmation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlBadConfirmation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlBadConfirmation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlBadConfirmation()";
            const SELECTOR: [u8; 4] = [102u8, 151u8, 178u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `AccessControlUnauthorizedAccount(address,bytes32)` and selector `0xe2517d3f`.
```solidity
error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub neededRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlUnauthorizedAccount) -> Self {
                (value.account, value.neededRole)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    neededRole: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlUnauthorizedAccount(address,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 81u8, 125u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.neededRole),
                )
            }
        }
    };
    /**Custom error with signature `AllEmissionsCompleted()` and selector `0x4555892c`.
```solidity
error AllEmissionsCompleted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AllEmissionsCompleted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AllEmissionsCompleted> for UnderlyingRustTuple<'_> {
            fn from(value: AllEmissionsCompleted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AllEmissionsCompleted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AllEmissionsCompleted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AllEmissionsCompleted()";
            const SELECTOR: [u8; 4] = [69u8, 85u8, 137u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `BridgeNotAuthorized()` and selector `0x882eec12`.
```solidity
error BridgeNotAuthorized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BridgeNotAuthorized {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BridgeNotAuthorized> for UnderlyingRustTuple<'_> {
            fn from(value: BridgeNotAuthorized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BridgeNotAuthorized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BridgeNotAuthorized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BridgeNotAuthorized()";
            const SELECTOR: [u8; 4] = [136u8, 46u8, 236u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `BridgeNotConfigured()` and selector `0x7614917a`.
```solidity
error BridgeNotConfigured();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BridgeNotConfigured {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BridgeNotConfigured> for UnderlyingRustTuple<'_> {
            fn from(value: BridgeNotConfigured) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BridgeNotConfigured {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BridgeNotConfigured {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BridgeNotConfigured()";
            const SELECTOR: [u8; 4] = [118u8, 20u8, 145u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `CheckpointUnorderedInsertion()` and selector `0x2520601d`.
```solidity
error CheckpointUnorderedInsertion();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CheckpointUnorderedInsertion {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CheckpointUnorderedInsertion>
        for UnderlyingRustTuple<'_> {
            fn from(value: CheckpointUnorderedInsertion) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for CheckpointUnorderedInsertion {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CheckpointUnorderedInsertion {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CheckpointUnorderedInsertion()";
            const SELECTOR: [u8; 4] = [37u8, 32u8, 96u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignature()` and selector `0xf645eedf`.
```solidity
error ECDSAInvalidSignature();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignature {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignature()";
            const SELECTOR: [u8; 4] = [246u8, 69u8, 238u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureLength(uint256)` and selector `0xfce698f7`.
```solidity
error ECDSAInvalidSignatureLength(uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureLength {
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureLength) -> Self {
                (value.length,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ECDSAInvalidSignatureLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { length: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureLength(uint256)";
            const SELECTOR: [u8; 4] = [252u8, 230u8, 152u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureS(bytes32)` and selector `0xd78bce0c`.
```solidity
error ECDSAInvalidSignatureS(bytes32 s);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureS {
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureS> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureS) -> Self {
                (value.s,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignatureS {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { s: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureS {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureS(bytes32)";
            const SELECTOR: [u8; 4] = [215u8, 139u8, 206u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
        }
    };
    /**Custom error with signature `ERC20ExceededSafeSupply(uint256,uint256)` and selector `0x1cb15d26`.
```solidity
error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20ExceededSafeSupply {
        #[allow(missing_docs)]
        pub increasedSupply: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub cap: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20ExceededSafeSupply> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20ExceededSafeSupply) -> Self {
                (value.increasedSupply, value.cap)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20ExceededSafeSupply {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    increasedSupply: tuple.0,
                    cap: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20ExceededSafeSupply {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20ExceededSafeSupply(uint256,uint256)";
            const SELECTOR: [u8; 4] = [28u8, 177u8, 93u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.increasedSupply),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.cap),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InsufficientAllowance(address,uint256,uint256)` and selector `0xfb8f41b2`.
```solidity
error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InsufficientAllowance {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub allowance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InsufficientAllowance>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InsufficientAllowance) -> Self {
                (value.spender, value.allowance, value.needed)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC20InsufficientAllowance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    spender: tuple.0,
                    allowance: tuple.1,
                    needed: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InsufficientAllowance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InsufficientAllowance(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [251u8, 143u8, 65u8, 178u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allowance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.needed),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InsufficientBalance(address,uint256,uint256)` and selector `0xe450d38c`.
```solidity
error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InsufficientBalance {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub balance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InsufficientBalance>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InsufficientBalance) -> Self {
                (value.sender, value.balance, value.needed)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC20InsufficientBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    sender: tuple.0,
                    balance: tuple.1,
                    needed: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InsufficientBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InsufficientBalance(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [228u8, 80u8, 211u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.needed),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidApprover(address)` and selector `0xe602df05`.
```solidity
error ERC20InvalidApprover(address approver);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidApprover {
        #[allow(missing_docs)]
        pub approver: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidApprover> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidApprover) -> Self {
                (value.approver,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidApprover {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { approver: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidApprover {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidApprover(address)";
            const SELECTOR: [u8; 4] = [230u8, 2u8, 223u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.approver,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidReceiver(address)` and selector `0xec442f05`.
```solidity
error ERC20InvalidReceiver(address receiver);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidReceiver {
        #[allow(missing_docs)]
        pub receiver: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidReceiver> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidReceiver) -> Self {
                (value.receiver,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidReceiver {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { receiver: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidReceiver {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidReceiver(address)";
            const SELECTOR: [u8; 4] = [236u8, 68u8, 47u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.receiver,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidSender(address)` and selector `0x96c6fd1e`.
```solidity
error ERC20InvalidSender(address sender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidSender {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidSender> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidSender) -> Self {
                (value.sender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidSender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { sender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidSender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidSender(address)";
            const SELECTOR: [u8; 4] = [150u8, 198u8, 253u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidSpender(address)` and selector `0x94280d62`.
```solidity
error ERC20InvalidSpender(address spender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidSpender {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidSpender> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidSpender) -> Self {
                (value.spender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidSpender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { spender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidSpender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidSpender(address)";
            const SELECTOR: [u8; 4] = [148u8, 40u8, 13u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC2612ExpiredSignature(uint256)` and selector `0x62791302`.
```solidity
error ERC2612ExpiredSignature(uint256 deadline);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC2612ExpiredSignature {
        #[allow(missing_docs)]
        pub deadline: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC2612ExpiredSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ERC2612ExpiredSignature) -> Self {
                (value.deadline,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC2612ExpiredSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { deadline: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC2612ExpiredSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC2612ExpiredSignature(uint256)";
            const SELECTOR: [u8; 4] = [98u8, 121u8, 19u8, 2u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deadline),
                )
            }
        }
    };
    /**Custom error with signature `ERC2612InvalidSigner(address,address)` and selector `0x4b800e46`.
```solidity
error ERC2612InvalidSigner(address signer, address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC2612InvalidSigner {
        #[allow(missing_docs)]
        pub signer: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC2612InvalidSigner> for UnderlyingRustTuple<'_> {
            fn from(value: ERC2612InvalidSigner) -> Self {
                (value.signer, value.owner)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC2612InvalidSigner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    signer: tuple.0,
                    owner: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC2612InvalidSigner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC2612InvalidSigner(address,address)";
            const SELECTOR: [u8; 4] = [75u8, 128u8, 14u8, 70u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signer,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC5805FutureLookup(uint256,uint48)` and selector `0xecd3f81e`.
```solidity
error ERC5805FutureLookup(uint256 timepoint, uint48 clock);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC5805FutureLookup {
        #[allow(missing_docs)]
        pub timepoint: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub clock: alloy::sol_types::private::primitives::aliases::U48,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<48>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U48,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC5805FutureLookup> for UnderlyingRustTuple<'_> {
            fn from(value: ERC5805FutureLookup) -> Self {
                (value.timepoint, value.clock)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC5805FutureLookup {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    timepoint: tuple.0,
                    clock: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC5805FutureLookup {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC5805FutureLookup(uint256,uint48)";
            const SELECTOR: [u8; 4] = [236u8, 211u8, 248u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.timepoint),
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self.clock),
                )
            }
        }
    };
    /**Custom error with signature `ERC6372InconsistentClock()` and selector `0x6ff07140`.
```solidity
error ERC6372InconsistentClock();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC6372InconsistentClock {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC6372InconsistentClock>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC6372InconsistentClock) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC6372InconsistentClock {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC6372InconsistentClock {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC6372InconsistentClock()";
            const SELECTOR: [u8; 4] = [111u8, 240u8, 113u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionsAlreadyStarted()` and selector `0x71d27b7a`.
```solidity
error EmissionsAlreadyStarted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionsAlreadyStarted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionsAlreadyStarted> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionsAlreadyStarted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionsAlreadyStarted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionsAlreadyStarted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionsAlreadyStarted()";
            const SELECTOR: [u8; 4] = [113u8, 210u8, 123u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionsNotActive()` and selector `0x66bf2674`.
```solidity
error EmissionsNotActive();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionsNotActive {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionsNotActive> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionsNotActive) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionsNotActive {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionsNotActive {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionsNotActive()";
            const SELECTOR: [u8; 4] = [102u8, 191u8, 38u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionsNotStarted()` and selector `0x8f984041`.
```solidity
error EmissionsNotStarted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionsNotStarted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionsNotStarted> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionsNotStarted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionsNotStarted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionsNotStarted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionsNotStarted()";
            const SELECTOR: [u8; 4] = [143u8, 152u8, 64u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EnforcedPause()` and selector `0xd93c0665`.
```solidity
error EnforcedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EnforcedPause {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EnforcedPause> for UnderlyingRustTuple<'_> {
            fn from(value: EnforcedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EnforcedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EnforcedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EnforcedPause()";
            const SELECTOR: [u8; 4] = [217u8, 60u8, 6u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EpochAlreadyMinted()` and selector `0xe085d22b`.
```solidity
error EpochAlreadyMinted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EpochAlreadyMinted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EpochAlreadyMinted> for UnderlyingRustTuple<'_> {
            fn from(value: EpochAlreadyMinted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EpochAlreadyMinted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EpochAlreadyMinted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EpochAlreadyMinted()";
            const SELECTOR: [u8; 4] = [224u8, 133u8, 210u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ExceedsEmissionsSupply()` and selector `0x23064ebd`.
```solidity
error ExceedsEmissionsSupply();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExceedsEmissionsSupply {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExceedsEmissionsSupply> for UnderlyingRustTuple<'_> {
            fn from(value: ExceedsEmissionsSupply) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExceedsEmissionsSupply {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExceedsEmissionsSupply {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExceedsEmissionsSupply()";
            const SELECTOR: [u8; 4] = [35u8, 6u8, 78u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ExpectedPause()` and selector `0x8dfc202b`.
```solidity
error ExpectedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExpectedPause {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExpectedPause> for UnderlyingRustTuple<'_> {
            fn from(value: ExpectedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExpectedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExpectedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExpectedPause()";
            const SELECTOR: [u8; 4] = [141u8, 252u8, 32u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InsufficientLimit()` and selector `0x72567b64`.
```solidity
error InsufficientLimit();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientLimit {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientLimit> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientLimit) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientLimit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientLimit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientLimit()";
            const SELECTOR: [u8; 4] = [114u8, 86u8, 123u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidAccountNonce(address,uint256)` and selector `0x752d88c0`.
```solidity
error InvalidAccountNonce(address account, uint256 currentNonce);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidAccountNonce {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub currentNonce: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidAccountNonce> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidAccountNonce) -> Self {
                (value.account, value.currentNonce)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidAccountNonce {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    currentNonce: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidAccountNonce {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidAccountNonce(address,uint256)";
            const SELECTOR: [u8; 4] = [117u8, 45u8, 136u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.currentNonce),
                )
            }
        }
    };
    /**Custom error with signature `InvalidEpoch()` and selector `0xd5b25b63`.
```solidity
error InvalidEpoch();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidEpoch {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidEpoch> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidEpoch) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidEpoch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidEpoch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidEpoch()";
            const SELECTOR: [u8; 4] = [213u8, 178u8, 91u8, 99u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidShortString()` and selector `0xb3512b0c`.
```solidity
error InvalidShortString();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidShortString {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidShortString> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidShortString) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidShortString {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidShortString {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidShortString()";
            const SELECTOR: [u8; 4] = [179u8, 81u8, 43u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `SafeCastOverflowedUintDowncast(uint8,uint256)` and selector `0x6dfcc650`.
```solidity
error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SafeCastOverflowedUintDowncast {
        #[allow(missing_docs)]
        pub bits: u8,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u8,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SafeCastOverflowedUintDowncast>
        for UnderlyingRustTuple<'_> {
            fn from(value: SafeCastOverflowedUintDowncast) -> Self {
                (value.bits, value.value)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SafeCastOverflowedUintDowncast {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    bits: tuple.0,
                    value: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SafeCastOverflowedUintDowncast {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SafeCastOverflowedUintDowncast(uint8,uint256)";
            const SELECTOR: [u8; 4] = [109u8, 252u8, 198u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.bits),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
        }
    };
    /**Custom error with signature `StringTooLong(string)` and selector `0x305a27a9`.
```solidity
error StringTooLong(string str);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct StringTooLong {
        #[allow(missing_docs)]
        pub str: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<StringTooLong> for UnderlyingRustTuple<'_> {
            fn from(value: StringTooLong) -> Self {
                (value.str,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for StringTooLong {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { str: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for StringTooLong {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "StringTooLong(string)";
            const SELECTOR: [u8; 4] = [48u8, 90u8, 39u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.str,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `VotesExpiredSignature(uint256)` and selector `0x4683af0e`.
```solidity
error VotesExpiredSignature(uint256 expiry);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct VotesExpiredSignature {
        #[allow(missing_docs)]
        pub expiry: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<VotesExpiredSignature> for UnderlyingRustTuple<'_> {
            fn from(value: VotesExpiredSignature) -> Self {
                (value.expiry,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for VotesExpiredSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { expiry: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for VotesExpiredSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "VotesExpiredSignature(uint256)";
            const SELECTOR: [u8; 4] = [70u8, 131u8, 175u8, 14u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiry),
                )
            }
        }
    };
    /**Custom error with signature `ZeroAddress()` and selector `0xd92e233d`.
```solidity
error ZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAddress {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAddress()";
            const SELECTOR: [u8; 4] = [217u8, 46u8, 35u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ZeroAmount()` and selector `0x1f2a2005`.
```solidity
error ZeroAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAmount {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAmount> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAmount()";
            const SELECTOR: [u8; 4] = [31u8, 42u8, 32u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ZeroGasLimit()` and selector `0x3e267f95`.
```solidity
error ZeroGasLimit();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroGasLimit {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroGasLimit> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroGasLimit) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroGasLimit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroGasLimit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroGasLimit()";
            const SELECTOR: [u8; 4] = [62u8, 38u8, 127u8, 149u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Event with signature `Approval(address,address,uint256)` and selector `0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925`.
```solidity
event Approval(address indexed owner, address indexed spender, uint256 value);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Approval {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Approval {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Approval(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                140u8,
                91u8,
                225u8,
                229u8,
                235u8,
                236u8,
                125u8,
                91u8,
                209u8,
                79u8,
                113u8,
                66u8,
                125u8,
                30u8,
                132u8,
                243u8,
                221u8,
                3u8,
                20u8,
                192u8,
                247u8,
                178u8,
                41u8,
                30u8,
                91u8,
                32u8,
                10u8,
                200u8,
                199u8,
                195u8,
                185u8,
                37u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    owner: topics.1,
                    spender: topics.2,
                    value: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.owner.clone(), self.spender.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.owner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.spender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Approval {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Approval> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Approval) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeAuthorized(address)` and selector `0x6cf28439a2daab1b265097227212a5b71e0a76f9ed85e3f815b5a6c3e218eb7f`.
```solidity
event BridgeAuthorized(address indexed bridge);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeAuthorized {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeAuthorized {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeAuthorized(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                108u8,
                242u8,
                132u8,
                57u8,
                162u8,
                218u8,
                171u8,
                27u8,
                38u8,
                80u8,
                151u8,
                34u8,
                114u8,
                18u8,
                165u8,
                183u8,
                30u8,
                10u8,
                118u8,
                249u8,
                237u8,
                133u8,
                227u8,
                248u8,
                21u8,
                181u8,
                166u8,
                195u8,
                226u8,
                24u8,
                235u8,
                127u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { bridge: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeAuthorized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeAuthorized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeAuthorized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeDataUpdated(bytes,bytes)` and selector `0xb9a2088426f03b30a81c06428094fbfa9e2692739b3241af6b9ab1da4b5546be`.
```solidity
event BridgeDataUpdated(bytes oldData, bytes newData);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeDataUpdated {
        #[allow(missing_docs)]
        pub oldData: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub newData: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeDataUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "BridgeDataUpdated(bytes,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                185u8,
                162u8,
                8u8,
                132u8,
                38u8,
                240u8,
                59u8,
                48u8,
                168u8,
                28u8,
                6u8,
                66u8,
                128u8,
                148u8,
                251u8,
                250u8,
                158u8,
                38u8,
                146u8,
                115u8,
                155u8,
                50u8,
                65u8,
                175u8,
                107u8,
                154u8,
                177u8,
                218u8,
                75u8,
                85u8,
                70u8,
                190u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldData: data.0,
                    newData: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.oldData,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.newData,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeDataUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeDataUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeDataUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeDeauthorized(address)` and selector `0x02c2f0ba15b03f88b18f4832609a18cf35fc6b3f4546a9992076d7453d1334a8`.
```solidity
event BridgeDeauthorized(address indexed bridge);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeDeauthorized {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeDeauthorized {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeDeauthorized(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                2u8,
                194u8,
                240u8,
                186u8,
                21u8,
                176u8,
                63u8,
                136u8,
                177u8,
                143u8,
                72u8,
                50u8,
                96u8,
                154u8,
                24u8,
                207u8,
                53u8,
                252u8,
                107u8,
                63u8,
                69u8,
                70u8,
                169u8,
                153u8,
                32u8,
                118u8,
                215u8,
                69u8,
                61u8,
                19u8,
                52u8,
                168u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { bridge: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeDeauthorized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeDeauthorized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeDeauthorized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeLimitsSet(address,uint256,uint256)` and selector `0xaa807d0abf30d91968c7478c66b6d82521a106af13eda036e2036da9af168958`.
```solidity
event BridgeLimitsSet(address indexed bridge, uint256 mintingLimit, uint256 burningLimit);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeLimitsSet {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub mintingLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningLimit: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeLimitsSet {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeLimitsSet(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                170u8,
                128u8,
                125u8,
                10u8,
                191u8,
                48u8,
                217u8,
                25u8,
                104u8,
                199u8,
                71u8,
                140u8,
                102u8,
                182u8,
                216u8,
                37u8,
                33u8,
                161u8,
                6u8,
                175u8,
                19u8,
                237u8,
                160u8,
                54u8,
                226u8,
                3u8,
                109u8,
                169u8,
                175u8,
                22u8,
                137u8,
                88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    bridge: topics.1,
                    mintingLimit: data.0,
                    burningLimit: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.mintingLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.burningLimit),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeLimitsSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeLimitsSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeLimitsSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeProxyUpdated(address,address)` and selector `0x07015b6a9f05913148fd5faddf2acc9708f305937f3072ca2b4b46faa5d0898b`.
```solidity
event BridgeProxyUpdated(address indexed oldProxy, address indexed newProxy);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeProxyUpdated {
        #[allow(missing_docs)]
        pub oldProxy: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newProxy: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeProxyUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeProxyUpdated(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                7u8,
                1u8,
                91u8,
                106u8,
                159u8,
                5u8,
                145u8,
                49u8,
                72u8,
                253u8,
                95u8,
                173u8,
                223u8,
                42u8,
                204u8,
                151u8,
                8u8,
                243u8,
                5u8,
                147u8,
                127u8,
                48u8,
                114u8,
                202u8,
                43u8,
                75u8,
                70u8,
                250u8,
                165u8,
                208u8,
                137u8,
                139u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldProxy: topics.1,
                    newProxy: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.oldProxy.clone(),
                    self.newProxy.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.oldProxy,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newProxy,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeProxyUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeProxyUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeProxyUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `DelegateChanged(address,address,address)` and selector `0x3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f`.
```solidity
event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DelegateChanged {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub fromDelegate: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub toDelegate: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DelegateChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "DelegateChanged(address,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                49u8,
                52u8,
                232u8,
                162u8,
                230u8,
                217u8,
                126u8,
                146u8,
                154u8,
                126u8,
                84u8,
                1u8,
                30u8,
                165u8,
                72u8,
                93u8,
                125u8,
                25u8,
                109u8,
                213u8,
                240u8,
                186u8,
                77u8,
                78u8,
                249u8,
                88u8,
                3u8,
                232u8,
                227u8,
                252u8,
                37u8,
                127u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    delegator: topics.1,
                    fromDelegate: topics.2,
                    toDelegate: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.delegator.clone(),
                    self.fromDelegate.clone(),
                    self.toDelegate.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.delegator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.fromDelegate,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.toDelegate,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DelegateChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DelegateChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DelegateChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `DelegateVotesChanged(address,uint256,uint256)` and selector `0xdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724`.
```solidity
event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DelegateVotesChanged {
        #[allow(missing_docs)]
        pub delegate: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub previousVotes: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newVotes: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DelegateVotesChanged {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "DelegateVotesChanged(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                222u8,
                194u8,
                186u8,
                205u8,
                210u8,
                240u8,
                91u8,
                89u8,
                222u8,
                52u8,
                218u8,
                155u8,
                82u8,
                61u8,
                255u8,
                139u8,
                228u8,
                46u8,
                94u8,
                56u8,
                232u8,
                24u8,
                200u8,
                47u8,
                219u8,
                11u8,
                174u8,
                119u8,
                67u8,
                135u8,
                167u8,
                36u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    delegate: topics.1,
                    previousVotes: data.0,
                    newVotes: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.previousVotes),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newVotes),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.delegate.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.delegate,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DelegateVotesChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DelegateVotesChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DelegateVotesChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EIP712DomainChanged()` and selector `0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31`.
```solidity
event EIP712DomainChanged();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EIP712DomainChanged {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EIP712DomainChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EIP712DomainChanged()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                10u8,
                99u8,
                135u8,
                201u8,
                234u8,
                54u8,
                40u8,
                184u8,
                138u8,
                99u8,
                59u8,
                180u8,
                243u8,
                177u8,
                81u8,
                119u8,
                15u8,
                112u8,
                8u8,
                81u8,
                23u8,
                161u8,
                95u8,
                155u8,
                243u8,
                120u8,
                124u8,
                218u8,
                83u8,
                241u8,
                61u8,
                49u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EIP712DomainChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EIP712DomainChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EIP712DomainChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionMinted(uint256,uint256,address)` and selector `0x34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb`.
```solidity
event EmissionMinted(uint256 epoch, uint256 amount, address indexed destination);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionMinted {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub destination: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionMinted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "EmissionMinted(uint256,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                52u8,
                183u8,
                61u8,
                12u8,
                150u8,
                233u8,
                255u8,
                77u8,
                83u8,
                17u8,
                67u8,
                72u8,
                23u8,
                200u8,
                236u8,
                201u8,
                48u8,
                231u8,
                210u8,
                120u8,
                44u8,
                91u8,
                222u8,
                46u8,
                121u8,
                220u8,
                68u8,
                176u8,
                89u8,
                103u8,
                85u8,
                187u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    epoch: data.0,
                    amount: data.1,
                    destination: topics.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epoch),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.destination.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.destination,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionMinted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionMinted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionMinted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionsPaused()` and selector `0x73a5fc60aafeec8f139af22d98e62140e2ce914d1f155c692b427757c3e4014c`.
```solidity
event EmissionsPaused();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionsPaused {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionsPaused {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EmissionsPaused()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                115u8,
                165u8,
                252u8,
                96u8,
                170u8,
                254u8,
                236u8,
                143u8,
                19u8,
                154u8,
                242u8,
                45u8,
                152u8,
                230u8,
                33u8,
                64u8,
                226u8,
                206u8,
                145u8,
                77u8,
                31u8,
                21u8,
                92u8,
                105u8,
                43u8,
                66u8,
                119u8,
                87u8,
                195u8,
                228u8,
                1u8,
                76u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionsPaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionsPaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionsPaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionsResumed()` and selector `0x4a792a0be42b5672faa40129fc6469072490775ca8d3c34e852d4d55d3a735a9`.
```solidity
event EmissionsResumed();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionsResumed {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionsResumed {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EmissionsResumed()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                74u8,
                121u8,
                42u8,
                11u8,
                228u8,
                43u8,
                86u8,
                114u8,
                250u8,
                164u8,
                1u8,
                41u8,
                252u8,
                100u8,
                105u8,
                7u8,
                36u8,
                144u8,
                119u8,
                92u8,
                168u8,
                211u8,
                195u8,
                78u8,
                133u8,
                45u8,
                77u8,
                85u8,
                211u8,
                167u8,
                53u8,
                169u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionsResumed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionsResumed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionsResumed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionsStarted(uint256)` and selector `0x1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a3220341160`.
```solidity
event EmissionsStarted(uint256 startTime);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionsStarted {
        #[allow(missing_docs)]
        pub startTime: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionsStarted {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EmissionsStarted(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                17u8,
                148u8,
                176u8,
                52u8,
                207u8,
                169u8,
                171u8,
                88u8,
                7u8,
                73u8,
                74u8,
                29u8,
                92u8,
                102u8,
                125u8,
                139u8,
                14u8,
                110u8,
                151u8,
                243u8,
                136u8,
                136u8,
                116u8,
                42u8,
                163u8,
                135u8,
                26u8,
                50u8,
                32u8,
                52u8,
                17u8,
                96u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { startTime: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startTime),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionsStarted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionsStarted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionsStarted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Paused(address)` and selector `0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258`.
```solidity
event Paused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Paused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Paused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Paused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                98u8,
                231u8,
                140u8,
                234u8,
                1u8,
                190u8,
                227u8,
                32u8,
                205u8,
                78u8,
                66u8,
                2u8,
                112u8,
                181u8,
                234u8,
                116u8,
                0u8,
                13u8,
                17u8,
                176u8,
                201u8,
                247u8,
                71u8,
                84u8,
                235u8,
                219u8,
                252u8,
                84u8,
                75u8,
                5u8,
                162u8,
                88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Paused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Paused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Paused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Transfer(address,address,uint256)` and selector `0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef`.
```solidity
event Transfer(address indexed from, address indexed to, uint256 value);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Transfer {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Transfer {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Transfer(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                221u8,
                242u8,
                82u8,
                173u8,
                27u8,
                226u8,
                200u8,
                155u8,
                105u8,
                194u8,
                176u8,
                104u8,
                252u8,
                55u8,
                141u8,
                170u8,
                149u8,
                43u8,
                167u8,
                241u8,
                99u8,
                196u8,
                161u8,
                22u8,
                40u8,
                245u8,
                90u8,
                77u8,
                245u8,
                35u8,
                179u8,
                239u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    from: topics.1,
                    to: topics.2,
                    value: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.from.clone(), self.to.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.from,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.to,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Transfer {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Transfer> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Transfer) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Unpaused(address)` and selector `0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa`.
```solidity
event Unpaused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Unpaused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Unpaused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Unpaused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8,
                185u8,
                238u8,
                10u8,
                73u8,
                91u8,
                242u8,
                230u8,
                255u8,
                156u8,
                145u8,
                167u8,
                131u8,
                76u8,
                27u8,
                164u8,
                253u8,
                210u8,
                68u8,
                165u8,
                232u8,
                170u8,
                78u8,
                83u8,
                123u8,
                211u8,
                138u8,
                234u8,
                228u8,
                176u8,
                115u8,
                170u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Unpaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Unpaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Unpaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address defaultAdmin, address syndFoundationAddress, address emissionsManager, address pauser);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub defaultAdmin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub syndFoundationAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub emissionsManager: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub pauser: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value.defaultAdmin,
                        value.syndFoundationAddress,
                        value.emissionsManager,
                        value.pauser,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        defaultAdmin: tuple.0,
                        syndFoundationAddress: tuple.1,
                        emissionsManager: tuple.2,
                        pauser: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.defaultAdmin,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.syndFoundationAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.emissionsManager,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.pauser,
                    ),
                )
            }
        }
    };
    /**Function with signature `BRIDGE_LIMIT_DURATION()` and selector `0x99127d9b`.
```solidity
function BRIDGE_LIMIT_DURATION() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_LIMIT_DURATIONCall {}
    ///Container type for the return parameters of the [`BRIDGE_LIMIT_DURATION()`](BRIDGE_LIMIT_DURATIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_LIMIT_DURATIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_LIMIT_DURATIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_LIMIT_DURATIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_LIMIT_DURATIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_LIMIT_DURATIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_LIMIT_DURATIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_LIMIT_DURATIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BRIDGE_LIMIT_DURATIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BRIDGE_LIMIT_DURATIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BRIDGE_LIMIT_DURATION()";
            const SELECTOR: [u8; 4] = [153u8, 18u8, 125u8, 155u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `BRIDGE_MANAGER_ROLE()` and selector `0xf75e8512`.
```solidity
function BRIDGE_MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_MANAGER_ROLECall {}
    ///Container type for the return parameters of the [`BRIDGE_MANAGER_ROLE()`](BRIDGE_MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_MANAGER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_MANAGER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BRIDGE_MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BRIDGE_MANAGER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BRIDGE_MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [247u8, 94u8, 133u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `CLOCK_MODE()` and selector `0x4bf5d7e9`.
```solidity
function CLOCK_MODE() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CLOCK_MODECall {}
    ///Container type for the return parameters of the [`CLOCK_MODE()`](CLOCK_MODECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CLOCK_MODEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CLOCK_MODECall> for UnderlyingRustTuple<'_> {
                fn from(value: CLOCK_MODECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for CLOCK_MODECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CLOCK_MODEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: CLOCK_MODEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for CLOCK_MODEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for CLOCK_MODECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = CLOCK_MODEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CLOCK_MODE()";
            const SELECTOR: [u8; 4] = [75u8, 245u8, 215u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall {}
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DEFAULT_ADMIN_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DOMAIN_SEPARATOR()` and selector `0x3644e515`.
```solidity
function DOMAIN_SEPARATOR() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DOMAIN_SEPARATORCall {}
    ///Container type for the return parameters of the [`DOMAIN_SEPARATOR()`](DOMAIN_SEPARATORCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DOMAIN_SEPARATORReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DOMAIN_SEPARATORCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DOMAIN_SEPARATORCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DOMAIN_SEPARATORCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DOMAIN_SEPARATORReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DOMAIN_SEPARATORReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DOMAIN_SEPARATORReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DOMAIN_SEPARATORCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DOMAIN_SEPARATORReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DOMAIN_SEPARATOR()";
            const SELECTOR: [u8; 4] = [54u8, 68u8, 229u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSIONS_MANAGER_ROLE()` and selector `0xe3abdfcb`.
```solidity
function EMISSIONS_MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_MANAGER_ROLECall {}
    ///Container type for the return parameters of the [`EMISSIONS_MANAGER_ROLE()`](EMISSIONS_MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_MANAGER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_MANAGER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSIONS_MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSIONS_MANAGER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSIONS_MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [227u8, 171u8, 223u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSIONS_SUPPLY()` and selector `0x6cf01625`.
```solidity
function EMISSIONS_SUPPLY() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_SUPPLYCall {}
    ///Container type for the return parameters of the [`EMISSIONS_SUPPLY()`](EMISSIONS_SUPPLYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_SUPPLYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_SUPPLYCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_SUPPLYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_SUPPLYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_SUPPLYReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_SUPPLYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_SUPPLYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSIONS_SUPPLYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSIONS_SUPPLYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSIONS_SUPPLY()";
            const SELECTOR: [u8; 4] = [108u8, 240u8, 22u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EPOCH_DURATION()` and selector `0xa70b9f0c`.
```solidity
function EPOCH_DURATION() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EPOCH_DURATIONCall {}
    ///Container type for the return parameters of the [`EPOCH_DURATION()`](EPOCH_DURATIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EPOCH_DURATIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EPOCH_DURATIONCall> for UnderlyingRustTuple<'_> {
                fn from(value: EPOCH_DURATIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for EPOCH_DURATIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EPOCH_DURATIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EPOCH_DURATIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EPOCH_DURATIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EPOCH_DURATIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EPOCH_DURATIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EPOCH_DURATION()";
            const SELECTOR: [u8; 4] = [167u8, 11u8, 159u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `INITIAL_MINT_SUPPLY()` and selector `0x9b7ef64b`.
```solidity
function INITIAL_MINT_SUPPLY() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INITIAL_MINT_SUPPLYCall {}
    ///Container type for the return parameters of the [`INITIAL_MINT_SUPPLY()`](INITIAL_MINT_SUPPLYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INITIAL_MINT_SUPPLYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INITIAL_MINT_SUPPLYCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: INITIAL_MINT_SUPPLYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for INITIAL_MINT_SUPPLYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INITIAL_MINT_SUPPLYReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: INITIAL_MINT_SUPPLYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for INITIAL_MINT_SUPPLYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for INITIAL_MINT_SUPPLYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = INITIAL_MINT_SUPPLYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "INITIAL_MINT_SUPPLY()";
            const SELECTOR: [u8; 4] = [155u8, 126u8, 246u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PAUSER_ROLE()` and selector `0xe63ab1e9`.
```solidity
function PAUSER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PAUSER_ROLECall {}
    ///Container type for the return parameters of the [`PAUSER_ROLE()`](PAUSER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PAUSER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PAUSER_ROLECall> for UnderlyingRustTuple<'_> {
                fn from(value: PAUSER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PAUSER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PAUSER_ROLEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: PAUSER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PAUSER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PAUSER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PAUSER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PAUSER_ROLE()";
            const SELECTOR: [u8; 4] = [230u8, 58u8, 177u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `TOTAL_EPOCHS()` and selector `0x5f15c3c9`.
```solidity
function TOTAL_EPOCHS() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_EPOCHSCall {}
    ///Container type for the return parameters of the [`TOTAL_EPOCHS()`](TOTAL_EPOCHSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_EPOCHSReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_EPOCHSCall> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_EPOCHSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_EPOCHSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_EPOCHSReturn> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_EPOCHSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_EPOCHSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TOTAL_EPOCHSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = TOTAL_EPOCHSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TOTAL_EPOCHS()";
            const SELECTOR: [u8; 4] = [95u8, 21u8, 195u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `TOTAL_SUPPLY()` and selector `0x902d55a5`.
```solidity
function TOTAL_SUPPLY() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_SUPPLYCall {}
    ///Container type for the return parameters of the [`TOTAL_SUPPLY()`](TOTAL_SUPPLYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_SUPPLYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_SUPPLYCall> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_SUPPLYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_SUPPLYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_SUPPLYReturn> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_SUPPLYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_SUPPLYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TOTAL_SUPPLYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = TOTAL_SUPPLYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TOTAL_SUPPLY()";
            const SELECTOR: [u8; 4] = [144u8, 45u8, 85u8, 165u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `allowance(address,address)` and selector `0xdd62ed3e`.
```solidity
function allowance(address owner, address spender) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowanceCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`allowance(address,address)`](allowanceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowanceReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowanceCall> for UnderlyingRustTuple<'_> {
                fn from(value: allowanceCall) -> Self {
                    (value.owner, value.spender)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        spender: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowanceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: allowanceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allowanceCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = allowanceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allowance(address,address)";
            const SELECTOR: [u8; 4] = [221u8, 98u8, 237u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `approve(address,uint256)` and selector `0x095ea7b3`.
```solidity
function approve(address spender, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveCall {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`approve(address,uint256)`](approveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveCall> for UnderlyingRustTuple<'_> {
                fn from(value: approveCall) -> Self {
                    (value.spender, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        spender: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveReturn> for UnderlyingRustTuple<'_> {
                fn from(value: approveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for approveCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = approveReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "approve(address,uint256)";
            const SELECTOR: [u8; 4] = [9u8, 94u8, 167u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `authorizedBridges(address)` and selector `0x6fc063be`.
```solidity
function authorizedBridges(address) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct authorizedBridgesCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`authorizedBridges(address)`](authorizedBridgesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct authorizedBridgesReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<authorizedBridgesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: authorizedBridgesCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for authorizedBridgesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<authorizedBridgesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: authorizedBridgesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for authorizedBridgesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for authorizedBridgesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = authorizedBridgesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "authorizedBridges(address)";
            const SELECTOR: [u8; 4] = [111u8, 192u8, 99u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `balanceOf(address)` and selector `0x70a08231`.
```solidity
function balanceOf(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`balanceOf(address)`](balanceOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for balanceOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = balanceOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "balanceOf(address)";
            const SELECTOR: [u8; 4] = [112u8, 160u8, 130u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeData()` and selector `0x2481bb5c`.
```solidity
function bridgeData() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeDataCall {}
    ///Container type for the return parameters of the [`bridgeData()`](bridgeDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeDataReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeDataReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeDataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeDataReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeData()";
            const SELECTOR: [u8; 4] = [36u8, 129u8, 187u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeLimits(address)` and selector `0x44e181aa`.
```solidity
function bridgeLimits(address) external view returns (uint256 mintingMaxLimit, uint256 mintingCurrentLimit, uint256 burningMaxLimit, uint256 burningCurrentLimit, uint256 lastUpdate);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeLimitsCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`bridgeLimits(address)`](bridgeLimitsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeLimitsReturn {
        #[allow(missing_docs)]
        pub mintingMaxLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub mintingCurrentLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningMaxLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningCurrentLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub lastUpdate: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeLimitsCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeLimitsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeLimitsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeLimitsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeLimitsReturn) -> Self {
                    (
                        value.mintingMaxLimit,
                        value.mintingCurrentLimit,
                        value.burningMaxLimit,
                        value.burningCurrentLimit,
                        value.lastUpdate,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeLimitsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        mintingMaxLimit: tuple.0,
                        mintingCurrentLimit: tuple.1,
                        burningMaxLimit: tuple.2,
                        burningCurrentLimit: tuple.3,
                        lastUpdate: tuple.4,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeLimitsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeLimitsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeLimits(address)";
            const SELECTOR: [u8; 4] = [68u8, 225u8, 129u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeProxy()` and selector `0xa3d4485b`.
```solidity
function bridgeProxy() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeProxyCall {}
    ///Container type for the return parameters of the [`bridgeProxy()`](bridgeProxyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeProxyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeProxyCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeProxyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeProxyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeProxyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeProxyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeProxyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeProxyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeProxyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeProxy()";
            const SELECTOR: [u8; 4] = [163u8, 212u8, 72u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `burn(address,uint256)` and selector `0x9dc29fac`.
```solidity
function burn(address _user, uint256 _amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burnCall {
        #[allow(missing_docs)]
        pub _user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`burn(address,uint256)`](burnCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burnReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burnCall> for UnderlyingRustTuple<'_> {
                fn from(value: burnCall) -> Self {
                    (value._user, value._amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for burnCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _user: tuple.0,
                        _amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burnReturn> for UnderlyingRustTuple<'_> {
                fn from(value: burnReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for burnReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for burnCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = burnReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "burn(address,uint256)";
            const SELECTOR: [u8; 4] = [157u8, 194u8, 159u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `burningCurrentLimitOf(address)` and selector `0x998955d3`.
```solidity
function burningCurrentLimitOf(address _bridge) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burningCurrentLimitOfCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`burningCurrentLimitOf(address)`](burningCurrentLimitOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burningCurrentLimitOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burningCurrentLimitOfCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: burningCurrentLimitOfCall) -> Self {
                    (value._bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for burningCurrentLimitOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burningCurrentLimitOfReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: burningCurrentLimitOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for burningCurrentLimitOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for burningCurrentLimitOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = burningCurrentLimitOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "burningCurrentLimitOf(address)";
            const SELECTOR: [u8; 4] = [153u8, 137u8, 85u8, 211u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `burningMaxLimitOf(address)` and selector `0xc1eb7137`.
```solidity
function burningMaxLimitOf(address _bridge) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burningMaxLimitOfCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`burningMaxLimitOf(address)`](burningMaxLimitOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burningMaxLimitOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burningMaxLimitOfCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: burningMaxLimitOfCall) -> Self {
                    (value._bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for burningMaxLimitOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burningMaxLimitOfReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: burningMaxLimitOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for burningMaxLimitOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for burningMaxLimitOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = burningMaxLimitOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "burningMaxLimitOf(address)";
            const SELECTOR: [u8; 4] = [193u8, 235u8, 113u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkpoints(address,uint32)` and selector `0xf1127ed8`.
```solidity
function checkpoints(address account, uint32 pos) external view returns (Checkpoints.Checkpoint208 memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkpointsCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub pos: u32,
    }
    ///Container type for the return parameters of the [`checkpoints(address,uint32)`](checkpointsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkpointsReturn {
        #[allow(missing_docs)]
        pub _0: <Checkpoints::Checkpoint208 as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u32);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkpointsCall> for UnderlyingRustTuple<'_> {
                fn from(value: checkpointsCall) -> Self {
                    (value.account, value.pos)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkpointsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        pos: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Checkpoints::Checkpoint208,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Checkpoints::Checkpoint208 as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkpointsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: checkpointsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkpointsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkpointsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkpointsReturn;
            type ReturnTuple<'a> = (Checkpoints::Checkpoint208,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkpoints(address,uint32)";
            const SELECTOR: [u8; 4] = [241u8, 18u8, 126u8, 216u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.pos),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `clock()` and selector `0x91ddadf4`.
```solidity
function clock() external view returns (uint48);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct clockCall {}
    ///Container type for the return parameters of the [`clock()`](clockCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct clockReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U48,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<clockCall> for UnderlyingRustTuple<'_> {
                fn from(value: clockCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for clockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U48,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<clockReturn> for UnderlyingRustTuple<'_> {
                fn from(value: clockReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for clockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for clockCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = clockReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "clock()";
            const SELECTOR: [u8; 4] = [145u8, 221u8, 173u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `currentEpoch()` and selector `0x76671808`.
```solidity
function currentEpoch() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentEpochCall {}
    ///Container type for the return parameters of the [`currentEpoch()`](currentEpochCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentEpochReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentEpochCall> for UnderlyingRustTuple<'_> {
                fn from(value: currentEpochCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentEpochCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentEpochReturn> for UnderlyingRustTuple<'_> {
                fn from(value: currentEpochReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentEpochReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for currentEpochCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = currentEpochReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "currentEpoch()";
            const SELECTOR: [u8; 4] = [118u8, 103u8, 24u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `decimals()` and selector `0x313ce567`.
```solidity
function decimals() external view returns (uint8);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decimalsCall {}
    ///Container type for the return parameters of the [`decimals()`](decimalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decimalsReturn {
        #[allow(missing_docs)]
        pub _0: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decimalsCall> for UnderlyingRustTuple<'_> {
                fn from(value: decimalsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decimalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decimalsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: decimalsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decimalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for decimalsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = decimalsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "decimals()";
            const SELECTOR: [u8; 4] = [49u8, 60u8, 229u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `delegate(address)` and selector `0x5c19a95c`.
```solidity
function delegate(address delegatee) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateCall {
        #[allow(missing_docs)]
        pub delegatee: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`delegate(address)`](delegateCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateCall> for UnderlyingRustTuple<'_> {
                fn from(value: delegateCall) -> Self {
                    (value.delegatee,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { delegatee: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateReturn> for UnderlyingRustTuple<'_> {
                fn from(value: delegateReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegateCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegateReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegate(address)";
            const SELECTOR: [u8; 4] = [92u8, 25u8, 169u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegatee,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)` and selector `0xc3cda520`.
```solidity
function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateBySigCall {
        #[allow(missing_docs)]
        pub delegatee: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub expiry: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub v: u8,
        #[allow(missing_docs)]
        pub r: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)`](delegateBySigCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateBySigReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateBySigCall> for UnderlyingRustTuple<'_> {
                fn from(value: delegateBySigCall) -> Self {
                    (
                        value.delegatee,
                        value.nonce,
                        value.expiry,
                        value.v,
                        value.r,
                        value.s,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateBySigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        delegatee: tuple.0,
                        nonce: tuple.1,
                        expiry: tuple.2,
                        v: tuple.3,
                        r: tuple.4,
                        s: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateBySigReturn> for UnderlyingRustTuple<'_> {
                fn from(value: delegateBySigReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateBySigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegateBySigCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegateBySigReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [195u8, 205u8, 165u8, 32u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegatee,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiry),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.v),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.r),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `delegates(address)` and selector `0x587cde1e`.
```solidity
function delegates(address account) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegatesCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`delegates(address)`](delegatesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegatesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegatesCall> for UnderlyingRustTuple<'_> {
                fn from(value: delegatesCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegatesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegatesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: delegatesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegatesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegatesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegatesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegates(address)";
            const SELECTOR: [u8; 4] = [88u8, 124u8, 222u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `eip712Domain()` and selector `0x84b0196e`.
```solidity
function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainCall {}
    ///Container type for the return parameters of the [`eip712Domain()`](eip712DomainCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainReturn {
        #[allow(missing_docs)]
        pub fields: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub version: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub verifyingContract: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub salt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub extensions: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainCall> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainReturn> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainReturn) -> Self {
                    (
                        value.fields,
                        value.name,
                        value.version,
                        value.chainId,
                        value.verifyingContract,
                        value.salt,
                        value.extensions,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        fields: tuple.0,
                        name: tuple.1,
                        version: tuple.2,
                        chainId: tuple.3,
                        verifyingContract: tuple.4,
                        salt: tuple.5,
                        extensions: tuple.6,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for eip712DomainCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = eip712DomainReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "eip712Domain()";
            const SELECTOR: [u8; 4] = [132u8, 176u8, 25u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionSchedule(uint256)` and selector `0x334d0bbd`.
```solidity
function emissionSchedule(uint256) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionScheduleCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`emissionSchedule(uint256)`](emissionScheduleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionScheduleReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionScheduleCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionScheduleCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionScheduleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionScheduleReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionScheduleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionScheduleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionScheduleCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionScheduleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionSchedule(uint256)";
            const SELECTOR: [u8; 4] = [51u8, 77u8, 11u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsActive()` and selector `0x22a97d9c`.
```solidity
function emissionsActive() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsActiveCall {}
    ///Container type for the return parameters of the [`emissionsActive()`](emissionsActiveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsActiveReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsActiveCall> for UnderlyingRustTuple<'_> {
                fn from(value: emissionsActiveCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for emissionsActiveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsActiveReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsActiveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsActiveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsActiveCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsActiveReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsActive()";
            const SELECTOR: [u8; 4] = [34u8, 169u8, 125u8, 156u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsEnded()` and selector `0xa4d7e31d`.
```solidity
function emissionsEnded() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsEndedCall {}
    ///Container type for the return parameters of the [`emissionsEnded()`](emissionsEndedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsEndedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsEndedCall> for UnderlyingRustTuple<'_> {
                fn from(value: emissionsEndedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for emissionsEndedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsEndedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsEndedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsEndedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsEndedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsEndedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsEnded()";
            const SELECTOR: [u8; 4] = [164u8, 215u8, 227u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsStartTime()` and selector `0x48b0daa6`.
```solidity
function emissionsStartTime() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartTimeCall {}
    ///Container type for the return parameters of the [`emissionsStartTime()`](emissionsStartTimeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartTimeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartTimeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartTimeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartTimeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartTimeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartTimeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartTimeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsStartTimeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsStartTimeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsStartTime()";
            const SELECTOR: [u8; 4] = [72u8, 176u8, 218u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsStarted()` and selector `0x5adf0021`.
```solidity
function emissionsStarted() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartedCall {}
    ///Container type for the return parameters of the [`emissionsStarted()`](emissionsStartedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsStartedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsStartedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsStarted()";
            const SELECTOR: [u8; 4] = [90u8, 223u8, 0u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeConfiguration()` and selector `0x07a1d5fa`.
```solidity
function getBridgeConfiguration() external view returns (address proxy, bytes memory data);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeConfigurationCall {}
    ///Container type for the return parameters of the [`getBridgeConfiguration()`](getBridgeConfigurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeConfigurationReturn {
        #[allow(missing_docs)]
        pub proxy: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeConfigurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeConfigurationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeConfigurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeConfigurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeConfigurationReturn) -> Self {
                    (value.proxy, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeConfigurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        proxy: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeConfigurationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeConfigurationReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeConfiguration()";
            const SELECTOR: [u8; 4] = [7u8, 161u8, 213u8, 250u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeInfo(address)` and selector `0x7c790cab`.
```solidity
function getBridgeInfo(address bridge) external view returns (bool authorized, uint256 mintingMax, uint256 mintingCurrent, uint256 burningMax, uint256 burningCurrent);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeInfoCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getBridgeInfo(address)`](getBridgeInfoCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeInfoReturn {
        #[allow(missing_docs)]
        pub authorized: bool,
        #[allow(missing_docs)]
        pub mintingMax: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub mintingCurrent: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningMax: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningCurrent: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeInfoCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeInfoCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBridgeInfoCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                bool,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeInfoReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeInfoReturn) -> Self {
                    (
                        value.authorized,
                        value.mintingMax,
                        value.mintingCurrent,
                        value.burningMax,
                        value.burningCurrent,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBridgeInfoReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        authorized: tuple.0,
                        mintingMax: tuple.1,
                        mintingCurrent: tuple.2,
                        burningMax: tuple.3,
                        burningCurrent: tuple.4,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeInfoCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeInfoReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeInfo(address)";
            const SELECTOR: [u8; 4] = [124u8, 121u8, 12u8, 171u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeUtilization(address)` and selector `0x23e460d2`.
```solidity
function getBridgeUtilization(address bridge) external view returns (uint256 mintingUtilization, uint256 burningUtilization);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeUtilizationCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getBridgeUtilization(address)`](getBridgeUtilizationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeUtilizationReturn {
        #[allow(missing_docs)]
        pub mintingUtilization: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningUtilization: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeUtilizationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeUtilizationCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeUtilizationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeUtilizationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeUtilizationReturn) -> Self {
                    (value.mintingUtilization, value.burningUtilization)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeUtilizationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        mintingUtilization: tuple.0,
                        burningUtilization: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeUtilizationCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeUtilizationReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeUtilization(address)";
            const SELECTOR: [u8; 4] = [35u8, 228u8, 96u8, 210u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCurrentEpochInfo()` and selector `0xbabc394f`.
```solidity
function getCurrentEpochInfo() external view returns (uint256 epoch, uint256 nextEmissionTime, uint256 nextEmissionAmount, bool canMintEmission);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochInfoCall {}
    ///Container type for the return parameters of the [`getCurrentEpochInfo()`](getCurrentEpochInfoCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochInfoReturn {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nextEmissionTime: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nextEmissionAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub canMintEmission: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochInfoCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochInfoCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentEpochInfoCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                bool,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochInfoReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochInfoReturn) -> Self {
                    (
                        value.epoch,
                        value.nextEmissionTime,
                        value.nextEmissionAmount,
                        value.canMintEmission,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentEpochInfoReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epoch: tuple.0,
                        nextEmissionTime: tuple.1,
                        nextEmissionAmount: tuple.2,
                        canMintEmission: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentEpochInfoCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCurrentEpochInfoReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentEpochInfo()";
            const SELECTOR: [u8; 4] = [186u8, 188u8, 57u8, 79u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCurrentTotalSupply()` and selector `0xc02ae754`.
```solidity
function getCurrentTotalSupply() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentTotalSupplyCall {}
    ///Container type for the return parameters of the [`getCurrentTotalSupply()`](getCurrentTotalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentTotalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentTotalSupplyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentTotalSupplyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentTotalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentTotalSupplyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentTotalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentTotalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentTotalSupplyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCurrentTotalSupplyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentTotalSupply()";
            const SELECTOR: [u8; 4] = [192u8, 42u8, 231u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getEmissionSchedule()` and selector `0xaf2aa63b`.
```solidity
function getEmissionSchedule() external view returns (uint256[48] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEmissionScheduleCall {}
    ///Container type for the return parameters of the [`getEmissionSchedule()`](getEmissionScheduleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEmissionScheduleReturn {
        #[allow(missing_docs)]
        pub _0: [alloy::sol_types::private::primitives::aliases::U256; 48usize],
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEmissionScheduleCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEmissionScheduleCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEmissionScheduleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    48usize,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                [alloy::sol_types::private::primitives::aliases::U256; 48usize],
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEmissionScheduleReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEmissionScheduleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEmissionScheduleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getEmissionScheduleCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getEmissionScheduleReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    48usize,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getEmissionSchedule()";
            const SELECTOR: [u8; 4] = [175u8, 42u8, 166u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPastTotalSupply(uint256)` and selector `0x8e539e8c`.
```solidity
function getPastTotalSupply(uint256 blockNumber) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastTotalSupplyCall {
        #[allow(missing_docs)]
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getPastTotalSupply(uint256)`](getPastTotalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastTotalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastTotalSupplyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastTotalSupplyCall) -> Self {
                    (value.blockNumber,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastTotalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blockNumber: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastTotalSupplyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastTotalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastTotalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPastTotalSupplyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPastTotalSupplyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPastTotalSupply(uint256)";
            const SELECTOR: [u8; 4] = [142u8, 83u8, 158u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPastVotes(address,uint256)` and selector `0x3a46b1a8`.
```solidity
function getPastVotes(address account, uint256 timepoint) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotesCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub timepoint: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getPastVotes(address,uint256)`](getPastVotesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotesCall> for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotesCall) -> Self {
                    (value.account, value.timepoint)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPastVotesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        timepoint: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPastVotesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPastVotesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPastVotesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPastVotes(address,uint256)";
            const SELECTOR: [u8; 4] = [58u8, 70u8, 177u8, 168u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.timepoint),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPastVotingPower(address,uint256)` and selector `0xb0ca253e`.
```solidity
function getPastVotingPower(address account, uint256 blockNumber) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotingPowerCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getPastVotingPower(address,uint256)`](getPastVotingPowerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotingPowerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotingPowerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotingPowerCall) -> Self {
                    (value.account, value.blockNumber)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastVotingPowerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        blockNumber: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotingPowerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotingPowerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastVotingPowerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPastVotingPowerCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPastVotingPowerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPastVotingPower(address,uint256)";
            const SELECTOR: [u8; 4] = [176u8, 202u8, 37u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRemainingEmissions()` and selector `0x4bdd36ce`.
```solidity
function getRemainingEmissions() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRemainingEmissionsCall {}
    ///Container type for the return parameters of the [`getRemainingEmissions()`](getRemainingEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRemainingEmissionsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRemainingEmissionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRemainingEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRemainingEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRemainingEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRemainingEmissionsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRemainingEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRemainingEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRemainingEmissionsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRemainingEmissions()";
            const SELECTOR: [u8; 4] = [75u8, 221u8, 54u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRoleAdminReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getVotes(address)` and selector `0x9ab24eb0`.
```solidity
function getVotes(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotesCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getVotes(address)`](getVotesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotesCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVotesCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVotesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getVotesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVotesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVotesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getVotesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVotes(address)";
            const SELECTOR: [u8; 4] = [154u8, 178u8, 78u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getVotingPower(address)` and selector `0xbb4d4436`.
```solidity
function getVotingPower(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotingPowerCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getVotingPower(address)`](getVotingPowerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotingPowerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotingPowerCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVotingPowerCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVotingPowerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotingPowerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getVotingPowerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getVotingPowerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVotingPowerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getVotingPowerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVotingPower(address)";
            const SELECTOR: [u8; 4] = [187u8, 77u8, 68u8, 54u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasRoleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isBridge(address)` and selector `0x726600ce`.
```solidity
function isBridge(address bridge) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isBridgeCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isBridge(address)`](isBridgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isBridgeReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isBridgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: isBridgeCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isBridgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isBridgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isBridgeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isBridgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isBridgeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isBridgeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isBridge(address)";
            const SELECTOR: [u8; 4] = [114u8, 102u8, 0u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mint(address,uint256)` and selector `0x40c10f19`.
```solidity
function mint(address _user, uint256 _amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintCall {
        #[allow(missing_docs)]
        pub _user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`mint(address,uint256)`](mintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintCall> for UnderlyingRustTuple<'_> {
                fn from(value: mintCall) -> Self {
                    (value._user, value._amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _user: tuple.0,
                        _amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: mintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mint(address,uint256)";
            const SELECTOR: [u8; 4] = [64u8, 193u8, 15u8, 25u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mintEmission()` and selector `0x284e1333`.
```solidity
function mintEmission() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintEmissionCall {}
    ///Container type for the return parameters of the [`mintEmission()`](mintEmissionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintEmissionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintEmissionCall> for UnderlyingRustTuple<'_> {
                fn from(value: mintEmissionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintEmissionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintEmissionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: mintEmissionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintEmissionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintEmissionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintEmissionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mintEmission()";
            const SELECTOR: [u8; 4] = [40u8, 78u8, 19u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mintingCurrentLimitOf(address)` and selector `0x651fd268`.
```solidity
function mintingCurrentLimitOf(address _bridge) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintingCurrentLimitOfCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`mintingCurrentLimitOf(address)`](mintingCurrentLimitOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintingCurrentLimitOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintingCurrentLimitOfCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: mintingCurrentLimitOfCall) -> Self {
                    (value._bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mintingCurrentLimitOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintingCurrentLimitOfReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: mintingCurrentLimitOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mintingCurrentLimitOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintingCurrentLimitOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintingCurrentLimitOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mintingCurrentLimitOf(address)";
            const SELECTOR: [u8; 4] = [101u8, 31u8, 210u8, 104u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mintingMaxLimitOf(address)` and selector `0x0c05f82c`.
```solidity
function mintingMaxLimitOf(address _bridge) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintingMaxLimitOfCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`mintingMaxLimitOf(address)`](mintingMaxLimitOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintingMaxLimitOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintingMaxLimitOfCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: mintingMaxLimitOfCall) -> Self {
                    (value._bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mintingMaxLimitOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintingMaxLimitOfReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: mintingMaxLimitOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mintingMaxLimitOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintingMaxLimitOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintingMaxLimitOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mintingMaxLimitOf(address)";
            const SELECTOR: [u8; 4] = [12u8, 5u8, 248u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `name()` and selector `0x06fdde03`.
```solidity
function name() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nameCall {}
    ///Container type for the return parameters of the [`name()`](nameCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nameReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nameCall> for UnderlyingRustTuple<'_> {
                fn from(value: nameCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nameReturn> for UnderlyingRustTuple<'_> {
                fn from(value: nameReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nameCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = nameReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "name()";
            const SELECTOR: [u8; 4] = [6u8, 253u8, 222u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `nonces(address)` and selector `0x7ecebe00`.
```solidity
function nonces(address owner) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct noncesCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`nonces(address)`](noncesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct noncesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<noncesCall> for UnderlyingRustTuple<'_> {
                fn from(value: noncesCall) -> Self {
                    (value.owner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for noncesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { owner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<noncesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: noncesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for noncesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for noncesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = noncesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nonces(address)";
            const SELECTOR: [u8; 4] = [126u8, 206u8, 190u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `numCheckpoints(address)` and selector `0x6fcfff45`.
```solidity
function numCheckpoints(address account) external view returns (uint32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct numCheckpointsCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`numCheckpoints(address)`](numCheckpointsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct numCheckpointsReturn {
        #[allow(missing_docs)]
        pub _0: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<numCheckpointsCall> for UnderlyingRustTuple<'_> {
                fn from(value: numCheckpointsCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for numCheckpointsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<numCheckpointsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: numCheckpointsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for numCheckpointsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for numCheckpointsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = numCheckpointsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "numCheckpoints(address)";
            const SELECTOR: [u8; 4] = [111u8, 207u8, 255u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pause()` and selector `0x8456cb59`.
```solidity
function pause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseCall {}
    ///Container type for the return parameters of the [`pause()`](pauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause()";
            const SELECTOR: [u8; 4] = [132u8, 86u8, 203u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pauseEmissions()` and selector `0x6c33bced`.
```solidity
function pauseEmissions() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseEmissionsCall {}
    ///Container type for the return parameters of the [`pauseEmissions()`](pauseEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseEmissionsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseEmissionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: pauseEmissionsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pauseEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseEmissionsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pauseEmissions()";
            const SELECTOR: [u8; 4] = [108u8, 51u8, 188u8, 237u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `paused()` and selector `0x5c975abb`.
```solidity
function paused() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedCall {}
    ///Container type for the return parameters of the [`paused()`](pausedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedCall> for UnderlyingRustTuple<'_> {
                fn from(value: pausedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pausedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pausedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pausedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `permit(address,address,uint256,uint256,uint8,bytes32,bytes32)` and selector `0xd505accf`.
```solidity
function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct permitCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub deadline: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub v: u8,
        #[allow(missing_docs)]
        pub r: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`permit(address,address,uint256,uint256,uint8,bytes32,bytes32)`](permitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct permitReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<permitCall> for UnderlyingRustTuple<'_> {
                fn from(value: permitCall) -> Self {
                    (
                        value.owner,
                        value.spender,
                        value.value,
                        value.deadline,
                        value.v,
                        value.r,
                        value.s,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for permitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        spender: tuple.1,
                        value: tuple.2,
                        deadline: tuple.3,
                        v: tuple.4,
                        r: tuple.5,
                        s: tuple.6,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<permitReturn> for UnderlyingRustTuple<'_> {
                fn from(value: permitReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for permitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for permitCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = permitReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [213u8, 5u8, 172u8, 207u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deadline),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.v),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.r),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address callerConfirmation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub callerConfirmation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.callerConfirmation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        callerConfirmation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callerConfirmation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `resumeEmissions()` and selector `0x359b76fe`.
```solidity
function resumeEmissions() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resumeEmissionsCall {}
    ///Container type for the return parameters of the [`resumeEmissions()`](resumeEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resumeEmissionsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resumeEmissionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: resumeEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for resumeEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resumeEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: resumeEmissionsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resumeEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for resumeEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = resumeEmissionsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "resumeEmissions()";
            const SELECTOR: [u8; 4] = [53u8, 155u8, 118u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeData(bytes)` and selector `0x13beaa5b`.
```solidity
function setBridgeData(bytes memory _bridgeData) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeDataCall {
        #[allow(missing_docs)]
        pub _bridgeData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`setBridgeData(bytes)`](setBridgeDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeDataReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeDataCall) -> Self {
                    (value._bridgeData,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridgeData: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeDataReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeDataReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeDataCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeDataReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeData(bytes)";
            const SELECTOR: [u8; 4] = [19u8, 190u8, 170u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._bridgeData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeProxy(address)` and selector `0xa571e184`.
```solidity
function setBridgeProxy(address _bridgeProxy) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeProxyCall {
        #[allow(missing_docs)]
        pub _bridgeProxy: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setBridgeProxy(address)`](setBridgeProxyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeProxyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeProxyCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeProxyCall) -> Self {
                    (value._bridgeProxy,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeProxyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridgeProxy: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeProxyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeProxyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBridgeProxyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeProxyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeProxyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeProxy(address)";
            const SELECTOR: [u8; 4] = [165u8, 113u8, 225u8, 132u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridgeProxy,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setLimits(address,uint256,uint256)` and selector `0xa08d5654`.
```solidity
function setLimits(address _bridge, uint256 _mintingLimit, uint256 _burningLimit) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setLimitsCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _mintingLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _burningLimit: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setLimits(address,uint256,uint256)`](setLimitsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setLimitsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setLimitsCall> for UnderlyingRustTuple<'_> {
                fn from(value: setLimitsCall) -> Self {
                    (value._bridge, value._mintingLimit, value._burningLimit)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setLimitsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _bridge: tuple.0,
                        _mintingLimit: tuple.1,
                        _burningLimit: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setLimitsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setLimitsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setLimitsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setLimitsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setLimitsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setLimits(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [160u8, 141u8, 86u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._mintingLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._burningLimit),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `startEmissions()` and selector `0x1b02f845`.
```solidity
function startEmissions() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startEmissionsCall {}
    ///Container type for the return parameters of the [`startEmissions()`](startEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startEmissionsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startEmissionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: startEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: startEmissionsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for startEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for startEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = startEmissionsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "startEmissions()";
            const SELECTOR: [u8; 4] = [27u8, 2u8, 248u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = supportsInterfaceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `symbol()` and selector `0x95d89b41`.
```solidity
function symbol() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct symbolCall {}
    ///Container type for the return parameters of the [`symbol()`](symbolCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct symbolReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<symbolCall> for UnderlyingRustTuple<'_> {
                fn from(value: symbolCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<symbolReturn> for UnderlyingRustTuple<'_> {
                fn from(value: symbolReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for symbolCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = symbolReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "symbol()";
            const SELECTOR: [u8; 4] = [149u8, 216u8, 155u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `totalEmissionsMinted()` and selector `0xf508e19d`.
```solidity
function totalEmissionsMinted() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalEmissionsMintedCall {}
    ///Container type for the return parameters of the [`totalEmissionsMinted()`](totalEmissionsMintedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalEmissionsMintedReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalEmissionsMintedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: totalEmissionsMintedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for totalEmissionsMintedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalEmissionsMintedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: totalEmissionsMintedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for totalEmissionsMintedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalEmissionsMintedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = totalEmissionsMintedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalEmissionsMinted()";
            const SELECTOR: [u8; 4] = [245u8, 8u8, 225u8, 157u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `totalSupply()` and selector `0x18160ddd`.
```solidity
function totalSupply() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalSupplyCall {}
    ///Container type for the return parameters of the [`totalSupply()`](totalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalSupplyCall> for UnderlyingRustTuple<'_> {
                fn from(value: totalSupplyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalSupplyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: totalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalSupplyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = totalSupplyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalSupply()";
            const SELECTOR: [u8; 4] = [24u8, 22u8, 13u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transfer(address,uint256)` and selector `0xa9059cbb`.
```solidity
function transfer(address to, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`transfer(address,uint256)`](transferCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferCall) -> Self {
                    (value.to, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transfer(address,uint256)";
            const SELECTOR: [u8; 4] = [169u8, 5u8, 156u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferFrom(address,address,uint256)` and selector `0x23b872dd`.
```solidity
function transferFrom(address from, address to, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferFromCall {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`transferFrom(address,address,uint256)`](transferFromCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferFromReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromCall) -> Self {
                    (value.from, value.to, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        to: tuple.1,
                        value: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferFromCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferFromReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferFrom(address,address,uint256)";
            const SELECTOR: [u8; 4] = [35u8, 184u8, 114u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `unpause()` and selector `0x3f4ba83a`.
```solidity
function unpause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseCall {}
    ///Container type for the return parameters of the [`unpause()`](unpauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unpauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unpauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unpause()";
            const SELECTOR: [u8; 4] = [63u8, 75u8, 168u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`SyndicateToken`](self) function calls.
    pub enum SyndicateTokenCalls {
        #[allow(missing_docs)]
        BRIDGE_LIMIT_DURATION(BRIDGE_LIMIT_DURATIONCall),
        #[allow(missing_docs)]
        BRIDGE_MANAGER_ROLE(BRIDGE_MANAGER_ROLECall),
        #[allow(missing_docs)]
        CLOCK_MODE(CLOCK_MODECall),
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        DOMAIN_SEPARATOR(DOMAIN_SEPARATORCall),
        #[allow(missing_docs)]
        EMISSIONS_MANAGER_ROLE(EMISSIONS_MANAGER_ROLECall),
        #[allow(missing_docs)]
        EMISSIONS_SUPPLY(EMISSIONS_SUPPLYCall),
        #[allow(missing_docs)]
        EPOCH_DURATION(EPOCH_DURATIONCall),
        #[allow(missing_docs)]
        INITIAL_MINT_SUPPLY(INITIAL_MINT_SUPPLYCall),
        #[allow(missing_docs)]
        PAUSER_ROLE(PAUSER_ROLECall),
        #[allow(missing_docs)]
        TOTAL_EPOCHS(TOTAL_EPOCHSCall),
        #[allow(missing_docs)]
        TOTAL_SUPPLY(TOTAL_SUPPLYCall),
        #[allow(missing_docs)]
        allowance(allowanceCall),
        #[allow(missing_docs)]
        approve(approveCall),
        #[allow(missing_docs)]
        authorizedBridges(authorizedBridgesCall),
        #[allow(missing_docs)]
        balanceOf(balanceOfCall),
        #[allow(missing_docs)]
        bridgeData(bridgeDataCall),
        #[allow(missing_docs)]
        bridgeLimits(bridgeLimitsCall),
        #[allow(missing_docs)]
        bridgeProxy(bridgeProxyCall),
        #[allow(missing_docs)]
        burn(burnCall),
        #[allow(missing_docs)]
        burningCurrentLimitOf(burningCurrentLimitOfCall),
        #[allow(missing_docs)]
        burningMaxLimitOf(burningMaxLimitOfCall),
        #[allow(missing_docs)]
        checkpoints(checkpointsCall),
        #[allow(missing_docs)]
        clock(clockCall),
        #[allow(missing_docs)]
        currentEpoch(currentEpochCall),
        #[allow(missing_docs)]
        decimals(decimalsCall),
        #[allow(missing_docs)]
        delegate(delegateCall),
        #[allow(missing_docs)]
        delegateBySig(delegateBySigCall),
        #[allow(missing_docs)]
        delegates(delegatesCall),
        #[allow(missing_docs)]
        eip712Domain(eip712DomainCall),
        #[allow(missing_docs)]
        emissionSchedule(emissionScheduleCall),
        #[allow(missing_docs)]
        emissionsActive(emissionsActiveCall),
        #[allow(missing_docs)]
        emissionsEnded(emissionsEndedCall),
        #[allow(missing_docs)]
        emissionsStartTime(emissionsStartTimeCall),
        #[allow(missing_docs)]
        emissionsStarted(emissionsStartedCall),
        #[allow(missing_docs)]
        getBridgeConfiguration(getBridgeConfigurationCall),
        #[allow(missing_docs)]
        getBridgeInfo(getBridgeInfoCall),
        #[allow(missing_docs)]
        getBridgeUtilization(getBridgeUtilizationCall),
        #[allow(missing_docs)]
        getCurrentEpochInfo(getCurrentEpochInfoCall),
        #[allow(missing_docs)]
        getCurrentTotalSupply(getCurrentTotalSupplyCall),
        #[allow(missing_docs)]
        getEmissionSchedule(getEmissionScheduleCall),
        #[allow(missing_docs)]
        getPastTotalSupply(getPastTotalSupplyCall),
        #[allow(missing_docs)]
        getPastVotes(getPastVotesCall),
        #[allow(missing_docs)]
        getPastVotingPower(getPastVotingPowerCall),
        #[allow(missing_docs)]
        getRemainingEmissions(getRemainingEmissionsCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        getVotes(getVotesCall),
        #[allow(missing_docs)]
        getVotingPower(getVotingPowerCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        isBridge(isBridgeCall),
        #[allow(missing_docs)]
        mint(mintCall),
        #[allow(missing_docs)]
        mintEmission(mintEmissionCall),
        #[allow(missing_docs)]
        mintingCurrentLimitOf(mintingCurrentLimitOfCall),
        #[allow(missing_docs)]
        mintingMaxLimitOf(mintingMaxLimitOfCall),
        #[allow(missing_docs)]
        name(nameCall),
        #[allow(missing_docs)]
        nonces(noncesCall),
        #[allow(missing_docs)]
        numCheckpoints(numCheckpointsCall),
        #[allow(missing_docs)]
        pause(pauseCall),
        #[allow(missing_docs)]
        pauseEmissions(pauseEmissionsCall),
        #[allow(missing_docs)]
        paused(pausedCall),
        #[allow(missing_docs)]
        permit(permitCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        resumeEmissions(resumeEmissionsCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        setBridgeData(setBridgeDataCall),
        #[allow(missing_docs)]
        setBridgeProxy(setBridgeProxyCall),
        #[allow(missing_docs)]
        setLimits(setLimitsCall),
        #[allow(missing_docs)]
        startEmissions(startEmissionsCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
        #[allow(missing_docs)]
        symbol(symbolCall),
        #[allow(missing_docs)]
        totalEmissionsMinted(totalEmissionsMintedCall),
        #[allow(missing_docs)]
        totalSupply(totalSupplyCall),
        #[allow(missing_docs)]
        transfer(transferCall),
        #[allow(missing_docs)]
        transferFrom(transferFromCall),
        #[allow(missing_docs)]
        unpause(unpauseCall),
    }
    #[automatically_derived]
    impl SyndicateTokenCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 255u8, 201u8, 167u8],
            [6u8, 253u8, 222u8, 3u8],
            [7u8, 161u8, 213u8, 250u8],
            [9u8, 94u8, 167u8, 179u8],
            [12u8, 5u8, 248u8, 44u8],
            [19u8, 190u8, 170u8, 91u8],
            [24u8, 22u8, 13u8, 221u8],
            [27u8, 2u8, 248u8, 69u8],
            [34u8, 169u8, 125u8, 156u8],
            [35u8, 184u8, 114u8, 221u8],
            [35u8, 228u8, 96u8, 210u8],
            [36u8, 129u8, 187u8, 92u8],
            [36u8, 138u8, 156u8, 163u8],
            [40u8, 78u8, 19u8, 51u8],
            [47u8, 47u8, 241u8, 93u8],
            [49u8, 60u8, 229u8, 103u8],
            [51u8, 77u8, 11u8, 189u8],
            [53u8, 155u8, 118u8, 254u8],
            [54u8, 68u8, 229u8, 21u8],
            [54u8, 86u8, 138u8, 190u8],
            [58u8, 70u8, 177u8, 168u8],
            [63u8, 75u8, 168u8, 58u8],
            [64u8, 193u8, 15u8, 25u8],
            [68u8, 225u8, 129u8, 170u8],
            [72u8, 176u8, 218u8, 166u8],
            [75u8, 221u8, 54u8, 206u8],
            [75u8, 245u8, 215u8, 233u8],
            [88u8, 124u8, 222u8, 30u8],
            [90u8, 223u8, 0u8, 33u8],
            [92u8, 25u8, 169u8, 92u8],
            [92u8, 151u8, 90u8, 187u8],
            [95u8, 21u8, 195u8, 201u8],
            [101u8, 31u8, 210u8, 104u8],
            [108u8, 51u8, 188u8, 237u8],
            [108u8, 240u8, 22u8, 37u8],
            [111u8, 192u8, 99u8, 190u8],
            [111u8, 207u8, 255u8, 69u8],
            [112u8, 160u8, 130u8, 49u8],
            [114u8, 102u8, 0u8, 206u8],
            [118u8, 103u8, 24u8, 8u8],
            [124u8, 121u8, 12u8, 171u8],
            [126u8, 206u8, 190u8, 0u8],
            [132u8, 86u8, 203u8, 89u8],
            [132u8, 176u8, 25u8, 110u8],
            [142u8, 83u8, 158u8, 140u8],
            [144u8, 45u8, 85u8, 165u8],
            [145u8, 209u8, 72u8, 84u8],
            [145u8, 221u8, 173u8, 244u8],
            [149u8, 216u8, 155u8, 65u8],
            [153u8, 18u8, 125u8, 155u8],
            [153u8, 137u8, 85u8, 211u8],
            [154u8, 178u8, 78u8, 176u8],
            [155u8, 126u8, 246u8, 75u8],
            [157u8, 194u8, 159u8, 172u8],
            [160u8, 141u8, 86u8, 84u8],
            [162u8, 23u8, 253u8, 223u8],
            [163u8, 212u8, 72u8, 91u8],
            [164u8, 215u8, 227u8, 29u8],
            [165u8, 113u8, 225u8, 132u8],
            [167u8, 11u8, 159u8, 12u8],
            [169u8, 5u8, 156u8, 187u8],
            [175u8, 42u8, 166u8, 59u8],
            [176u8, 202u8, 37u8, 62u8],
            [186u8, 188u8, 57u8, 79u8],
            [187u8, 77u8, 68u8, 54u8],
            [192u8, 42u8, 231u8, 84u8],
            [193u8, 235u8, 113u8, 55u8],
            [195u8, 205u8, 165u8, 32u8],
            [213u8, 5u8, 172u8, 207u8],
            [213u8, 71u8, 116u8, 31u8],
            [221u8, 98u8, 237u8, 62u8],
            [227u8, 171u8, 223u8, 203u8],
            [230u8, 58u8, 177u8, 233u8],
            [241u8, 18u8, 126u8, 216u8],
            [245u8, 8u8, 225u8, 157u8],
            [247u8, 94u8, 133u8, 18u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateTokenCalls {
        const NAME: &'static str = "SyndicateTokenCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 76usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::BRIDGE_LIMIT_DURATION(_) => {
                    <BRIDGE_LIMIT_DURATIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::BRIDGE_MANAGER_ROLE(_) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::CLOCK_MODE(_) => {
                    <CLOCK_MODECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DOMAIN_SEPARATOR(_) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSIONS_MANAGER_ROLE(_) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSIONS_SUPPLY(_) => {
                    <EMISSIONS_SUPPLYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EPOCH_DURATION(_) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::INITIAL_MINT_SUPPLY(_) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PAUSER_ROLE(_) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TOTAL_EPOCHS(_) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TOTAL_SUPPLY(_) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::allowance(_) => {
                    <allowanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::approve(_) => <approveCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::authorizedBridges(_) => {
                    <authorizedBridgesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::balanceOf(_) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeData(_) => {
                    <bridgeDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeLimits(_) => {
                    <bridgeLimitsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeProxy(_) => {
                    <bridgeProxyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::burn(_) => <burnCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::burningCurrentLimitOf(_) => {
                    <burningCurrentLimitOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::burningMaxLimitOf(_) => {
                    <burningMaxLimitOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkpoints(_) => {
                    <checkpointsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::clock(_) => <clockCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::currentEpoch(_) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::decimals(_) => <decimalsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::delegate(_) => <delegateCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::delegateBySig(_) => {
                    <delegateBySigCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::delegates(_) => {
                    <delegatesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::eip712Domain(_) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionSchedule(_) => {
                    <emissionScheduleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsActive(_) => {
                    <emissionsActiveCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsEnded(_) => {
                    <emissionsEndedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsStartTime(_) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsStarted(_) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeConfiguration(_) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeInfo(_) => {
                    <getBridgeInfoCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeUtilization(_) => {
                    <getBridgeUtilizationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCurrentEpochInfo(_) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCurrentTotalSupply(_) => {
                    <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getEmissionSchedule(_) => {
                    <getEmissionScheduleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPastTotalSupply(_) => {
                    <getPastTotalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPastVotes(_) => {
                    <getPastVotesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPastVotingPower(_) => {
                    <getPastVotingPowerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRemainingEmissions(_) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getVotes(_) => <getVotesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getVotingPower(_) => {
                    <getVotingPowerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isBridge(_) => <isBridgeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::mint(_) => <mintCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::mintEmission(_) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::mintingCurrentLimitOf(_) => {
                    <mintingCurrentLimitOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::mintingMaxLimitOf(_) => {
                    <mintingMaxLimitOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::name(_) => <nameCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::nonces(_) => <noncesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::numCheckpoints(_) => {
                    <numCheckpointsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pauseEmissions(_) => {
                    <pauseEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::paused(_) => <pausedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::permit(_) => <permitCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::resumeEmissions(_) => {
                    <resumeEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeData(_) => {
                    <setBridgeDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeProxy(_) => {
                    <setBridgeProxyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setLimits(_) => {
                    <setLimitsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::startEmissions(_) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::symbol(_) => <symbolCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::totalEmissionsMinted(_) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::totalSupply(_) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transfer(_) => <transferCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::transferFrom(_) => {
                    <transferFromCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unpause(_) => <unpauseCall as alloy_sol_types::SolCall>::SELECTOR,
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<SyndicateTokenCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn name(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <nameCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::name)
                    }
                    name
                },
                {
                    fn getBridgeConfiguration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getBridgeConfiguration)
                    }
                    getBridgeConfiguration
                },
                {
                    fn approve(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <approveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::approve)
                    }
                    approve
                },
                {
                    fn mintingMaxLimitOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <mintingMaxLimitOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::mintingMaxLimitOf)
                    }
                    mintingMaxLimitOf
                },
                {
                    fn setBridgeData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <setBridgeDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::setBridgeData)
                    }
                    setBridgeData
                },
                {
                    fn totalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <totalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::totalSupply)
                    }
                    totalSupply
                },
                {
                    fn startEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <startEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::startEmissions)
                    }
                    startEmissions
                },
                {
                    fn emissionsActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionsActiveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionsActive)
                    }
                    emissionsActive
                },
                {
                    fn transferFrom(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <transferFromCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::transferFrom)
                    }
                    transferFrom
                },
                {
                    fn getBridgeUtilization(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getBridgeUtilizationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getBridgeUtilization)
                    }
                    getBridgeUtilization
                },
                {
                    fn bridgeData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <bridgeDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::bridgeData)
                    }
                    bridgeData
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn mintEmission(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <mintEmissionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::mintEmission)
                    }
                    mintEmission
                },
                {
                    fn grantRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn decimals(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <decimalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::decimals)
                    }
                    decimals
                },
                {
                    fn emissionSchedule(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionScheduleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionSchedule)
                    }
                    emissionSchedule
                },
                {
                    fn resumeEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <resumeEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::resumeEmissions)
                    }
                    resumeEmissions
                },
                {
                    fn DOMAIN_SEPARATOR(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::DOMAIN_SEPARATOR)
                    }
                    DOMAIN_SEPARATOR
                },
                {
                    fn renounceRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn getPastVotes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getPastVotesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getPastVotes)
                    }
                    getPastVotes
                },
                {
                    fn unpause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::unpause)
                    }
                    unpause
                },
                {
                    fn mint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <mintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::mint)
                    }
                    mint
                },
                {
                    fn bridgeLimits(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <bridgeLimitsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::bridgeLimits)
                    }
                    bridgeLimits
                },
                {
                    fn emissionsStartTime(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionsStartTime)
                    }
                    emissionsStartTime
                },
                {
                    fn getRemainingEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getRemainingEmissions)
                    }
                    getRemainingEmissions
                },
                {
                    fn CLOCK_MODE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <CLOCK_MODECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::CLOCK_MODE)
                    }
                    CLOCK_MODE
                },
                {
                    fn delegates(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <delegatesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::delegates)
                    }
                    delegates
                },
                {
                    fn emissionsStarted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionsStartedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionsStarted)
                    }
                    emissionsStarted
                },
                {
                    fn delegate(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <delegateCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::delegate)
                    }
                    delegate
                },
                {
                    fn paused(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::paused)
                    }
                    paused
                },
                {
                    fn TOTAL_EPOCHS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::TOTAL_EPOCHS)
                    }
                    TOTAL_EPOCHS
                },
                {
                    fn mintingCurrentLimitOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <mintingCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::mintingCurrentLimitOf)
                    }
                    mintingCurrentLimitOf
                },
                {
                    fn pauseEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <pauseEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::pauseEmissions)
                    }
                    pauseEmissions
                },
                {
                    fn EMISSIONS_SUPPLY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EMISSIONS_SUPPLYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EMISSIONS_SUPPLY)
                    }
                    EMISSIONS_SUPPLY
                },
                {
                    fn authorizedBridges(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <authorizedBridgesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::authorizedBridges)
                    }
                    authorizedBridges
                },
                {
                    fn numCheckpoints(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <numCheckpointsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::numCheckpoints)
                    }
                    numCheckpoints
                },
                {
                    fn balanceOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::balanceOf)
                    }
                    balanceOf
                },
                {
                    fn isBridge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <isBridgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::isBridge)
                    }
                    isBridge
                },
                {
                    fn currentEpoch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <currentEpochCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::currentEpoch)
                    }
                    currentEpoch
                },
                {
                    fn getBridgeInfo(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getBridgeInfoCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getBridgeInfo)
                    }
                    getBridgeInfo
                },
                {
                    fn nonces(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <noncesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::nonces)
                    }
                    nonces
                },
                {
                    fn pause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::pause)
                    }
                    pause
                },
                {
                    fn eip712Domain(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <eip712DomainCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::eip712Domain)
                    }
                    eip712Domain
                },
                {
                    fn getPastTotalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getPastTotalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getPastTotalSupply)
                    }
                    getPastTotalSupply
                },
                {
                    fn TOTAL_SUPPLY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::TOTAL_SUPPLY)
                    }
                    TOTAL_SUPPLY
                },
                {
                    fn hasRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn clock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <clockCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::clock)
                    }
                    clock
                },
                {
                    fn symbol(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <symbolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::symbol)
                    }
                    symbol
                },
                {
                    fn BRIDGE_LIMIT_DURATION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <BRIDGE_LIMIT_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::BRIDGE_LIMIT_DURATION)
                    }
                    BRIDGE_LIMIT_DURATION
                },
                {
                    fn burningCurrentLimitOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <burningCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::burningCurrentLimitOf)
                    }
                    burningCurrentLimitOf
                },
                {
                    fn getVotes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getVotesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getVotes)
                    }
                    getVotes
                },
                {
                    fn INITIAL_MINT_SUPPLY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::INITIAL_MINT_SUPPLY)
                    }
                    INITIAL_MINT_SUPPLY
                },
                {
                    fn burn(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <burnCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::burn)
                    }
                    burn
                },
                {
                    fn setLimits(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <setLimitsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::setLimits)
                    }
                    setLimits
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn bridgeProxy(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <bridgeProxyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::bridgeProxy)
                    }
                    bridgeProxy
                },
                {
                    fn emissionsEnded(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionsEndedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionsEnded)
                    }
                    emissionsEnded
                },
                {
                    fn setBridgeProxy(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <setBridgeProxyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::setBridgeProxy)
                    }
                    setBridgeProxy
                },
                {
                    fn EPOCH_DURATION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EPOCH_DURATION)
                    }
                    EPOCH_DURATION
                },
                {
                    fn transfer(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <transferCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::transfer)
                    }
                    transfer
                },
                {
                    fn getEmissionSchedule(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getEmissionScheduleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getEmissionSchedule)
                    }
                    getEmissionSchedule
                },
                {
                    fn getPastVotingPower(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getPastVotingPowerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getPastVotingPower)
                    }
                    getPastVotingPower
                },
                {
                    fn getCurrentEpochInfo(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getCurrentEpochInfo)
                    }
                    getCurrentEpochInfo
                },
                {
                    fn getVotingPower(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getVotingPowerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getVotingPower)
                    }
                    getVotingPower
                },
                {
                    fn getCurrentTotalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getCurrentTotalSupply)
                    }
                    getCurrentTotalSupply
                },
                {
                    fn burningMaxLimitOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <burningMaxLimitOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::burningMaxLimitOf)
                    }
                    burningMaxLimitOf
                },
                {
                    fn delegateBySig(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <delegateBySigCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::delegateBySig)
                    }
                    delegateBySig
                },
                {
                    fn permit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <permitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::permit)
                    }
                    permit
                },
                {
                    fn revokeRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn allowance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <allowanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::allowance)
                    }
                    allowance
                },
                {
                    fn EMISSIONS_MANAGER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EMISSIONS_MANAGER_ROLE)
                    }
                    EMISSIONS_MANAGER_ROLE
                },
                {
                    fn PAUSER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::PAUSER_ROLE)
                    }
                    PAUSER_ROLE
                },
                {
                    fn checkpoints(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <checkpointsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::checkpoints)
                    }
                    checkpoints
                },
                {
                    fn totalEmissionsMinted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::totalEmissionsMinted)
                    }
                    totalEmissionsMinted
                },
                {
                    fn BRIDGE_MANAGER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::BRIDGE_MANAGER_ROLE)
                    }
                    BRIDGE_MANAGER_ROLE
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::BRIDGE_LIMIT_DURATION(inner) => {
                    <BRIDGE_LIMIT_DURATIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BRIDGE_MANAGER_ROLE(inner) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CLOCK_MODE(inner) => {
                    <CLOCK_MODECall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DOMAIN_SEPARATOR(inner) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSIONS_MANAGER_ROLE(inner) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSIONS_SUPPLY(inner) => {
                    <EMISSIONS_SUPPLYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EPOCH_DURATION(inner) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::INITIAL_MINT_SUPPLY(inner) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PAUSER_ROLE(inner) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TOTAL_EPOCHS(inner) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TOTAL_SUPPLY(inner) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::allowance(inner) => {
                    <allowanceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::authorizedBridges(inner) => {
                    <authorizedBridgesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::bridgeData(inner) => {
                    <bridgeDataCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::bridgeLimits(inner) => {
                    <bridgeLimitsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridgeProxy(inner) => {
                    <bridgeProxyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::burn(inner) => {
                    <burnCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::burningCurrentLimitOf(inner) => {
                    <burningCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::burningMaxLimitOf(inner) => {
                    <burningMaxLimitOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkpoints(inner) => {
                    <checkpointsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::clock(inner) => {
                    <clockCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::currentEpoch(inner) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::decimals(inner) => {
                    <decimalsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::delegate(inner) => {
                    <delegateCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::delegateBySig(inner) => {
                    <delegateBySigCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::delegates(inner) => {
                    <delegatesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionSchedule(inner) => {
                    <emissionScheduleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsActive(inner) => {
                    <emissionsActiveCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsEnded(inner) => {
                    <emissionsEndedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsStartTime(inner) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsStarted(inner) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeConfiguration(inner) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeInfo(inner) => {
                    <getBridgeInfoCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeUtilization(inner) => {
                    <getBridgeUtilizationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCurrentEpochInfo(inner) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCurrentTotalSupply(inner) => {
                    <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getEmissionSchedule(inner) => {
                    <getEmissionScheduleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPastTotalSupply(inner) => {
                    <getPastTotalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPastVotes(inner) => {
                    <getPastVotesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPastVotingPower(inner) => {
                    <getPastVotingPowerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRemainingEmissions(inner) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getVotes(inner) => {
                    <getVotesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getVotingPower(inner) => {
                    <getVotingPowerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isBridge(inner) => {
                    <isBridgeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::mint(inner) => {
                    <mintCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::mintEmission(inner) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::mintingCurrentLimitOf(inner) => {
                    <mintingCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::mintingMaxLimitOf(inner) => {
                    <mintingMaxLimitOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::name(inner) => {
                    <nameCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::nonces(inner) => {
                    <noncesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::numCheckpoints(inner) => {
                    <numCheckpointsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pauseEmissions(inner) => {
                    <pauseEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::permit(inner) => {
                    <permitCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::resumeEmissions(inner) => {
                    <resumeEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setBridgeData(inner) => {
                    <setBridgeDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setBridgeProxy(inner) => {
                    <setBridgeProxyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setLimits(inner) => {
                    <setLimitsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::startEmissions(inner) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::symbol(inner) => {
                    <symbolCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::totalEmissionsMinted(inner) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::totalSupply(inner) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transfer(inner) => {
                    <transferCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::BRIDGE_LIMIT_DURATION(inner) => {
                    <BRIDGE_LIMIT_DURATIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BRIDGE_MANAGER_ROLE(inner) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CLOCK_MODE(inner) => {
                    <CLOCK_MODECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DOMAIN_SEPARATOR(inner) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSIONS_MANAGER_ROLE(inner) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSIONS_SUPPLY(inner) => {
                    <EMISSIONS_SUPPLYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EPOCH_DURATION(inner) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::INITIAL_MINT_SUPPLY(inner) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PAUSER_ROLE(inner) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TOTAL_EPOCHS(inner) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TOTAL_SUPPLY(inner) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::allowance(inner) => {
                    <allowanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::authorizedBridges(inner) => {
                    <authorizedBridgesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeData(inner) => {
                    <bridgeDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeLimits(inner) => {
                    <bridgeLimitsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeProxy(inner) => {
                    <bridgeProxyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::burn(inner) => {
                    <burnCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::burningCurrentLimitOf(inner) => {
                    <burningCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::burningMaxLimitOf(inner) => {
                    <burningMaxLimitOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkpoints(inner) => {
                    <checkpointsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::clock(inner) => {
                    <clockCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::currentEpoch(inner) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::decimals(inner) => {
                    <decimalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegate(inner) => {
                    <delegateCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegateBySig(inner) => {
                    <delegateBySigCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegates(inner) => {
                    <delegatesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionSchedule(inner) => {
                    <emissionScheduleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsActive(inner) => {
                    <emissionsActiveCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsEnded(inner) => {
                    <emissionsEndedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsStartTime(inner) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsStarted(inner) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeConfiguration(inner) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeInfo(inner) => {
                    <getBridgeInfoCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeUtilization(inner) => {
                    <getBridgeUtilizationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCurrentEpochInfo(inner) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCurrentTotalSupply(inner) => {
                    <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getEmissionSchedule(inner) => {
                    <getEmissionScheduleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPastTotalSupply(inner) => {
                    <getPastTotalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPastVotes(inner) => {
                    <getPastVotesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPastVotingPower(inner) => {
                    <getPastVotingPowerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRemainingEmissions(inner) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVotes(inner) => {
                    <getVotesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVotingPower(inner) => {
                    <getVotingPowerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::isBridge(inner) => {
                    <isBridgeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mint(inner) => {
                    <mintCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::mintEmission(inner) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mintingCurrentLimitOf(inner) => {
                    <mintingCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mintingMaxLimitOf(inner) => {
                    <mintingMaxLimitOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::name(inner) => {
                    <nameCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::nonces(inner) => {
                    <noncesCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::numCheckpoints(inner) => {
                    <numCheckpointsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pauseEmissions(inner) => {
                    <pauseEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::permit(inner) => {
                    <permitCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::resumeEmissions(inner) => {
                    <resumeEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeData(inner) => {
                    <setBridgeDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeProxy(inner) => {
                    <setBridgeProxyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setLimits(inner) => {
                    <setLimitsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::startEmissions(inner) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::symbol(inner) => {
                    <symbolCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::totalEmissionsMinted(inner) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::totalSupply(inner) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transfer(inner) => {
                    <transferCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`SyndicateToken`](self) custom errors.
    pub enum SyndicateTokenErrors {
        #[allow(missing_docs)]
        AccessControlBadConfirmation(AccessControlBadConfirmation),
        #[allow(missing_docs)]
        AccessControlUnauthorizedAccount(AccessControlUnauthorizedAccount),
        #[allow(missing_docs)]
        AllEmissionsCompleted(AllEmissionsCompleted),
        #[allow(missing_docs)]
        BridgeNotAuthorized(BridgeNotAuthorized),
        #[allow(missing_docs)]
        BridgeNotConfigured(BridgeNotConfigured),
        #[allow(missing_docs)]
        CheckpointUnorderedInsertion(CheckpointUnorderedInsertion),
        #[allow(missing_docs)]
        ECDSAInvalidSignature(ECDSAInvalidSignature),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureLength(ECDSAInvalidSignatureLength),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureS(ECDSAInvalidSignatureS),
        #[allow(missing_docs)]
        ERC20ExceededSafeSupply(ERC20ExceededSafeSupply),
        #[allow(missing_docs)]
        ERC20InsufficientAllowance(ERC20InsufficientAllowance),
        #[allow(missing_docs)]
        ERC20InsufficientBalance(ERC20InsufficientBalance),
        #[allow(missing_docs)]
        ERC20InvalidApprover(ERC20InvalidApprover),
        #[allow(missing_docs)]
        ERC20InvalidReceiver(ERC20InvalidReceiver),
        #[allow(missing_docs)]
        ERC20InvalidSender(ERC20InvalidSender),
        #[allow(missing_docs)]
        ERC20InvalidSpender(ERC20InvalidSpender),
        #[allow(missing_docs)]
        ERC2612ExpiredSignature(ERC2612ExpiredSignature),
        #[allow(missing_docs)]
        ERC2612InvalidSigner(ERC2612InvalidSigner),
        #[allow(missing_docs)]
        ERC5805FutureLookup(ERC5805FutureLookup),
        #[allow(missing_docs)]
        ERC6372InconsistentClock(ERC6372InconsistentClock),
        #[allow(missing_docs)]
        EmissionsAlreadyStarted(EmissionsAlreadyStarted),
        #[allow(missing_docs)]
        EmissionsNotActive(EmissionsNotActive),
        #[allow(missing_docs)]
        EmissionsNotStarted(EmissionsNotStarted),
        #[allow(missing_docs)]
        EnforcedPause(EnforcedPause),
        #[allow(missing_docs)]
        EpochAlreadyMinted(EpochAlreadyMinted),
        #[allow(missing_docs)]
        ExceedsEmissionsSupply(ExceedsEmissionsSupply),
        #[allow(missing_docs)]
        ExpectedPause(ExpectedPause),
        #[allow(missing_docs)]
        InsufficientLimit(InsufficientLimit),
        #[allow(missing_docs)]
        InvalidAccountNonce(InvalidAccountNonce),
        #[allow(missing_docs)]
        InvalidEpoch(InvalidEpoch),
        #[allow(missing_docs)]
        InvalidShortString(InvalidShortString),
        #[allow(missing_docs)]
        SafeCastOverflowedUintDowncast(SafeCastOverflowedUintDowncast),
        #[allow(missing_docs)]
        StringTooLong(StringTooLong),
        #[allow(missing_docs)]
        VotesExpiredSignature(VotesExpiredSignature),
        #[allow(missing_docs)]
        ZeroAddress(ZeroAddress),
        #[allow(missing_docs)]
        ZeroAmount(ZeroAmount),
        #[allow(missing_docs)]
        ZeroGasLimit(ZeroGasLimit),
    }
    #[automatically_derived]
    impl SyndicateTokenErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [28u8, 177u8, 93u8, 38u8],
            [31u8, 42u8, 32u8, 5u8],
            [35u8, 6u8, 78u8, 189u8],
            [37u8, 32u8, 96u8, 29u8],
            [48u8, 90u8, 39u8, 169u8],
            [62u8, 38u8, 127u8, 149u8],
            [69u8, 85u8, 137u8, 44u8],
            [70u8, 131u8, 175u8, 14u8],
            [75u8, 128u8, 14u8, 70u8],
            [98u8, 121u8, 19u8, 2u8],
            [102u8, 151u8, 178u8, 50u8],
            [102u8, 191u8, 38u8, 116u8],
            [109u8, 252u8, 198u8, 80u8],
            [111u8, 240u8, 113u8, 64u8],
            [113u8, 210u8, 123u8, 122u8],
            [114u8, 86u8, 123u8, 100u8],
            [117u8, 45u8, 136u8, 192u8],
            [118u8, 20u8, 145u8, 122u8],
            [136u8, 46u8, 236u8, 18u8],
            [141u8, 252u8, 32u8, 43u8],
            [143u8, 152u8, 64u8, 65u8],
            [148u8, 40u8, 13u8, 98u8],
            [150u8, 198u8, 253u8, 30u8],
            [179u8, 81u8, 43u8, 12u8],
            [213u8, 178u8, 91u8, 99u8],
            [215u8, 139u8, 206u8, 12u8],
            [217u8, 46u8, 35u8, 61u8],
            [217u8, 60u8, 6u8, 101u8],
            [224u8, 133u8, 210u8, 43u8],
            [226u8, 81u8, 125u8, 63u8],
            [228u8, 80u8, 211u8, 140u8],
            [230u8, 2u8, 223u8, 5u8],
            [236u8, 68u8, 47u8, 5u8],
            [236u8, 211u8, 248u8, 30u8],
            [246u8, 69u8, 238u8, 223u8],
            [251u8, 143u8, 65u8, 178u8],
            [252u8, 230u8, 152u8, 247u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateTokenErrors {
        const NAME: &'static str = "SyndicateTokenErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 37usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccessControlBadConfirmation(_) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AccessControlUnauthorizedAccount(_) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AllEmissionsCompleted(_) => {
                    <AllEmissionsCompleted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BridgeNotAuthorized(_) => {
                    <BridgeNotAuthorized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BridgeNotConfigured(_) => {
                    <BridgeNotConfigured as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CheckpointUnorderedInsertion(_) => {
                    <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignature(_) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureLength(_) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureS(_) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20ExceededSafeSupply(_) => {
                    <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InsufficientAllowance(_) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InsufficientBalance(_) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidApprover(_) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidReceiver(_) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidSender(_) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidSpender(_) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC2612ExpiredSignature(_) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC2612InvalidSigner(_) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC5805FutureLookup(_) => {
                    <ERC5805FutureLookup as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC6372InconsistentClock(_) => {
                    <ERC6372InconsistentClock as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionsAlreadyStarted(_) => {
                    <EmissionsAlreadyStarted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionsNotActive(_) => {
                    <EmissionsNotActive as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionsNotStarted(_) => {
                    <EmissionsNotStarted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EnforcedPause(_) => {
                    <EnforcedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EpochAlreadyMinted(_) => {
                    <EpochAlreadyMinted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExceedsEmissionsSupply(_) => {
                    <ExceedsEmissionsSupply as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExpectedPause(_) => {
                    <ExpectedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientLimit(_) => {
                    <InsufficientLimit as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidAccountNonce(_) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidEpoch(_) => {
                    <InvalidEpoch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidShortString(_) => {
                    <InvalidShortString as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SafeCastOverflowedUintDowncast(_) => {
                    <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::SELECTOR
                }
                Self::StringTooLong(_) => {
                    <StringTooLong as alloy_sol_types::SolError>::SELECTOR
                }
                Self::VotesExpiredSignature(_) => {
                    <VotesExpiredSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAddress(_) => {
                    <ZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAmount(_) => {
                    <ZeroAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroGasLimit(_) => {
                    <ZeroGasLimit as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<SyndicateTokenErrors>] = &[
                {
                    fn ERC20ExceededSafeSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20ExceededSafeSupply)
                    }
                    ERC20ExceededSafeSupply
                },
                {
                    fn ZeroAmount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ZeroAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ZeroAmount)
                    }
                    ZeroAmount
                },
                {
                    fn ExceedsEmissionsSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ExceedsEmissionsSupply as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ExceedsEmissionsSupply)
                    }
                    ExceedsEmissionsSupply
                },
                {
                    fn CheckpointUnorderedInsertion(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::CheckpointUnorderedInsertion)
                    }
                    CheckpointUnorderedInsertion
                },
                {
                    fn StringTooLong(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <StringTooLong as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::StringTooLong)
                    }
                    StringTooLong
                },
                {
                    fn ZeroGasLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ZeroGasLimit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ZeroGasLimit)
                    }
                    ZeroGasLimit
                },
                {
                    fn AllEmissionsCompleted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <AllEmissionsCompleted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::AllEmissionsCompleted)
                    }
                    AllEmissionsCompleted
                },
                {
                    fn VotesExpiredSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <VotesExpiredSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::VotesExpiredSignature)
                    }
                    VotesExpiredSignature
                },
                {
                    fn ERC2612InvalidSigner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC2612InvalidSigner)
                    }
                    ERC2612InvalidSigner
                },
                {
                    fn ERC2612ExpiredSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC2612ExpiredSignature)
                    }
                    ERC2612ExpiredSignature
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::AccessControlBadConfirmation)
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn EmissionsNotActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <EmissionsNotActive as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::EmissionsNotActive)
                    }
                    EmissionsNotActive
                },
                {
                    fn SafeCastOverflowedUintDowncast(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::SafeCastOverflowedUintDowncast)
                    }
                    SafeCastOverflowedUintDowncast
                },
                {
                    fn ERC6372InconsistentClock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC6372InconsistentClock as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC6372InconsistentClock)
                    }
                    ERC6372InconsistentClock
                },
                {
                    fn EmissionsAlreadyStarted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <EmissionsAlreadyStarted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::EmissionsAlreadyStarted)
                    }
                    EmissionsAlreadyStarted
                },
                {
                    fn InsufficientLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <InsufficientLimit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::InsufficientLimit)
                    }
                    InsufficientLimit
                },
                {
                    fn InvalidAccountNonce(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <InvalidAccountNonce as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::InvalidAccountNonce)
                    }
                    InvalidAccountNonce
                },
                {
                    fn BridgeNotConfigured(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <BridgeNotConfigured as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::BridgeNotConfigured)
                    }
                    BridgeNotConfigured
                },
                {
                    fn BridgeNotAuthorized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <BridgeNotAuthorized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::BridgeNotAuthorized)
                    }
                    BridgeNotAuthorized
                },
                {
                    fn ExpectedPause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ExpectedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ExpectedPause)
                    }
                    ExpectedPause
                },
                {
                    fn EmissionsNotStarted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <EmissionsNotStarted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::EmissionsNotStarted)
                    }
                    EmissionsNotStarted
                },
                {
                    fn ERC20InvalidSpender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InvalidSpender)
                    }
                    ERC20InvalidSpender
                },
                {
                    fn ERC20InvalidSender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InvalidSender as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InvalidSender)
                    }
                    ERC20InvalidSender
                },
                {
                    fn InvalidShortString(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <InvalidShortString as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::InvalidShortString)
                    }
                    InvalidShortString
                },
                {
                    fn InvalidEpoch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <InvalidEpoch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::InvalidEpoch)
                    }
                    InvalidEpoch
                },
                {
                    fn ECDSAInvalidSignatureS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ECDSAInvalidSignatureS)
                    }
                    ECDSAInvalidSignatureS
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn EnforcedPause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <EnforcedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::EnforcedPause)
                    }
                    EnforcedPause
                },
                {
                    fn EpochAlreadyMinted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <EpochAlreadyMinted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::EpochAlreadyMinted)
                    }
                    EpochAlreadyMinted
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::AccessControlUnauthorizedAccount)
                    }
                    AccessControlUnauthorizedAccount
                },
                {
                    fn ERC20InsufficientBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InsufficientBalance)
                    }
                    ERC20InsufficientBalance
                },
                {
                    fn ERC20InvalidApprover(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InvalidApprover)
                    }
                    ERC20InvalidApprover
                },
                {
                    fn ERC20InvalidReceiver(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InvalidReceiver)
                    }
                    ERC20InvalidReceiver
                },
                {
                    fn ERC5805FutureLookup(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC5805FutureLookup as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC5805FutureLookup)
                    }
                    ERC5805FutureLookup
                },
                {
                    fn ECDSAInvalidSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ECDSAInvalidSignature)
                    }
                    ECDSAInvalidSignature
                },
                {
                    fn ERC20InsufficientAllowance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InsufficientAllowance)
                    }
                    ERC20InsufficientAllowance
                },
                {
                    fn ECDSAInvalidSignatureLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ECDSAInvalidSignatureLength)
                    }
                    ECDSAInvalidSignatureLength
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AllEmissionsCompleted(inner) => {
                    <AllEmissionsCompleted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BridgeNotAuthorized(inner) => {
                    <BridgeNotAuthorized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BridgeNotConfigured(inner) => {
                    <BridgeNotConfigured as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CheckpointUnorderedInsertion(inner) => {
                    <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20ExceededSafeSupply(inner) => {
                    <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InsufficientAllowance(inner) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InsufficientBalance(inner) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidApprover(inner) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidReceiver(inner) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidSender(inner) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidSpender(inner) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC2612ExpiredSignature(inner) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC2612InvalidSigner(inner) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC5805FutureLookup(inner) => {
                    <ERC5805FutureLookup as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC6372InconsistentClock(inner) => {
                    <ERC6372InconsistentClock as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionsAlreadyStarted(inner) => {
                    <EmissionsAlreadyStarted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionsNotActive(inner) => {
                    <EmissionsNotActive as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionsNotStarted(inner) => {
                    <EmissionsNotStarted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EpochAlreadyMinted(inner) => {
                    <EpochAlreadyMinted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ExceedsEmissionsSupply(inner) => {
                    <ExceedsEmissionsSupply as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InsufficientLimit(inner) => {
                    <InsufficientLimit as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidAccountNonce(inner) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidEpoch(inner) => {
                    <InvalidEpoch as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidShortString(inner) => {
                    <InvalidShortString as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SafeCastOverflowedUintDowncast(inner) => {
                    <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::StringTooLong(inner) => {
                    <StringTooLong as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::VotesExpiredSignature(inner) => {
                    <VotesExpiredSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ZeroGasLimit(inner) => {
                    <ZeroGasLimit as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AllEmissionsCompleted(inner) => {
                    <AllEmissionsCompleted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BridgeNotAuthorized(inner) => {
                    <BridgeNotAuthorized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BridgeNotConfigured(inner) => {
                    <BridgeNotConfigured as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CheckpointUnorderedInsertion(inner) => {
                    <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20ExceededSafeSupply(inner) => {
                    <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InsufficientAllowance(inner) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InsufficientBalance(inner) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidApprover(inner) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidReceiver(inner) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidSender(inner) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidSpender(inner) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC2612ExpiredSignature(inner) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC2612InvalidSigner(inner) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC5805FutureLookup(inner) => {
                    <ERC5805FutureLookup as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC6372InconsistentClock(inner) => {
                    <ERC6372InconsistentClock as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionsAlreadyStarted(inner) => {
                    <EmissionsAlreadyStarted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionsNotActive(inner) => {
                    <EmissionsNotActive as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionsNotStarted(inner) => {
                    <EmissionsNotStarted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EpochAlreadyMinted(inner) => {
                    <EpochAlreadyMinted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExceedsEmissionsSupply(inner) => {
                    <ExceedsEmissionsSupply as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientLimit(inner) => {
                    <InsufficientLimit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidAccountNonce(inner) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidEpoch(inner) => {
                    <InvalidEpoch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidShortString(inner) => {
                    <InvalidShortString as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SafeCastOverflowedUintDowncast(inner) => {
                    <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::StringTooLong(inner) => {
                    <StringTooLong as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::VotesExpiredSignature(inner) => {
                    <VotesExpiredSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::ZeroGasLimit(inner) => {
                    <ZeroGasLimit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`SyndicateToken`](self) events.
    pub enum SyndicateTokenEvents {
        #[allow(missing_docs)]
        Approval(Approval),
        #[allow(missing_docs)]
        BridgeAuthorized(BridgeAuthorized),
        #[allow(missing_docs)]
        BridgeDataUpdated(BridgeDataUpdated),
        #[allow(missing_docs)]
        BridgeDeauthorized(BridgeDeauthorized),
        #[allow(missing_docs)]
        BridgeLimitsSet(BridgeLimitsSet),
        #[allow(missing_docs)]
        BridgeProxyUpdated(BridgeProxyUpdated),
        #[allow(missing_docs)]
        DelegateChanged(DelegateChanged),
        #[allow(missing_docs)]
        DelegateVotesChanged(DelegateVotesChanged),
        #[allow(missing_docs)]
        EIP712DomainChanged(EIP712DomainChanged),
        #[allow(missing_docs)]
        EmissionMinted(EmissionMinted),
        #[allow(missing_docs)]
        EmissionsPaused(EmissionsPaused),
        #[allow(missing_docs)]
        EmissionsResumed(EmissionsResumed),
        #[allow(missing_docs)]
        EmissionsStarted(EmissionsStarted),
        #[allow(missing_docs)]
        Paused(Paused),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
        #[allow(missing_docs)]
        Transfer(Transfer),
        #[allow(missing_docs)]
        Unpaused(Unpaused),
    }
    #[automatically_derived]
    impl SyndicateTokenEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                2u8,
                194u8,
                240u8,
                186u8,
                21u8,
                176u8,
                63u8,
                136u8,
                177u8,
                143u8,
                72u8,
                50u8,
                96u8,
                154u8,
                24u8,
                207u8,
                53u8,
                252u8,
                107u8,
                63u8,
                69u8,
                70u8,
                169u8,
                153u8,
                32u8,
                118u8,
                215u8,
                69u8,
                61u8,
                19u8,
                52u8,
                168u8,
            ],
            [
                7u8,
                1u8,
                91u8,
                106u8,
                159u8,
                5u8,
                145u8,
                49u8,
                72u8,
                253u8,
                95u8,
                173u8,
                223u8,
                42u8,
                204u8,
                151u8,
                8u8,
                243u8,
                5u8,
                147u8,
                127u8,
                48u8,
                114u8,
                202u8,
                43u8,
                75u8,
                70u8,
                250u8,
                165u8,
                208u8,
                137u8,
                139u8,
            ],
            [
                10u8,
                99u8,
                135u8,
                201u8,
                234u8,
                54u8,
                40u8,
                184u8,
                138u8,
                99u8,
                59u8,
                180u8,
                243u8,
                177u8,
                81u8,
                119u8,
                15u8,
                112u8,
                8u8,
                81u8,
                23u8,
                161u8,
                95u8,
                155u8,
                243u8,
                120u8,
                124u8,
                218u8,
                83u8,
                241u8,
                61u8,
                49u8,
            ],
            [
                17u8,
                148u8,
                176u8,
                52u8,
                207u8,
                169u8,
                171u8,
                88u8,
                7u8,
                73u8,
                74u8,
                29u8,
                92u8,
                102u8,
                125u8,
                139u8,
                14u8,
                110u8,
                151u8,
                243u8,
                136u8,
                136u8,
                116u8,
                42u8,
                163u8,
                135u8,
                26u8,
                50u8,
                32u8,
                52u8,
                17u8,
                96u8,
            ],
            [
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ],
            [
                49u8,
                52u8,
                232u8,
                162u8,
                230u8,
                217u8,
                126u8,
                146u8,
                154u8,
                126u8,
                84u8,
                1u8,
                30u8,
                165u8,
                72u8,
                93u8,
                125u8,
                25u8,
                109u8,
                213u8,
                240u8,
                186u8,
                77u8,
                78u8,
                249u8,
                88u8,
                3u8,
                232u8,
                227u8,
                252u8,
                37u8,
                127u8,
            ],
            [
                52u8,
                183u8,
                61u8,
                12u8,
                150u8,
                233u8,
                255u8,
                77u8,
                83u8,
                17u8,
                67u8,
                72u8,
                23u8,
                200u8,
                236u8,
                201u8,
                48u8,
                231u8,
                210u8,
                120u8,
                44u8,
                91u8,
                222u8,
                46u8,
                121u8,
                220u8,
                68u8,
                176u8,
                89u8,
                103u8,
                85u8,
                187u8,
            ],
            [
                74u8,
                121u8,
                42u8,
                11u8,
                228u8,
                43u8,
                86u8,
                114u8,
                250u8,
                164u8,
                1u8,
                41u8,
                252u8,
                100u8,
                105u8,
                7u8,
                36u8,
                144u8,
                119u8,
                92u8,
                168u8,
                211u8,
                195u8,
                78u8,
                133u8,
                45u8,
                77u8,
                85u8,
                211u8,
                167u8,
                53u8,
                169u8,
            ],
            [
                93u8,
                185u8,
                238u8,
                10u8,
                73u8,
                91u8,
                242u8,
                230u8,
                255u8,
                156u8,
                145u8,
                167u8,
                131u8,
                76u8,
                27u8,
                164u8,
                253u8,
                210u8,
                68u8,
                165u8,
                232u8,
                170u8,
                78u8,
                83u8,
                123u8,
                211u8,
                138u8,
                234u8,
                228u8,
                176u8,
                115u8,
                170u8,
            ],
            [
                98u8,
                231u8,
                140u8,
                234u8,
                1u8,
                190u8,
                227u8,
                32u8,
                205u8,
                78u8,
                66u8,
                2u8,
                112u8,
                181u8,
                234u8,
                116u8,
                0u8,
                13u8,
                17u8,
                176u8,
                201u8,
                247u8,
                71u8,
                84u8,
                235u8,
                219u8,
                252u8,
                84u8,
                75u8,
                5u8,
                162u8,
                88u8,
            ],
            [
                108u8,
                242u8,
                132u8,
                57u8,
                162u8,
                218u8,
                171u8,
                27u8,
                38u8,
                80u8,
                151u8,
                34u8,
                114u8,
                18u8,
                165u8,
                183u8,
                30u8,
                10u8,
                118u8,
                249u8,
                237u8,
                133u8,
                227u8,
                248u8,
                21u8,
                181u8,
                166u8,
                195u8,
                226u8,
                24u8,
                235u8,
                127u8,
            ],
            [
                115u8,
                165u8,
                252u8,
                96u8,
                170u8,
                254u8,
                236u8,
                143u8,
                19u8,
                154u8,
                242u8,
                45u8,
                152u8,
                230u8,
                33u8,
                64u8,
                226u8,
                206u8,
                145u8,
                77u8,
                31u8,
                21u8,
                92u8,
                105u8,
                43u8,
                66u8,
                119u8,
                87u8,
                195u8,
                228u8,
                1u8,
                76u8,
            ],
            [
                140u8,
                91u8,
                225u8,
                229u8,
                235u8,
                236u8,
                125u8,
                91u8,
                209u8,
                79u8,
                113u8,
                66u8,
                125u8,
                30u8,
                132u8,
                243u8,
                221u8,
                3u8,
                20u8,
                192u8,
                247u8,
                178u8,
                41u8,
                30u8,
                91u8,
                32u8,
                10u8,
                200u8,
                199u8,
                195u8,
                185u8,
                37u8,
            ],
            [
                170u8,
                128u8,
                125u8,
                10u8,
                191u8,
                48u8,
                217u8,
                25u8,
                104u8,
                199u8,
                71u8,
                140u8,
                102u8,
                182u8,
                216u8,
                37u8,
                33u8,
                161u8,
                6u8,
                175u8,
                19u8,
                237u8,
                160u8,
                54u8,
                226u8,
                3u8,
                109u8,
                169u8,
                175u8,
                22u8,
                137u8,
                88u8,
            ],
            [
                185u8,
                162u8,
                8u8,
                132u8,
                38u8,
                240u8,
                59u8,
                48u8,
                168u8,
                28u8,
                6u8,
                66u8,
                128u8,
                148u8,
                251u8,
                250u8,
                158u8,
                38u8,
                146u8,
                115u8,
                155u8,
                50u8,
                65u8,
                175u8,
                107u8,
                154u8,
                177u8,
                218u8,
                75u8,
                85u8,
                70u8,
                190u8,
            ],
            [
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ],
            [
                221u8,
                242u8,
                82u8,
                173u8,
                27u8,
                226u8,
                200u8,
                155u8,
                105u8,
                194u8,
                176u8,
                104u8,
                252u8,
                55u8,
                141u8,
                170u8,
                149u8,
                43u8,
                167u8,
                241u8,
                99u8,
                196u8,
                161u8,
                22u8,
                40u8,
                245u8,
                90u8,
                77u8,
                245u8,
                35u8,
                179u8,
                239u8,
            ],
            [
                222u8,
                194u8,
                186u8,
                205u8,
                210u8,
                240u8,
                91u8,
                89u8,
                222u8,
                52u8,
                218u8,
                155u8,
                82u8,
                61u8,
                255u8,
                139u8,
                228u8,
                46u8,
                94u8,
                56u8,
                232u8,
                24u8,
                200u8,
                47u8,
                219u8,
                11u8,
                174u8,
                119u8,
                67u8,
                135u8,
                167u8,
                36u8,
            ],
            [
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for SyndicateTokenEvents {
        const NAME: &'static str = "SyndicateTokenEvents";
        const COUNT: usize = 19usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Approval as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Approval as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Approval)
                }
                Some(<BridgeAuthorized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BridgeAuthorized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeAuthorized)
                }
                Some(
                    <BridgeDataUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeDataUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeDataUpdated)
                }
                Some(
                    <BridgeDeauthorized as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeDeauthorized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeDeauthorized)
                }
                Some(<BridgeLimitsSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BridgeLimitsSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeLimitsSet)
                }
                Some(
                    <BridgeProxyUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeProxyUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeProxyUpdated)
                }
                Some(<DelegateChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <DelegateChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DelegateChanged)
                }
                Some(
                    <DelegateVotesChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DelegateVotesChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DelegateVotesChanged)
                }
                Some(
                    <EIP712DomainChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EIP712DomainChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EIP712DomainChanged)
                }
                Some(<EmissionMinted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionMinted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionMinted)
                }
                Some(<EmissionsPaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionsPaused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionsPaused)
                }
                Some(<EmissionsResumed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionsResumed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionsResumed)
                }
                Some(<EmissionsStarted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionsStarted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionsStarted)
                }
                Some(<Paused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Paused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Paused)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleRevoked)
                }
                Some(<Transfer as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Transfer as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Transfer)
                }
                Some(<Unpaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Unpaused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Unpaused)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for SyndicateTokenEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeAuthorized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeDataUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeDeauthorized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeLimitsSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeProxyUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DelegateChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DelegateVotesChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EIP712DomainChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionMinted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionsPaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionsResumed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionsStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeAuthorized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeDataUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeDeauthorized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeLimitsSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeProxyUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DelegateChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DelegateVotesChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EIP712DomainChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionMinted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionsPaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionsResumed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionsStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`SyndicateToken`](self) contract instance.

See the [wrapper's documentation](`SyndicateTokenInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> SyndicateTokenInstance<T, P, N> {
        SyndicateTokenInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        defaultAdmin: alloy::sol_types::private::Address,
        syndFoundationAddress: alloy::sol_types::private::Address,
        emissionsManager: alloy::sol_types::private::Address,
        pauser: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<SyndicateTokenInstance<T, P, N>>,
    > {
        SyndicateTokenInstance::<
            T,
            P,
            N,
        >::deploy(
            provider,
            defaultAdmin,
            syndFoundationAddress,
            emissionsManager,
            pauser,
        )
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        defaultAdmin: alloy::sol_types::private::Address,
        syndFoundationAddress: alloy::sol_types::private::Address,
        emissionsManager: alloy::sol_types::private::Address,
        pauser: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        SyndicateTokenInstance::<
            T,
            P,
            N,
        >::deploy_builder(
            provider,
            defaultAdmin,
            syndFoundationAddress,
            emissionsManager,
            pauser,
        )
    }
    /**A [`SyndicateToken`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`SyndicateToken`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct SyndicateTokenInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for SyndicateTokenInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("SyndicateTokenInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`SyndicateToken`](self) contract instance.

See the [wrapper's documentation](`SyndicateTokenInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            defaultAdmin: alloy::sol_types::private::Address,
            syndFoundationAddress: alloy::sol_types::private::Address,
            emissionsManager: alloy::sol_types::private::Address,
            pauser: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<SyndicateTokenInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                defaultAdmin,
                syndFoundationAddress,
                emissionsManager,
                pauser,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            defaultAdmin: alloy::sol_types::private::Address,
            syndFoundationAddress: alloy::sol_types::private::Address,
            emissionsManager: alloy::sol_types::private::Address,
            pauser: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            defaultAdmin,
                            syndFoundationAddress,
                            emissionsManager,
                            pauser,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> SyndicateTokenInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> SyndicateTokenInstance<T, P, N> {
            SyndicateTokenInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`BRIDGE_LIMIT_DURATION`] function.
        pub fn BRIDGE_LIMIT_DURATION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BRIDGE_LIMIT_DURATIONCall, N> {
            self.call_builder(&BRIDGE_LIMIT_DURATIONCall {})
        }
        ///Creates a new call builder for the [`BRIDGE_MANAGER_ROLE`] function.
        pub fn BRIDGE_MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BRIDGE_MANAGER_ROLECall, N> {
            self.call_builder(&BRIDGE_MANAGER_ROLECall {})
        }
        ///Creates a new call builder for the [`CLOCK_MODE`] function.
        pub fn CLOCK_MODE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, CLOCK_MODECall, N> {
            self.call_builder(&CLOCK_MODECall {})
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall {})
        }
        ///Creates a new call builder for the [`DOMAIN_SEPARATOR`] function.
        pub fn DOMAIN_SEPARATOR(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DOMAIN_SEPARATORCall, N> {
            self.call_builder(&DOMAIN_SEPARATORCall {})
        }
        ///Creates a new call builder for the [`EMISSIONS_MANAGER_ROLE`] function.
        pub fn EMISSIONS_MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSIONS_MANAGER_ROLECall, N> {
            self.call_builder(&EMISSIONS_MANAGER_ROLECall {})
        }
        ///Creates a new call builder for the [`EMISSIONS_SUPPLY`] function.
        pub fn EMISSIONS_SUPPLY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSIONS_SUPPLYCall, N> {
            self.call_builder(&EMISSIONS_SUPPLYCall {})
        }
        ///Creates a new call builder for the [`EPOCH_DURATION`] function.
        pub fn EPOCH_DURATION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EPOCH_DURATIONCall, N> {
            self.call_builder(&EPOCH_DURATIONCall {})
        }
        ///Creates a new call builder for the [`INITIAL_MINT_SUPPLY`] function.
        pub fn INITIAL_MINT_SUPPLY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, INITIAL_MINT_SUPPLYCall, N> {
            self.call_builder(&INITIAL_MINT_SUPPLYCall {})
        }
        ///Creates a new call builder for the [`PAUSER_ROLE`] function.
        pub fn PAUSER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PAUSER_ROLECall, N> {
            self.call_builder(&PAUSER_ROLECall {})
        }
        ///Creates a new call builder for the [`TOTAL_EPOCHS`] function.
        pub fn TOTAL_EPOCHS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, TOTAL_EPOCHSCall, N> {
            self.call_builder(&TOTAL_EPOCHSCall {})
        }
        ///Creates a new call builder for the [`TOTAL_SUPPLY`] function.
        pub fn TOTAL_SUPPLY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, TOTAL_SUPPLYCall, N> {
            self.call_builder(&TOTAL_SUPPLYCall {})
        }
        ///Creates a new call builder for the [`allowance`] function.
        pub fn allowance(
            &self,
            owner: alloy::sol_types::private::Address,
            spender: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, allowanceCall, N> {
            self.call_builder(&allowanceCall { owner, spender })
        }
        ///Creates a new call builder for the [`approve`] function.
        pub fn approve(
            &self,
            spender: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, approveCall, N> {
            self.call_builder(&approveCall { spender, value })
        }
        ///Creates a new call builder for the [`authorizedBridges`] function.
        pub fn authorizedBridges(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, authorizedBridgesCall, N> {
            self.call_builder(&authorizedBridgesCall { _0 })
        }
        ///Creates a new call builder for the [`balanceOf`] function.
        pub fn balanceOf(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, balanceOfCall, N> {
            self.call_builder(&balanceOfCall { account })
        }
        ///Creates a new call builder for the [`bridgeData`] function.
        pub fn bridgeData(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeDataCall, N> {
            self.call_builder(&bridgeDataCall {})
        }
        ///Creates a new call builder for the [`bridgeLimits`] function.
        pub fn bridgeLimits(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeLimitsCall, N> {
            self.call_builder(&bridgeLimitsCall { _0 })
        }
        ///Creates a new call builder for the [`bridgeProxy`] function.
        pub fn bridgeProxy(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeProxyCall, N> {
            self.call_builder(&bridgeProxyCall {})
        }
        ///Creates a new call builder for the [`burn`] function.
        pub fn burn(
            &self,
            _user: alloy::sol_types::private::Address,
            _amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, burnCall, N> {
            self.call_builder(&burnCall { _user, _amount })
        }
        ///Creates a new call builder for the [`burningCurrentLimitOf`] function.
        pub fn burningCurrentLimitOf(
            &self,
            _bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, burningCurrentLimitOfCall, N> {
            self.call_builder(
                &burningCurrentLimitOfCall {
                    _bridge,
                },
            )
        }
        ///Creates a new call builder for the [`burningMaxLimitOf`] function.
        pub fn burningMaxLimitOf(
            &self,
            _bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, burningMaxLimitOfCall, N> {
            self.call_builder(&burningMaxLimitOfCall { _bridge })
        }
        ///Creates a new call builder for the [`checkpoints`] function.
        pub fn checkpoints(
            &self,
            account: alloy::sol_types::private::Address,
            pos: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkpointsCall, N> {
            self.call_builder(&checkpointsCall { account, pos })
        }
        ///Creates a new call builder for the [`clock`] function.
        pub fn clock(&self) -> alloy_contract::SolCallBuilder<T, &P, clockCall, N> {
            self.call_builder(&clockCall {})
        }
        ///Creates a new call builder for the [`currentEpoch`] function.
        pub fn currentEpoch(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, currentEpochCall, N> {
            self.call_builder(&currentEpochCall {})
        }
        ///Creates a new call builder for the [`decimals`] function.
        pub fn decimals(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, decimalsCall, N> {
            self.call_builder(&decimalsCall {})
        }
        ///Creates a new call builder for the [`delegate`] function.
        pub fn delegate(
            &self,
            delegatee: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, delegateCall, N> {
            self.call_builder(&delegateCall { delegatee })
        }
        ///Creates a new call builder for the [`delegateBySig`] function.
        pub fn delegateBySig(
            &self,
            delegatee: alloy::sol_types::private::Address,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
            expiry: alloy::sol_types::private::primitives::aliases::U256,
            v: u8,
            r: alloy::sol_types::private::FixedBytes<32>,
            s: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, delegateBySigCall, N> {
            self.call_builder(
                &delegateBySigCall {
                    delegatee,
                    nonce,
                    expiry,
                    v,
                    r,
                    s,
                },
            )
        }
        ///Creates a new call builder for the [`delegates`] function.
        pub fn delegates(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, delegatesCall, N> {
            self.call_builder(&delegatesCall { account })
        }
        ///Creates a new call builder for the [`eip712Domain`] function.
        pub fn eip712Domain(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, eip712DomainCall, N> {
            self.call_builder(&eip712DomainCall {})
        }
        ///Creates a new call builder for the [`emissionSchedule`] function.
        pub fn emissionSchedule(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionScheduleCall, N> {
            self.call_builder(&emissionScheduleCall { _0 })
        }
        ///Creates a new call builder for the [`emissionsActive`] function.
        pub fn emissionsActive(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsActiveCall, N> {
            self.call_builder(&emissionsActiveCall {})
        }
        ///Creates a new call builder for the [`emissionsEnded`] function.
        pub fn emissionsEnded(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsEndedCall, N> {
            self.call_builder(&emissionsEndedCall {})
        }
        ///Creates a new call builder for the [`emissionsStartTime`] function.
        pub fn emissionsStartTime(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsStartTimeCall, N> {
            self.call_builder(&emissionsStartTimeCall {})
        }
        ///Creates a new call builder for the [`emissionsStarted`] function.
        pub fn emissionsStarted(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsStartedCall, N> {
            self.call_builder(&emissionsStartedCall {})
        }
        ///Creates a new call builder for the [`getBridgeConfiguration`] function.
        pub fn getBridgeConfiguration(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeConfigurationCall, N> {
            self.call_builder(&getBridgeConfigurationCall {})
        }
        ///Creates a new call builder for the [`getBridgeInfo`] function.
        pub fn getBridgeInfo(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeInfoCall, N> {
            self.call_builder(&getBridgeInfoCall { bridge })
        }
        ///Creates a new call builder for the [`getBridgeUtilization`] function.
        pub fn getBridgeUtilization(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeUtilizationCall, N> {
            self.call_builder(&getBridgeUtilizationCall { bridge })
        }
        ///Creates a new call builder for the [`getCurrentEpochInfo`] function.
        pub fn getCurrentEpochInfo(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getCurrentEpochInfoCall, N> {
            self.call_builder(&getCurrentEpochInfoCall {})
        }
        ///Creates a new call builder for the [`getCurrentTotalSupply`] function.
        pub fn getCurrentTotalSupply(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getCurrentTotalSupplyCall, N> {
            self.call_builder(&getCurrentTotalSupplyCall {})
        }
        ///Creates a new call builder for the [`getEmissionSchedule`] function.
        pub fn getEmissionSchedule(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getEmissionScheduleCall, N> {
            self.call_builder(&getEmissionScheduleCall {})
        }
        ///Creates a new call builder for the [`getPastTotalSupply`] function.
        pub fn getPastTotalSupply(
            &self,
            blockNumber: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPastTotalSupplyCall, N> {
            self.call_builder(
                &getPastTotalSupplyCall {
                    blockNumber,
                },
            )
        }
        ///Creates a new call builder for the [`getPastVotes`] function.
        pub fn getPastVotes(
            &self,
            account: alloy::sol_types::private::Address,
            timepoint: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPastVotesCall, N> {
            self.call_builder(
                &getPastVotesCall {
                    account,
                    timepoint,
                },
            )
        }
        ///Creates a new call builder for the [`getPastVotingPower`] function.
        pub fn getPastVotingPower(
            &self,
            account: alloy::sol_types::private::Address,
            blockNumber: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPastVotingPowerCall, N> {
            self.call_builder(
                &getPastVotingPowerCall {
                    account,
                    blockNumber,
                },
            )
        }
        ///Creates a new call builder for the [`getRemainingEmissions`] function.
        pub fn getRemainingEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRemainingEmissionsCall, N> {
            self.call_builder(&getRemainingEmissionsCall {})
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`getVotes`] function.
        pub fn getVotes(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getVotesCall, N> {
            self.call_builder(&getVotesCall { account })
        }
        ///Creates a new call builder for the [`getVotingPower`] function.
        pub fn getVotingPower(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getVotingPowerCall, N> {
            self.call_builder(&getVotingPowerCall { account })
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`isBridge`] function.
        pub fn isBridge(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isBridgeCall, N> {
            self.call_builder(&isBridgeCall { bridge })
        }
        ///Creates a new call builder for the [`mint`] function.
        pub fn mint(
            &self,
            _user: alloy::sol_types::private::Address,
            _amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintCall, N> {
            self.call_builder(&mintCall { _user, _amount })
        }
        ///Creates a new call builder for the [`mintEmission`] function.
        pub fn mintEmission(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintEmissionCall, N> {
            self.call_builder(&mintEmissionCall {})
        }
        ///Creates a new call builder for the [`mintingCurrentLimitOf`] function.
        pub fn mintingCurrentLimitOf(
            &self,
            _bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintingCurrentLimitOfCall, N> {
            self.call_builder(
                &mintingCurrentLimitOfCall {
                    _bridge,
                },
            )
        }
        ///Creates a new call builder for the [`mintingMaxLimitOf`] function.
        pub fn mintingMaxLimitOf(
            &self,
            _bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintingMaxLimitOfCall, N> {
            self.call_builder(&mintingMaxLimitOfCall { _bridge })
        }
        ///Creates a new call builder for the [`name`] function.
        pub fn name(&self) -> alloy_contract::SolCallBuilder<T, &P, nameCall, N> {
            self.call_builder(&nameCall {})
        }
        ///Creates a new call builder for the [`nonces`] function.
        pub fn nonces(
            &self,
            owner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, noncesCall, N> {
            self.call_builder(&noncesCall { owner })
        }
        ///Creates a new call builder for the [`numCheckpoints`] function.
        pub fn numCheckpoints(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, numCheckpointsCall, N> {
            self.call_builder(&numCheckpointsCall { account })
        }
        ///Creates a new call builder for the [`pause`] function.
        pub fn pause(&self) -> alloy_contract::SolCallBuilder<T, &P, pauseCall, N> {
            self.call_builder(&pauseCall {})
        }
        ///Creates a new call builder for the [`pauseEmissions`] function.
        pub fn pauseEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, pauseEmissionsCall, N> {
            self.call_builder(&pauseEmissionsCall {})
        }
        ///Creates a new call builder for the [`paused`] function.
        pub fn paused(&self) -> alloy_contract::SolCallBuilder<T, &P, pausedCall, N> {
            self.call_builder(&pausedCall {})
        }
        ///Creates a new call builder for the [`permit`] function.
        pub fn permit(
            &self,
            owner: alloy::sol_types::private::Address,
            spender: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
            deadline: alloy::sol_types::private::primitives::aliases::U256,
            v: u8,
            r: alloy::sol_types::private::FixedBytes<32>,
            s: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, permitCall, N> {
            self.call_builder(
                &permitCall {
                    owner,
                    spender,
                    value,
                    deadline,
                    v,
                    r,
                    s,
                },
            )
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            callerConfirmation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceRoleCall, N> {
            self.call_builder(
                &renounceRoleCall {
                    role,
                    callerConfirmation,
                },
            )
        }
        ///Creates a new call builder for the [`resumeEmissions`] function.
        pub fn resumeEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, resumeEmissionsCall, N> {
            self.call_builder(&resumeEmissionsCall {})
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`setBridgeData`] function.
        pub fn setBridgeData(
            &self,
            _bridgeData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeDataCall, N> {
            self.call_builder(&setBridgeDataCall { _bridgeData })
        }
        ///Creates a new call builder for the [`setBridgeProxy`] function.
        pub fn setBridgeProxy(
            &self,
            _bridgeProxy: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeProxyCall, N> {
            self.call_builder(&setBridgeProxyCall { _bridgeProxy })
        }
        ///Creates a new call builder for the [`setLimits`] function.
        pub fn setLimits(
            &self,
            _bridge: alloy::sol_types::private::Address,
            _mintingLimit: alloy::sol_types::private::primitives::aliases::U256,
            _burningLimit: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setLimitsCall, N> {
            self.call_builder(
                &setLimitsCall {
                    _bridge,
                    _mintingLimit,
                    _burningLimit,
                },
            )
        }
        ///Creates a new call builder for the [`startEmissions`] function.
        pub fn startEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, startEmissionsCall, N> {
            self.call_builder(&startEmissionsCall {})
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<T, &P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`symbol`] function.
        pub fn symbol(&self) -> alloy_contract::SolCallBuilder<T, &P, symbolCall, N> {
            self.call_builder(&symbolCall {})
        }
        ///Creates a new call builder for the [`totalEmissionsMinted`] function.
        pub fn totalEmissionsMinted(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, totalEmissionsMintedCall, N> {
            self.call_builder(&totalEmissionsMintedCall {})
        }
        ///Creates a new call builder for the [`totalSupply`] function.
        pub fn totalSupply(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, totalSupplyCall, N> {
            self.call_builder(&totalSupplyCall {})
        }
        ///Creates a new call builder for the [`transfer`] function.
        pub fn transfer(
            &self,
            to: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferCall, N> {
            self.call_builder(&transferCall { to, value })
        }
        ///Creates a new call builder for the [`transferFrom`] function.
        pub fn transferFrom(
            &self,
            from: alloy::sol_types::private::Address,
            to: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferFromCall, N> {
            self.call_builder(
                &transferFromCall {
                    from,
                    to,
                    value,
                },
            )
        }
        ///Creates a new call builder for the [`unpause`] function.
        pub fn unpause(&self) -> alloy_contract::SolCallBuilder<T, &P, unpauseCall, N> {
            self.call_builder(&unpauseCall {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Approval`] event.
        pub fn Approval_filter(&self) -> alloy_contract::Event<T, &P, Approval, N> {
            self.event_filter::<Approval>()
        }
        ///Creates a new event filter for the [`BridgeAuthorized`] event.
        pub fn BridgeAuthorized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeAuthorized, N> {
            self.event_filter::<BridgeAuthorized>()
        }
        ///Creates a new event filter for the [`BridgeDataUpdated`] event.
        pub fn BridgeDataUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeDataUpdated, N> {
            self.event_filter::<BridgeDataUpdated>()
        }
        ///Creates a new event filter for the [`BridgeDeauthorized`] event.
        pub fn BridgeDeauthorized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeDeauthorized, N> {
            self.event_filter::<BridgeDeauthorized>()
        }
        ///Creates a new event filter for the [`BridgeLimitsSet`] event.
        pub fn BridgeLimitsSet_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeLimitsSet, N> {
            self.event_filter::<BridgeLimitsSet>()
        }
        ///Creates a new event filter for the [`BridgeProxyUpdated`] event.
        pub fn BridgeProxyUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeProxyUpdated, N> {
            self.event_filter::<BridgeProxyUpdated>()
        }
        ///Creates a new event filter for the [`DelegateChanged`] event.
        pub fn DelegateChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DelegateChanged, N> {
            self.event_filter::<DelegateChanged>()
        }
        ///Creates a new event filter for the [`DelegateVotesChanged`] event.
        pub fn DelegateVotesChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DelegateVotesChanged, N> {
            self.event_filter::<DelegateVotesChanged>()
        }
        ///Creates a new event filter for the [`EIP712DomainChanged`] event.
        pub fn EIP712DomainChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EIP712DomainChanged, N> {
            self.event_filter::<EIP712DomainChanged>()
        }
        ///Creates a new event filter for the [`EmissionMinted`] event.
        pub fn EmissionMinted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionMinted, N> {
            self.event_filter::<EmissionMinted>()
        }
        ///Creates a new event filter for the [`EmissionsPaused`] event.
        pub fn EmissionsPaused_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionsPaused, N> {
            self.event_filter::<EmissionsPaused>()
        }
        ///Creates a new event filter for the [`EmissionsResumed`] event.
        pub fn EmissionsResumed_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionsResumed, N> {
            self.event_filter::<EmissionsResumed>()
        }
        ///Creates a new event filter for the [`EmissionsStarted`] event.
        pub fn EmissionsStarted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionsStarted, N> {
            self.event_filter::<EmissionsStarted>()
        }
        ///Creates a new event filter for the [`Paused`] event.
        pub fn Paused_filter(&self) -> alloy_contract::Event<T, &P, Paused, N> {
            self.event_filter::<Paused>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
        ///Creates a new event filter for the [`Transfer`] event.
        pub fn Transfer_filter(&self) -> alloy_contract::Event<T, &P, Transfer, N> {
            self.event_filter::<Transfer>()
        }
        ///Creates a new event filter for the [`Unpaused`] event.
        pub fn Unpaused_filter(&self) -> alloy_contract::Event<T, &P, Unpaused, N> {
            self.event_filter::<Unpaused>()
        }
    }
}
